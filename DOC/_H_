//:[_H_]: Hashtag Comments. For ANYTHING! ================== ://
/** ******************************************************** ***
    NEWEST_COMMENTS_ALWAYS_GO_TO_THE_TOP_OF_THIS_FILE
    SO_WE_HAVE_A_RECORD_OF_WHAT_WAS_DONE_IN_WHAT_ORDER

    //#   VIDEO COMMENT TIMESTAMP EXAMPLE   #//
    //( @VID_IID@[ 0045 ]TIME[ 5H33M0S    ] )//  
    //( @VID_URL@[ TODO_YOUTUBE_VIDEO_URL ] )//
    //[   VIDEO COMMENT TIMESTAMP EXAMPLE   ]//
*** ******************************************************** ***


#_WHY_NO_INSTANCES_IN_GPUDATA_##################################

    UPDATE_DATE[2020_12_25]: ***********************************

        GPUDATA now serves as a TEMPORARY container for 
        passing information about sub-system texture 
        memory.
    
        All of the data LIVES in file scope variables.

        Because: FLAT IS BETTER THAN NESTED.

        Specifically in:

        PIXNAME.D._

            This also gives us a high level summary of all of
            the important 512x512 system data allocations
            in the entire game engine within one file.

    ***********************************: UPDATE_DATE[2020_12_25]

    EXTRACTED_FROM[ DOC/WHY_NO_INSTANCE_IN_GPUDATA.TXT ]

    WHY_NO_INSTANCES_IN_GPUDATA: (WRITTEN_BEFORE[ 2020_12_25 ])
    -------------------------------------------------------- 
    I will NOT have instances of AAC2020_GPUDATA             
    in [ this / GPUDATA.D._ / GPUDATA.H._ ] file.            
                                                             
    This is because RIGHT NOW I want a texture for           
    graphics, and much later I know I'll be adding           
    another texture for ENEMY_POSITIONS or something         
    non-graphical in nature.                                 
                                                             
    Comming BACK to this GPUDATA library to add              
    something of that much significance would                
    be a violation of my layered design.                     
    -------------------------------------------------------- 

##################################_WHY_NO_INSTANCES_IN_GPUDATA_#
#_WHY_GPUDATA_PAINT5D_##########################################

    UPDATE[ 2020_12_25 ]: **************************************

        After working with "AAC2020_GPUDATA_PAINT5D"
        I have decided this namespace pattern breaker
        is a pain in the ass and have re-named it to
        "AAC2020_PAINT5D".

    **************************************: UPDATE[ 2020_12_25 ]

    EXTRACTED_FROM[ DOC/WHY_GPU_DATA_PAINT5D.TXT ]

    WHY_GPUDATA_PAINT5D:

        AAC2020_GPUDATA_PAINT5D: 
        
            Memory For a 5 Dimensional
            MS-PAINT program. I was thinking about 
            calling it "AAC2020_GPUDATA_GENERIC" because
            I wanted a chunk of memory I wasn't sure what
            to do with I could start to work with.
        
            HOWEVER!
        
            I want to avoid being ABSTRACT whenever 
            possible to make the project easier to follow.
        
            So the first instance of AAC2020_GPUDATA
            in our project will be:
        
                VAR:   AAC2020_GPUDATA_PAINT5D_dat
                FILE:  AAC2020_GPUDATA_PAINT5D.D._

            ----------------------------------------------------

            The end goal is a GAME. However, whenever possible,
            compiling up to a non-terminal point in our
            LIBCHAN (library_chain) should yeild a usable 
            product.

            Therefore, when we compile up to:

##########################################_WHY_GPUDATA_PAINT5D_#
#_WHY_GPU_DATA_#################################################

    EXTRACTED_FROM[ DOC/WHY_GPUDATA.TXT ]

    This was NOT named GRADATA (graphics data)
            because from past experience I know that 
            some of the data on the GPU will be used for
            rendering while other data on the GPU may be
            used for things like storing the current 
            position of enemies.
    
            GPUDATA will keep a local CPU cache of the
            arrays of data it pushes to the GPU. Being
            careful to always keep both sets of data
            in sync (the same).
    
            The reason for this is that querying GPU values
            for CPU tasks will use up on bandwidth AND be
            relatively slow.

#################################################_WHY_GPU_DATA_#
#_WHY_FRAGBED_DEFAULT_COPY_#####################################

    EXTRACTED_FROM[ DOC/WHY_FRAGBED_DEFAULT_COPY.TXT ]

    WHY_FRAGBED_DEFAULT_COPY:

        We copy all of the default shaders hard coded
        into the .EXE's memory (.text segment) so that
        all of our shader pointers are FREEABLE pointers.

        This [consistency/regularity/normalization] makes
        the code simpler. But it also means a bigger memory
        footprint.

#####################################_WHY_FRAGBED_DEFAULT_COPY_#
#_WHY_COG_IN_DIAGRAM_###########################################

    EXTRACTED_FROM[ DOC/WHY_COG_IN_DIAGRAM.TXT ]

    WHY_COG_IN_DIAGRAM:

    COG.H is in our diagram because previous experience
    has told me that setting up OpenCL <==> OpenGL 
    interop is NOT a trivial task.

    If we decide to add OpenCL or Vulkan to the project,
    the COG.H library will be stubbed into this position.

    However, Since it might also be doing OpenGL <==> Vulkan
    or Vulkan <==> OpenCL interop, we need a different name.

           123_123
    Maybe: GINTLAY (Graphics_INTerop_LAYer)
           1234567

###########################################_WHY_COG_IN_DIAGRAM_#
#_PREVIOUS_PROJECT_#############################################

    EXTRACTED_FROM[ DOC/PREVIOUS_PROJECT.TXT ]

    RANT:(BEGIN)

    I write so much code that I sometimes lose track of things
    written a long time ago. Brain research on memorization
    says that forming linked lists in your head can help
    remember things. This makes sense. Because memory is
    just associations. And if you have an orphaned WIKIPEDIA
    article (metaphore) in your head, there is no way to get
    there. You need both memory AND a mechanism for retrieval.

    RANT:( END ) 


    Comment below extracted from AAC2020.C11 .

    //: PREVIOUS_LIBRARY: A2_JC.JS ------------------------- ://
    //: CURRENT__LIBRARY: AAC2020                            ://
    //:                                                      ://
    //: Re-write of A2JC ( R:\G\A2_JC ) into C only code.    ://
    //: A2_JC:DEMO[ file:///R:/G/A2_JC/AA2.HTM         ]     ://
    //: A2_JC:ANIM[ https://imgur.com/XiNdLvT          ]     ://
    //: A2_JC:GITH[ github.com/HeavyMetalCookies/A2_JC ]     ://
    //: ---------------------------------------------------- ://

#############################################_PREVIOUS_PROJECT_#
#_LIBRARY_CHAIN_################################################

    EXTRACTED_FROM[ DOC/LIBRARY_CHAIN.TXT ]

    ******************************************************** ***
                                                             
    Goal: Project composed of a chain of libraries (LIBCHAN)    
        that we can split at ANY POINT to do a binary search  
        on the project.                                       
                                                             
    Why:                                                     
            1.  DEBUGGING:                                   
                For those really hard to debug moments       
                when you've introduced undefined behavior.   
                                                             
            2.  UNDERSTANDING:                                  
                I think the reason my boss had such a better    
                understanding of the code base at "IDB" was     
                because he was around to BUILD it. By keeping   
                a [ layered / chained ] approach, the goal is   
                for a newcomer to this code to know exactly how 
                the project was built. Understanding the        
                [ journey / path ] taken to build up this code  
                to where it is now is vital to an expert level  
                understanding of the code.                      
    Rules:                                                      
                                                            
        1. Build up project in small DOTADIW pieces.        
        2. LOWER LIBRARIES CANNOT REFERENCE HIGHER LIBS     
                                                            
        DOTADIW: Do One Thing And Do It Well                
                                                            
    ******************************************************** **/

################################################_LIBRARY_CHAIN_#
#_DATA_THEN_FUNCTIONS_##########################################

    EXTRACTED_FROM[ DOC/DATA_THEN_FUNCTIONS.TXT ]

    DATA_THEN_FUNCTIONS

        Everything is either data or functions.
        
        Why:(BEG)
        |
        |   Take a dependency problem where classes
        |   "A" and "B" both reference each other in their
        |   implementations:
        |   
        |       The_Problem: -------------------------------- ::
        | 
        |           #include MY_CLASS_A.C
        |           #include MY_CLASS_B.C
        | 
        |       :: -------------------------------- :The_Problem
        |   
        |   ABOVE won't compile without forward declarations.
        |   I am not a fan of this trickery.
        | 
        |       My_Fix: ------------------------------------- ::
        | 
        |       //:DATA BEFORE FUNCTIONS:
        | 
        |           #include MY_CLASS_A.D._
        |           #include MY_CLASS_B.D._
        | 
        | 
        |       //:FUNCTIONS AFTER DATA:
        | 
        |           #include MY_CLASS_A.F._
        |           #include MY_CLASS_B.F._
        |           
        |       :: ------------------------------------- :My_Fix
        Why:(END)

##########################################_DATA_THEN_FUNCTIONS_#
##_DOCUMENTATION_DOT_TXT_2020_12_25_############################

    EXTRACTED_FROM[ DOC/DOCUMENTATION.TXT ]

    ******************************************************** 
                                                             
    This file ( DOCUMENTATION.TXT ) only exists because I    
    figured someone new to the project would probably        
    start here. Actual documentation in files listed below.  
                                                             
    ******************************************************** 
    ******************************************************** 
                                                             
    SUMMARY  (S): FILE[ DOC/_S_ ]                            
    FUNCTION (S): FILE[ DOC/_F_ ]                            
    DATA     (S): FILE[ DOC/_D_ ] 
    HASHTAG  (S): FILE[ DOC/_H_ ] ( #WHATEVER# , @WHATEVER@ )
    
    ********************************************************  
    ********************************************************  
    #WHATEVER#  Cut comments out from source code and replace
                with hastag summary. #HASHTAG_COMMENT#
                
    @WHATEVER@  Will be found in HASHTAG DOCUMENTATION (_H_)
                Do not split into a "at" _A_ file because
                sometimes HASHTAG _H_ documentation includes
                diagrams where we need to use "@" to 
                succinctly point out variable.
                
                Example:
                
                @EOV@              
                   \
                    +---+---+  EOV: Example Origin Variable
                    |   |   |
                    +---+---+
                    |   |   |
                    +---+---+
    
    ********************************************************  

#############################_DOCUMENTATION_DOT_TXT_2020_12_25_#
#_GAKU_DESIGN_NOTES_TXT_########################################

    EXTRACTED_FROM[ DOC/DESIGN_NOTES.TXT ]

    From: GAKU.H

    We want a dependency something conceptually like this:
    ( A Bindings layer for OpenGL and others, then a )
    ( COG layer that creates interops between different )
    ( graphics libraries. )

    //|¯¯|¯¯|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|¯¯|¯¯|//
    //|  |  |                                |  |  |//
    /* //|--|// */#include "../COG/COG.H"  //|--|  |// 
    //|  |  |                                |  |  |//
    //|  |  |      GLEB_SWIN  <--Gets Win32  |  |  |//
    //|  |  |         ||         Window      |  |  |//
    //|  |  |         ||                     |  |  |//
    //|  |  Gets      ||               Gets  |  |  |//
    //|  |OpenGL --> GLEB     CLEB <-- OpenCL|  |  |//
    //|  Context         \   /         Context  |  |//
    //|  |  |             \ /                |  |  |//
    //|  |  |             COG <===== CO:CO_mpute|  |//
    //|  |  |                         G:G_raphics  |//
    //|  |  |              |            Gets GLCL  |//
    //|  |  |              |            Context |  |//
    //|  |  |    +---+---GA_KU---+---+       |  |  |//
    //|  |  |    |                   |       |  |  |//
    //|  |  |    |GA: OpenGL Code    |       |  |  |//
    //|  |  |    |                   |       |  |  |//
    //|  |  |    |KU: OpenCL Code    |       |  |  |//
    //|  |  |    |                   |       |  |  |//
    //|  |  |    |GAKU: Coordination |       |  |  |//
    //|  |  |    |      GA<==>KU code|       |  |  |//
    //|  |  |    |                   |       |  |  |//
    //|  |  |    |GAKUSHARE:         |       |  |  |//
    //|  |  |    |Implementation of  |       |  |  |//
    //|  |  |    |GA<==KU            |       |  |  |//
    //|  |  |    |coordination code. |       |  |  |//
    //|  |  |    |                   |       |  |  |//
    //|  |  |    |GAKU/GAKU_ is only |       |  |  |//
    //|  |  |    |PUBLIC namespace   |       |  |  |//
    //|  |  |    |to be used by      |       |  |  |//
    //|  |  |    |other libraries    |       |  |  |//
    //|  |  |    |down the chain.    |       |  |  |//
    //|  |  |    +-------------------+       |  |  |//
    //|  |--|                                |--|  |//
    //|  |  |                                |  |  |//
    //|__|__|________________________________|__|__|//

    Commit Messages:

        WHITESPACE_CRASH:
            Blanks lines with WHITESPACE characters 
            cause file reading to crash. Specifically
            OPEN_GL_SEARCH_PATHS.TXT

########################################_GAKU_DESIGN_NOTES_TXT_#
@TREE_LEVEL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @TREE_LEVEL@: 

        Identifies that the code you are looking at
        is somehow part of a nesting level of a
        quad tree or quad tree like data-structure.

        @VID_IID[ 0057 ]TIME[ 7H 54M 10S ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TREE_LEVEL@
@GRASPING_AT_STRAWS_WITH_TEST_CODE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @GRASPING_AT_STRAWS_WITH_TEST_CODE@ :

    Seems that "grasping at straws" with bugs found by
    unit test code is a common theme in our life. So
    when you see this annotation in code it means we
    added that code because we have no clue what is
    going on and we are just trying "random" things
    all over the place to hopefully find the
    source of some type of problem.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@GRASPING_AT_STRAWS_WITH_TEST_CODE@
#DONT_GET_STUCK_IN_AN_OOP_TRAP##################################

    @VID_IID[ 5H 25M 24S ] <<- when I wrote the below
    @VID_IID[ 5H 30M 51S ] <<- after I explained it.
    @VID_IID[ 5H 33M 46S ] <<- okay. Really stopping stream now.

    When doing the code for: AAC2020_TAUTYPE_rec_inc...
    We do ____NOT____ want a struct type for the[ rec_inc ].

    REASONS:
        1. More code.
           1.A: Deserialize Into A rectangle.
           1.B: Manipulate Rectangle
           1.C: Re-serialize rectangle into bitmap bytes.

        2. Who is the canonical copy? The data in the bitmap?
           Or the rectangle we extracted from the bitmap.

    By just saying "Hey, a rectangle object exists in "
    "this location on the bitmap data". We can directly
    manipulate it in place. 1 step. Rather than 3.

##################################DONT_GET_STUCK_IN_AN_OOP_TRAP#
#STUPIDCODE_REPLACED_WITH_1_EQUALS_1############################

    THIS CODE:

        if( 
        &&  t2.i_x >= r2->x_1 //:last_x_of_inclusive_range
        &&  t2.i_y >= r2->y_1 //:last_y_of_inclusive_range
        ){
        
            ....whatever_code_bla_bla_bla....
        };;

    Replaced With This Code:

        if( 1 == 1 ){
        
            ....whatever_code_bla_bla_bla....
        };;

    IN: TAUSYNC.F._ 
    IN: FUNCTION[ aac2020_tausync_Run(...) ]

    @VID_IID[ 0054 ]TIME[ 7H 37M 35S ]

############################STUPIDCODE_REPLACED_WITH_1_EQUALS_1#
@STFU_GCC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @STFU_GCC: Shut_The_Fuck_Up:GCC 
              (GCC:Gnu_Compiler_Collection)

                The code annoted with this is done so in 
                order to quelch a compiler warning of 
                some sort.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@STFU_GCC@
#_RESET_HISTOGRAM_##############################################
#_ZERO_OUT_HISTOGRAM_###########################################

    @VID_IID[ 0053 ]TIME[ 7H 36M 51S ]

    To help with writing unit tests for TAUSYNC.F._
    we need summary variables to give us a high level
    overview of what was done when we last called the
    SYNC command. ( aac2020_tausync_Run() )

    NAMELY:

        1: aac2020_tausync_num_dirty_pix_pushed

           Stored as a file scope variable.

        2: num_dirty_sectors_pushed_to_gpu

           Returned as I32 from function.

##############################################_RESET_HISTOGRAM_#
###########################################_ZERO_OUT_HISTOGRAM_#
#V_IS_ZERO_TO_ZERO_FOR_THIS_TEST################################

    /** #V_IS_ZERO_TO_ZERO_FOR_THIS_TEST# **/
    /** @VID_IID[ 0053 ]TIME[ 7H 4M 50S ] **/

    The "V" (Variable Index) Must only be ONE loop iteration
    for these nested loops. Because we only want to set
    ONE DIRTY PIXEL per 32x32 block.

    Because, we are trying to get the number of dirty 
    blocks to match the number of dirty pixels in
    this test.

################################V_IS_ZERO_TO_ZERO_FOR_THIS_TEST#
@N_P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @N_P : aac2020_tausync_num_dirty_pix_pushed
           [N]umber_of_[P]ixels
    
            SEE[ TAUSYNC.D._ ]
 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N_P@
@p1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@p2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@p3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@p4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @VID_IID[ 4H 17M 1S ]

    @p1 : Pixel 1 of 4 of TAU variable.
    @p2 : Pixel 2 of 4 of TAU variable.
    @p3 : Pixel 3 of 4 of TAU variable.
    @p4 : Pixel 4 of 4 of TAU variable.

        Each variable that we want to store on the GPU
        is packed into a Uint32 RGBA texture.

        Each variable gets a cluster of 4 pixels.

        Meaning we can store up to a 128bit unsigned
        integer if needed.

        Also, we decided on 4 pixels because we commonly
        need to encode RECTANGLES that have exactly
        4 - 32bit unsigned integers defining them.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@p1@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@p2@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@p3@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@p4@
@VID_IID[ 0053 ]TIME[ 2H 9M 56 ]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    AzarlakTwitch: It's flexible in the sense
    that metal is flexible; It can be bent in
    any way you like,but it takes a lot of
    effort,and you really don't want to keep
    bending it back and forth,or everything's
    gonna break ;)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@VID_IID[ 0053 ]TIME[ 2H 9M 56 ]@
#FPT############################################################

    #FPT# : FOLDER NAME: [F]ake[P]roject[T]ree
                          F_ake_P_roject_T_ree
                          Fake_Project_Tree

############################################################FPT#
#N_IS_A_NON_STANDARD_FILE_EXTENSION#############################
#G_IS_A_NON_STANDARD_FILE_EXTENSION#############################

    .N._ : Files are NOTES files. 

    However the only filetypes that are standard are:

        .D._: DATA
        .F._: FUNCTIONS

    We can invent lots of other extensions, but that will
    inevitably spiral out of control and make our code
    far too granular.

    So, do not expect the user of code base to have to
    remember anything except ".D._" and ".F._".

#############################N_IS_A_NON_STANDARD_FILE_EXTENSION#
#############################G_IS_A_NON_STANDARD_FILE_EXTENSION#
@NEG_OOB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@POS_OOB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@OOB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @OOB: Out Of Bounds 1D INDEX or 2D [X|Y] COORDINATE.
    
        Typically an INDEX value within some type of
        tilemap or pixel array structure that is either
        less than ZERO (NEG_OOB) or >= the [WID|HIG]
        of the [ tilemap / bitmap ] data.

        @NEG_OOB: Negative Out Of Bounds Index
        @POS_OOB: Positive Out Of Bounds Index

        @OOB_NEG: SEE[ @NEG_OOB ]
        @OOB_POS: SEE[ @POS_OOB ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@OOB@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NEG_OOB@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@POS_OOB@
@4X4_C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@16X16_C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @4X4_C   : Denotes 4x4 Cells. EXAMPLE: TAUDIRT.D._
    @16X16_C : Denotes 4x4 Cells. EXAMPLE: TAUDIRT.D._

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4X4_C@ 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@16X16_C@
@TEMP_STACK_VARS_FOR_SCOPE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    VID_IID[ 0051 ]TIME[ 4H 41M 50S ]

    These variables must have been created inbetween
    some scope operators within the body of a function.

    EXAMPLE:

        int main( void ){

                { //:extra scope

                    int i_ll_die_if_i_leave_my_scope;

                } //:extra scope

            //: i_ll_die_if_i_leave_my_scope 
            //: DOES NOT EXIST HERE.
    
        };

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TEMP_STACK_VARS_FOR_SCOPE@
#IID_0051_3H_45#################################################

    ************************************************************
    This code was stripped out of the source at the timestamp
    of 3 hours and 45 minutes. VID_IID[ 0051 ].
    ************************************************************

        #if( AAC2020_TAUDIRT_BUG_001 >= 1 ) //:##://
        LOG( "[BEFORE:........................]",0);
        P_R( "[BEFORE:rec_032]:" , &REC_032 );
        P_R( "[BEFORE:prv_032]:" , &prv_032 );
        
        printf( "REC_032.x_0 = MIN( %d , %d )\n",
                prv_032.x_0 , x_C );;
        printf( "REC_032.x_1 = MAX( %d , %d )\n",
                prv_032.x_1 , x_C );;
        
        printf( "REC_032.y_0 = MIN( %d , %d )\n",
                prv_032.y_0 , y_C );;
        printf( "REC_032.y_1 = MAX( %d , %d )\n",
        prv_032.y_1 , y_C );;
        
        LOG( "[........................:BEFORE]",0);
        #endif //:###############################://



        #if( AAC2020_TAUDIRT_BUG_001 >= 1 ) //:##://
        LOG( "[AFTER_:........................]",0);
        P_R( "[AFTER_:rec_032]:" , &REC_032 );
        P_R( "[AFTER_:prv_032]:" , &prv_032 );
        LOG( "[........................:AFTER_]",0);
        #endif //:###############################://

#################################################IID_0051_3H_45#
@MRK_TWICE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    VID_IID[ 0051 ]TIME[ 1H 50M 51S ]

    @MRK_TWICE : Using a command that should be idempotent
                 is FAILING when used twice in a row with
                 the same [parameters/arguments].

                 @MRK_TWICE denotes attempt to address the
                 issue. Once issue is FIXED, we will still
                 KEEP the @MRK_TWICE annotation in the code
                 to remind ourselves of what we fixed.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@MRK_TWICE@
#SHBCE##########################################################

    #SHBCE#: Should_Have_Been_Caught_Earlier

        The error you are experiencing should have been
        caught earlier. Good thing you programmed a 
        redundancy just in case.

##########################################################SHBCE#
@too_granular@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @too_granular: Means that the code is commented out because
                   it is literally too granular. And whatever
                   operation you are performing needs to be
                   done at a coarser level.

    EXAMPLES:
    ------------------------------------------------------------
    1: TAUSYNC.F._ :: aac2020_tausync_Run
    
        We shouldn't push individual 2x2 clusters of pixels
        in a texture push. We should push the entire dirty
        region that exists on the 32x32 cluster of pixels
        within one of the #DIA_VAR_CEL# partitions.
        ( #DIA_VAR_CEL# : SEE: TAUDEPO.D._ )
                
    ------------------------------------------------------------

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@too_granular@
@u_x@@u_y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @u_x: Upper_Left_Pixel_X (EXAMPLE: SEE: TAUSYNC.F._ )
    @u_y: Upper_Left_Pixel_Y (EXAMPLE: SEE: TAUSYNC.F._ )

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@u_x@@u_y@
@2x2_VAR@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @2x2_VAR@: Referring to a 2x2 cluster of pixels
               stored on "taudepo" memory allocation
               that is used to encode 
               [variable/uniform] in GPU texture memory.

               SEE[ @2x2_VAR@ ]ON_DIAGRAM[ #DIA_VAR_CEL# ]
               CURRENTLY_IN[ TAUDEPO.D._ ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2x2_VAR@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DEEPEST_DEEP@
@DEEPEST_DEEP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    GENERALLY:
        Means we have drilled down as deep as we can into
        a tree structure. May also be notated so you realize
        why some type of pattern has broken down in this
        section of code.

    ************************************************************
    RELATED_TO: TAUDEPO.D._ 
                TAUDIRT.D._     
                TAUSYNC.F._

    The pattern breaks down a bit once you get to the
    terminal DEPTH.

    Conceptually, [ r3 == c_4 ] at the deepest depth.

    Because we don't need to overlay FLAGS on top of
    a datastructure to be dived into at this bottomed-out
    level.
    ************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DEEPEST_DEEP@
@VID_URL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @VID_URL@
        Denotes the VIDEO URL of code base commentary.
        Looking up this video with the timestamp
        associated with it_1 can find a video of me
        when I wrote the comment itself explaining it_2
        in more detail than the written comments in the
        code may be [ doing / able-to ].

        it_1 : VIDEO URL or the video on youtube itself.
        it_2 : The code
        
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@VID_URL@
@VID_IID@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @VID@ : Use @VID_IID@ to make easy to search for all in
            a single go. ( a single search query )

    @IID@ : Use @VID_IID@ to make easy to search for all in
            a single go. ( a single search query )

    EXAMPLE_USE:
    //( @VID_IID@[ 0045 ]TIME[ 5H33M0S    ] )//  
    //( @VID_URL@[ TODO_YOUTUBE_VIDEO_URL ] )//

    VID_IID is the integer id of the video recording you
            were doing when you wrote the code comment
            in question. 
    
            No one has time to watch all of this stuff,
            but providing video timestamps can help people
            watch pertinent parts of video to explain
            what we were up to when we wrote that code.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@VID_IID@
#_BTS_BEATS_TOM_################################################

    ****************************************
    @5 hours , 18 minutes , & 11 seconds.
    OF_VIDEO: IID: 0045 (DATE: 2020_12_16 )
    ****************************************

    BTS: BACKUP ==> TEST ==> RESTORE

    BTS is better than TOM.

    TOM: ( Tests On Mockdata )

    BTS:
        PRO: Reflects real world situation closer.
        PRO: More confidence tests are correct.
        CON: Could alter game state if not careful
             to backup and restore data.

    TOM:
        PRO: Wont alter game state through side effects.
        CON: Tests are further from the reality of situation.
        CON: Must WRITE the mock object code.
        CON: Must FIGURE OUT how to properly use the mocks.

################################################_BTS_BEATS_TOM_#
@DANGER@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @DANGER_1@ : Mark point of "malloc" and "free"

    @DANGER_2@ : Mark point of "malloc" and "free"

    Mallocing memory is a dangerous thing. If we do it
    we should be careful to make sure the malloc and free
    calls are ballanced. Good way to do this is to tag
    the allocation and de-allocation of variable with
    some type of unique name within file as a hackish
    visual check.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DANGER@
#_DIRTY_SECTOR_ASK_IS_A_BIT_MUCH_BUT_HELPFUL_###################

    aac2020_taudirt_DirtySectorAsk

    Is a bit complex. And we've computed a lot of this stuff
    before. 

    BUT... It is being used in a TEST function. So these
    re-computations can serve as a redundancy to check our
    math.


###################_DIRTY_SECTOR_ASK_IS_A_BIT_MUCH_BUT_HELPFUL_#
@TRAP_VALUE@@_TRAP_VALUE_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    A trap value is typically a BOGUS initialization value
    that is intentionally [ wrong / invalid ]. If we FORGET
    to overwrite the trap value before using the value,
    a fatal error is usually triggered.

    The idea here is to help us catch problems quickly by
    intentionally setting invalid state where we can.

    Essentially we are setting "TRAP"(S) for ourselves
    in the code to make the code more "FAIL FAST" than
    it would otherwise be.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TRAP_VALUE@@_TRAP_VALUE_@
@_DONT_ABUSE_THE_STACK_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    It's definitely easier and less error prone to avoid
    malloc. However in some cases we need to malloc memory
    to avoid abusing the stack.

    Stack space is limited and we shouldn't put large
    memory allocations on it.
    
    The limit for stack seems to be around...

    100 bytes per stack frame....

    So... Lets say any array more than 32 bytes should
    be malloced.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_DONT_ABUSE_THE_STACK_@
@_NO_POINTERS_IN_THIS_SECTION_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    It is intentional that none of the members in any of    
    the data within this code section do NOT use pointers.
    Usage of pointers here would wreck what we are working
    towards.

    Specifically, AAC2020_TAUDIRT_UnitTest needs to
    backup[ AAC2020_TAUDIRT_DIR_ANY ] before the test is ran
    and if the object containes pointers we cannot easily
    do a deep copy.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_NO_POINTERS_IN_THIS_SECTION_@
#BAK_NUM_WHATEVER###############################################

        I am tired of trying to figure out names.         
        Just call them "bak_###" for "backup # whatever"  

###############################################BAK_NUM_WHATEVER#
#TAUDEPO_DATA_BACKUP_OR_RESTORE#################################

    /** ************************************************ **/
    /** We should copy over TAUDEPO's buffer before we   **/
    /** run our test so we can restore it when finished. **/
    /** Since we run our tests on game bootup, this      **/
    /** step is probably NOT NECESSARY, but just in case **/
    /** we should do this as a good habit.               **/
    /** ************************************************ **/

#################################TAUDEPO_DATA_BACKUP_OR_RESTORE#
@NON_INDENTED_LOOP_LEVELS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    My column space is limited and even when it isn't much
    of the time I can seem the patterns a lot better when
    I keep all levels of multiple nested loops at the
    same indentation level. WRITTEN_ON_DATE[ 2020_12_16 ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NON_INDENTED_LOOP_LEVELS@
@NES_LEV@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @NES_LEV@ : shorthand for "Nesting Level"
                of a tree structure. Nesting level 0
                being top level, having not drilled down
                into the tree.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NES_LEV@
@PRIVATE_NAMESPACE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    lowercase namespaces means that a function is "private".
    I use "private" loosely to mean
    "You better know what the fuck you are doing"
    "with this function call"

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@PRIVATE_NAMESPACE@
@one1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@two2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@NONE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @one1@ : If you see a #define like this, there is probably
             a diagramatic explanation of what @one1@
             represents.

    @two2@ : DITTO above.
    @NONE@ : DITTO above.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@one1@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@two2@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NONE@
#_DONT_ADD_THE_DEEPEST_2X2_#####################################

    ************************************************************
    In[ TAUSYNC.F._ ]We DONT want to find the upper-left
    origin of individual 2x2 pixel clusters. Because we don't
    want to PUSH individual 2x2 pixel chunks at a time.

    We want to step one level out and take the entire
    range of dirty 2x2 pixels within #DIA_VAR_CEL# (@cel_128@)

    We should be pushing a rectangular region in the
    size ranges (min -&- max) of [ 1x1 -and- 32x32 ].

    ** * * * * * * * * * * * * ****** * * * * * * * * * * * * **

    Code as it was in TAUSYNC.F._ at the time of writing this.
    (Found In Function[ aac2020_tausync_Run ] )

    ************************************************************

                //:upper_left:OF:DIA_VAR_CELL:---------------://
                //:              DIA_VAR_CELL ~=~ @cel_128@
                    u_x =( 0

                            //:@cel_512@(s) are 128x128 pixels
                     +      ( t0.i_x * 128 ) 

                            //:@cel_128@(s) are  32x32  pixels
                     +      ( t1.i_x *  32 )

                            //[ #_DONT_ADD_THE_DEEPEST_2X2_# ]//
                            //:@cel_032@(s) are   2x2   pixels
                //:  +      ( t2.i_x *   2 )

                    );;
                    u_y =( 0

                            //:@cel_512@(s) are 128x128 pixels
                     +      ( t0.i_y * 128 ) 

                            //:@cel_128@(s) are  32x32  pixels
                     +      ( t1.i_y *  32 )

                            //[ #_DONT_ADD_THE_DEEPEST_2X2_# ]//
                            //:@cel_032@(s) are   2x2   pixels
                //:  +      ( t2.i_y *   2 )
                    );;

                //:---------------:upper_left:OF:DIA_VAR_CELL://

#####################################_DONT_ADD_THE_DEEPEST_2X2_#
@just_push_it@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @just_push_it@ : Talking about a texture push my friend.
                     DATE[ 2020_12_15 ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@just_push_it@
@LEVEL_A( l_A )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@LEVEL_B( l_B )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@LEVEL_C( l_C )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    SEE_DIAGRAM_IN[ LIB/TAUDEPO.D._ ]

    [ l_A , l_B , l_C ] are shorthand notation for
    the different nesting levels of our dirty rectangle
    marking regions.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEVEL_A( l_A )@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEVEL_B( l_B )@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@LEVEL_C( l_C )@
@INTERN_BOTTOM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @INTERN_BOTTOM@ 
        Means the "externed" variable at the top of the
        file is declared "~interned~" at the bottom of
        the same file.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@INTERN_BOTTOM@
#_FIRST_TAUDIRT_ATTEMPT_WAS_WRONG_##############################

    VID_IID[ 0053 ]TIME[ 0H 04M 58S ]
    Got rid of the comment 
    "#_FIRST_TAUDIRT_ATTEMPT_WAS_WRONG_#"
    today because it was clutter.

    ************************************************************
    These calculations for TAUDIRTY are WRONG!
    But they have the right line of thinking.
    Kept here for reference as I fix my mistakes.

    When I mean "wrong" I don't mean "typo". I mean the
    underlying logic has a huge flaw. We need a nested
    data structure to have a proper "quad-tree".

    ( Really a hexakaideca-ish tree )

    ************************************************************

    :DATA:-----------------------------------------------------:

    Is ANYTHING at all dirty?  

    U08 AAC2020_TAUDIRT_DIR_ANY =( 0 );

    Grouped Block Dirty Flags 

    U08 AAC2020_TAUDIRT_DIR_512 =( 0 );
    U08 AAC2020_TAUDIRT_DIR_128 =( 0 );
    U08 AAC2020_TAUDIRT_DIR_032 =( 0 );
    
    Individual Cell Dirty Flags 

    U08 AAC2020_TAUDIRT_CEL_512[ 16] ={ 0 }; //: 4 x  4 cells.
    U08 AAC2020_TAUDIRT_CEL_128[ 16] ={ 0 }; //: 4 x  4 cells.
    U08 AAC2020_TAUDIRT_CEL_032[256] ={ 0 }; //:16 x 16 cells.
    
    Rectangular Region Of Dirty Cells Optimization.  
    ( REC === AAC2020_TAUDIRT_rec_inc )

    REC AAC2020_TAUDIRT_REC_512 = { 0 };
    REC AAC2020_TAUDIRT_REC_128 = { 0 };
    REC AAC2020_TAUDIRT_REC_032 = { 0 };

    :-----------------------------------------------------:DATA:

        //:DIRTY_SECTOR_MANAGEMENT:--------------------------://
        #define DIR_ANY AAC2020_TAUDIRT_DIR_ANY       //: 01 ://
        //:     DIR_512 AAC2020_TAUDIRT_DIR_512       //: 02 ://
        //:     DIR_128 AAC2020_TAUDIRT_DIR_128       //: 03 ://
        //:     DIR_032 AAC2020_TAUDIRT_DIR_032       //: 04 ://
                                                      //: -- ://
        #define CEL_512 AAC2020_TAUDIRT_CEL_512       //: 05 ://
        #define CEL_128 AAC2020_TAUDIRT_CEL_128       //: 06 ://
        #define CEL_032 AAC2020_TAUDIRT_CEL_032       //: 07 ://
                                                      //: -- ://
        #define REC_512 AAC2020_TAUDIRT_REC_512       //: 08 ://
        #define REC_128 AAC2020_TAUDIRT_REC_128       //: 09 ://  
        #define REC_032 AAC2020_TAUDIRT_REC_032       //: 10 ://
                                                      //: -- ://
        #define TAU_015 DEX_TAU_000_015               //: 11 ://
        #define SUB_015 DEX_SUB_000_015               //: 12 ://
        #define VAR_255 DEX_VAR_000_255               //: 13 ://

            //:Get_Dirty_Cell_XY_Tiles:----------------------://

                /** 512x512 pixels, 004x004 (016) cells **/

                x_A  =  CEL_512       %  16 ;
                y_A  = (CEL_512 - x_A)/  16 ;

                /** 128x128 pixels, 004x004 (016) cells. **/

                x_B  =  CEL_128       %  16 ;
                y_B  = (CEL_128 - x_B)/  16 ;

                /** 032x032 pixels, 016x016 (256) cells **/

                x_C  =  CEL_032       % 256 ;
                y_C  = (CEL_032 - x_C)/ 256 ;

            //:----------------------:Get_Dirty_Cell_XY_Tiles://
            //:Expand_Dirty_Rect_Selections:-----------------://
            #define MIN AAC2020_TAUDIRT_Min           //: 01 ://
            #define MAX AAC2020_TAUDIRT_Max           //: 02 ://

                /** >= 1 : REC is @VALID, use MIN+MAX   **/
                /** <= 0 : REC is @@JUNK, re-initialize **/

            //: #DIA_TAU_CEL# (BELOW) ://

                ;;;;;;if( CEL_512[ TAU_015 ] >= 1  ){ //: @VALID

                    REC_512.x_0 = MIN( REC_512.x_0 , x_A );
                    REC_512.x_1 = MAX( REC_512.x_1 , x_A );

                    REC_512.y_0 = MIN( REC_512.y_0 , y_A );
                    REC_512.y_1 = MAX( REC_512.y_1 , y_A );

                }else if( CEL_512[ TAU_015 ] <= 0 ){ //:  @@JUNK

                    REC_512.x_0 =    (               x_A );
                    REC_512.x_1 =    (               x_A );
                                                 
                    REC_512.y_0 =    (               y_A );
                    REC_512.y_1 =    (               y_A );

                }else{ aac2020_taudepo_Halt("[WTF:CEL_512]"); };

            //: #DIA_SUB_CEL# (BELOW) ://

                ;;;;;;if( CEL_128[ SUB_015 ] >= 1  ){ //: @VALID

                    REC_128.x_0 = MIN( REC_128.x_0 , x_B );
                    REC_128.x_1 = MAX( REC_128.x_1 , x_B );

                    REC_128.y_0 = MIN( REC_128.y_0 , y_B );
                    REC_128.y_1 = MAX( REC_128.y_1 , y_B );

                }else if( CEL_128[ SUB_015 ] <= 0 ){ //:  @@JUNK

                    REC_128.x_0 =    (               x_B );
                    REC_128.x_1 =    (               x_B );
                                                 
                    REC_128.y_0 =    (               y_B );
                    REC_128.y_1 =    (               y_B );

                }else{ aac2020_taudepo_Halt("[WTF:CEL_128]"); };

            //: #DIA_VAR_CEL# (BELOW) ://

                ;;;;;;if( CEL_032[ VAR_255 ] >= 1  ){ //: @VALID

                    REC_032.x_0 = MIN( REC_032.x_0 , x_C );
                    REC_032.x_1 = MAX( REC_032.x_1 , x_C );

                    REC_032.y_0 = MIN( REC_032.y_0 , y_C );
                    REC_032.y_1 = MAX( REC_032.y_1 , y_C );

                }else if( CEL_032[ VAR_255 ] <= 0 ){ //:  @@JUNK

                    REC_032.x_0 =    (               x_C );
                    REC_032.x_1 =    (               x_C );
                                                 
                    REC_032.y_0 =    (               y_C );
                    REC_032.y_1 =    (               y_C );

                }else{ aac2020_taudepo_Halt("[WTF:CEL_032]"); };

            #undef  MIN                               //: 01 ://
            #undef  MAX                               //: 02 ://
            //:-----------------:Expand_Dirty_Rect_Selections://
            //:Mark_Individual_Cells_As_Dirty:---------------://

                DIR_ANY =( 1 );
                CEL_512[ TAU_015 ]=( 1 );
                CEL_128[ SUB_015 ]=( 1 );
                CEL_032[ VAR_255 ]=( 1 );

            //:---------------:Mark_Individual_Cells_As_Dirty://

        #undef  DIR_ANY AAC2020_TAUDIRT_DIR_ANY       //: 01 ://
        //:     DIR_512 AAC2020_TAUDIRT_DIR_512       //: 02 ://
        //:     DIR_128 AAC2020_TAUDIRT_DIR_128       //: 03 ://
        //:     DIR_032 AAC2020_TAUDIRT_DIR_032       //: 04 ://
                                                      //: -- ://
        #undef  CEL_512 AAC2020_TAUDIRT_CEL_512       //: 05 ://
        #undef  CEL_128 AAC2020_TAUDIRT_CEL_128       //: 06 ://
        #undef  CEL_032 AAC2020_TAUDIRT_CEL_032       //: 07 ://
                                                      //: -- ://
        #undef  REC_512 AAC2020_TAUDIRT_REC_512       //: 08 ://
        #undef  REC_128 AAC2020_TAUDIRT_REC_128       //: 09 ://  
        #undef  REC_032 AAC2020_TAUDIRT_REC_032       //: 10 ://
                                                      //: -- ://
        #undef  TAU_015 DEX_TAU_000_015               //: 11 ://
        #undef  SUB_015 DEX_SUB_000_015               //: 12 ://
        #undef  VAR_255 DEX_VAR_000_255               //: 13 ://
        //:--------------------------:DIRTY_SECTOR_MANAGEMENT://

##############################_FIRST_TAUDIRT_ATTEMPT_WAS_WRONG_#
#PAIRED_IDENTICAL_BLOCKS_OF_4_LINES#############################

    Same idea as #PAIRED_IDENTICAL_BLOCKS_OF_3_LINES#
    But 4 lines instead of 3.

#############################PAIRED_IDENTICAL_BLOCKS_OF_4_LINES#
#PAIRED_IDENTICAL_BLOCKS_OF_3_LINES#############################

    PAIRED_IDENTICAL_BLOCKS_OF_3_LINES:

        Marks a place in source code where an identical
        block of source code should exist.

        The identical blocks of code in question should
        be exactly 3 lines of code each. For a total
        of 6 lines. ( But only 3 unique lines )

        Doing this because writing a common helper function
        would be more code than just cut+paste and would add
        extra indirection which would make the code
        harder to understand.

#############################PAIRED_IDENTICAL_BLOCKS_OF_3_LINES#
@AFD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @AFD@: Allow_Forward_Declaration:
    
        Typically my code is written WITHOUT forward 
        declarations to maintain strict ordering of
        functions.

        However, unit tests can become VERY FUCKING LONG.
        And I'd rather not have to scroll through all of
        that stuff to see the code I care about.

        Thus, unit tests will always be at bottom of file.

        Unit tests are typically called LAZILY by the
        initializer functions so that it is VERY DIFFICULT
        to shut off unit tests.

        This rigidity is by design to avoid "Code Rot"
        of the unit tests.

        Code Rot Scenario:
        1. Someone disables unit tests.
        2. 3 months pass.
        3. Someone enables unit tests.
        4. Unit test fail all over the place and
           no one has any fucking clue how to fix them
           because now errors have compounded in the program.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AFD@
#_ONLY_TAUDEPO_CAN_USE_TEX_LOT_ZERO_############################

    Originally I never wanted to use texture slot (tex_lot)
    zero for ANYTHING. But now I've decided that taudepo
    "CAN" and "MUST" use texture slot 0.

    All other sub-systems must use slots [ 1 -to- 9 ]
    inclusive.

############################_ONLY_TAUDEPO_CAN_USE_TEX_LOT_ZERO_#
#_CHANGED_MY_MIND_ON_TEX_LOT_ZERO_##############################
#_CHANGED_MY_MIND_ON_ZERO_######################################

    RELATED_TO_OLD_TAG: #_WE_NEVER_USE___ZERO_FOR___SAM_VAL_#

    CHANGED_MY_MIND_ON_DATE[ 2020_12_13 ]
    I decided to use texture slot zero for "taudepo".
    Because we need a common texture to share uniforms
    that are encoded into the texture itself.

        OLD_COMMENT_BELOW: ( Changed My Mind. Now using )
                           ( slot 0 for taudepo.        )
        *************************************************
            Texture Slot If Configured On CPU Side  
            And then uploaded to GPU. This is how   
            I know this value should never be <= 0  
            Because.. I DONT USE ZERO FOR THIS.   
        *************************************************

######################################_CHANGED_MY_MIND_ON_ZERO_#
##############################_CHANGED_MY_MIND_ON_TEX_LOT_ZERO_#
#LOOP_TICK######################################################
#LoopTick#######################################################

    #LOOP_TICK#: A  SomeFunction_LoopTick(...) is a function
                 that is meant to be called within the 
                 body of a loop.

                 TYPICALLY:

                    1. A game loop
                    2. A render loop

######################################################LOOP_TICK#
#######################################################LoopTick#
#DO_SWITCH######################################################

    #DO_SWITCH#: Using a do-while(0) loop to create 
                 switch-like structure that does not    
                 require compile time constants for
                 each case.

    EXAMPLE: ORIGINAL SWITCH STATEMENT: (2020_12_13)

            switch( chr_key ){
            case '1' :{ str = P_1; dex_fou = 1; };break;
            case '2' :{ str = P_2; dex_fou = 2; };break;
            case '3' :{ str = P_3; dex_fou = 3; };break;
            case '4' :{ str = P_4; dex_fou = 4; };break;
            case '5' :{ str = P_5; dex_fou = 5; };break;
            case '6' :{ str = P_6; dex_fou = 6; };break;
            case '7' :{ str = P_7; dex_fou = 7; };break;
            case '8' :{ str = P_8; dex_fou = 8; };break;
            case '9' :{ str = P_9; dex_fou = 9; };break;
            default:{ 
                INFO("[PICK_SHADER_USING_NUMBER_KEY]\n");
            };};;

    EXAMPLE: REFACTORED INTO DO_SWITCH (2020_12_13)

            ****************************************************
            Intead of compile time constants '1'  -to- '9'
            We are comparing against vars BED_001 -to- BED_009
            ****************************************************

            //:#DO_SWITCH#:==================================://
            #define KEY chr_key
            #define BIF if( dex_fou > 0 ){break;};
            do{
                if( KEY == BED_001 ){ str = P_1; dex_fou = 1; };
            BIF
                if( KEY == BED_002 ){ str = P_2; dex_fou = 2; };
            BIF
                if( KEY == BED_003 ){ str = P_3; dex_fou = 3; };
            BIF
                if( KEY == BED_004 ){ str = P_4; dex_fou = 4; };
            BIF
                if( KEY == BED_005 ){ str = P_5; dex_fou = 5; };
            BIF
                if( KEY == BED_006 ){ str = P_6; dex_fou = 6; };
            BIF
                if( KEY == BED_007 ){ str = P_7; dex_fou = 7; };
            BIF
                if( KEY == BED_008 ){ str = P_8; dex_fou = 8; };
            BIF
                if( KEY == BED_009 ){ str = P_9; dex_fou = 9; };
            BIF
            }while( 0 );
            #undef  KEY   /** chr_key , key pressed **/
            #undef  BIF   /** BIF:Break_If_Found    **/
            //:==================================:#DO_SWITCH#://

######################################################DO_SWITCH#
#_MINIMAL_MENTAL_INDIRECTION_###################################

    WRITTEN_ON_DATE[ 2020_12_13 ]

    Example: AAC2020_KEYBIND.FRAGBED

        These bindings add less mental indirection than
        they do physical indirection.

        bed_000 == '0'
        bed_001 == '1'
        bed_002 == '2'

        000 maps to 0
        001 maps to 1
        002 maps to 2

        ETC. We only have to remember the "bed_" prefix
        and the overall pattern. But we don't need to
        individually memorize the re-mapping for each
        variable since the pattern is consistent.

###################################_MINIMAL_MENTAL_INDIRECTION_#
#LAX_COMMA_HACK#################################################

    A variable who's only existance is to allow me to 
    put commas in front each variable in an initializer 
    list. See (AAC2020_KEYBIND) for example.

#################################################LAX_COMMA_HACK#
#_PAINT5D_KEY_BINDING_JUSTIFY_REASON_###########################


    ************************************************************
    We want the muscle memory to be intuitive.
    The HIGH keys go FORWARD.            (q,w,e,r,t,y,u,i,o,p)
    The LOW  keys go BACKWARDS.          (z,x,c,v,b,n,m)
    The MID  keys are not directional.   (a,s,d,f,g,h,j,k,l)

    EXCEPTION: E,S,D,F for (WASD-Like directional movement)

    ************************************************************

,   .PAINT5D.p5d_lef = 'S'
,   .PAINT5D.p5d_rig = 'F'
,   .PAINT5D.p5d_upp = 'E'
,   .PAINT5D.p5d_dow = 'D'

,   .PAINT5D.p5d_v_n = 'T' /**[V]alue(oftile)[N]ext **/
,   .PAINT5D.p5d_v_b = 'B' /**[V]alue(oftile)[B]ack **/

    //: G in the middle. Because is both + and - .
,   .PAINT5D.p5d_tog = 'G' /**Toggle Tile On Off. (SET/UNSET)**/

    //: TILE_SIZE:
    //: W: Feels like moving UP  . Which is progressive.
    //: X: Feels like moving DOWN. Which is backwards.
,   .PAINT5D.p5d_e_n = 'W' /** tile size [E]xponent [N]ext **/
,   .PAINT5D.p5d_e_b = 'X' /** tile size [E]xponent [B]ack **/

    //: ZOOM_IN_OUT:
    //: R: Feels like moving UP  . Which is progressive.
    //: V: Feels like moving DOWN. Which is backwards.
,   .PAINT5D.p5d_z_o = 'R' /** Zoom OUT (Moving UP and over) **/
,   .PAINT5D.p5d_z_i = 'V' /** Zoom INN (Digging DOWN lower) **/

###########################_PAINT5D_KEY_BINDING_JUSTIFY_REASON_#
@ONLY4NOW@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @ONLY4NOW@ :
        Means you probably have some commented out variables
        that are NOT used yet, but you intend to use them
        later. The @ONLY4NOW@ is pointing at the only
        variable that has been left un-commented in the
        source code.

        SEE[ TAUDEPO.D._ ]ON[ 2020_12_12 ]TIME[ 640AM - 800AM ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ONLY4NOW@
#_LOCATIONS_MUST_BE_MODDABLE_BY_FOUR_###########################

    Each variable is stored as 4 pixels on the gpu texture.
    Thus each constant identifiying the variable location
    must be evenly divisible by 4.

###########################_LOCATIONS_MUST_BE_MODDABLE_BY_FOUR_#
###########################_LOCATIONS_MUST_BE_MODDABLE_BY_FOUR_#
@IAM_DIFFERENT_NOTICE_ME@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    Also known as a #PATTERN_BREAKER#

@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@IAM_DIFFERENT_NOTICE_ME@
#PAINT5D_OLD_LIBCHAN_NOTES######################################

        //: #PATTERN_BREAKER# ------------------------------ ://
        //: You might be expecting:                          ://
        //: 1: AAC2020_INCLUDE_GPUDATA_PAINT5D               ://
        //: 2: INCLUDE_GPUDATA_PAINT5D                       ://
        //: But using shorter namespacing for our            ://
        //: includes to avoid running over column limit.     ://
        //: ------------------------------------------------ ://
        #define AAC2020_INCLUDE_GPUDATA_PAINT5D "DO_NOT_USE"
        #define INCLUDE_GPUDATA_PAINT5D         "DO_NOT_USE"

        //:GPUDATA_PAINT5D: -------------------------------- ://
        //:        Graphical Data For a 5-Dimensional        ://
        //:        MS-PAINT 95 like program.                 ://
        //:                                                  ://
        //:        Dimensions:                               ://
        //:        1. Tile X                                 ://
        //:        2. Tile Y                                 ://
        //:        3. Tile Size                              ://
        //:        4. Tile Layer                             ://
        //:        5. Tile Color                             ://
        //:   NOT: "LIB/PAINT5D.D._" << #PATTERN_BREAKER     ://

######################################PAINT5D_OLD_LIBCHAN_NOTES#
#TAUDEPO_SIGNATURE_SKETCHING####################################

    This is how I want to use the TAUDEPO system:

    THIS! A bit clunky. But easy to figure out where
    everything is comming from.

        ********************************************************
        AAC2020_TAUDEPO_Put( 
            AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
        ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
        ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
        ,   x0,x1,y0,y1
        );;
        ********************************************************

    Maybe NOT with #defines for everything? 

        #define PUT AAC2020_TAUDEPO_Put
        #define TAU AAC2020_TAUDEPO
            PUT(TAU.TAU_015 , TAU.PAINT5D, TAU.VIEWPORT1, 
                x0,x1,y0,y1 );
        #undef PUT
        #undef TAU

    CLOSER....

        #define TAU_PUT AAC2020_TAUDEPO_Put

            TAU_PUT( TAU_015 , PAINT5D, VIEWPORT1, x0,x1,y0,y1 )

        #undef TAU_PUT


    CLOSE_BUT_NOT_WHAT_I_DECIDED_ON:

        TAU_PUT_000( PAINT5D,VIEWPORT1,x0,x1,y0,y1 );
        TAU_PUT_015( PAINT5D,VIEWPORT1,x0,x1,y0,y1 );

        TAU_PUT( PAINT5D , VIEWPORT1 , x0 ,x1, y0, y1 )
        TAU_PUT( PAINT5D , ITIME     , it ,__, __, __ );

####################################TAUDEPO_SIGNATURE_SKETCHING#
@_VP0_@@_VP1_@@_VPC_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@VP0@@VP1@@VPC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    :VIEWPORT_TYPES:-------------------------------------------:

@_VP0_@   VP0:Viewport_Zero(0): (Destination/Screen Viewport)
@_VP1_@   VP1:Viewport_One( 1): (Offscreen/Source/BitmapData)
@_VPC_@   VPC:Viewport_Canvas : (Or: Window/OpenGL)

    :-------------------------------------------:VIEWPORT_TYPES:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_VP0_@@_VP1_@@_VPC_@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@VP0@@VP1@@VPC@
#_UNIFORM_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_###############
#_UNIFORMITY_OF_CODE_TRUMPS_PARANOID_ERROR_CHECKING_############
#_CONSISTENT_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_############

    I was thinking about using the LATTER signature because
    it would help the compiler catch accidential mixing
    of wrong types.... 

    Lets not make the code less consistent just because
    we are paranoid.

    I08
    AAC2020_TAUDEPO_Put( 
        U08 DEX_TAU_000_015  <--- GOOD
    ,   U08 DEX_SUB_000_015  <--- GOOD
    ,   U08 DEX_VAR_000_255  <--- GOOD
        ....
    )

    I08
    AAC2020_TAUDEPO_Put( 
        U08 DEX_TAU_000_015  <--- BAD
    ,   U08 DEX_SUB_000_015  <--- BAD
    ,   I32 DEX_VAR_000_255  <--- BAD
        ....
    )
 
############_CONSISTENT_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_#
############_UNIFORMITY_OF_CODE_TRUMPS_PARANOID_ERROR_CHECKING_#
###############_UNIFORM_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_#
#_TAUDEPO_SHOULD_BE_DEFINES_####################################

    //: Example Value For: DEX_TAU_000_015

        #define AAC2020_TAUDEPO_TAU_000 ( 0 )  



    //: Example Value For: DEX_SUB_000_015

        #define AAC2020_TAUDEPO_SUB_PAINT5D ( 1 )



    //: Example value For: DEX_VAR_000_255

        #define AAC2020_TAUDEPO_VAR_vp0



####################################_TAUDEPO_SHOULD_BE_DEFINES_#
#_TAUDEPO_SHOULD_NOT_BE_A_LIBRARY_STRUCT_#######################

    ************************************************************
    We cannot INJECT the needed values into hard coded 
    shader source strings if we use anything besides
    defines ( #define ) for our TAUDEPO constants.
    ************************************************************

    struct AAC2020_TAUDEPO_PUBLIC_LIBRARY_STRUCT{

        //:DEX_TAU_000_015 : TAU [ SET / BLOCK ] Section
        //:DEX_SUB_000_015 : Sub System [Index/Enumeration/IID]
        //:DEX_VAR_000_255 : ( dex_var % 4 == 0 ) (Var Location)

    }AAC2020_TAUDEPO={

        /** These are NOT texture slots, we just use the **/
        /** numbers for the texture slots to facilitate  **/
        /** TIGHT COUPLING and SIMPLICITY.               **/

        //:DEX_TAU_000_015 : TAU [ SET / BLOCK ] Section
            .TAU_000 = 0
            .TAU_001 = 0
            .TAU_002 = 0
                 .........
       
        //:DEX_SUB_000_015 : Sub System [Index/Enumeration/IID]
            .TAUDEPO = AAC2020_PIXNAME_taudepo_tex_lot //: 0 ://
    ,       .PAINT5D = AAC2020_PIXNAME_paint5d_tex_lot //: 1 ://
    ,       .TODO_02 = AAC2020_PIXNAME_paint5d_tex_lot //: 2 ://
    ,       .TODO_03 = AAC2020_PIXNAME_paint5d_tex_lot //: 3 ://
     
    };

#######################_TAUDEPO_SHOULD_NOT_BE_A_LIBRARY_STRUCT_#
#_TAUDEPO_JUSTIFICATION_FOR_LIBRARY_STRUCT_#####################
    
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    I WAS WRONG ABOUT THIS. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SEE[ #_TAUDEPO_SHOULD_NOT_BE_A_LIBRARY_STRUCT_# ]
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    *******************************************
    Shorthand access using a library struct is 
    much LESS convoluted than without.
    *******************************************
    ------------------------------------------------------------
    FUCK_THIS:

        #define T( name ) AAC2020_TAUDEPO_##name

            T(TAU_015) //: AAC2020_TAUDEPO_TAU_015

    USE__THIS:

        #define T AAC2020_TAUDEPO

            T.TAU_015  //: AAC2020_TAUDEPO.TAU_015

    ------------------------------------------------------------
######################_TAUDEPO_JUSTIFICATION_FOR_LIBRARY_STRUCT_

#_KEEP_TAUGET_VOID_TO_AVOID_CONFUSION_##########################

    If AAC2020_TAUDEPO_Get returns by both 
    output parameters (points to U32) and by a return 
    value, it is likely to be used improperly.

    Someone might think the return value is the value
    we are trying to get with the getter. And that isn't
    an INSANE assumption to make.

##########################_KEEP_TAUGET_VOID_TO_AVOID_CONFUSION_#
@TAU_PUT@@TAU_GET@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @TAU_PUT@ :Shorthand For AAC2020_TAUDEPO_Put

    @TAU_GET@ :Shorthand For AAC2020_TAUDEPO_Get

    AAC2020_TAU_Put : TYPO_OF[ AAC2020_TAUDEPO_Put ]
    AAC2020_TAU_Get : TYPO_OF[ AAC2020_TAUDEPO_Get ]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TAU_PUT@@TAU_GET@
#FILL_PATTERN###################################################

    [ fill-pattern ]SEE[ AAC2020_PIXLOAD_TestPattern ]
    [ fill pattern ]SEE[ AAC2020_PIXLOAD_TestPattern ]

###################################################FILL_PATTERN#
@NEVER_SILENCE_ME@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    NEVER_SILENCE_ME: Means that we should not add any code
                      to silence messages from this function.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NEVER_SILENCE_ME@
#BRACKET_COMMENT_NOTATION_EXPLAINED#############################

    This is a bad choice....
    This is a [ bad / immoral ] choice.
    This is a [ bad / incorrect ] choice.

#############################BRACKET_COMMENT_NOTATION_EXPLAINED#
@DOUBLE_PRINT_FLUSH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @DOUBLE_PRINT_FLUSH@ :

    Before printing actual message content, we print
    a simple message first and flush console so that
    in advent of complex printf message causing a segfault,
    we still have some type of feedback to grab onto to
    find the location of where things went wrong.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DOUBLE_PRINT_FLUSH@
@GETTER@PUTTER@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @GETTER@: Denote function is a GETTER function.
    @PUTTER@: Denote function is a PUTTER function.

    @SETTER@: DONT_FUCKING_DO_THIS.
              (Delta between Get & Set is only 1 letter. )
              (Delta between Get & Put is      2 letters. )

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@GETTER@PUTTER@
@VDAWEA@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    VDAWEA:values_dont_agree_with_each_other

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@VDAWEA@
#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_########################

        AAC2020_PIXLOAD_sam_get <-- DONT USE.

        PIK: AAC2020_PIXLOAD_sam_loc( &gpudata ) <--[A]
        PIK: AAC2020_PIXLOAD_sam_val( &gpudata ) <--[B]

        [A]: Loads sampler location into: gpudata->sam_loc
        [B]: Loads sampler    value into: gpudata->sam_val

        BOTH ARE FAULT TOLERANT.
        (No look before you leap required)

########################_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#
#DEFINITELY_FORGOT_TO_INIT_44044################################

    Sampler LOCATION (sam_loc) is inited to 44044
    in PIXNAME.D._ . This is an intentional TRAP value
    so that we can locate the source of the problem
    if sampler is flagged as not existing. ( sam_loc < 0 ).

    ( If not locate, at least remove PIXNAME filescope        )
    ( variable initialization from the list of possibilities. )

################################DEFINITELY_FORGOT_TO_INIT_44044#
#_WE_DONT_CONTROL_THE_SAMPLER_LOCATION_#########################

    sam_loc : CAN BE ZERO , we don't CONTROL this value.

    sam_val : MUST NOT BE ZERO.
              ( We control this value. And while OpenGL allows)
              ( us to sample from texture slot 0 (sam_val==0) )
              ( AAC2020 code base dis-allows this in the name )
              ( of avoiding error prone code.                 )

#########################_WE_DONT_CONTROL_THE_SAMPLER_LOCATION_#
#I_THINK_SHOULD_BE_ERROR_0338AM#################################

    #I_THINK_SHOULD_BE_ERROR_0338AM#:

    Because we look before we leap, we should always see
    that a texture sampler is flagged as existing inside
    the[ aac2020_pixload_PushSampler ]function.

    REMOVED_THIS_COMMENTARY_FROM:PIXLOAD.F._ :

        Do nothing. Just always re-fetch the        
        Uniform after uploading the texture data.   
        You just uploaded (512*512*4) bytes,        
        what is 4 more (uint32 sampler uniform) ?   
        
        DO_NOTHING_HERE  

#################################I_THINK_SHOULD_BE_ERROR_0338AM#
#_SAM_VAL_ZERO_NEVER_USED_IN_THIS_CODE_BASE_####################
#_WE_NEVER_USE___ZERO_FOR___SAM_VAL_############################

    In reference to this.... AGAIN!
    #_2ND_GUESSING_PIXLOAD_TEX_SAM_ERR_#    

    sam_val cannot be ZERO because WE DONT USE ZERO
    AS A TEXTURE SLOT IN THIS CODE BASE.

    Zero however IS a valid address in terms of
    open gl uniform locations. It is just not a valid
    address for this code base.

############################_WE_NEVER_USE___ZERO_FOR___SAM_VAL_#
####################_SAM_VAL_ZERO_NEVER_USED_IN_THIS_CODE_BASE_#
#_DEBUGGING_2020_12_11_NOTES_###################################

    I [ THINK ]....
        I may be confusing "sam_loc" with "sam_val"

        "sam_val" === "tex_lot"

        "sam_loc" === ADDRESS_OF[ pix_name ]IN_GLSL_SHADER
                (  You do not control this value and     )
                (  cannot expect it to be anything .     )
                (  VALID SETUP MEANS: sam_loc >= 0       )
                (  Unfortunately, zero is valid address  )

    CONSOLE_MESSAGES:
    ************************************************************
    [aac2020_paint5d_Info_dec]...
    [AAC2020_PAINT5D_init_call_count]:2

    [aac2020_paint5d_Okay]:
            [OH_FUCK...Code_Below_Was_Never_Ran_Before]

    [FATAL_ERROR:AAC2020_pixload]:[IMPROPER_SETUP:sam_loc]
    [ENTER_TO_EXIT]:
    ************************************************************

##################################_DEBUGGING_2020_12_11_NOTES_##
#_EDITOR_INIT_SPAM_GAURD_#######################################

    GOOD_SPAM_GAURD:-------------------------------------------:

        Because[ AAC2020_CEDITOR_nex_edi ]AND
               [ AAC2020_CEDITOR_dex_edi ]
        
            Are set at a more coarse higher-level managing
            scope. ( AAC2020_HandleInput ), this is less 
            prone to breakage.

            However, having state tightly coupled with
            a "HandleInput" function does seem a bit 
            [ wonky / bad / improper / ugly ] and we 
            might want to think about how to revisit this.

        if( AAC2020_CEDITOR_nex_edi 
        ==  AAC2020_CEDITOR_dex_edi
        ){
            O_K("[PAINT5D:Init_Already_Up_To_Date]");
        };;

    :-------------------------------------------:GOOD_SPAM_GAURD:
    BAD_SPAM_GAURD:--------------------------------------------:
    
        This spam gaurd is bad because it relies on 
        EVERY SINGLE EDITOR correctly setting the
       (AAC2020_CEDITOR_dex_ini) flag.

        Highly Error Prone.
        Also prone to re-breaking all the time
        as new systems are added.

        /** Editor Initialization Spam Gaurd **/
        if( AAC2020_CEDITOR_dex_ini ==
            AAC2020_CEDITOR_paint5d
        ){
            O_K("[PAINT5D:Init_Already_Up_To_Date]");
            return( 0x00 );
        };;

    :-------------------------------------------:BAD_SPAM_GAURD:

#######################################_EDITOR_INIT_SPAM_GAURD_#
#_DONT_DISABLE_VERTEX_ATTRIB_ARRAY_IN_GRAQUAD_##################

    //[ DON'T DO THIS.                                   ]//
    //[ Your triangle will vanish!                       ]//
    //- AAC2020_GLEBIND.glDisableVertexAttribArray(0);   -//
    //- fn(ErrChk)("[DisVerAttArr]");                    -//

##################_DONT_DISABLE_VERTEX_ATTRIB_ARRAY_IN_GRAQUAD_#
#_BASIC_UNIFORM_UPDATE_DOESNT_USE_CALLBACKS_####################

    EXTRACTED_FROM[ GRAQUAD.F._ ]ON_DATE[ 2020_12_11 ]

    ------------------------------------------------------------
    Originally this code called from the future using   
    a callback. But decided.                            
                                                        
    1: Calling from future violates LIBCHAN design.     
    2: Callbacks made the code harder to follow.        
    Avoid them when possible.                          
                                                       
    (Still a fan of using callback to create   )       
    (abstract classes, like my tilemap entities)       
    (that exist by rendering themselves as     )       
    (tiles on a tilemap using function pointers)       
    (to GetTile and SetTile functions.         )       
    ------------------------------------------------------------

    aac2020_graquad_ReLoadShaderUniforms_iMouse      (0x00);
    aac2020_graquad_ReLoadShaderUniforms_iTime       (0x00);
    aac2020_graquad_ReLoadShaderUniforms_iResolution (0x00);

####################_BASIC_UNIFORM_UPDATE_DOESNT_USE_CALLBACKS_#
@SAFETY_DOUBLE_FLUSH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    Incase printf parameters cause segfault, have a basic
    print and flush BEFORE your real call to printf.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SAFETY_DOUBLE_FLUSH@
#_SILENCEALL_NOTIMPLEMENTED_####################################
#_SILENCE_ALL_NOT_IMPLEMENTED_##################################

    ************************************************************
    I forgot to implement AAC2020_SILENCE.SILENCE
    while I was refactoring. I doubt I will ever want to
    use this, so just leave it unimplemented until a need
    arises for you to use it.

    WRITTEN_ON[ DATE[ 2020_12_11 ]
    ************************************************************
    
####################################_SILENCEALL_NOTIMPLEMENTED_#
##################################_SILENCE_ALL_NOT_IMPLEMENTED_#
#_WHAT_IS_AACMAIN_##############################################

    #WHAT_IS_AAC_MAIN# : What Is AACMAIN ?
    ------------------------------------------------------------

        AACMAIN is a ficticious namespace.
        It is the namespace of code without a namespace.

        AKA: MAIN code. The code that couples together 
             all of the LIBCHAN sub-library code and runs it.

        ADDED[ AAC2020_SILENCE.AACMAIN ]ON_DATE[ 2020_12_11 ]

        So I have a way to silence top-level code that is not
        part of any sub-library in the LIBCHAN.
    ------------------------------------------------------------

##############################################_WHAT_IS_AACMAIN_#
#_OUTSIDE_OF_MY_PAY_GRADE_GRAQUAD_REMOVED_######################

    Legacy comment from a previous project.
    This comment is probably 100% useless now.
    COMMENTARY_WRITTEN[ 2020_12_11 ]

    //:#FUNCTION_EXECUTION_ORDER_MATTERS#://
    ga_MakeViewportTextureAndActivate( 1 );  << BOARDWIN's job
    ga_ConfigureTextureSampling_PORPIX( 1 ); << BOARDWIN's job
    ga_UploadTexturePixels_PORPIX( 1 );      << BOARDWIN's job
  
######################_OUTSIDE_OF_MY_PAY_GRADE_GRAQUAD_REMOVED_#
#KEEP_INIT_CHAIN_FLAT_NOT_NESTED################################
    
    Extracted_From[ GRAQUAD.F ]ON_DATE[ 2020_12_11 ]

            Commented out. + + + + + + + + + + + + + + + + + + +  
            COG_Init();    - - - - - - - - - - - - - - - - - - -  
            Initialize after other dependencies. But don't      
            Initialize dependencies inside here. That works,    
            but makes the logic a lot harder to follow.         
            It also could create a very large init chain        
            that unecessarily creates a very deeply             
            nested stack.                                       
            - - - - - - - - - - - - ---- - - - - - - - - - - - -  
            - - - - - - - - - - - - ---- - - - - - - - - - - - -  

################################KEEP_INIT_CHAIN_FLAT_NOT_NESTED#
#HALT_OR_STATUS_CODE_AND_FAULT_TOLERANT_SHADERS#################

        COMMENTARY: (DATE[ 2020_12_11 ])
        ********************************************************
        The hashtag in the extracted comment below cannot be
        found. Probably back when I was putting each comment
        in it's own file. (BAD IDEA ADMINISTRATIVELY)

        HALT_OR_STATUS_CODE (HOS)
        Is basically telling you should you HALT or return
        a status code if things go wrong. This enables you to
        wrap the function in a FAIL_FAST and FAULT_TOLERANT
        version.

        Fault tolerant version is needed if we are going
        to allow users of the game to modify the shader
        source code at will by editing shader source
        in the "MOD" folder.
        ********************************************************

        EXTRACTED_COMMENT: ( From: GRAQUAD.F._ ON:2020_12_11 )
        ********************************************************
        //: A4[ #FEATURE:FAULT_TOLERANT_USER_FRAG_SHADERS# ] ://
        //: If function fails, what should it do?            ://
        //: AAC2020_GRAQUAD_FAIL_FAST                        ://
        //: AAC2020_GRAQUAD_FAIL_CODE                        ://
        ********************************************************

#################HALT_OR_STATUS_CODE_AND_FAULT_TOLERANT_SHADERS#
#DLL_LOADING_WILL_FAIL_STOP_HERE################################

    EXTRACTED_FROM[ GLEBIND.F ]ON_DATE[ 2020_12_11 ]

            Without search paths, we will fail to load   
            the DLL. Best to stop here so the console    
            output's last message is the ROOT problem. 
  
            fflush(stdout);exit(666);

################################DLL_LOADING_WILL_FAIL_STOP_HERE#
#_DONT_GET_SO_MARCO_HEAVY_WITH_DEBUG_PRINTS_####################

    ************************************************************
    This code was a bad idea. 
    Refactoring_This[ AAC2020_GLEBIND_MM_DEBUGPRINT_01 ]
    Refactoring___To[ aac2020_glebind_Hunt ]
    ************************************************************

    #define AAC2020_GLEBIND_MV_DEBUGPRINT_01 0                       
    #if(AAC2020_GLEBIND_MV_DEBUGPRINT_01 <= 0)                       
                                                                     
        //: emp_mac_arg:empty_macro_arg ://                          
        #define AAC2020_GLEBIND_MM_DEBUGPRINT_01( emp_mac_arg )      
                                                                     
    #else                                                            
                                                                     
        void AAC2020_GLEBIND_MM_DEBUGPRINT_01( const char* m ){      
            printf("[AAC2020_GLEBIND:DP_01]:%s\n",m);                
            fflush(stdout);                                          
        }                                                            
                                                                     
    #endif   

####################_DONT_GET_SO_MARCO_HEAVY_WITH_DEBUG_PRINTS_#


#_DO_NOT_INIT_WINDOW_CODE_HERE_#################################
 
    //:POSSIBLE_SOURCE_OF_REFACTOR_PROBLEMS:=================://

        /** This might be okay. The vital piece is that a    **/
        /** window must exist before you are able to create  **/
        /** an openGL context. AAC2020_GINAWIN_Init(...)     **/
        /** will do this. However, calling it here goes      **/
        /** against the LIBCHAN (library chain) code         **/
        /** structure we are trying to make.                 **/
        /** -John Mark Isaac Madison DATE[ 2020_11_01 ]      **/

        //[ ************************************************ ]//
        //- AAC2020_GINAWIN_Init(); <------ Commented out.   -//
        //[ ************************************************ ]//

        printf("*********************************\n");
        printf(
        "[DEBUG_NOTE:Originally_GLEB_Inited_GLEB_SWIN_here]\n"
        );;
        printf("*********************************\n");

    //:=================:POSSIBLE_SOURCE_OF_REFACTOR_PROBLEMS://
    /** **************************************************** **/

#################################_DO_NOT_INIT_WINDOW_CODE_HERE_#
#POINTER_SATED_ASSERTS_NON_NULL_PTR#############################

    Used to make sure function pointer is NOT null.      
    Hopefully can swap out for macro in the future to    
    remove this overhead when in a release mode.         

#############################POINTER_SATED_ASSERTS_NON_NULL_PTR#
#GLEBIND_FORGOT_TO_INIT_ERROR_CHECK#############################

    Forgetting to INIT is a root error, so crash  
    here first before checking function pointer.  

#############################GLEBIND_FORGOT_TO_INIT_ERROR_CHECK#
@ECHOFUNC_EXTRAFLUSH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    Denotes an extra fflush(stdout) in an echo/print
    type function. Typically to help prevent not seeing
    any messages because the message string itself 
    in a worst case scenario could be responsible for
    a SEGFAULT.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ECHOFUNC_EXTRAFLUSH@
#INFO_MESSAGES_SD###############################################

    Section containing "INFO" message functions.
    But contains: _str & _dec overloaded varieties.

###############################################INFO_MESSAGES_SD#
#_DUI_PICKCOLOR_KEPT_FOR_REFERENCE_#############################

    /** This version of function adapts to if GINAWIN        **/
    /** Library exists or not. Think I will NOT use this     **/
    /** function but instead use                             **/
    /** AAC2020_DUI_AskUserToPickColor_BWO , but will keep   **/
    /** this code for reference.                             **/

    AAC2020_DUI_AskUserToPickColor <--TALKING ABOUT THIS

#############################_DUI_PICKCOLOR_KEPT_FOR_REFERENCE_#
#_PARENT_ALWAYS_DESKTOP_HERE_DUI_###############################

    //: Parent window always desktop window because      ://
    //: we are in the version of function to be called   ://
    //: before main window opens.                        ://

###############################_PARENT_ALWAYS_DESKTOP_HERE_DUI_#
#ABOUT_HEAP_FREE################################################

    Kernel32.dll                     
    Frees a memory block alloced     
    from a heap by the HeapAlloc     
    or HeapReAlloc function.     

################################################ABOUT_HEAP_FREE#
#_WHY_HW_COMMENTED_OUT_IN_CALL_BELOW_###########################

    /** DATE[ 2020_10_30 ] ********************************* **/
    /** GINAWIN is only meant for ONE window. So we should   **/
    /** make as many variables FILESCOPE as possible to avoid**/
    /** problems resulting from passing around variables.    **/
    /** HENCE: "Hw" commented out in the call below.         **/

    Msg = aac2020_ginawin_WindowLoop( /** Hw **/ );

###########################_WHY_HW_COMMENTED_OUT_IN_CALL_BELOW_#
@CALL_FROM_ANOTHER_THREAD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    This function should be called from a different thread.
    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CALL_FROM_ANOTHER_THREAD@
#_WINTOP_IS_ANNOYING_###########################################
    
    Having "window always on top" is annoying as hell.
    Don't do that. If you don't like it, others will
    definitely hate it.

###########################################_WINTOP_IS_ANNOYING_#
#_SET_FLAG_AFTER_SETTING_DEVICE_CONTEXT_########################

    EXTRACTED_ON_DATE[ 2020_12_09 ]

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯MC|//
    //|PUT AFTER device context has been set,or your   MC|//
    //|device context fetching function waiting on     MC|//
    //|this flag to be set in this thread will end up  MC|//
    //|with a NULL device context. Speaking Of:        MC|//
    //|AAC2020_GINAWIN_GetWindowDeviceContext();       MC|//
    AAC2020_GINAWIN.window_created =( 1 );

########################_SET_FLAG_AFTER_SETTING_DEVICE_CONTEXT_#
@STP_VAR@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    EXTRACTED_ON_DATE[ 2020_12_09 ]

    int ok=( 1 );
    /** ok: Single_Threaded_Promise_Variable( STP_VAR ) **/

    We use the "ok" variable to un-branch single threaded
    logic that would otherwise be heavily nested. So I think
    of the structure just like if I were using a promise
    in node.js or javascript.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@STP_VAR@
#_DONT_CALL_FUNCTION_POINTER_IN_SPINLOCK_#######################

        //: CANDO: (NOT: T-o-d-o ):
        //: Could call a function pointer here.
        //: BUT current plan is to ABANDON multi-threadin.
        //: BECAUSE: KEEP_IT_SIMPLE_STUPID.
        //: Like in DOOM, game logic is tied to frame rate
        //: because they KEEP_IT_SIMPLE_STUPID.

#######################_DONT_CALL_FUNCTION_POINTER_IN_SPINLOCK_#
#_DONT_LET_WINDOW_CODE_MAKE_OPENGL_CALLS_#######################

    ************************************************************
    Found this large comment in my window code above
    [ aac2020_ginawin_WindowLoop ]. I think we should
    NOT call GL calls from the window code. Because
    window code is platform specific and we want to
    avoid tight coupling so refactoring to another
    platform isn't too hard.

    BELOW_EXTRACTED_ON_DATE[ 2020_12_09 ]
    ************************************************************

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //| Since you are discussing threads here,     |//
    //| you are aware that GL commands can only    |//
    //| be issued from a thread that has an        |//
    //| active GL context,correct? And that a      |//
    //| context can only be active in 0 or 1       |//
    //| threads at a time. If you ever tried to    |//
    //| issue commands from a different thread     |//
    //| than the one that created your context,    |//
    //| and you do not understand this then        |//
    //| confusing run-time behvior would ensue;    |//
    //| multi-threading is fine in GL,but you      |//
    //| have to mind which threads have active     |//
    //| contexts.                                  |//
    //| stackoverflow.com/questions/21685932/      |//
    //|____________________________________________|//
    //# Might want to call update here by          #//
    //# adding a render update callback?           #//
    //# That would get it to fire during WM_PAINT  #//
    //# AND get it on same thread, alleviating     #//
    //# two possible problems.                     #//

#######################_DONT_LET_WINDOW_CODE_MAKE_OPENGL_CALLS_#
#_EXTRAFLUSH_INCASE_BADFMTSTR_##################################
    
    Extra fflush(stdout) between printf statements in case
    the 2nd printf statement using a format string variable
    has an invalid format that will cause a segfault.

##################################_EXTRAFLUSH_INCASE_BADFMTSTR_#
#_SETFOCUS_FAILS_IF_DIALOG_IS_OPEN_#############################

    EXTRACTED_DATE[ 2020_12_09 ]FROM[ GINAWIN.F._ ]

        //:NOTE: SetFocus: Will FAIL when other dialogs are
        //:                opened as children of the main
        //:                window. SetFocus probably should
        //:                NOT be used in our 
        //:               [ window_loop / window_tick ]

#############################_SETFOCUS_FAILS_IF_DIALOG_IS_OPEN_#
#_SETFOCUS_DOES_NOT_PUT_WINDOW_TOP_#############################

    EXTRACTED_DATE[ 2020_12_09 ]FROM[ GINAWIN.F._ ]

        //:NOTE: SetFocus: Is NOT responsible for window
        //:                always being on top. That is
        //:                0x00000008L /** WS_EX_TOPMOST **/ 
        //:                Used during window creation.

#############################_SETFOCUS_DOES_NOT_PUT_WINDOW_TOP_#
#_ALWAYS_SHOW_MESSAGE_ON_CRASH_#################################

    If we are crashing the program. Always show the
    todo message that caused the crash.

    Even if( AAC2020_SILENCE.TODOMAN >= 1 )

    Because... It would be a real pain in the ass to 
    terminate the program and not show a reason why.
    So do not allow that behavior.

#################################_ALWAYS_SHOW_MESSAGE_ON_CRASH_#
#_GINAWIN_DOLOOP_ISNOTTHE_FINALFIX_#############################

    Now we wait and see if that stops the crashing.
    I think it will because my guess is I was failing
    to empty ( drain ) the message queue and after 
    enough time of messages being built up, the
    program decides it is being unresponsive.

    Pressing CTLR+ALT+DEL
    makes the program repsonsive again because it
    [flushes/discards] the message queue.

    Allowing you to have to wait for the queue to overflow
    again before the program becomes unresponsive.

    Well fuck... I was wrong....

#############################_GINAWIN_DOLOOP_ISNOTTHE_FINALFIX_#
#__END_OF_GINAWIN_BUGHUNT_001__#################################

    //: END_OF_THE_BUG_HUNT!                             ://
    //: PROBLEM: You for some reason thought that        ://
    //: GetWinDC returned "handle_to_window"             ://
    //: when it does NOT. Type Error.                    ://

#################################__END_OF_GINAWIN_BUGHUNT_001__#
#_ginawin_assert_single_threaded_mode_##########################

    COMMENT:EXTRACTED: DATE[2020_12_09]FROM[GINAWIN.F._]
    
        This function is only for running GINAWIN
        in single threaded mode. The integer supplied
        to function is to help [remember/re-inforce]
        this face.
    
    CODE::::EXTRACTED: DATE[2020_12_09]FROM[GINAWIN.F._]
    
        //:#_ginawin_assert_single_threaded_mode_#:----------://
        #define H aac2020_ginawin_Halt
        
            if( aac2020_ginawin_single_threaded
            !=  AAC2020_GINAWIN_SINGLE_THREADED
            ){
                H("[SINGLE_THREADED_ONLY]");
            };;
            if( AAC2020_GINAWIN.type_of_threading
            !=  AAC2020_GINAWIN_SINGLE_THREADED  
            ){
                H("[INTENTIONS_PURE_BUT_ARE_MULTI_THREADING]" );
            };;
        
        #undef  H
        //:------------:_ginawin_assert_single_threaded_mode_://

##########################_ginawin_assert_single_threaded_mode_#
#_WM_PAINT_RECYCLED_2020_12_09_#################################

    ************************************************************
    Extraced from the WM_PAINT case of GINAWIN.F
    on DATE[ 2020_12_09 ]. All of what was extracted was
    already commented out. Pretty sure we DONT want to run
    any graphics code on WM_PAINT section... But... Do we
    need to do something in here specifically to keep
    the window responsive?
    ************************************************************

            //:[TODO]:Something to pace the updating
            //:of graphics.


            //+ DELETE THIS BLOCK +//
            //- //:I dont think this is needed:         -//
            //- //: You may use the same HDC in both    -//
            //- //: threads, but not at the same time.  -//
            //- //: SEE[ gl-hdc-thread-quote ]          -//
            //- if(AAC2020_GINAWIN.render_tick_function_has){ -//
            //-    AAC2020_GINAWIN.render_tick_function();    -//
            //- };;                                     -//

            //: This might be better done setting a flag
            //: than using a callback. In order to prevent
            //: drawing code from being invoked on the
            //: wrong thread.

            //: With that said, setting a flag:
        //: ENGETHER.THREADING.InterlockedIncrement64(
        //:     &( AAC2020_GINAWIN.THREAD_SAFE_FLAGS.
        //:        redraw_message_count )
        //: );;

            
            //+ This call needs to be made from    +//
            //+ the same thread as your OpenGL     +//
            //+ calls.                             +//
            //# DONT_HERE:AAC2020_GINAWIN_SwapBuffers(); #//

#################################_WM_PAINT_RECYCLED_2020_12_09_#
#_WM_CLOSE_VS_WM_DESTROY_#######################################

    SC[ WM_DESTROY_VS_WM_CLOSE ] *******************  
    WM_DESTROY: CANNOT BE STOPPED, must cleanup.      
    WM_CLOSE  : CAN CHOOSE TO IGNORE AND NOT CLOSE    
                stackoverflow.com/questions/3155782/  
    ************************************************  

#######################################_WM_CLOSE_VS_WM_DESTROY_#
@REFERENCE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    The commented out cod you see with @REFERENCE@ tag means
    it is commented out because it is used as reference.

    As apposed to commented out code because it used to
    be executed but you got rid of it.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@REFERENCE@
#_I_THINK_MUST_ALWAYS_CALL_DEFWINPROC_##########################

    REVISIT_NOTE[ 2020_12_09 ]

        I still have not fixed the bug with window code that
        causes it to become unresponsive. The bug that for
        some odd reason, pressing CTRL+F fixes.

        Even if you don't do ANYTHING with the task manager.

    EXTRACTED_DATE[ 2020_12_09 ]

        [GUESS]I THINK we must ALWAYS call the default window  
        procedure in order to fulfill some type of      
        contract with the operating system. Much like   
        how your parents would report you MISSING if    
        you didn't come home for 5 days, WINDOWS        
        will report your application as unresponsive    
        if your application does not report back        
        frequently enough.                              

##########################_I_THINK_MUST_ALWAYS_CALL_DEFWINPROC_#
#_ABOUT_F_MACROS_###############################################

    SEE[ #_ABOUT_F_MACROS_TOP_# ]

###############################################_ABOUT_F_MACROS_#
#_ABOUT_F_MACROS_BOT_###########################################

    SEE[ #_ABOUT_F_MACROS_TOP_# ]

###########################################_ABOUT_F_MACROS_BOT_#
#_ABOUT_F_MACROS_TOP_###########################################

    EXTRACTED_ON_DATE[ 2020_12_09 ]

    FMACROS.TOP : Declare Function Macros                    
                                                             
    REASON For This File:                                    
        Remove Visual Clutter From AAC2020.C11 's logic .    
                                                             
    More Info:                                               
        The LIBCHAN (librarychain) allows us to compile      
        the project up to different points, as we maintain   
        a strict ordering of our libraries.                  
                                                             
###########################################_ABOUT_F_MACROS_TOP_#
#_EDITOR_CENTRIC_###############################################

    This project is "EDITOR CENTRIC" meaning the game is
    first and foremost an "EDITOR" and the game runs on
    TOP of the editor.

    This is because:

    1. Having 1 [code/codes/sourcecode] for both EDITOR-&-GAME
       means less code to maintain.

    2. Having 1 [code/codes/sourcecode] for both EDITOR-&-GAME
       means what you see in the editor is what you will end
       up with in the game exactly.

    3. EDITOR -WITHOUT- GAME  : Fun art program.
       GAME   -WITHOUT- EDITOR: YOU HAVE NOTHING.

       A GAME IS NOTHING IF YOU CANNOT GET [DATA/ASSETS]
       INTO IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

###############################################_EDITOR_CENTRIC_#
#_YOU_SPELL_CPUNIFO_WRONG_A_LOT_################################

    CPUINFO : WRONG!! You Mean: CPUNIFO

################################_YOU_SPELL_CPUNIFO_WRONG_A_LOT_#
#_BE_NICE_AVOID_MACRO_POLLUTION_OF_OTHERS_CODE_#################

        DONT_POLLUTE_OTHER_PEOPLES_CODE_WITH_MACROS:

        I could see how these might be useful to other       
        people using the library.... But lets stick with a   
        YAGNI (You_Arent_Going_To_Need_It) philosophy.       

#################_BE_NICE_AVOID_MACRO_POLLUTION_OF_OTHERS_CODE_#
#_WHAT_IS_THE_LIBRARY_CHAIN_####################################

        Library chain is used as a hackish way to debug       
        code by divide and conquer. Any                       
        AAC2020_MAC_LIBCHAN_CUR value between [ 0 -to- MAX ]  
        (inclusive range) should yeild a working              
        executable.                                           
                                                             
        This requires being a bit meticulous with your        
        dependencies. But you should understand your          
        dependencies well enough to pull this off anyhow.     
                                                             
        Dependency injection or dependency resolvers are for  
        people who are writing clusterfucks. We want to       
        actually have a clear idea of what our code is doing. 
                                                            
        John Mark Isaac Madison DATE[2020_11_01]              

    /////// AAC2020_MAC_LIBCHAN_CUR ( ? ) //:<-- Compile_To_Here

####################################_WHAT_IS_THE_LIBRARY_CHAIN_#
#NEGONE_IF_NOT_IN_SHADER########################################


    glGetUniformLocation :

    This function returns -1 if name does not
    correspond to an active uniform variable in
    program,if name starts with the reserved
    prefix "gl_",or if name is associated with
    an atomic counter or a named uniform block.

    https://www.khronos.org/registry/OpenGL-Refpages/
                        gl4/html/glGetUniformLocation.xhtml

########################################NEGONE_IF_NOT_IN_SHADER#
#GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER###########################

    Data that I thought I was going to store in "GPUDATA"
    instances now lives in FILE_SCOPE variables in PIXNAME.

    We only pack vars from PIXNAME into GPUDATA 
    ________TEMPORARILY_______ when we need to use it
    with a function call.

###########################GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER#
#_GENTEX_ONCE_ON_EXE_STARTUP_###################################

        QUESTION: ( 2020_12_08 or before)

            Should we always re-generate textures  
            When initializing? Is function         
            idempotent if we do it this way?     

        ANSWER: ( 2020_12_09 )

            NO! Do this only once because when you switch
            programs (1 shader program per editor ).
            The texture memory allocated is ____NOT____ deleted.

            AKA: All programs share same texture memory.

###################################_GENTEX_ONCE_ON_EXE_STARTUP_#
@SYN_VAR@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    SYN_VAR: Synonymous_Variables:

        Used to mark two variables that mean the 
        same exact thing in code. We try to avoid
        having two variables that mean the exact 
        same thing in our code because it disrupts
        the VISUAL PATTERNS of the source code.
        But sometimes it happens.

        Example: (FROM: aac2020_gpudata_IIA_UploadTexture )

        /**  #SYN_VAR[ cpu_pix ============ pix_arr ] **/
        U08*           pix_arr = gpudata -> cpu_pix; 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SYN_VAR@
#SYN_VAR########################################################

    SEE[ @SYN_VAR@ ]

########################################################SYN_VAR#
#KEEP_VOID_TO_AVOID_CONFUSION###################################

    DATE_WRITTEN[ 2020_12_09 ]

    Sometimes I like functions to return an unsigned integer
    that means NOTHING so I have the ability to give that
    returned integer a meaning in the future. However in
    some functions, returning a number can make things
    confusing to follow. 

    For example, AAC2020_GPUDATA_GetPixelOnCPU_RGBA
                 returns it's [ r,g,b,a ] via 
                 output parameter pointers to U08.

                 Giving this function a return value
                 can distract from that I believe.

###################################KEEP_VOID_TO_AVOID_CONFUSION#
#SIX_FIGURES_IS_ONLY############################################

    I wrote this when I was a bit distracted and wondering
    how much you would REALLY have to make in terms of
    gross profits to get to six figures after tax.
    These are the source code calculations removed from
    [ GPUDATA.F ]ON_DATE[ 2020_12_09 ]To reduce some of
    the clutter in there as we review the code.

                //:SIDE_TRACKED_BUT_FUCKYOU_ITS_MY_CODE:-----://

                //:How much is six figures? If you have 100% ://
                //:markup on your product. And after 10%     ://
                //:sales tax.                                ://
               
                /** G_Y: Gross profit per year. **/
                /** G_D: Gross profit per day . **/
                float K = ( 1000 );
                float G_Y = ( 100 * K );
                float G_D  = ( G_Y / 365 );

                /** B_T: Before 10% tax                      **/
                /** **************************************** **/
                /** 0.9 is your percent KEEP *************** **/
                /** G_D = B_T * 0.9;         *************** **/
                float B_T = ( G_D / 0.9 );
                /** **************************************** **/

                /** B_M: Before Markup of 200%               **/
                /** **************************************** **/
                float M_U = 2.0; //:markup percentage.
                float M_T = 1.0 / M_U; //:Markup tax.
                /** EXAMPLE: If you sell for 800% markup, **/
                /** That means 1/8th is expenses. So you  **/
                /** can think of that as a 1/8th tax.     **/
                float P_K = ( 1.0 - M_T );
                if( P_K <= 0 ){ ERR("[BadPercentKeep]"); };
                float B_M = ( B_T / P_K );
                /** **************************************** **/
                
                /** At given tax rate and markup rate. **/

                //: 608 / 2 * 0.9 * 365 == Close To 100K
                printf("[SIX_FIGURES_IS:B_M]%f\n",B_M);
                fflush(stdout);

                //:-----:SIDE_TRACKED_BUT_FUCKYOU_ITS_MY_CODE://

############################################SIX_FIGURES_IS_ONLY#
#_GPUDATA_MATH_FUNCTIONS_ARE_BARE_BASIC_ABSTRACTIONS_###########
#BASIC_2D_ARRAY_ABSTRACTIONS_ONLY###############################

    YES:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        GPUDATA math functions should abstract the 512x512
        section of memory as a 512x512 bitmap. It should only
        handle basic abstractions like "index-to-xy" and
        "xy-to-index".
    :::::::::::::::::::::::::::::::::::::::::::::::::::::::::YES
    NOT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        Something like:
        "xy+tilesize+tilelayer" --> to "PhysicalPixelLocation"
        Does NOT belong in GPUDATA but rather in PAINT5D.
       ( Or another sub editor with it's own abstraction of )
       ( what the[ cpu_pix ]of[ PIXNAME -or- GPUDATA ]mean. )

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!NOT

###############################BASIC_2D_ARRAY_ABSTRACTIONS_ONLY#
###########_GPUDATA_MATH_FUNCTIONS_ARE_BARE_BASIC_ABSTRACTIONS_#
#_GROUP_MATH_FUNCTIONS_WITH_THEIR_INVERSES_#####################

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /** Centralizing these functions will help me avoid      **/
    /** making mistakes. They could be inlined. But lets     **/
    /** not do that right now, as it makes the code more     **/
    /** likely to break during compilation.                  **/
    /** https://www.geeksforgeeks.org/inline-function-in-c/  **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#####################_GROUP_MATH_FUNCTIONS_WITH_THEIR_INVERSES_#
#DO_NOT_EXTRACT#################################################

    SEE[ #_DO_NOT_EXTRACT_# ]

#################################################DO_NOT_EXTRACT#
#_NEW_PROGRAMS_DONT_REMOVE_OLD_TEXTURES_########################

    https://www.khronos.org/opengl/wiki/Texture

    Texture objects are not directly associated 
    with or attached to program objects. Instead, 
    program samplers reference texture image unit 
    indices. Whatever textures are bound to those 
    image units at the time of rendering are used 
    by the program. So the first step is to set the 
    uniform value for the program samplers.

#########################_NEW_PROGRAMS_DONT_REMOVE_OLD_TEXTURES_
#_INI_SPAM_AND_RECURSION_GAURD_#################################

    Code that is [guarding/protecting] an initializer
    function from.

    1. being spammed (invoked rapidly in multiple succession)
    2. recursively being called.

    NOTE:
        This is not intended as a hackish solution to 
        make initializers idempotent by exiting early.

        Not intended to prevent 2x in a row execution.
        Just prevent QUICK successive calls.

        Though the naive method for this will typically
        prevent 2x in a row calls... DO NOT RELY ON THAT
        TO MAKE FUNCTION IDEMPOTENT.

#################################_INI_SPAM_AND_RECURSION_GAURD_#
@QUELCHNOTUSED@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    
    @QUELCHNOTUSED@ 
    @QUELCH_NOT_USED@
    @QUELCH_UNUSED@
    @QUELCHUNUSED@

        Denotes we are trying to quelch an un-used
        variable compiler error.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QUELCHNOTUSED@
@IDEMPOTENT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @IDEMPOTENT@

    Used to denote an function (typically initializer)
    that can be called multiple times in a row without
    breaking or causing unexpected behavior.

    If you marked something as @IDEMPOTENT@ and it is not,
    chances are the CODE IS WRONG not the COMMENT.

    @IDEMPOTENT@ is conveying design intent. It would be
    foolish to think that the comment is wrong and the
    code correct in this case.
        
    Fuck You "cleanCode®™"

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IDEMPOTENT@
#_sam_val_ALWAYS_EQUALS_tex_lot_################################
#_tex_lot_ALWAYS_EQUALS_sam_val_################################

    For simplicity sam_val == tex_lot.
    ( Specificially[ sam_val ]DEPENDS_ON[ tex_lot ] )

    A 1:1 mapping between the texture slot.....

    WAIT.... NOT FOR SIMPLICITY. For NECESSITY!!!!

    tex_lot: Where the texture is loaded.

    sam_val: Tell your sampler uniform to sample that texture
             by setting: (sam_val)==(tex_lot)

################################_sam_val_ALWAYS_EQUALS_tex_lot_#
################################_tex_lot_ALWAYS_EQUALS_sam_val_#
#_2ND_GUESSING_PIXLOAD_TEX_SAM_ERR_#############################
                                         
        Actually... This could happen because     
        AAC2020_GPUDATA_InitInstanceAll may have  
        been called when a shader that did NOT    
        have a texture sampler uniform in it's    
        source was [ in focus / loaded ]          
                                                  
        THIS CASE IS NOT AN ERROR **/             
                                                  
        Wait... it is an error but only if....    
        Only if... "tex_sam_HAS" is true.         

#############################_2ND_GUESSING_PIXLOAD_TEX_SAM_ERR_#
#TEX_IMAGE_2D_CORRECTION########################################

    SEARCHED_FOR[ texImage2D ]WHAT_YOU_WANT[ glTexImage2D ]

########################################TEX_IMAGE_2D_CORRECTION#
()calledby() :::::::::::::::::::::::::::::::::::::::::::::::::::

    Comment used to help track what calls what.
    Example:  bar()calleby()foo

::::::::::::::::::::::::::::::::::::::::::::::::::::()calledby()
()calls() ::::::::::::::::::::::::::::::::::::::::::::::::::::::

    Comment used to help track what calls what.
    Example:  foo()calls()bar

:::::::::::::::::::::::::::::::::::::::::::::::::::::::()calls()
#WHY_PIX_DEX_AND_COM_DEX########################################
#DEX_PIX#DEX_COM################################################

    #DEX_PIX# #dex_pix# -----------> pix_dex ( PIXel     inDEX )
    #DEX_COM# #dex_com# -----------> com_dex ( COMponent inDEX )

    Usually we go "general to specific"
    and thus "pix_dex" and "com_dex" are the proper
    variables. As "index (dex)" is a more general
    variable specifier than "pixel(pix)" or "component(com)"

    However: pix_dex is GRANDFATHERED in because it was first
             used in the context of:

             pix_wid
             pix_hig
             pix_arr
             pix_dex
                 |||
             com_dex
             
             Where "pix" is the generic aspect and
             "dex" is the more specific aspect.

             To avoid fractionating our variable namespaces
             (conceputal namespaces in our HEAD) we need to
             pick one [ permutation / ordering ] and    
             stick with it. To ease decision, it is whatever
             we use FIRST. Hence "GRANDFATHERED IN"

################################################DEX_PIX#DEX_COM#
########################################WHY_PIX_DEX_AND_COM_DEX#
@INIT_ALL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @INIT_ALL@ : Added so when searching for AAC2020_GPUDATA
                 with "find in files" I can find the
                 instance of[ gpudata ]that I am looking for.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@INIT_ALL@
#_TODOS_CAN_BREAK_COLUMN_LIMIT_#################################

    "TODO" notes are allowed to break the 64 character
    source code column limit because.....
        
        1. It sticks out like a sore thumb (Its Noticable)
        2. It annoys the hell out of me

            Annoying things more likely to get my attention.
            Annoying things more likely to be silenced
            by getting them fixed.

        SAYING: The sqeaky wheel gets the grease.

#################################_TODOS_CAN_BREAK_COLUMN_LIMIT_#
#_CTRL_F_HELP_##################################################

    #_CTRL_F_HELP_#:
    
        A comment tag used to denote a comment that should
        NOT be extracted into this (_H_) file because
        it's mechanic is to help programmers find when
        they are looking for when they

        1. Find String In Files VIA editor
        2. GREP via command line

##################################################_CTRL_F_HELP_#
#_SAM_PRECISION_BEFORE_SAM_VAR_#################################

    //: Must declare precision before            
    //: declaring any uniforms                   

    precision highp usampler2D; //:<<<<<<<<<< 1st

    uniform usampler2D paint5d; //:<<<<<<<<<< 2nd

#################################_SAM_PRECISION_BEFORE_SAM_VAR_#
#_KEEP_USAMPLER_HIGH_###########################################


    //: Pretty sure sampler precision must       :// 
    //: always be high. Otherwise we will corrupt:// 
    //: our bit-packing patterns that are stored :// 
    //: in each pixel.                           :// 
    ;//:- - - - - - - -:// 

###########################################_KEEP_USAMPLER_HIGH_#
#_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#############################

    If you don't see your PAINT5D GLSL code, remember that the       
    prescense (spelling?) of "SHADER_001_PAINT5D.FRAG" 
    will override the hard-coded default shader code
    embedded in the ".text" segment of your executable
    source code.

    Or more plainly:

    Instead of loading AAC2020_PAINT5D_DEFAULT_001 from EXE,
    we load "SHADER_001_PAINT5D.FRAG" from disk if it is
    present.

    This allows users of our game to make mods to game
    if they are [informed/knowledgeable] of GLSL code.

#############################_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#
#_PULL_GLSL_SHADER_DATA_FROM_FUTURE_############################

        Because ALL DATA is declared before      
        ALL FUNCTIONS, we can get away with      
        referencing a piece of data from the     
        future like this.   
                     
############################_PULL_GLSL_SHADER_DATA_FROM_FUTURE_#
#_GPU_DATA_IS_A_TEMPORARY_HELPER_OBJECT_ONLY_###################

    Flat is better than nested. But sometimes we need to
    pass around a bundle of arguments to a helper function.

    Don't make your data LIVE in a nested structure just
    because sometimes it needs to be passed around in
    a bundle.

    REASONS:
        1. Flat code easier to memorize.
        2. Packing into nested structure at locations
           where it is needed make the code readable 
           WITHOUT intellisense because you can see
           what members you are packing into the struct
           at the fuction call site.

###################_GPU_DATA_IS_A_TEMPORARY_HELPER_OBJECT_ONLY_#
#_DO_NOT_EXTRACT_COMMENT_#######################################
#_DO_NOT_EXTRACT_###############################################

    #_DO_NOT_EXTRACT_COMMENT_#:  ( Synonymous Hashtags )
    #_DO_NOT_EXTRACT_#        :  ( Synonymous Hashtags )

        Means the comment itself serves some type of
        [ mechanical / administrative ] purpose meerly
        by existing where it does.

        Most commonly this would be for:

        1. WARNING COMMENTS 
        2. CTRL_F_HELP Comments.
        
        The mechanics of both comments dictate that they
        will fail to serve their purpose if they are
        extraced into this (_H_) file.

###############################################_DO_NOT_EXTRACT_#
#######################################_DO_NOT_EXTRACT_COMMENT_#
#_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_############################

    Prioritize SIMPLE over OPTIMIZED/PERFORMANT code.

    Optimizing can happen. But only in 2 cases.

    1. Performance loss makes project UN-Usable.
    2. Game is 100% finished and we are in POLISH stage.

############################_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_#
#_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_######################

    The names "todo_02" , "todo_03" etc are
    name of reserved memory slots that have not
    been assigned a purpose yet.

    Though not assigned a purpose yet, we should still
    allocate them.

    (Yes wasteful I know)

    Reason:
        When ready to use memory for something, all we need
        to do is a name refactor without changing any
        functionality.

        If there is a problem that can occure by reserving
        more than ONE block of GPUDATA, we will know
        RIGHT_FUCKING_NOW. Even though we only are going to
        use one of those blocks RIGHT_FUCKING_NOW.

        #_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_#

######################_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_#
#_BAD_IDEA_001_#################################################

    ------------------------------------------------------------
    Below was a bad idea. The correct way to handle this was
    to create error friendly wrapper functions so that we 
    can consolidate all the function calls needed to be
    made on a ONE LINE PER CALL basis.
    
    Reducing the density like this I think is a BAD IDEA.
    But originally did it because function calls were not
    error friendly. So we fixed that up a bit and
    make aac2020_gpudata wrapper functions for openGl
    binding library functions in AAC2020_GLEBIND.

        1:  aac2020_gpudata_glGetUniformLocation
        2:  aac2020_gpudata_glGetUniformiv      
    ------------------------------------------------------------

        //:GET_TEXTURE_SAMPLER:ALL:--------------------------://
        //:##################################################://
        //: MACROS: Functions: UPPERCASE                     ://
        //: MACROS: Constants: UPPERCASE                     ://
        //: MACROS: Variables: lowercase                     ://
        //:                                                  ://
        //: Dont be afraid of long functions. This is kinda  ://
        //: verbose and ugly and long... And very cut+paste. ://
        //: But also pretty easy to follow with only         ://
        //: 1 level of indirection.                          ://
        //: (We will see how easy to follow when we )        ://
        //: (come back to it in a month from now.   )        ://
        //: (DATE_WRITTEN: 2020_12_07               )        ://
        //:                                                  ://
        //:##################################################://
        #define N   ( 0 - 1 );                           //:1://
        #define P   (aac2020_graquad.data.POG_IID)       //:1://
        #define L   AAC2020_GLEBIND.glGetUniformLocation //:1://
        #define V   AAC2020_GLEBIND.glGetUniformiv       //:1://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    
            /** Sections by which texture sampler we are **/
            /** getting.                                 **/

            //:0101010101010101010101010101010101010101010101://
            #define s &(AAC2020_PIXNAME_paint5d[ 0 ] ) 
            #define h   AAC2020_PIXNAME_paint5d_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_paint5d_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_paint5d_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_001:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0101010101010101010101010101010101010101010101://
            //:0202020202020202020202020202020202020202020202://
            #define s &(AAC2020_PIXNAME_todo_02[ 0 ] ) 
            #define h   AAC2020_PIXNAME_todo_02_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_todo_02_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_todo_02_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_002:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0202020202020202020202020202020202020202020202://
            //:0303030303030303030303030303030303030303030303://
            #define s &(AAC2020_PIXNAME_todo_03[ 0 ] ) 
            #define h   AAC2020_PIXNAME_todo_03_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_todo_03_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_todo_03_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_003:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0303030303030303030303030303030303030303030303://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  N //:Not Exist is Negative One           //:1://
        #undef  P //:Program Integer Id (POG_IID)        //:2://
        #undef  L //:Program Integer Id (POG_IID)        //:3://
        #undef  V //:Program Integer Id (POG_IID)        //:4://
        //:##################################################://
        //:--------------------------:GET_TEXTURE_SAMPLER:ALL://

#################################################_BAD_IDEA_001_#
#_ONE_EXIT_POINT_ALWAYS_########################################

    Functions should always have exactly one EXIT point
    as last line of function. A RETURN statement to be
    precise.

    Any function that does NOT obey this needs refactoring
    eventually.

    Multiple exit points are too error prone as I tend to
    miss them when reading code.

    The idea of "Get out of function as soon as possible"
    "before you screw stuff up" is a good idea though.
    To account for that philosophy, we should properly
    gaurd code blocks with an [ ok / o_k ] variable if
    their design typically WOULD best accomidate multiple
    return statements.

    WRITTEN_DATE[ 2020_12_07 ]

########################################_ONE_EXIT_POINT_ALWAYS_#
#_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_#########################

    It is TEMPTING to change the signature of wrapped functions
    to something NICER to use. However, doing that means
    it will be harder to interchangibly swapp the

        WRAPPED

    version with the

        UN-WRAPPED

    version of the function. I can see some benifit to that.

        BENIFITS:

            1. More flexibility.
            2. Dont have to THINK UP new signature format.

    So... WRAPER FUNCTION SHOULD HAVE IDENTICAL SIGNATURE
          TO THE FUNCTION IT IS WRAPPING.

#########################_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_#
#_ALWAYS_RELOAD_TEXSAM_AFTER_RELOADING_SHADER_##################

    Just because GPUDATA is initialized does NOT mean the
    texture sampler was successfully created. Texture sampler
    will only successfully exist if the texture sampler
    name is present in the currently loaded shader
    source code.

    Texture Sampler Names:
        AAC2020_PIXNAME_paint5d
        AAC2020_PIXNAME_todo_02  << Not_Yet_Assigned_As_Of_NOW
        AAC2020_PIXNAME_todo_03  << Not_Yet_Assigned_As_Of_NOW
        .... ETC

    Not_Yet_Assigned_As_Of_NOW: 2020_12_07

##################_ALWAYS_RELOAD_TEXSAM_AFTER_RELOADING_SHADER_#
#_PIXNAME_PATTERN_BREAKER_######################################

    EXTRACTED_FROM[ LIBCHAN.TOP._ ]ON_DATE[ 2020_12_06 ]

        //:--------------------------------------------------://
        //:#PATTERN_BREAKER# (slightly)                      ://
        //:                                                  ://
        //: A list of names of all of the gpu textures       ://
        //: defined by different GPUDATA instances.          ://
        //:                                                  ://
        //: We don't know what those names will be yet.      ://
        //: That is why this breaks project structure.       ://
        //:                                                  ://
        //: To mitigate the problem, these values will only  ://
        //: be used to ASSERT the correct values in future   ://
        //: libraries.                                       ://
        //:                                                  ://
        //:Q: Why are we breaking the LIBCHAN pattern here?  ://
        //:A: A consolidated list of all GPU textures        ://
        //:   is useful.                                     ://
        //:--------------------------------------------------://

######################################_PIXNAME_PATTERN_BREAKER_#
#_GPUDATA_IS_NOT_LIMITED_TO_GRAPHICS_###########################

    EXTRACTED_FROM[ LIBCHAN.TOP._ ]ON_DATE[ 2020_12_06 ]

        //:GPUDATA: GraphicsProcessingUnit_DATA
        //:        (NOT NECCESSARILY GRAPHICAL DATA)
        //:        (NOT NECCESSARILY GRAPHICAL INFORMATION)
        //:        GPUDATA tells me where the data is stored,
        //:        but not what the data represents.

###########################_GPUDATA_IS_NOT_LIMITED_TO_GRAPHICS_#
#TEMPCON########################################################

    #TEMPCON#: Tagging some variable as a "temporary container"

    For example: GPUDATA is a TEMPCON as of DATE[ 2020_12_06 ]

#########################################################TEMPCON#
#_FOR_SIMPLICITY_ALL_MEMORY_IS_512x512_#########################

    All memory for all systems is a 512x512 RGBA 
    UN-signed (NO NEGATIVES) integer texture.

    Art is about working with contraints. A block of marble
    with ZERO contraints is a block of marble. A statue is
    a block of marble with constraints put on it.

    Everything is nothing.

    111111111111111111111111111111111111111 <<<< NOTHING
    000000000000000000000000000000000000000 <<<< NOTHING
    010100101010111111000001111000001010101 <<<< SOMETHING

    This is why the void of nothingness is sometimes 
    refered to a "chaos" because the void of nothingness
    and complete chaos are the same exact thing.

#########################_FOR_SIMPLICITY_ALL_MEMORY_IS_512x512_#
#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#######################

    REMOVED, because now pointless. 
    REMOVED_DATE[ 2020_12_05 : 1134PM ]

            if( strcmp( 
                &(                 paint5d.pix_nam[ 0 ]  )
            ,   &( AAC2020_PIXNAME_paint5d[ 0 ]          )
            ) != 0 ){
                ERR("[paint5d:INIT_FAIL:ON:pix_nam]");
            };;
    
            if( AAC2020_PIXNAME_paint5d_tex_lot
                   !=   paint5d.g_pixel.tex_lot
            ){
                ERR("[paint5d:INIT_FAIL:ON:tex_lot]");
            };;

#######################_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#
#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_####################
    
    ------------------------------------------------------------
    For the sake of keeping things as SIMPLE & FLAT as possible,
    "GPUDATA" is now a temporary container only. For when we
    need to pass the data to a helper function. Actual data
    for "GPUDATA" exists in "PIXNAME". 

    REASON:
        1. PIXNAME way is SIMPLE + FLAT
        2. GPUDATA way is easy to pass around but harder to
           follow and read the code.

        We want to avoid fractionating our variable space,
        so if we want the "best of both worlds" GPUDATA 
        must be a TEMPORARY object only.

    ------------------------------------------------------------

        /// SBE: [Set/Put]Before_Init ///

            paint5d.g_pixel.tex_lot   = 1         ; /// SBE ///

         //:paint5d.g_pixel.pix_nam   = "paint5d" ; /// SBE ///
            paint5d.pix_nam[ 0 ] = 'p' ;          ;
            paint5d.pix_nam[ 1 ] = 'a' ;          ;
            paint5d.pix_nam[ 2 ] = 'i' ;          ;
            paint5d.pix_nam[ 3 ] = 'n' ;          ;
            paint5d.pix_nam[ 4 ] = 't' ;          ;
            paint5d.pix_nam[ 5 ] = '5' ;          ;
            paint5d.pix_nam[ 6 ] = 'd' ;          ;
            paint5d.pix_nam[ 7 ] = '\0';          ;
                           
            //:#WHY_PAINT5D_ERRORS_2020_12_04#
            if( paint5d.cpu_pix[0]      != 0 ){ ERR("[E_1]");};                   
            if( paint5d.g_pixel.tex_han != 0 ){ ERR("[E_2]");};
            if( paint5d.g_pixel.sam_loc != 0 ){ ERR("[E_3]");};
            if( paint5d.g_pixel.sam_val != 0 ){ ERR("[E_4]");};

####################_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#
#_GPUDATA_FLAT_IS_BETTER_THAN_NESTED_###########################

    In retrospect, nesting things into a "g_pixel" member
    was a bad idea. The intent was to communicate the
    division between "data on the GPU" and "data on the CPU".

    (CPU==HOST   Side)
    (GPU==DEVICE Side)

    But the only purpose GPUDATA struct should have is a
    container to pass around a bundle of stuff.... Don't change
    code structure for the sake of self-documenting code.

        //:REMOVED_ON[ DATE[ 2020_12_05 ] ]

        //:Handle to GPU texture representing cpu_pix :::::::://
        struct AAC2020_GPUDATA_G_PIXEL{

            //: -------------------------------------------- ://
            //: activeTexture( tex_lot )                     ://
            //: bindTexture(   tex_han );                    ://
            //: Means:                                       ://
            //:     OPEN_GL_TEXTURES[ tex_lot ]=( tex_han ); ://
            //: -------------------------------------------- ://
            int
            tex_lot ;//:USE_WITH[ activeTexture ]   
            int
            tex_han ;//:USE_WITH[ bindTexture   ]   
            
            //: -------------------------------------------- ://
            //: Texture SAMPLER_UNIFORM Value ************** ://
            //: sam_loc: Memory ADDRESS of SAMPLER_UNIFORM   ://
            //: sam_val: ValueOf[ tex_lot ]stored at ADDRESS ://
            //: -------------------------------------------- ://
            int
            sam_loc ;//:USE_WITH[ uniform1i( sam_loc, sam_val )]
            int
            sam_val ;//:USE_WITH[ uniform1i( sam_loc, sam_val )]

        }g_pixel; /// AKA: gpu_pix / gpu_han ///

###########################_GPUDATA_FLAT_IS_BETTER_THAN_NESTED_#
#_GAME_WITHOUT_MUTEXES_#########################################

        //: Removed, lets try to make an entire game without ://
        //: having to use mutexes, semaphores, and fences.   ://

        //: ENGETHER.THREADING.InterlockedIncrement64(
        //:     &( AAC2020_GINAWIN.THREAD_SAFE_FLAGS.
        //:        resize_message_count )
        //: );;

        //: #define C_B AAC2020_GINAWIN.OPTIONAL_CALLBACKS
        //: if(C_B.resize_function_has){
        //:    C_B.resize_function();
        //: };;
        //: #undef  C_B

#########################################_GAME_WITHOUT_MUTEXES_#
#_FRAGBED_UNIFORM_FREEABLE_POINTERS_############################

    EXTRACTED_FROM[ FRAGBED.D._ ]ON_DATE[ 2020_12_15 ]

    DESIGN_NOTES:

    I originally thought "AAC2020_FRAGBED_loaded_##_ptr"(s)
    could point to either the default shaders
    ( "AAC2020_FRAGBED_DEFAULT_###" ) or to shader code
    on the hard disk.
    
    Problem:

    This would mean sometimes the pointer is FREEABLE
    (when it points to disk) and UN-FREEABLE when it points
    to a hard coded (in source code) FILE_SCOPE char array.

    Solution:

    FILE_SCOPE char arrays must be copied over to malloced 
    memory for consistency.


############################_FRAGBED_UNIFORM_FREEABLE_POINTERS_#
#_GRAQUAD_CAME_FROM_GLEB_SWIN_##################################

    Extracted_From[ GRAQUAD.F._ ]ON_DATE[ 2020_12_05 ]

    Refactor Note:
    GLEB_SWIN --> GINAWIN (Graphics_Init_And_WINdow)
    GLEB -------> GLEBIND (open_GL_Easy_BINDings   )

##################################_GRAQUAD_CAME_FROM_GLEB_SWIN_#
#_TWO_DEFAULT_SHADERS_ONLY_#####################################

    EXTRACTED_FROM[ GRAQUAD.D.FRAG ]ON_DATE[ 2020_12_05 ]

        GRAQUAD.D.FRAG._:                                        
        GRAQUAD.DATA.FRAGMENT_SHADERS:                           
                                                                 
        These are just the shaders with different messages in    
        them for the user. Do NOT put AAC2020_FRAGBED default    
        shaders here. I get that you want to consolidate shader  
        code, but those default shaders need to be placed        
        where you would logically look for them in the future.   
                                                                 
        Which is with AAC2020_FRAGBED                            

#####################################_TWO_DEFAULT_SHADERS_ONLY_#
#_UNIFORM_NAMING_CONVENTION_####################################

    Uniform names copies of SHADERTOY.COM uniform names. 

    That way:

        1. I don't have to think about what to call them.
        2. I can easily [cut+paste] [ to | from ] Shadertoy.com

####################################_UNIFORM_NAMING_CONVENTION_#
#_WHY_THESE_IMOUSE_NAMES_#######################################

        //: ------------------------------------------------ ://
        //: [x,y,z,w]                                        ://
        //:                                                  ://
        //: These will be backed into VEC4 when              ://
        //: loaded into iMouse uniform.                      ://
        //: Decided to label these as their actual values    ://
        //: in the GLSL code rather than their usage.        ://
        //:                                                  ://
        //: Reason: I might not correctly understand what    ://
        //:         these values SHOULD BE and I don't want  ://
        //:         to have variable names that lie in my    ://
        //:         code.                                    ://
        //: ------------------------------------------------ ://
        U32   AAC2020_CPUNIFO_iMouse_vec4_x =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_y =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_z =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_w =( 0 );

#######################################_WHY_THESE_IMOUSE_NAMES_#
#_EXTRACTED_GLEBIND_CLUTTER_NOTES_##############################

    //:NOTES:================================================://


        PREDACESSOR: GLEB: openGL_Easy_Bindings
        CURRENT_LIB: AAC2020_GLEBIND (GL_Easy_BINDings)
        
        Prefixes:
        AAC2020_GLEBIND_   :Library namespace prefix.
        MV_     :Macro Variable / Value
        MM_     :Maybe A Macro (MV_ value will decide)
        
        Function Names:
        DEBUGPRINT_01: Print ONE(01) string.

    //:================================================:NOTES://
    //:INCLUDES:=============================================://
    //://////////////////////////////////////////////////////://   
    //# Before you judge, include gaurds exist.              #//   
    //://////////////////////////////////////////////////////://   
                                                        //:  ://
    //  #include <stdint.h> //:int32_t      ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <stdlib.h> //:malloc(....) ://         //:  ://
    //  #include <stdlib.h> //:free(......) ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <string.h> //: strcmp      ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <stdio.h>  //:printf(....) ://         //:  ://
    //  #include <stdio.h>  //:fprintf(...) ://         //:  ://
    //  #include <stdio.h>  //:fflush(....) ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <ctype.h>  //:isspace(...) ://         //:  ://
                                                        //:  ://
        //[ Using: PEB20202_LoadLibrary    - - - - - ]////:  ://
        //[ Using: PEB2020_GetProcAddress  - - - - - ]////:  ://
        //-  Windows.h for:        - - - - - - - - - -////:  ://
        //-  1. LoadLibrary        - - - - - - - - - -////:  ://
        //-  2. GetProcAddress     - - - - - - - - - -////:  ://
        //-  3. FreeLibrary        - - - - - - - - - -////:  ://
        //-  #include <Windows.h>  - - - - - - - - - -////:  ://
                                                        //:  ://
    //://////////////////////////////////////////////////////://   
    //# Before you judge, include gaurds exist.              #//   
    //://////////////////////////////////////////////////////://   
    //:=============================================:INCLUDES://
 
##############################_EXTRACTED_GLEBIND_CLUTTER_NOTES_#
#GLEBIND_THIS_ONE_IS_SPECIAL####################################

    This one is special.                 
    The wrapper function is called       
                                         
        AAC2020_GLEBIND_wglGetProcAddress    
                                         
    instead of                           
                                         
        wglGetProcAddress                
                                         
    to avoid conflicts with Windows.h. The
    "wglGetProcAddress" function does NOT work "out of
    the box" like "GetProcAddress".                    
                                       
    I am sure if I knew more about linkers I could fix
    this. But messing with linkers would destroy the
    point of this library being an
                                         
        "easy bindings"                      
                                         
    library. The whole point is to just include this
    file and get access to openGL functions.

#DOES_NOT_REQUIRE_GL_CONTEXT_TO_CALL############################

    Also does NOT need an openGL context           
    in order to fetch it.                                       
                   
############################DOES_NOT_REQUIRE_GL_CONTEXT_TO_CALL#                      
####################################GLEBIND_THIS_ONE_IS_SPECIAL#
#_IF_NO_GL_LIST_CREATE_ONE_#####################################

    If "OPEN_GL_SEARCH_PATHS.TXT" does not    
    exist, create it now and populate it      
    with some default values.                 
    #SEE_IF_FILE_EXISTS_THEN_USE#  
    stackoverflow.com/questions/230062        

#####################################_IF_NO_GL_LIST_CREATE_ONE_#
#_WHY_GLEBIND_TOUCHFILE_########################################

    TouchFile function did not exist in GLEB.H      
    Added to GLEBIND.F (GLEBIND_DOT_F) to make      
    program a bit more user friendly.               
                                                    
    GOAL: Program is a single .EXE file, no         
        supplimentary files need to be copied to    
        maintain a working executable.              
                                                    
    This function makes it so you don't have to     
    copy around OPEN_GL_SEARCH_PATHS.TXT            

########################################_WHY_GLEBIND_TOUCHFILE_#
##############################if_not_exist_add_default_contents#

    int if_not_exist_add_default_contents :

        If the file did not exist before we touched it,   
        should we initialize it's contents with some      
        default search paths for where we can expect      
        OpenGL32.dll to be?                               

#if_not_exist_add_default_contents##############################
#_WHY_CANT_I_SEE_MY_WINDOW_#####################################

    Trying to figure out why window does not show up:
    
    Possible fixes/problems:
    
    F01: You never initialise hdc with the result of 
        the BeginPaint call, so your painting will fail.  
        https://stackoverflow.com/questions/30551850

#####################################_WHY_CANT_I_SEE_MY_WINDOW_#
#_OLD_GINAWIN_DOCUMENTATION_####################################
    
    --------------------------------------------------------
    Documentation for GINAWIN that I think was left over
    from when I cut and pasted the code from previous 
    project. Not sure how relevant these comments below are.
    --------------------------------------------------------

    KEY/PREFIXES:
        aac2020_ginawin_:
        The namespace prefix for all functions
        that belong to this section of code.
    
        gleb: open_GL_Easy_Bindings
        
        swin:
        SWIN=="SILKWIN"==="THREADED_WINDOW"
        The idea is a "window made of silk" 
        because threads can be made of silk.
        I am thinking the window was woven
        by a spider's threads.
    
        pfn: Pointer_to_FuNction
             (Convention take from Vulkan)
    
    CONVENTIONS:
    
      1. Non-terminal objects of library
         structs are ALL_CAPITAL.
    
      2. Terminal objects of library struct are:
         A: CamelCaseIfFunction
         B: snake_case_if_variable
         C: OR: Written in convention of whatever
            I am trying to wrap that exists from
            some other library I don't own.
    
      3. Includes often are put near where
         they are needed, rather than all at
         the top of the file. Standard headers
         have include gaurds, so this shouldn't
         be a problem.
    
      4. Global Windows Functions Allowed:
         1. LoadLibraryA
         2. GetProcAddress
         Anything else should be wrapped in
         a library struct that tells us the
         .dll file of origin.
    
         Convoluted and rigid and a pain to
         port to another operating system?
    
         I'll worry about porting after I've made
         a million dollars off of something.
         Otherwise, not worth the hassel.

####################################_OLD_GINAWIN_DOCUMENTATION_#
#_CEDITOR_DESIGN_NOTES_2020_12_04_##############################

    CEDITOR: Current_EDITOR

    Currently the project is setup to use 9 different shaders.
    That each activate when the corresponding number key is
    pressed. For example, pressing "3" loads fragment shader
    #3 into our pipeline.

    Let's build upon this:

    NUMKEY 1 ===>  Active:FragShader_1 , dex_edi == 1
    NUMKEY 2 ===>  Active:FragShader_2 , dex_edi == 2
    NUMKEY 3 ===>  Active:FragShader_3 , dex_edi == 3
    NUMKEY 4 ===>  Active:FragShader_4 , dex_edi == 4
    NUMKEY 5 ===>  Active:FragShader_5 , dex_edi == 5
    NUMKEY 6 ===>  Active:FragShader_6 , dex_edi == 6
    NUMKEY 7 ===>  Active:FragShader_7 , dex_edi == 7
    NUMKEY 8 ===>  Active:FragShader_8 , dex_edi == 8
    NUMKEY 9 ===>  Active:FragShader_9 , dex_edi == 9
     
    When zero is pressed, no conceptual "sub editor"      
    is in focus. Maybe when that happens, the keyboard    
    will only respond to keys "0" - "9" because there is  
    no editor in focus to listen to what keys were
    pressed. ?
    NUMKEY 0 ===>  Active:FragShader_0 , dex_edi == 0

##############################_CEDITOR_DESIGN_NOTES_2020_12_04_#
#_LIKE_glo_eve_OBJECT_in_A2_JC_#################################

    Like: glo_eve object in R:\G\A2_JC.js  

          glo_eve == "global event"
          A generic [system/platform] agnostic event object.

          Thought "keyboard event" was too specific and
          "input event" also too specific because controls
          might be wired into an A.I.
 
#################################_LIKE_glo_eve_OBJECT_in_A2_JC_#
#_MARK_ALL_KEYS_AS_DIRTY_#######################################

        After you've consumed the keyboard events  
        mark all IKEYBOX data as dirty.  

        U32  AAC2020_IKEYBOX_dirty = ( 1 );

#######################################_MARK_ALL_KEYS_AS_DIRTY_#
#_KEEP_KEY_PRESSED_DEAD_SIMPLE_FOR_NOW_#########################

        Keep it dead simple for now.  
        This is the most recent NON controll key pressed.    
        This should be suitable for basic editors.  
        We can figure out something more complex    
        when we need responsive game controls.   

        char AAC2020_IKEYBOX_k_p = '_' ; //:k_p: Key_Pressed

#########################_KEEP_KEY_PRESSED_DEAD_SIMPLE_FOR_NOW_#
#_WHY_TEXTURE_SLOTS_IN_PIXNAME_#################################

    A bit weird, but let's keep the texture slot values   
    centralized here as well so that we can easily        
    verify that all texture slots are UNIQUE .            

#################################_WHY_TEXTURE_SLOTS_IN_PIXNAME_#
#KEYPAD_HASHTAGS################################################

    Keep those 1:1 relationships. 
    SEE[ #EDITOR_ONE_TO_ONE_RELATIONSHIPS# ]

    #KEYPAD_1# : Thing is associated with EDITOR#1, KEYPAD1
    #KEYPAD_2# : Thing is associated with EDITOR#2, KEYPAD1
    #KEYPAD_3# : Thing is associated with EDITOR#3, KEYPAD1
    #KEYPAD_4# : Thing is associated with EDITOR#4, KEYPAD1
    #KEYPAD_5# : Thing is associated with EDITOR#5, KEYPAD1
    #KEYPAD_6# : Thing is associated with EDITOR#6, KEYPAD1
    #KEYPAD_7# : Thing is associated with EDITOR#7, KEYPAD1
    #KEYPAD_8# : Thing is associated with EDITOR#8, KEYPAD1
    #KEYPAD_9# : Thing is associated with EDITOR#9, KEYPAD1

################################################KEYPAD_HASHTAGS#
#PATTERN_BREAKER_PIXNAME########################################

    ************************************************************
    REVISITED[ DATE[ 2020_12_09 ]:
    No longer a problem. We refactored:
    AAC2200_GPUDATA_PIXNAME ===> AAC2020_PIXNAME
    ************************************************************

    EXTRACTED_FROM[ PIXNAME.D._ ]ON_DATE[ 2020_12_04 : 0840PM ]
                                           
    #PATTERN_BREAKER#       
                                                            
    This somewhat breaks the spirit of our LIBCHAN          
    (library chain) pattern of adding things on as you      
    build up.                                               
                                                            
    The variables here will only be used for:               
        1. Human Reference                                  
        2. Asserts                                          
                                                            
    It will never be used as an assingnment like:           
                                                            
        ACC2020_GPUDATA_PAINT5D_dat.pix_nam=(               
        AAC2020_PIXNAME_paint5d ); <<<<<<< NO! NEVER!       
                                                            
    But will rather be used like so:                        
                                                            
        ACC2020_GPUDATA_PAINT5D_dat.pix_nam = "paint5d";    
        assert( AAC2020_PIXNAME_paint5d    == "paint5d" );  
                                                            
    Reason:                                                 
                                                            
        Make the code easy to follow with minimal           
        indirection, while still having the benifit of      
        a centralized area where all of the different       
        512 -x- 512 chunks of memory are defined.           
 
########################################PATTERN_BREAKER_PIXNAME#
#WHY_PAINT5D_ERRORS_2020_12_04##################################

    These errors could happen if                  
    1: You failed to zero initialize struct       
    2: You called initializer TWICE or MORE.     
    
    if( paint5d.cpu_pix[0]      != 0 ){ ERR("[E_1]");};                   
    if( paint5d.g_pixel.tex_han != 0 ){ ERR("[E_2]");};
    if( paint5d.g_pixel.sam_loc != 0 ){ ERR("[E_3]");};
    if( paint5d.g_pixel.sam_val != 0 ){ ERR("[E_4]");}; 

##################################WHY_PAINT5D_ERRORS_2020_12_04#
#PROJECT_IS_EDITOR_CENTRIC######################################

    As we build a game, we want the game play to just be
    an editor view where the user's controls do not allow
    for editing the level, but rather just moving and
    controlling the player.

    Level is still mutable by things like destructable
    geometry, but not by editing tools.

    Doing it this way means we only have ONE code base
    to maintain. (An editor code base) rather than a
    game engine and level editor code base.

######################################PROJECT_IS_EDITOR_CENTRIC#
#EDITOR_ONE_TO_ONE_RELATIONSHIPS################################

    Even if there is shared state or components,
    every editor should get unique copies of things
    to keep the relationships simple 1:1 relationships.

    If two editors need to share the same TILEBRUSH, we
    just copy over E1_TILEBRUSH to E2_TILEBRUSH when
    switch views from EDITOR #1 (E1) to EDITOR #2 (E2)

    THIS_IS_GOOD::::::::::::::::::::::::::::::::::::::::::::::::

    1 : 1 : 1 : 1 Relationship for each editor:

    E1_DATA : E1_RENDERCODE : E1_USERINPUT : E1_TILEBRUSH
    E2_DATA : E2_RENDERCODE : E2_USERINPUT : E2_TILEBRUSH
    E3_DATA : E3_RENDERCODE : E3_USERINPUT : E3_TILEBRUSH
    E4_DATA : E4_RENDERCODE : E4_USERINPUT : E4_TILEBRUSH

    ::::::::::::::::::::::::::::::::::::::::::::::::THIS_IS_GOOD
    THIS_IS_BAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    E1_DATA   E1_RENDERCODE   E1_USERINPUT   E1_TILEBRUSH
     |                             |              |
     |                             |              |
    DATA                          UI           TILEBRUSH
     |                             |              |
     |                             |              |
    E2_DATA   E2_RENDERCODE   E2_USERINPUT   E2_TILEBRUSH
     |
     |
    DATA
     |
     |
    E3_DATA   E3_RENDERCODE   E3_USERINPUT   E3_TILEBRUSH


    E4_DATA   E4_RENDERCODE   E4_USERINPUT   E4_TILEBRUSH

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!THIS_IS_BAD

################################EDITOR_ONE_TO_ONE_RELATIONSHIPS#
#PATTERN_BREAKER################################################

    #PATTERN_BREAKER# is a warning to reader of code that
    something about this code breaks the [conventions/patterns]
    typically used in the code base.

################################################PATTERN_BREAKER#
#NAMESPACE_PATTERN_BREAKER_PAINT5D##############################
                                                    
    Full Namespace Is:  AAC2020_GPUDATA_PAINT5D              
    You may have been expecting AAC2020_PAINT5D   #TAG_P5D#  
                                                            
    Leave comment here so that people can easily find what   
    they are looking for when searching for AAC2020_PAINT5D  

##############################NAMESPACE_PATTERN_BREAKER_PAINT5D#
#ALL_DATA_IS_512X512_RGBA_UNSIGNED##############################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0549PM ]
     
    All data will be represented by 512 x 512   
    pixel bitmaps. Each pixel being stored as   
    a series of 4 bytes. 4 bytes being RGBA     
    respectively.                               
    
##############################ALL_DATA_IS_512X512_RGBA_UNSIGNED#
#ASSERT_SAM_VAL_EQUALS_TEX_LOT##################################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0547PM ]

    NOTE: assert( sam_val == tex_lot )
        I think that is how we connect the
        texture to the sampler.
        USE[ edit_a2jc ]ForSomeReference

##################################ASSERT_SAM_VAL_EQUALS_TEX_LOT#
#GPUDATA_ONE_TO_ONE_MAPPING_DESIGN_NOTE#########################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0546PM ]
    
    DESIGN NOTE:                                          
        1:1 mapping between everything.              
                                                     
        1: Array Of Pixels (cpu_pix)                 
        1: Name to identify everything (pix_nam)     
        1: Actual Texture (tex_han)                  
        1: Put in ONE spot only (tex_lot)            
        1: Texture Sampler (sam_loc )                
        1: Sample ONE texture (sam_val == tex_lot )  
    
#########################GPUDATA_ONE_TO_ONE_MAPPING_DESIGN_NOTE#
#HASHTAG_COMMENT################################################

    Example comment referenced in DOCUMENTATION.TXT.
    
################################################HASHTAG_COMMENT#
#OVERRIDE_DEFAULT_SHADER_001####################################

    NOTES_FOR[ DOC/_S_ ]-->[ GPUDATA_PAINT5D ]

    Let's not go backwards into previous code and edit
    the source for the default shader #1. Instead let's
    OVERRIDE the default shader in slot #1.
    (Associated/Activated with NumberKey #1)
    
    Details on where to find the default shader we need
    to override:
                                        
    SOURCE________FILE: FRAGBED_DEFAULT_SHADERS/FDS_001._ 
    VARIABLE______NAME: AAC2020_FRAGBED_DEFAULT_001       
    USER_EDITABLE_COPY: FRAGBED_001.FRAG                  

####################################OVERRIDE_DEFAULT_SHADER_001#
#EVERY_EDITOR_GETS_512x512_GPUDATA_CHUNK########################

    Let's keep it simple and keep all of our
    relationships 1:1.
    [ 1editor == 1memorychunk == 1GLSL_Renderer ]
    
    This will be wasteful at times. But human brain
    is limited in what it can keep track of. Computers
    are always getting faster.
    
    If you have a 2D & 3D view of the same data...
    Still use two seperate memory chunks and copy 
    the data over when switching views.
    
    It is ugly and wasteful, but dead simple.
    Worry about optimization after you already have
    a finished product and are rich.
    
########################EVERY_EDITOR_GETS_512x512_GPUDATA_CHUNK#
*** ******************************************************** ***

    NEWEST_COMMENTS_ALWAYS_GO_TO_THE_TOP_OF_THIS_FILE
    SO_WE_HAVE_A_RECORD_OF_WHAT_WAS_DONE_IN_WHAT_ORDER
    
*** ******************************************************** **/
//:[_H_]: Hashtag Comments. For ANYTHING! ================== ://