//[[_H_]: Hashtag Comments. For ANYTHING! ================== ]//
/** ******************************************************** ***

    NEWEST_COMMENTS_ALWAYS_GO_TO_THE_TOP_OF_THIS_FILE
    SO WE HAVE A RECORD OF WHAT WAS DONE IN WHAT ORDER.
    
*** ******************************************************** ***

#_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#############################

    If you don't see your PAINT5D GLSL code, remember that the       
    prescense (spelling?) of "SHADER_001_PAINT5D.FRAG" 
    will override the hard-coded default shader code
    embedded in the ".text" segment of your executable
    source code.

    Or more plainly:

    Instead of loading AAC2020_PAINT5D_DEFAULT_001 from EXE,
    we load "SHADER_001_PAINT5D.FRAG" from disk if it is
    present.

    This allows users of our game to make mods to game
    if they are [informed/knowledgeable] of GLSL code.

#############################_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#
#_PULL_GLSL_SHADER_DATA_FROM_FUTURE_############################

        Because ALL DATA is declared before      
        ALL FUNCTIONS, we can get away with      
        referencing a piece of data from the     
        future like this.   
                     
############################_PULL_GLSL_SHADER_DATA_FROM_FUTURE_#
#_GPU_DATA_IS_A_TEMPORARY_HELPER_OBJECT_ONLY_###################

    Flat is better than nested. But sometimes we need to
    pass around a bundle of arguments to a helper function.

    Don't make your data LIVE in a nested structure just
    because sometimes it needs to be passed around in
    a bundle.

    REASONS:
        1. Flat code easier to memorize.
        2. Packing into nested structure at locations
           where it is needed make the code readable 
           WITHOUT intellisense because you can see
           what members you are packing into the struct
           at the fuction call site.

###################_GPU_DATA_IS_A_TEMPORARY_HELPER_OBJECT_ONLY_#
#_DO_NOT_EXTRACT_COMMENT_#######################################

    #_DO_NOT_EXTRACT_COMMENT_#:

        Means the comment itself serves some type of
        [ mechanical / administrative ] purpose meerly
        by existing where it does.

        Most commonly this would be for:

        1. WARNING COMMENTS 
        2. CTRL_F_HELP Comments.
        
        The mechanics of both comments dictate that they
        will fail to serve their purpose if they are
        extraced into this (_H_) file.

#######################################_DO_NOT_EXTRACT_COMMENT_#
#_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_############################

    Prioritize SIMPLE over OPTIMIZED/PERFORMANT code.

    Optimizing can happen. But only in 2 cases.

    1. Performance loss makes project UN-Usable.
    2. Game is 100% finished and we are in POLISH stage.

############################_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_#
#_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_######################

    The names "todo_02" , "todo_03" etc are
    name of reserved memory slots that have not
    been assigned a purpose yet.

    Though not assigned a purpose yet, we should still
    allocate them.

    (Yes wasteful I know)

    Reason:
        When ready to use memory for something, all we need
        to do is a name refactor without changing any
        functionality.

        If there is a problem that can occure by reserving
        more than ONE block of GPUDATA, we will know
        RIGHT_FUCKING_NOW. Even though we only are going to
        use one of those blocks RIGHT_FUCKING_NOW.

        #_SIMPLE_CODE_TRUMPS_OPTIMIZED_CODE_#

######################_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_#
#_BAD_IDEA_001_#################################################

    ------------------------------------------------------------
    Below was a bad idea. The correct way to handle this was
    to create error friendly wrapper functions so that we 
    can consolidate all the function calls needed to be
    made on a ONE LINE PER CALL basis.
    
    Reducing the density like this I think is a BAD IDEA.
    But originally did it because function calls were not
    error friendly. So we fixed that up a bit and
    make aac2020_gpudata wrapper functions for openGl
    binding library functions in AAC2020_GLEBIND.

        1:  aac2020_gpudata_glGetUniformLocation
        2:  aac2020_gpudata_glGetUniformiv      
    ------------------------------------------------------------

        //:GET_TEXTURE_SAMPLER:ALL:--------------------------://
        //:##################################################://
        //: MACROS: Functions: UPPERCASE                     ://
        //: MACROS: Constants: UPPERCASE                     ://
        //: MACROS: Variables: lowercase                     ://
        //:                                                  ://
        //: Dont be afraid of long functions. This is kinda  ://
        //: verbose and ugly and long... And very cut+paste. ://
        //: But also pretty easy to follow with only         ://
        //: 1 level of indirection.                          ://
        //: (We will see how easy to follow when we )        ://
        //: (come back to it in a month from now.   )        ://
        //: (DATE_WRITTEN: 2020_12_07               )        ://
        //:                                                  ://
        //:##################################################://
        #define N   ( 0 - 1 );                           //:1://
        #define P   (aac2020_graquad.data.POG_IID)       //:1://
        #define L   AAC2020_GLEBIND.glGetUniformLocation //:1://
        #define V   AAC2020_GLEBIND.glGetUniformiv       //:1://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    
            /** Sections by which texture sampler we are **/
            /** getting.                                 **/

            //:0101010101010101010101010101010101010101010101://
            #define s &(AAC2020_PIXNAME_paint5d[ 0 ] ) 
            #define h   AAC2020_PIXNAME_paint5d_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_paint5d_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_paint5d_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_001:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0101010101010101010101010101010101010101010101://
            //:0202020202020202020202020202020202020202020202://
            #define s &(AAC2020_PIXNAME_todo_02[ 0 ] ) 
            #define h   AAC2020_PIXNAME_todo_02_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_todo_02_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_todo_02_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_002:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0202020202020202020202020202020202020202020202://
            //:0303030303030303030303030303030303030303030303://
            #define s &(AAC2020_PIXNAME_todo_03[ 0 ] ) 
            #define h   AAC2020_PIXNAME_todo_03_tex_sam_HAS     
            #define l   AAC2020_PIXNAME_todo_03_tex_sam.sam_loc                        
            #define v   AAC2020_PIXNAME_todo_03_tex_sam.sam_val                        
             
                l = L( P , s );  
                if(      l == N ){  /** DO_NOTHING **/   }
                else if( l >= 0 ){  V(P, l ,  &( v )  ); }
                else{ INI_ALL_ERR("[SAM_LOC_003:ERR]");  };;
                
                if( N == l ){ l = N ; v = N ; h =( 0 ); }
                else{         l = l ; v = v ; h =( 1 ); }
      
            #undef  s  //:-----------------------------------://
            #undef  h  //:-----------------------------------://
            #undef  l  //:-----------------------------------://              
            #undef  v  //:-----------------------------------://
            //:0303030303030303030303030303030303030303030303://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  N //:Not Exist is Negative One           //:1://
        #undef  P //:Program Integer Id (POG_IID)        //:2://
        #undef  L //:Program Integer Id (POG_IID)        //:3://
        #undef  V //:Program Integer Id (POG_IID)        //:4://
        //:##################################################://
        //:--------------------------:GET_TEXTURE_SAMPLER:ALL://

#################################################_BAD_IDEA_001_#
#_ONE_EXIT_POINT_ALWAYS_########################################

    Functions should always have exactly one EXIT point
    as last line of function. A RETURN statement to be
    precise.

    Any function that does NOT obey this needs refactoring
    eventually.

    Multiple exit points are too error prone as I tend to
    miss them when reading code.

    The idea of "Get out of function as soon as possible"
    "before you screw stuff up" is a good idea though.
    To account for that philosophy, we should properly
    gaurd code blocks with an [ ok / o_k ] variable if
    their design typically WOULD best accomidate multiple
    return statements.

    WRITTEN_DATE[ 2020_12_07 ]

########################################_ONE_EXIT_POINT_ALWAYS_#
#_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_#########################

    It is TEMPTING to change the siguatre of wrapped functions
    to something NICER to use. However, doing that means
    it will be harder to interchangibly swapp the

        WRAPPED

    version with the

        UN-WRAPPED

    version of the function. I can see some benifit to that.

        BENIFITS:

            1. More flexibility.
            2. Dont have to THINK UP new signature format.

    So... WRAPER FUNCTION SHOULD HAVE IDENTICAL SIGNATURE
          TO THE FUNCTION IT IS WRAPPING.

#########################_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_#
#_ALWAYS_RELOAD_TEXSAM_AFTER_RELOADING_SHADER_##################

    Just because GPUDATA is initialized does NOT mean the
    texture sampler was successfully created. Texture sampler
    will only successfully exist if the texture sampler
    name is present in the currently loaded shader
    source code.

    Texture Sampler Names:
        AAC2020_PIXNAME_paint5d
        AAC2020_PIXNAME_todo_02  << Not_Yet_Assigned_As_Of_NOW
        AAC2020_PIXNAME_todo_03  << Not_Yet_Assigned_As_Of_NOW
        .... ETC

    Not_Yet_Assigned_As_Of_NOW: 2020_12_07

##################_ALWAYS_RELOAD_TEXSAM_AFTER_RELOADING_SHADER_#
#_PIXNAME_PATTERN_BREAKER_######################################

    EXTRACTED_FROM[ LIBCHAN.TOP._ ]ON_DATE[ 2020_12_06 ]

        //:--------------------------------------------------://
        //:#PATTERN_BREAKER# (slightly)                      ://
        //:                                                  ://
        //: A list of names of all of the gpu textures       ://
        //: defined by different GPUDATA instances.          ://
        //:                                                  ://
        //: We don't know what those names will be yet.      ://
        //: That is why this breaks project structure.       ://
        //:                                                  ://
        //: To mitigate the problem, these values will only  ://
        //: be used to ASSERT the correct values in future   ://
        //: libraries.                                       ://
        //:                                                  ://
        //:Q: Why are we breaking the LIBCHAN pattern here?  ://
        //:A: A consolidated list of all GPU textures        ://
        //:   is useful.                                     ://
        //:--------------------------------------------------://

######################################_PIXNAME_PATTERN_BREAKER_#
#_GPUDATA_IS_NOT_LIMITED_TO_GRAPHICS_###########################

    EXTRACTED_FROM[ LIBCHAN.TOP._ ]ON_DATE[ 2020_12_06 ]

        //:GPUDATA: GraphicsProcessingUnit_DATA
        //:        (NOT NECCESSARILY GRAPHICAL DATA)
        //:        (NOT NECCESSARILY GRAPHICAL INFORMATION)
        //:        GPUDATA tells me where the data is stored,
        //:        but not what the data represents.

###########################_GPUDATA_IS_NOT_LIMITED_TO_GRAPHICS_#
#TEMPCON########################################################

    #TEMPCON#: Tagging some variable as a "temporary container"

    For example: GPUDATA is a TEMPCON as of DATE[ 2020_12_06 ]

#########################################################TEMPCON#
#_FOR_SIMPLICITY_ALL_MEMORY_IS_512x512_#########################

    All memory for all systems is a 512x512 RGBA 
    UN-signed (NO NEGATIVES) integer texture.

    Art is about working with contraints. A block of marble
    with ZERO contraints is a block of marble. A statue is
    a block of marble with constraints put on it.

    Everything is nothing.

    111111111111111111111111111111111111111 <<<< NOTHING
    000000000000000000000000000000000000000 <<<< NOTHING
    010100101010111111000001111000001010101 <<<< SOMETHING

    This is why the void of nothingness is sometimes 
    refered to a "chaos" because the void of nothingness
    and complete chaos are the same exact thing.

#########################_FOR_SIMPLICITY_ALL_MEMORY_IS_512x512_#
#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#######################

    REMOVED, because now pointless. 
    REMOVED_DATE[ 2020_12_05 : 1134PM ]

            if( strcmp( 
                &(                 paint5d.pix_nam[ 0 ]  )
            ,   &( AAC2020_PIXNAME_paint5d[ 0 ]          )
            ) != 0 ){
                ERR("[paint5d:INIT_FAIL:ON:pix_nam]");
            };;
    
            if( AAC2020_PIXNAME_paint5d_tex_lot
                   !=   paint5d.g_pixel.tex_lot
            ){
                ERR("[paint5d:INIT_FAIL:ON:tex_lot]");
            };;

#######################_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#
#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_####################
    
    ------------------------------------------------------------
    For the sake of keeping things as SIMPLE & FLAT as possible,
    "GPUDATA" is now a temporary container only. For when we
    need to pass the data to a helper function. Actual data
    for "GPUDATA" exists in "PIXNAME". 

    REASON:
        1. PIXNAME way is SIMPLE + FLAT
        2. GPUDATA way is easy to pass around but harder to
           follow and read the code.

        We want to avoid fractionating our variable space,
        so if we want the "best of both worlds" GPUDATA 
        must be a TEMPORARY object only.

    ------------------------------------------------------------

        /// SBE: [Set/Put]Before_Init ///

            paint5d.g_pixel.tex_lot   = 1         ; /// SBE ///

         //:paint5d.g_pixel.pix_nam   = "paint5d" ; /// SBE ///
            paint5d.pix_nam[ 0 ] = 'p' ;          ;
            paint5d.pix_nam[ 1 ] = 'a' ;          ;
            paint5d.pix_nam[ 2 ] = 'i' ;          ;
            paint5d.pix_nam[ 3 ] = 'n' ;          ;
            paint5d.pix_nam[ 4 ] = 't' ;          ;
            paint5d.pix_nam[ 5 ] = '5' ;          ;
            paint5d.pix_nam[ 6 ] = 'd' ;          ;
            paint5d.pix_nam[ 7 ] = '\0';          ;
                           
            //:#WHY_PAINT5D_ERRORS_2020_12_04#
            if( paint5d.cpu_pix[0]      != 0 ){ ERR("[E_1]");};                   
            if( paint5d.g_pixel.tex_han != 0 ){ ERR("[E_2]");};
            if( paint5d.g_pixel.sam_loc != 0 ){ ERR("[E_3]");};
            if( paint5d.g_pixel.sam_val != 0 ){ ERR("[E_4]");};

####################_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#
#_GPUDATA_FLAT_IS_BETTER_THAN_NESTED_###########################

    In retrospect, nesting things into a "g_pixel" member
    was a bad idea. The intent was to communicate the
    division between "data on the GPU" and "data on the CPU".

    (CPU==HOST   Side)
    (GPU==DEVICE Side)

    But the only purpose GPUDATA struct should have is a
    container to pass around a bundle of stuff.... Don't change
    code structure for the sake of self-documenting code.

        //:REMOVED_ON[ DATE[ 2020_12_05 ] ]

        //:Handle to GPU texture representing cpu_pix :::::::://
        struct AAC2020_GPUDATA_G_PIXEL{

            //: -------------------------------------------- ://
            //: activeTexture( tex_lot )                     ://
            //: bindTexture(   tex_han );                    ://
            //: Means:                                       ://
            //:     OPEN_GL_TEXTURES[ tex_lot ]=( tex_han ); ://
            //: -------------------------------------------- ://
            int
            tex_lot ;//:USE_WITH[ activeTexture ]   
            int
            tex_han ;//:USE_WITH[ bindTexture   ]   
            
            //: -------------------------------------------- ://
            //: Texture SAMPLER_UNIFORM Value ************** ://
            //: sam_loc: Memory ADDRESS of SAMPLER_UNIFORM   ://
            //: sam_val: ValueOf[ tex_lot ]stored at ADDRESS ://
            //: -------------------------------------------- ://
            int
            sam_loc ;//:USE_WITH[ uniform1i( sam_loc, sam_val )]
            int
            sam_val ;//:USE_WITH[ uniform1i( sam_loc, sam_val )]

        }g_pixel; /// AKA: gpu_pix / gpu_han ///

###########################_GPUDATA_FLAT_IS_BETTER_THAN_NESTED_#
#_GAME_WITHOUT_MUTEXES_#########################################

        //: Removed, lets try to make an entire game without ://
        //: having to use mutexes, semaphores, and fences.   ://

        //: ENGETHER.THREADING.InterlockedIncrement64(
        //:     &( AAC2020_GINAWIN.THREAD_SAFE_FLAGS.
        //:        resize_message_count )
        //: );;

        //: #define C_B AAC2020_GINAWIN.OPTIONAL_CALLBACKS
        //: if(C_B.resize_function_has){
        //:    C_B.resize_function();
        //: };;
        //: #undef  C_B

#########################################_GAME_WITHOUT_MUTEXES_#
#_FRAGBED_UNIFORM_FREEABLE_POINTERS_############################

    EXTRACTED_FROM[ FRAGBED.D._ ]ON_DATE[ 2020_12_15 ]

    DESIGN_NOTES:

    I originally thought "AAC2020_FRAGBED_loaded_##_ptr"(s)
    could point to either the default shaders
    ( "AAC2020_FRAGBED_DEFAULT_###" ) or to shader code
    on the hard disk.
    
    Problem:

    This would mean sometimes the pointer is FREEABLE
    (when it points to disk) and UN-FREEABLE when it points
    to a hard coded (in source code) FILE_SCOPE char array.

    Solution:

    FILE_SCOPE char arrays must be copied over to malloced 
    memory for consistency.


############################_FRAGBED_UNIFORM_FREEABLE_POINTERS_#
#_GRAQUAD_CAME_FROM_GLEB_SWIN_##################################

    Extracted_From[ GRAQUAD.F._ ]ON_DATE[ 2020_12_05 ]

    Refactor Note:
    GLEB_SWIN --> GINAWIN (Graphics_Init_And_WINdow)
    GLEB -------> GLEBIND (open_GL_Easy_BINDings   )

##################################_GRAQUAD_CAME_FROM_GLEB_SWIN_#
#_TWO_DEFAULT_SHADERS_ONLY_#####################################

    EXTRACTED_FROM[ GRAQUAD.D.FRAG ]ON_DATE[ 2020_12_05 ]

        GRAQUAD.D.FRAG._:                                        
        GRAQUAD.DATA.FRAGMENT_SHADERS:                           
                                                                 
        These are just the shaders with different messages in    
        them for the user. Do NOT put AAC2020_FRAGBED default    
        shaders here. I get that you want to consolidate shader  
        code, but those default shaders need to be placed        
        where you would logically look for them in the future.   
                                                                 
        Which is with AAC2020_FRAGBED                            

#####################################_TWO_DEFAULT_SHADERS_ONLY_#
#_UNIFORM_NAMING_CONVENTION_####################################

    Uniform names copies of SHADERTOY.COM uniform names. 

    That way:

        1. I don't have to think about what to call them.
        2. I can easily [cut+paste] [ to | from ] Shadertoy.com

####################################_UNIFORM_NAMING_CONVENTION_#
#_WHY_THESE_IMOUSE_NAMES_#######################################

        //: ------------------------------------------------ ://
        //: [x,y,z,w]                                        ://
        //:                                                  ://
        //: These will be backed into VEC4 when              ://
        //: loaded into iMouse uniform.                      ://
        //: Decided to label these as their actual values    ://
        //: in the GLSL code rather than their usage.        ://
        //:                                                  ://
        //: Reason: I might not correctly understand what    ://
        //:         these values SHOULD BE and I don't want  ://
        //:         to have variable names that lie in my    ://
        //:         code.                                    ://
        //: ------------------------------------------------ ://
        U32   AAC2020_CPUNIFO_iMouse_vec4_x =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_y =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_z =( 0 );
        U32   AAC2020_CPUNIFO_iMouse_vec4_w =( 0 );

#######################################_WHY_THESE_IMOUSE_NAMES_#
#_EXTRACTED_GLEBIND_CLUTTER_NOTES_##############################

    //:NOTES:================================================://


        PREDACESSOR: GLEB: openGL_Easy_Bindings
        CURRENT_LIB: AAC2020_GLEBIND (GL_Easy_BINDings)
        
        Prefixes:
        AAC2020_GLEBIND_   :Library namespace prefix.
        MV_     :Macro Variable / Value
        MM_     :Maybe A Macro (MV_ value will decide)
        
        Function Names:
        DEBUGPRINT_01: Print ONE(01) string.

    //:================================================:NOTES://
    //:INCLUDES:=============================================://
    //://////////////////////////////////////////////////////://   
    //# Before you judge, include gaurds exist.              #//   
    //://////////////////////////////////////////////////////://   
                                                        //:  ://
    //  #include <stdint.h> //:int32_t      ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <stdlib.h> //:malloc(....) ://         //:  ://
    //  #include <stdlib.h> //:free(......) ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <string.h> //: strcmp      ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <stdio.h>  //:printf(....) ://         //:  ://
    //  #include <stdio.h>  //:fprintf(...) ://         //:  ://
    //  #include <stdio.h>  //:fflush(....) ://         //:  ://
    //                      //:             ://         //:  ://
    //  #include <ctype.h>  //:isspace(...) ://         //:  ://
                                                        //:  ://
        //[ Using: PEB20202_LoadLibrary    - - - - - ]////:  ://
        //[ Using: PEB2020_GetProcAddress  - - - - - ]////:  ://
        //-  Windows.h for:        - - - - - - - - - -////:  ://
        //-  1. LoadLibrary        - - - - - - - - - -////:  ://
        //-  2. GetProcAddress     - - - - - - - - - -////:  ://
        //-  3. FreeLibrary        - - - - - - - - - -////:  ://
        //-  #include <Windows.h>  - - - - - - - - - -////:  ://
                                                        //:  ://
    //://////////////////////////////////////////////////////://   
    //# Before you judge, include gaurds exist.              #//   
    //://////////////////////////////////////////////////////://   
    //:=============================================:INCLUDES://
 
##############################_EXTRACTED_GLEBIND_CLUTTER_NOTES_#
#GLEBIND_THIS_ONE_IS_SPECIAL####################################

    This one is special.                 
    The wrapper function is called       
                                         
        AAC2020_GLEBIND_wglGetProcAddress    
                                         
    instead of                           
                                         
        wglGetProcAddress                
                                         
    to avoid conflicts with Windows.h. The
    "wglGetProcAddress" function does NOT work "out of
    the box" like "GetProcAddress".                    
                                       
    I am sure if I knew more about linkers I could fix
    this. But messing with linkers would destroy the
    point of this library being an
                                         
        "easy bindings"                      
                                         
    library. The whole point is to just include this
    file and get access to openGL functions.

#DOES_NOT_REQUIRE_GL_CONTEXT_TO_CALL############################

    Also does NOT need an openGL context           
    in order to fetch it.                                       
                   
############################DOES_NOT_REQUIRE_GL_CONTEXT_TO_CALL#                      
####################################GLEBIND_THIS_ONE_IS_SPECIAL#
#_IF_NO_GL_LIST_CREATE_ONE_#####################################

    If "OPEN_GL_SEARCH_PATHS.TXT" does not    
    exist, create it now and populate it      
    with some default values.                 
    #SEE_IF_FILE_EXISTS_THEN_USE#  
    stackoverflow.com/questions/230062        

#####################################_IF_NO_GL_LIST_CREATE_ONE_#
#_WHY_GLEBIND_TOUCHFILE_########################################

    TouchFile function did not exist in GLEB.H      
    Added to GLEBIND.F (GLEBIND_DOT_F) to make      
    program a bit more user friendly.               
                                                    
    GOAL: Program is a single .EXE file, no         
        supplimentary files need to be copied to    
        maintain a working executable.              
                                                    
    This function makes it so you don't have to     
    copy around OPEN_GL_SEARCH_PATHS.TXT            

########################################_WHY_GLEBIND_TOUCHFILE_#
##############################if_not_exist_add_default_contents#

    int if_not_exist_add_default_contents :

        If the file did not exist before we touched it,   
        should we initialize it's contents with some      
        default search paths for where we can expect      
        OpenGL32.dll to be?                               

#if_not_exist_add_default_contents##############################
#_WHY_CANT_I_SEE_MY_WINDOW_#####################################

    Trying to figure out why window does not show up:
    
    Possible fixes/problems:
    
    F01: You never initialise hdc with the result of 
        the BeginPaint call, so your painting will fail.  
        https://stackoverflow.com/questions/30551850

#####################################_WHY_CANT_I_SEE_MY_WINDOW_#
#_OLD_GINAWIN_DOCUMENTATION_####################################
    
    --------------------------------------------------------
    Documentation for GINAWIN that I think was left over
    from when I cut and pasted the code from previous 
    project. Not sure how relevant these comments below are.
    --------------------------------------------------------

    KEY/PREFIXES:
        aac2020_ginawin_:
        The namespace prefix for all functions
        that belong to this section of code.
    
        gleb: open_GL_Easy_Bindings
        
        swin:
        SWIN=="SILKWIN"==="THREADED_WINDOW"
        The idea is a "window made of silk" 
        because threads can be made of silk.
        I am thinking the window was woven
        by a spider's threads.
    
        pfn: Pointer_to_FuNction
             (Convention take from Vulkan)
    
    CONVENTIONS:
    
      1. Non-terminal objects of library
         structs are ALL_CAPITAL.
    
      2. Terminal objects of library struct are:
         A: CamelCaseIfFunction
         B: snake_case_if_variable
         C: OR: Written in convention of whatever
            I am trying to wrap that exists from
            some other library I don't own.
    
      3. Includes often are put near where
         they are needed, rather than all at
         the top of the file. Standard headers
         have include gaurds, so this shouldn't
         be a problem.
    
      4. Global Windows Functions Allowed:
         1. LoadLibraryA
         2. GetProcAddress
         Anything else should be wrapped in
         a library struct that tells us the
         .dll file of origin.
    
         Convoluted and rigid and a pain to
         port to another operating system?
    
         I'll worry about porting after I've made
         a million dollars off of something.
         Otherwise, not worth the hassel.

####################################_OLD_GINAWIN_DOCUMENTATION_#
#_CEDITOR_DESIGN_NOTES_2020_12_04_##############################

    CEDITOR: Current_EDITOR

    Currently the project is setup to use 9 different shaders.
    That each activate when the corresponding number key is
    pressed. For example, pressing "3" loads fragment shader
    #3 into our pipeline.

    Let's build upon this:

    NUMKEY 1 ===>  Active:FragShader_1 , dex_edi == 1
    NUMKEY 2 ===>  Active:FragShader_2 , dex_edi == 2
    NUMKEY 3 ===>  Active:FragShader_3 , dex_edi == 3
    NUMKEY 4 ===>  Active:FragShader_4 , dex_edi == 4
    NUMKEY 5 ===>  Active:FragShader_5 , dex_edi == 5
    NUMKEY 6 ===>  Active:FragShader_6 , dex_edi == 6
    NUMKEY 7 ===>  Active:FragShader_7 , dex_edi == 7
    NUMKEY 8 ===>  Active:FragShader_8 , dex_edi == 8
    NUMKEY 9 ===>  Active:FragShader_9 , dex_edi == 9
     
    When zero is pressed, no conceptual "sub editor"      
    is in focus. Maybe when that happens, the keyboard    
    will only respond to keys "0" - "9" because there is  
    no editor in focus to listen to what keys were
    pressed. ?
    NUMKEY 0 ===>  Active:FragShader_0 , dex_edi == 0

##############################_CEDITOR_DESIGN_NOTES_2020_12_04_#
#_LIKE_glo_eve_OBJECT_in_A2_JC_#################################

    Like: glo_eve object in R:\G\A2_JC.js  

          glo_eve == "global event"
          A generic [system/platform] agnostic event object.

          Thought "keyboard event" was too specific and
          "input event" also too specific because controls
          might be wired into an A.I.
 
#################################_LIKE_glo_eve_OBJECT_in_A2_JC_#
#_MARK_ALL_KEYS_AS_DIRTY_#######################################

        After you've consumed the keyboard events  
        mark all IKEYBOX data as dirty.  

        U32  AAC2020_IKEYBOX_dirty = ( 1 );

#######################################_MARK_ALL_KEYS_AS_DIRTY_#
#_KEEP_KEY_PRESSED_DEAD_SIMPLE_FOR_NOW_#########################

        Keep it dead simple for now.  
        This is the most recent NON controll key pressed.    
        This should be suitable for basic editors.  
        We can figure out something more complex    
        when we need responsive game controls.   

        char AAC2020_IKEYBOX_k_p = '_' ; //:k_p: Key_Pressed

#########################_KEEP_KEY_PRESSED_DEAD_SIMPLE_FOR_NOW_#
#_WHY_TEXTURE_SLOTS_IN_PIXNAME_#################################

    A bit weird, but let's keep the texture slot values   
    centralized here as well so that we can easily        
    verify that all texture slots are UNIQUE .            

#################################_WHY_TEXTURE_SLOTS_IN_PIXNAME_#
#KEYPAD_HASHTAGS################################################

    Keep those 1:1 relationships. 
    SEE[ #EDITOR_ONE_TO_ONE_RELATIONSHIPS# ]

    #KEYPAD_1# : Thing is associated with EDITOR#1, KEYPAD1
    #KEYPAD_2# : Thing is associated with EDITOR#2, KEYPAD1
    #KEYPAD_3# : Thing is associated with EDITOR#3, KEYPAD1
    #KEYPAD_4# : Thing is associated with EDITOR#4, KEYPAD1
    #KEYPAD_5# : Thing is associated with EDITOR#5, KEYPAD1
    #KEYPAD_6# : Thing is associated with EDITOR#6, KEYPAD1
    #KEYPAD_7# : Thing is associated with EDITOR#7, KEYPAD1
    #KEYPAD_8# : Thing is associated with EDITOR#8, KEYPAD1
    #KEYPAD_9# : Thing is associated with EDITOR#9, KEYPAD1

################################################KEYPAD_HASHTAGS#
#PATTERN_BREAKER_PIXNAME########################################

    EXTRACTED_FROM[ PIXNAME.D._ ]ON_DATE[ 2020_12_04 : 0840PM ]
                                           
    #PATTERN_BREAKER#       
                                                            
    This somewhat breaks the spirit of our LIBCHAN          
    (library chain) pattern of adding things on as you      
    build up.                                               
                                                            
    The variables here will only be used for:               
        1. Human Reference                                  
        2. Asserts                                          
                                                            
    It will never be used as an assingnment like:           
                                                            
        ACC2020_GPUDATA_PAINT5D_dat.pix_nam=(               
        AAC2020_PIXNAME_paint5d ); <<<<<<< NO! NEVER!       
                                                            
    But will rather be used like so:                        
                                                            
        ACC2020_GPUDATA_PAINT5D_dat.pix_nam = "paint5d";    
        assert( AAC2020_PIXNAME_paint5d    == "paint5d" );  
                                                            
    Reason:                                                 
                                                            
        Make the code easy to follow with minimal           
        indirection, while still having the benifit of      
        a centralized area where all of the different       
        512 -x- 512 chunks of memory are defined.           
 
########################################PATTERN_BREAKER_PIXNAME#
#WHY_PAINT5D_ERRORS_2020_12_04##################################

    These errors could happen if                  
    1: You failed to zero initialize struct       
    2: You called initializer TWICE or MORE.     
    
    if( paint5d.cpu_pix[0]      != 0 ){ ERR("[E_1]");};                   
    if( paint5d.g_pixel.tex_han != 0 ){ ERR("[E_2]");};
    if( paint5d.g_pixel.sam_loc != 0 ){ ERR("[E_3]");};
    if( paint5d.g_pixel.sam_val != 0 ){ ERR("[E_4]");}; 

##################################WHY_PAINT5D_ERRORS_2020_12_04#
#PROJECT_IS_EDITOR_CENTRIC######################################

    As we build a game, we want the game play to just be
    an editor view where the user's controls do not allow
    for editing the level, but rather just moving and
    controlling the player.

    Level is still mutable by things like destructable
    geometry, but not by editing tools.

    Doing it this way means we only have ONE code base
    to maintain. (An editor code base) rather than a
    game engine and level editor code base.

######################################PROJECT_IS_EDITOR_CENTRIC#
#EDITOR_ONE_TO_ONE_RELATIONSHIPS################################

    Even if there is shared state or components,
    every editor should get unique copies of things
    to keep the relationships simple 1:1 relationships.

    If two editors need to share the same TILEBRUSH, we
    just copy over E1_TILEBRUSH to E2_TILEBRUSH when
    switch views from EDITOR #1 (E1) to EDITOR #2 (E2)

    THIS_IS_GOOD::::::::::::::::::::::::::::::::::::::::::::::::

    1 : 1 : 1 : 1 Relationship for each editor:

    E1_DATA : E1_RENDERCODE : E1_USERINPUT : E1_TILEBRUSH
    E2_DATA : E2_RENDERCODE : E2_USERINPUT : E2_TILEBRUSH
    E3_DATA : E3_RENDERCODE : E3_USERINPUT : E3_TILEBRUSH
    E4_DATA : E4_RENDERCODE : E4_USERINPUT : E4_TILEBRUSH

    ::::::::::::::::::::::::::::::::::::::::::::::::THIS_IS_GOOD
    THIS_IS_BAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    E1_DATA   E1_RENDERCODE   E1_USERINPUT   E1_TILEBRUSH
     |                             |              |
     |                             |              |
    DATA                          UI           TILEBRUSH
     |                             |              |
     |                             |              |
    E2_DATA   E2_RENDERCODE   E2_USERINPUT   E2_TILEBRUSH
     |
     |
    DATA
     |
     |
    E3_DATA   E3_RENDERCODE   E3_USERINPUT   E3_TILEBRUSH


    E4_DATA   E4_RENDERCODE   E4_USERINPUT   E4_TILEBRUSH

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!THIS_IS_BAD

################################EDITOR_ONE_TO_ONE_RELATIONSHIPS#
#PATTERN_BREAKER################################################

    #PATTERN_BREAKER# is a warning to reader of code that
    something about this code breaks the [conventions/patterns]
    typically used in the code base.

################################################PATTERN_BREAKER#
#NAMESPACE_PATTERN_BREAKER_PAINT5D##############################
                                                    
    Full Namespace Is:  AAC2020_GPUDATA_PAINT5D              
    You may have been expecting AAC2020_PAINT5D   #TAG_P5D#  
                                                            
    Leave comment here so that people can easily find what   
    they are looking for when searching for AAC2020_PAINT5D  

##############################NAMESPACE_PATTERN_BREAKER_PAINT5D#
#ALL_DATA_IS_512X512_RGBA_UNSIGNED##############################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0549PM ]
     
    All data will be represented by 512 x 512   
    pixel bitmaps. Each pixel being stored as   
    a series of 4 bytes. 4 bytes being RGBA     
    respectively.                               
    
##############################ALL_DATA_IS_512X512_RGBA_UNSIGNED#
#ASSERT_SAM_VAL_EQUALS_TEX_LOT##################################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0547PM ]

    NOTE: assert( sam_val == tex_lot )
        I think that is how we connect the
        texture to the sampler.
        USE[ edit_a2jc ]ForSomeReference

##################################ASSERT_SAM_VAL_EQUALS_TEX_LOT#
#GPUDATA_ONE_TO_ONE_MAPPING_DESIGN_NOTE#########################

    EXTRACTED_FROM[ GPUDATA.D._ ]ON[ 2020_12_04 : 0546PM ]
    
    DESIGN NOTE:                                          
        1:1 mapping between everything.              
                                                     
        1: Array Of Pixels (cpu_pix)                 
        1: Name to identify everything (pix_nam)     
        1: Actual Texture (tex_han)                  
        1: Put in ONE spot only (tex_lot)            
        1: Texture Sampler (sam_loc )                
        1: Sample ONE texture (sam_val == tex_lot )  
    
#########################GPUDATA_ONE_TO_ONE_MAPPING_DESIGN_NOTE#
#HASHTAG_COMMENT################################################

    Example comment referenced in DOCUMENTATION.TXT.
    
################################################HASHTAG_COMMENT#
#OVERRIDE_DEFAULT_SHADER_001####################################

    NOTES_FOR[ DOC/_S_ ]-->[ GPUDATA_PAINT5D ]

    Let's not go backwards into previous code and edit
    the source for the default shader #1. Instead let's
    OVERRIDE the default shader in slot #1.
    (Associated/Activated with NumberKey #1)
    
    Details on where to find the default shader we need
    to override:
                                        
    SOURCE________FILE: FRAGBED_DEFAULT_SHADERS/FDS_001._ 
    VARIABLE______NAME: AAC2020_FRAGBED_DEFAULT_001       
    USER_EDITABLE_COPY: FRAGBED_001.FRAG                  

####################################OVERRIDE_DEFAULT_SHADER_001#
#EVERY_EDITOR_GETS_512x512_GPUDATA_CHUNK########################

    Let's keep it simple and keep all of our
    relationships 1:1.
    [ 1editor == 1memorychunk == 1GLSL_Renderer ]
    
    This will be wasteful at times. But human brain
    is limited in what it can keep track of. Computers
    are always getting faster.
    
    If you have a 2D & 3D view of the same data...
    Still use two seperate memory chunks and copy 
    the data over when switching views.
    
    It is ugly and wasteful, but dead simple.
    Worry about optimization after you already have
    a finished product and are rich.
    
########################EVERY_EDITOR_GETS_512x512_GPUDATA_CHUNK#
*** ******************************************************** ***

    NEWEST_COMMENTS_ALWAYS_GO_TO_THE_TOP_OF_THIS_FILE
    SO WE HAVE A RECORD OF WHAT WAS DONE IN WHAT ORDER.
    
*** ******************************************************** **/
//[[_H_]: Hashtag Comments. For ANYTHING! ================== ]//