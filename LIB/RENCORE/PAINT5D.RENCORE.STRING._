"    //# DO_NOT_PUT_DOUBLE_OR_SINGLE_QUOTES_IN_THIS_FILE! #//\n"
"    //[ The shader pipeline pre-processes this file by   ]//\n"
"    //[ quoting it. Back slash characters can also lead  ]//\n"
"    //[ to problems as wel. -John Mark Isaac Madison     ]//        \n"
"    //# BACK_SLASHES_ARE_ALSO_A_VERY_BAD_IDEA_TOO!!!!!!! #//\n"
"    /** ************************************************ ***\n"
"    Specify how to blend together all 8 tile sizes that\n"
"    are on a given layer. Any pixel on screen has 8 tiles\n"
"    of 8 different sizes overlapping that [pixel/fragment].\n"
"    *** ************************************************ **/\n"
"    U32 AAC2020_PAINT5D_RENCORE_tilpixa_CTO_laypixu(\n"
"    U32                         tilpixa[ 8 ]\n"
"    )\n"
"    {\n"
"    #define B_Y_T_E_M_A_S_K MAK_U32( 0xFF )\n"
"        U32 laypixu;\n"
"        laypixu=( U32_000\n"
"        |   ((( U32_000\n"
"            + ( tilpixa[ 0 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 1 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 2 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 3 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 4 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 5 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 6 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 7 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            ) / U32_008)    <<24 )\n"
"        |   ((( U32_000\n"
"            + ( tilpixa[ 0 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 1 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 2 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 3 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 4 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 5 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 6 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 7 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            ) / U32_008)    <<16 )\n"
"        |   ((( U32_000\n"
"            + ( tilpixa[ 0 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 1 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 2 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 3 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 4 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 5 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 6 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( tilpixa[ 7 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            ) / U32_008)    << 8 )\n"
"        |   ( U32_255 << 0 ) //:Just set alpha to 100%\n"
"        );;\n"
"        return( laypixu );\n"
"    #undef B_Y_T_E_M_A_S_K\n"
"    }\n"
"    /** ************************************************ ***\n"
"    Specify how all 3 flattened layers are to be blended\n"
"    together to create the final pixel color that will be\n"
"    put onto screen.\n"
"    *** ************************************************ **/\n"
"    U32 AAC2020_PAINT5D_RENCORE_laypixa_CTO_plypix3(\n"
"    U32                         laypixa[ 3 ]\n"
"    )\n"
"    {\n"
"    #define B_Y_T_E_M_A_S_K MAK_U32( 0xFF )\n"
"    #define DIV_VAL ( U32_001 )\n"
"        U32 plypix3;\n"
"        plypix3=( U32_000\n"
"        |   ((( U32_000\n"
"            + ( laypixa[ 0 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 1 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 2 ]>>24 & B_Y_T_E_M_A_S_K )\n"
"            ) / DIV_VAL)    <<24 )\n"
"        |   ((( U32_000\n"
"            + ( laypixa[ 0 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 1 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 2 ]>>16 & B_Y_T_E_M_A_S_K )\n"
"            ) / DIV_VAL)    <<16 )\n"
"        |   ((( U32_000\n"
"            + ( laypixa[ 0 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 1 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            + ( laypixa[ 2 ]>> 8 & B_Y_T_E_M_A_S_K )\n"
"            ) / DIV_VAL)    << 8 )\n"
"        |   ( U32_255 << 0 ) //:Just set alpha to 100%\n"
"        );;\n"
"        return( plypix3 );\n"
"    #undef B_Y_T_E_M_A_S_K\n"
"    #undef DIV_VAL\n"
"    }\n"
"    /** ************************************************ ***\n"
"    @param aus_dex : AUtotileSet_inDEX\n"
"                     Maybe you want to use a different\n"
"                     pallet for different auto tile sets.\n"
"                     aus_dex range: 0 to 15 inclusive\n"
"    @param til_lay : TILe_LAYer\n"
"                     There are 3 layers for an auto tile\n"
"                     set design. [ 0 | 1 | 2 ]\n"
"    @param til_exp : TILe_EXPonent\n"
"                     A number[ 0 -to- 7 ]inclusive.\n"
"                     Tells us the relative size of the tile.\n"
"                     0 == 2^0 ==  1 (  1 pebble(s) in size)\n"
"                     1 == 2^1 ==  2 (  2 pebble(s) in size)\n"
"                     2 == 2^2 ==  4 (  4 pebble(s) in size)\n"
"                     3 == 2^3 ==  8 (  8 pebble(s) in size)\n"
"                     4 == 2^4 == 16 ( 16 pebble(s) in size)\n"
"                     5 == 2^5 == 32 ( 32 pebble(s) in size)\n"
"                     6 == 2^6 == 64 ( 64 pebble(s) in size)\n"
"                     7 == 2^7 ==128 (128 pebble(s) in size)\n"
"    @param til_val : TILe_VALue\n"
"                     A number[ 0 -to- 3 ]inclusive.\n"
"                     0 is used for[ nothingness ]by \n"
"                     convention. But nothing is stopping \n"
"                     you from doing something different\n"
"                     with it. Value[ 0 ]will still auto\n"
"                     tile like any other tile value.\n"
"    @param tou_val : TOUching_VALue\n"
"                     A number[ 0 -to- 15 ]inclusive.        \n"
"                     Tells us what conceptual[ sub tile ]\n"
"                     to grab. Since we are doing auto \n"
"                     tiling with shaders and __NOT__ with\n"
"                     oldschool bitmap graphics... there is\n"
"                     no physical sub tile to grab. But\n"
"                     you still need this value if you \n"
"                     are implementing auto-tile style\n"
"                     rendering for the different \n"
"                     tile values.\n"
"    @param tilop_x : Tile_Internal_LOcal_Percentage_X\n"
"                     A percent coorinate from -1.0 to +1.0\n"
"                     used to map a fragment coordinate to\n"
"                     the interior of tile being rendered.\n"
"                     0.0 is the dead center.\n"
"    @param tilop_y : Tile_Internal_LOcal_Percentage_Y\n"
"                     Same as [ tilop_x ]but Y-axis.\n"
"                     IMPORTANT!!!:\n"
"                     Graphical top-left origin.\n"
"                     Top    of tile == -1.0\n"
"                     Bottom of tile == +1.0\n"
"    *** ************************************************ **/\n"
"    U32 AAC2020_PAINT5D_RENCORE_tilodat_CTO_tilpixu(\n"
"        I32 aus_dex //:AKA[ aus_dex / a_d ]\n"
"    ,   I32 til_lay //:AKA[ til_lay / t_l ] \n"
"    ,   I32 til_exp //:AKA[ til_exp / t_e ] \n"
"    ,   U32 til_val //:AKA[ til_val / t_v ] \n"
"    ,   U32 tou_val //:AKA[ tou_val / tou ]\n"
"    ,   F32 tilop_x //:AKA[ tilop_x / p_x ]\n"
"    ,   F32 tilop_y //:AKA[ tilop_y / p_y ] \n"
"    )\n"
"    {\n"
"        if( aus_dex >       0  ){ /** NOOP **/ };\n"
"        if( til_lay >       0  ){ /** NOOP **/ };\n"
"        if( til_exp >       0  ){ /** NOOP **/ };\n"
"        if( til_val > U32_000  ){ /** NOOP **/ };\n"
"        if( tou_val > U32_000  ){ /** NOOP **/ };\n"
"        if( tilop_x >     0.0  ){ /** NOOP **/ };\n"
"        if( tilop_y >     0.0  ){ /** NOOP **/ };\n"
"        //: SQUARE_GRADIENT: max( abs( x ) , abs( y ) ) \n"
"        F32\n"
"        f32_gra=( /** Float32_GRAdient **/\n"
"        MAX_F32( ABS_F32( tilop_x ) , ABS_F32( tilop_y ) )\n"
"        );;\n"
"        if( f32_gra > 1.0 ){ /** NOOP **/ };\n"
"        /** Hackish little algorithm. **/\n"
"        /** til_lay determines monochrome layer color **/\n"
"        /** til_val determines monochrome lumonosity  **/\n"
"        U32 tilpixu =( U32_255 ); //:100% alpha, BLACK\n"
"        U32 lum_255 =( U32_085 * til_val );\n"
"        F32 tim_cos =(AAC2020_FRAGCOM_COS_F32(\n"
"            AAC2020_FRAGCOM_GET_iTime() / 2.0\n"
"        ));;\n"
"            lum_255 =(  \n"
"            /**/    I32_U32(\n"
"            /**/    MAX_I32( \n"
"            /**/        0\n"
"            /**/    ,\n"
"            /**/        (\n"
"            /**/            U32_I32( lum_255                   )\n"
"            /**/        -   F32_I32( f32_gra * 128.0 * tim_cos ) \n"
"            /**/        )\n"
"            /**/    )));;\n"
"        if( U32_000 == til_val ){\n"
"            tilpixu =( U32_255 ); //:100% alpha, BLACK\n"
"        }else{\n"
"            tilpixu =( tilpixu \n"
"            |   ( ( lum_255 ) << ((til_lay+1)*8) )\n"
"            );;\n"
"        };;\n"
"        return( tilpixu );\n"
"    }\n"
"        //:TODO: Delete this function once the new\n"
"        //:      pipeline is established.\n"
"        U32\n"
"        AAC2020_PAINT5D_RENCORE(\n"
"        /**/I32  fic_i_x  //:<--FragIntCoord:X           ://\n"
"        ,   I32  fic_i_y  //:<--FragIntCoord:Y           ://\n"
"        ,   I32  cuv_i_x  //:<--CanvasUserView           ://\n"
"        ,   I32  cuv_i_y  //:<--CanvasUserView           ://\n"
"        ,   I32  aus_dex  //:<--Auset_Index[ 0 -to- 15 ] ://\n"
"        ,   U32  u32_l_0  //:<--Layers( BitPacked Data ) ://\n"
"        ,   U32  u32_l_1  //:<--Layers( BitPacked Data ) ://\n"
"        ,   U32  u32_l_2  //:<--Layers( BitPacked Data ) ://\n"
"        )\n"
"        {\n"
"            /** TODO: 1: tile local coordinate. **/ \n"
"            /** TODO: 2: touching value of current tile **/\n"
"            /**          the renderer is over.          **/\n"
"            if( fic_i_x > 0 ){ /** NOOP **/ };\n"
"            if( fic_i_y > 0 ){ /** NOOP **/ };\n"
"            if( cuv_i_x > 0 ){ /** NOOP **/ };\n"
"            if( cuv_i_y > 0 ){ /** NOOP **/ };\n"
"            if( aus_dex > 0 ){ /** NOOP **/ };\n"
"            //:HARD_CODED_COLOR_PALLET:------------------://\n"
"                    //:Bot : layer_lumonosity_pallet\n"
"                    U32 pal_l_0[4]= ARR_U32(4)\n"
"                                    ARR_BEG\n"
"                                    /**/U32_016   \n"
"                                    ,   U32_032   \n"
"                                    ,   U32_048   \n"
"                                    ,   U32_064   \n"
"                                    ARR_END;\n"
"                    if( pal_l_0[0] > UFF ){ /**NOOP**/ };\n"
"                    //:Mid : layer_lumonosity_pallet :\n"
"                    U32 pal_l_1[4]= ARR_U32(4)\n"
"                                    ARR_BEG\n"
"                                    /**/U32_016   \n"
"                                    ,   U32_032   \n"
"                                    ,   U32_048   \n"
"                                    ,   U32_064   \n"
"                                    ARR_END;\n"
"                    //:Top : layer_lumonosity_pallet :\n"
"                    U32 pal_l_2[4]= ARR_U32(4)\n"
"                                    ARR_BEG\n"
"                                    /**/U32_016   \n"
"                                    ,   U32_032   \n"
"                                    ,   U32_048   \n"
"                                    ,   U32_064   \n"
"                                    ARR_END;\n"
"            //:------------------:HARD_CODED_COLOR_PALLET://\n"
"            //:NON_DILLUTED_AVERAGE:=====================://\n"
"                //:Total Number Of Non_Zero Tile Values\n"
"                //:Over the current pixel for the \n"
"                //:current layer.\n"
"                U32 tot_l_0=MAK_U32(0);\n"
"                U32 tot_l_1=MAK_U32(0);\n"
"                U32 tot_l_2=MAK_U32(0);\n"
"                tot_l_0=MAK_U32( 8 );\n"
"                tot_l_1=MAK_U32( 8 );\n"
"                tot_l_2=MAK_U32( 8 );\n"
"                U32 sum_l_0=MAK_U32(0);\n"
"                U32 sum_l_1=MAK_U32(0);\n"
"                U32 sum_l_2=MAK_U32(0);\n"
"                sum_l_0=( U32_000\n"
"                    + pal_l_0[ ( u32_l_0 >> 0 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >> 2 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >> 4 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >> 6 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >> 8 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >>10 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >>12 ) & B11 ]\n"
"                    + pal_l_0[ ( u32_l_0 >>14 ) & B11 ]\n"
"                );;\n"
"                sum_l_1=( U32_000\n"
"                    + pal_l_1[ ( u32_l_1 >> 0 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >> 2 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >> 4 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >> 6 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >> 8 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >>10 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >>12 ) & B11 ]\n"
"                    + pal_l_1[ ( u32_l_1 >>14 ) & B11 ]\n"
"                );;\n"
"                sum_l_2=( U32_000\n"
"                    + pal_l_2[ ( u32_l_2 >> 0 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >> 2 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >> 4 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >> 6 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >> 8 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >>10 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >>12 ) & B11 ]\n"
"                    + pal_l_2[ ( u32_l_2 >>14 ) & B11 ]\n"
"                );;\n"
"                //:Amount to add:\n"
"                U32 add_l_0=MAK_U32(0);\n"
"                U32 add_l_1=MAK_U32(0);\n"
"                U32 add_l_2=MAK_U32(0);\n"
"                add_l_0=(( sum_l_0 / tot_l_0 )+U32_000);\n"
"                add_l_1=(( sum_l_1 / tot_l_1 )+U32_000);\n"
"                add_l_2=(( sum_l_2 / tot_l_2 )+U32_000);\n"
"                if( add_l_0 > U32_128 ){ add_l_0 = U32_128; };\n"
"                if( add_l_1 > U32_128 ){ add_l_1 = U32_128; };\n"
"                if( add_l_2 > U32_128 ){ add_l_2 = U32_128; };\n"
"                U32 lum_l_0=MAK_U32(0);\n"
"                U32 lum_l_1=MAK_U32(0);\n"
"                U32 lum_l_2=MAK_U32(0);\n"
"                lum_l_0=(  MAK_U32(  0) + add_l_0 );\n"
"                lum_l_1=(  MAK_U32(  0) + add_l_1 );\n"
"                lum_l_2=(  MAK_U32(  0) + add_l_2 );\n"
"            //:=====================:NON_DILLUTED_AVERAGE://\n"
"            //:PACK_YOUR_FUCKING_BAGS:===================://\n"
"                U32 u32_pix=MAK_U32( 0 );\n"
"                if( lum_l_0 > UFF ){ lum_l_0 = UFF; };\n"
"                if( lum_l_1 > UFF ){ lum_l_1 = UFF; };\n"
"                if( lum_l_2 > UFF ){ lum_l_2 = UFF; };\n"
"                U32 lum_all=( lum_l_0 + lum_l_1 + lum_l_2 );\n"
"                if( lum_all > UFF ){ lum_all = UFF; };\n"
"                u32_pix=( \n"
"                    lum_all << 24\n"
"                       //    U32_000 << 24\n"
"                    |  lum_all << 16\n"
"                    |  lum_all <<  8\n"
"                    |  UFF     <<  0\n"
"                );;\n"
"            //:===================:PACK_YOUR_FUCKING_BAGS://\n"
"            //:OUTPUT_IS_U32_PIXEL_VALUE:================://\n"
"                return( u32_pix );\n"
"            //:================:OUTPUT_IS_U32_PIXEL_VALUE://\n"
"        }\n"
