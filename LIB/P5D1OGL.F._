//: P5D1OGL: FUNCTIONS:

#if( AAC2020_CRASH_ON_VITAL_TODO >= 1 ) //:##################://

    #error p5d_ogl ==> p5d1ogl  (1 is for subsystem 1)

#endif //:###################################################://
//:ONLY_TWO_TYPES_OF_MESSAGES:===============================://
#define P_F printf

    //:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:- - - - - - - - -://
        void 
        aac2020_p5d1ogl_Halt( const char* msg_err )
        {
            P_F("[FATAL_ERROR:aac2020_p5d1ogl]:%s\n", msg_err );
            fflush(stdout);
            exit( 23 /** 23rd of Janurary, year 2021 **/ );
        }
    //:- - - - - - - - -:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
    //:LOG_AFTER_HALT:- - - - - - - - - - - - - - - - - - - -://

        void
        aac2020_p5d1ogl_Info_any(
            const char* str_fmt
        ,   void*       dat_any   
        )
        { if( AAC2020_SILENCE.P5D1OGL <= 0 ){

            /** Same Line As Next Printf **/
            P_F("[p5d1ogl_log]....(   " ); fflush( stdout );
            P_F( str_fmt , dat_any      ); fflush( stdout );
            P_F(               "   )\n" ); fflush( stdout );

        };; }

    //:- - - - - - - - - - - - - - - - - - - -:LOG_AFTER_HALT://

#undef  P_F
//:===============================:ONLY_TWO_TYPES_OF_MESSAGES://
//:INIT_NONE:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_P5D1OGL_InitNone( U32 u32 ){
        if( u32 ){ /** reserved for future use **/ };

        /** **************************************** **/
        /** @VID_IID[ 0086 ]TIME[ 00:08:40 ]         **/
        /** @VID_IID[ 0086 ]TIME[ 00:45:40 ]         **/
        /** @VID_IID[ 0103 ]TIME[ 01:01:32 ]__MOVED__**/
        /** Always run this unit test. Tests  file   **/
        /** OPEN_GL_HAKCODE/P5D1OGL._ ************** **/
        #define E_V extern void                      ///
                                                     ///
                E_V aac2020_P5D1OGL_UnitTest( void );///
                    aac2020_P5D1OGL_UnitTest(      );///
                                                     ///
        #undef  E_V                                  ///
        /** **************************************** **/

        return( 0x00 );
    }

#undef  U32
//:================================================:INIT_NONE://
//[OPEN_GL_PAINT5D_Get:======================================]//
//[OPEN_GL_PAINT5D_painpix_CTO_glocpix:======================]//
                                                            
    /** @VID_IID[ 0085 ]TIME[ 01:04:20 ] *************** **/
    /** We want this code to be written in a way that    **/
    /** it can be cut+paste easily into our GLSL         **/
    /** shaders with minimal changes.                    **/
    /** ************************************************ **/

    /** ************************************************ **/
    /** @VID_IID[ 0103 ]TIME[ 01:05:50 ]                 **/      
    /** Moved From[ PAINT5D.F._ ]TO[ P5D1OGL.F._ ]       **/
    /** ************************************************ **/

    /** ************************************************ **/
    /** Polyfills to allow P5D1OGL code to run both as   **/
    /** C99 code and as OPENGL GLSL code. ............   **/
    #include "./OPEN_GL_HAKCODE/P5D1OGL.POL._" /** ***** **/
    /** ************************************************ **/

    /** @VID_IID[ 0103 ]TIME[ 01:10:00 ] *************** **/
    /** GLSL shader code written using C99 with          **/
    /** a lot of macro magic to allow it to be BOTH      **/
    /** valid C99 and valid GLSL code.                   **/
    /** So once code is tested on CPU side unit tests,   **/
    /** we can paste it directly into an openGL          **/
    /** GLSL shader string.                              **/
    #include "./OPEN_GL_HAKCODE/P5D1OGL._"  /** ******** **/
    /** ************************************************ **/

//[======================:OPEN_GL_PAINT5D_painpix_CTO_glocpix]//
//[======================================:OPEN_GL_PAINT5D_Get]//
//:UNIT_TEST_SECTION:P5D1OGL:================================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define I08   int8_t /** GCC: <stdint.h> **/          //: 02 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 03 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 04 ://
#define I16  int16_t /** GCC: <stdint.h> **/          //: 05 ://
#define U16 uint16_t /** GCC: <stdint.h> **/          //: 06 ://
#define ERR  aac2020_p5d1ogl_Halt                     //: 07 ://
#define LOG  aac2020_p5d1ogl_Info_any                 //: 08 ://

    void
    aac2020_P5D1OGL_UnitTest( void )
    {

        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/

            extern void 
            AAC2020_PAINT5D_Backup_taudirt( U08** );;
            AAC2020_PAINT5D_Backup_taudirt( &(taudirt) );

            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

            AAC2020_TODOMAN_Vital(
                "[FIX:taudirt_backup_is_invalid_back_reference]"
            );;

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://
        LOG("[ABOUT_TO_CALL:aac2020_P5D1OGL_UTC_private]\n",0);

            /** utc: unit test code **/
            extern void aac2020_P5D1OGL_UTC_private( void );
                        aac2020_P5D1OGL_UTC_private( );

        LOG("[OUTSIDE_OF::::aac2020_P5D1OGL_UTC_private]\n",0);
        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
        LOG("[P5D1OGL:PAINT5D_SYSTEM_DATA_RESTORE:BEG]",0);

            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                extern void
                AAC2020_PAINT5D_Restore_taudirt( U08** );
                AAC2020_PAINT5D_Restore_taudirt( &(taudirt) );

                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://

        LOG("[P5D1OGL:PAINT5D_SYSTEM_DATA_RESTORE:END]",0);
        //:------------------------------:SYSTEM_DATA:RESTORE://
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_P5D1OGL_UTC_private( void )
    {
    #define E_V extern void
    #define   V        void

        /** ************************************************ **/
        /** Functions are tested in order:               * * **/
        /** Lowest Level --> to --> Highest Level        * * **/
        /** AKA: Most depended on to least depended on.  * * **/
        /** @VID_IID[ 0087 ]TIME[ 00:23:32 ] *************** **/
        /** ************************************************ **/

        /** ************************************************ **/
        /** @VID_IID[ 0091 ]TIME[ 00:49:58 ]                 **/
        /** Failure of "polyfill_texel_fetch" leads me       **/
        /** to believe that BitPack_Get might actually       **/
        /** be wrong. Lets do tests that are aware of        **/
        /** the internal bit layout used.                    **/

        E_V aac2020_P5D1OGL_UTC_PokeAndProd_BitPack_Get( V );
            aac2020_P5D1OGL_UTC_PokeAndProd_BitPack_Get(   );

        /** ************************************************ **/

        E_V aac2020_P5D1OGL_UTC_polyfill_texel_fetch( void );
            aac2020_P5D1OGL_UTC_polyfill_texel_fetch(      );

        /** TEST:       OPEN_GL_PAINT5D_BitPack_Get( )**/
        E_V aac2020_P5D1OGL_UTC_BitPack_Get(V);
            aac2020_P5D1OGL_UTC_BitPack_Get( );

        /** TEST:       OPEN_GL_PAINT5D_til_exp_CTO_max_cor()**/
        E_V aac2020_P5D1OGL_UTC_til_exp_CTO_max_cor(V);
            aac2020_P5D1OGL_UTC_til_exp_CTO_max_cor( );

        /** TEST:       OPEN_GL_PAINT5D_til_exp_CTO_diagpix()**/
        E_V aac2020_P5D1OGL_UTC_til_exp_CTO_diagpix(V);
            aac2020_P5D1OGL_UTC_til_exp_CTO_diagpix( );

        /** TEST:       OPEN_GL_PAINT5D_painpix_CTO_glocpix()**/
        E_V aac2020_P5D1OGL_UTC_painpix_CTO_glocpix(V);
            aac2020_P5D1OGL_UTC_painpix_CTO_glocpix( );
    
        /** @VID_IID[ 0086 ]TIME[ 01:06:55 ] *************** **/
        /** We only care that this test passes. So only      **/
        /** write enough test code for OTHER functions in    **/
        /** P5D1OGL._ as to figure out how to fix the        **/
        /** code and get this function working properly.     **/

        /** TEST:       OPEN_GL_PAINT5D_Get(......); ******* **/
        E_V aac2020_P5D1OGL_UTC_Get( void );
            aac2020_P5D1OGL_UTC_Get(      );

        /** ************************************************ **/

        /** @VID_IID[ 0097 ]TIME[ 06:11:05 ] **/
        /** Stubbing in test for "Bitpacked Sampler" **/
        printf("[BEF_ENTER:utc_..._cuvipix_CTO_cuvbits]\n");
        for( I32 corner_to_target =  1 ;
                 corner_to_target <= 4 ;
                 corner_to_target   ++ 
        ){
            E_V aac2020_P5D1OGL_UTC_cuvipix_CTO_cuvbits( I32 );
                aac2020_P5D1OGL_UTC_cuvipix_CTO_cuvbits( 
                
                    corner_to_target

                );;
        };;
        printf("[AFT_ENTER:utc_..._cuvipix_CTO_cuvbits]\n");
        
        /** ************************************************ **/
        /** Like previous function, but we start from the    **/
        /** 16 bit binary expected output values and work    **/
        /** backwards to extract the input data test columns **/
        /** as seen in previous function's                   **/
        /** [ tab_utc_inn ] array.                           **/
        /** @VID_IID[ 0100 ]TIME[ 02:49:23 ] ............... **/
        E_V aac2020_P5D1OGL_UTC_P5D_cuvipix_CTO_cuvbits_002(V);
            aac2020_P5D1OGL_UTC_P5D_cuvipix_CTO_cuvbits_002( );

    #undef  E_V
    #undef    V
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_P5D_cuvipix_CTO_cuvbits_002( void)
    {
    //:MACROS_2020_01_21_0820_PM:----------------------------://
    #define TAB_INN_WID ( 3 * 8  ) //: num columns      : 01 ://
    #define TAB_OUT_WID (   3    ) //: 3 output columns : 02 ://
    #define NUM_TESTS   ( 39 / 3 ) //: 3 U16's per test.: 03 ://
    #define CUVIPIX     struct AAC2020_OPEN_GL_PAINT5D_CUVIPIX
    #define L_1 MACRO___P5D_UTD_cuvipix_CTO_cuvbits_LIT_END__LEN
    #define L_2 MACRO___P5D_UTD_cuvipix_CTO_cuvbits_BIG_END__LEN
    #define BIG_END  aac2020_P5D_UTD_cuvipix_CTO_cuvbits_BIG_END
    #define LIT_END  aac2020_P5D_UTD_cuvipix_CTO_cuvbits_LIT_END
    #define BIN_011  ( 3 )                            //: 09 ://
    #define    B_00  ( 0 )                            //: 10 ://
    #define    B_01  ( 1 )                            //: 11 ://
    #define    B_10  ( 2 )                            //: 12 ://
    #define    B_11  ( 3 )                            //: 13 ://
    #define    AAI   aac2020_paint5d_BASSU16_AssertAndInspect
    //:MACROS_2020_01_21_0820_PM:----------------------------://

    LOG("[OH_BOY_THIS_WAS_A_CRAZY_IDEA_JAN_2021:BEG]\n",0);

        //:declare_variables:--------------------------------://

            I32 big_lit =( 0 ); //:BIG_END or LIT_END test data?

            U16  tab_utc_inn[ TAB_INN_WID * NUM_TESTS ]={0};
            U16* tab_utc_out =((U16*)0);  /** p5d_utd **/

            //:indexes:--------------------------------------://
            /** indexes into tab_utc_inn **/

                I32 i_1 ; //:INDEX #1: test  index
                I32 i_2 ; //:INDEX #2: Block Index
                I32 i_3 ; //:INDEX #3: 2 bit binary value index.

            /** indexes into[ p5d_utd / tab_utc_out ] **/
            /** (...cuvipix_CTO_cuvbits_BIG_END)      **/
            /** (...cuvipix_CTO_cuvbits_LIT_END)      **/

                I32 u16_dex;

            //:--------------------------------------:indexes://
            //:relative_offsets:-----------------------------://

                I32 o23 ; //:Offset between: [ 0 -to- 23 ]

            //:-----------------------------:relative_offsets://
            //:values_quantities_or_scalars:-----------------://

                U16 u16_var; //: 16 bits.
                U08 u08_var; //:  2 bits.

            //:-----------------:values_quantities_or_scalars://
            //:loop_variables:-------------------------------://

                I32 t_e ; //: tile exponent (til_exp / t_e )
                I32 lay ; //: tile layer    (til_lay / t_l )

            //:-------------------------------:loop_variables://

        //:--------------------------------:declare_variables://

        /** This code is LIKE                            ....**/
        /** [ ...utc_cuvipix_CTO_cuvbits ]       ....**/
        /** Except we use 16 bit hex codes to generate   ....**/
        /** the first table. For ease of coding use the  ....**/
        /** same variable names as the function we are   ....**/
        /** basing this off of.                          ....**/
        /** @VID_IID[ 0100 ]TIME[ 00:16:06 ]             ....**/

        /** Make sure both arrays of data are the same len.  **/
        /** @VID_IID[ 0100 ]TIME[ 00:44:55 ]                 **/
        /** IN_FILE[ R:\G\AAC2020\LIB\DAT\UTD\P5D_UTD._ ]    **/
        _Static_assert( 
            MACRO___P5D_UTD_cuvipix_CTO_cuvbits_LIT_END__LEN
        ==  MACRO___P5D_UTD_cuvipix_CTO_cuvbits_BIG_END__LEN
        ,  "[LENS_NOT_EQUAL_DATE_2021_01_21]" );;

        /** We see from the tables in P5D_UTD._ that we have **/
        /** enough data for 13 tests total.   .............. **/
        /** @VID_IID[ 0100 ]TIME[ 00:48:00 ]  .............. **/
        _Static_assert( 13 == NUM_TESTS , "[OHBOYS_2021:A]" );
        
        _Static_assert(  3*8*13 == 312  , "[OHBOYS_2021:B]");
        _Static_assert(  39/3   ==  13  , "[OHBOYS_2021:C]");
        _Static_assert(  40/3   ==  13  , "[OHBOYS_2021:D]");
        _Static_assert( TAB_INN_WID * NUM_TESTS  == 312 
        , "[WHAT_DOES_MARCELLUS_WALLUS_LOOK_LIKE_2021]" );;
        

        /** Are we testing big endian or little endian? **/
        for( big_lit = 1 ; big_lit <= 2 ; big_lit ++ ){

           if( 1 == big_lit ){ tab_utc_out = BIG_END; }else
           if( 2 == big_lit ){ tab_utc_out = LIT_END; }else
           { ERR("[BAD_BIG_LIT_YEAR_2021]"); };;;;;;;;;

            //:populate_test_data_table:---------------------://
            for( i_1 = 0 ; i_1 <= (NUM_TESTS-1) ; i_1 ++ ){
                 i_2 =(    i_1 *  TAB_INN_WID ); /**BlockDex**/

                if( 0 != ( i_2 % 24 ) ){
                    /** @VID_IID[ 0102 ]TIME[ 01:16:50 ] ....**/
                    /** Each block of data for each test     **/
                    /** case INPUT is a block of 24 values.  **/
                    /** 3 columns for 3 layers, each column  **/
                    /** being 8 values HIGH because we have  **/
                    /** tile exponents 0 to 7                **/
                    ERR("[BLOCK_BASE_ADDR_NOT_MULTIPLE_OF_24]");
                };;

                //:Scanline order through             ://
                //:@_ONE_OF_THESE_BLOCKS_2021_01_21_@ ://
                for( t_e = 0 ; t_e <= (8-1) ; t_e ++ ){
                for( lay = 0 ; lay <= (3-1) ; lay ++ ){

                    /** Get Datum Index. 2bit binary index ..**/
                    /** @VID_IID[ 0102 ]TIME[ 01:20:30 ]     **/
                    /** Added[ o23 ]Offset Variable + Assert **/

                        o23 = ( (t_e*3) + lay );
                        i_3 = ( i_2 + o23 );
                        assert( o23 >= 0 && o23 <= 23 );

                    /** Get index of hextet in P5D_UTD._ file**/
                    /** @VID_IID[ 0100 ]TIME[ 01:08:10 ]     **/
                    /** It is on the LEFT SCREEN NOW.        **/

                        u16_dex=(( i_1 *  3 ) + lay );
                
                    /** ************************************ **/
                    /** Extract correct 2 bit value          **/
                    /** p5d_utd == tab_utc_out               **/
                    /** @VID_IID[ 0102 ]TIME[ 01:26:00 ]     **/
                    /** Fixing Bug;                          **/
                    /** WRONG  : ( u16_var >> t_e    )       **/
                    /** CORRECT: ( u16_var >>(t_e*2) )       **/
                    /** ************************************ **/

                        assert( u16_dex <=( 39-1) );
                        u16_var=(  tab_utc_out[ u16_dex ] );

                        //: te_te_te_te_te_te_te_te <-- t_e  ://
                        //: 07 06 05 04 03 02 01 00 .........://
                        //: 00 00 00 00 00 00 00 00 .........://
                        u08_var=( 
                            ( u16_var >>(t_e*2) ) & BIN_011
                        );;
                        assert( u08_var <= 3 );

                    /** Put 2 bit value into test data array **/
                    /** ------------------------------------ **/
                    /** @VID_IID[ 0102 ]TIME[ 01:35:50 ].....**/
                    /** I see I got lazy with the TYPES of   **/
                    /** these different tables. Or at least a**/
                    /** bit too inconsistant for my liking.  **/
    
                        assert(i_3 <=(TAB_INN_WID*NUM_TESTS)-1);
                        tab_utc_inn[ i_3 ]=( u08_var );

                        //:sanity_checks:--------------------://
                        /** Original Sanity Check.           **/
                        /** @VID_IID[ 0100 ]TIME[ 02:32:00 ] **/
                        /** Sanity check was wrong.          **/
                        /** @VID_IID[ 0102 ]TIME[ 00:31:32 ] **/
    
                        I08 f=(    0 ); /** failed? **/
                        U16 U=( 0x00 ); /** Uint16 to inspect**/

                        if( 1 == big_lit ){ //:BIG_END

                            if( 0 == lay && 0 == i_1 ){
                                U=( 0x6161);
                                if( 0x6161 != u16_var ){f=1;};
                            };;
                            if( 1 == lay && 1 == i_1 ){
                                U=( 0x656e);
                                if( 0x656e != u16_var ){f=1;};
                            };;
                            if( 2 == lay && 2 == i_1 ){
                                U=( 0x6f70);
                                if( 0x6f70 != u16_var ){f=1;};
                            };;
                        }else
                        if( 2 == big_lit ){ //:LIT_END
                            if( 0 == lay && 0 == i_1 ){
                                U=( 0x6161);
                                if( 0x6161 != u16_var ){f=1;};
                            };;
                            if( 1 == lay && 1 == i_1 ){
                                U=( 0x6e65);
                                if( 0x6e65 != u16_var ){f=1;};
                            };;
                            if( 2 == lay && 2 == i_1 ){
                                U=( 0x706f);
                                if( 0x706f != u16_var ){f=1;};
                            };;
                        };;

                        if( 0 != f ){   
                        #define P printf

                            P("\n\n");
                            P("[big_lit]:%d\n"    , big_lit);
                            P("[....t_e]:%d\n"    ,     t_e);     
                            P("[....lay]:%d\n"    ,     lay);     
                            P("[u16_var]:0x%04x\n", u16_var);

                            AAI( U , u16_var,"[AAI_2021_AAI]" );
            
                            /** Should never reach here now. **/
                            ERR("[SANITY_CHECK_FAILED]"   );

                        //: #error FIX_LOOKUP_LOGIC

                        #undef  P
                        };;
                        //:--------------------:sanity_checks://

                };;};;

            };;
            //:---------------------:populate_test_data_table://
            //:SANITY_CHECK:---------------------------------://
            /** ******************************************** **/
            /** Hard code the expected inputs for the first  **/
            /** test block of both big endian and little     **/
            /** to confirm we unpacked the data correctly.   **/
            /** @VID_IID[ 0100 ]TIME[ 01:39:42 ] ........... **/
            /** ******************************************** **/

            assert( BIG_END[ 0 ] == 0x6161 ); //:<-- l_00
            assert( BIG_END[ 1 ] == 0x6332 ); //:<-- l_01
            assert( BIG_END[ 2 ] == 0x3032 ); //:<-- l_02
            U32 tab_utc_inn_BIG[ 3 * 8 ]={
                    B_01,B_10,B_10  //:<--- tile exponent #0 
                ,   B_00,B_00,B_00  //:<--- tile exponent #1 
                ,   B_10,B_11,B_11  //:<--- tile exponent #2 
                ,   B_01,B_00,B_00  //:<--- tile exponent #3 
                ,   B_01,B_11,B_00  //:<--- tile exponent #4
                ,   B_00,B_00,B_00  //:<--- tile exponent #5 
                ,   B_10,B_10,B_11  //:<--- tile exponent #6 
                ,   B_01,B_01,B_00  //:<--- tile exponent #7
            };;

            assert( LIT_END[ 0 ] == 0x6161 ); //:<-- l_00
            assert( LIT_END[ 1 ] == 0x3263 ); //:<-- l_01
            assert( LIT_END[ 2 ] == 0x3230 ); //:<-- l_02
            U32 tab_utc_inn_LIT[ 3 * 8 ]={
                    B_01,B_11,B_00  //:<--- tile exponent #0 
                ,   B_00,B_00,B_00  //:<--- tile exponent #1 
                ,   B_10,B_10,B_11  //:<--- tile exponent #2 
                ,   B_01,B_01,B_00  //:<--- tile exponent #3 
                ,   B_01,B_10,B_10  //:<--- tile exponent #4
                ,   B_00,B_00,B_00  //:<--- tile exponent #5 
                ,   B_10,B_11,B_11  //:<--- tile exponent #6 
                ,   B_01,B_00,B_00  //:<--- tile exponent #7
            };;

            /** @VID_IID[ 0100 ]TIME[ 02:17:23 ] ............**/
            /** Loop through the first generated block of  ..**/
            /** test input values to make sure we are      ..**/
            /** generating them correctly.                 ..**/
            for( I32 d_c = 0 ; d_c <=((3*8)-1) ; d_c++ ){

                /**  d_c == dex_chk == index check **/

                if( 1 == big_lit ){ //:BIG_END
                    if( tab_utc_inn_BIG[ d_c /** dex_chk **/ ]
                    !=  tab_utc_inn[     d_c /** dex_chk **/ ]
                    ){
                        printf("\n\n\n");
                        U16 big = tab_utc_inn_BIG[ d_c ];
                        U16 inn = tab_utc_inn[     d_c ];
                        printf("[d_c]:%d\n"      , d_c );
                        printf("[big]:%d\n"      , big );
                        printf("[inn]:%d\n"      , inn );

                        printf("[EXTRACT_TABLE_WRONG:BIG_END]");
                        AAI( big , inn , "[AAI_BIG_INN_2021]");
                    };;

                }else
                if( 2 == big_lit ){ //:LIT_END
                    if( tab_utc_inn_LIT[ d_c /** dex_chk **/ ]
                    !=  tab_utc_inn[     d_c /** dex_chk **/ ]
                    ){
                        printf("\n\n\n");
                        U16 lit = tab_utc_inn_LIT[ d_c ];
                        U16 inn = tab_utc_inn[     d_c ];
                        printf("[d_c]:%d\n"      , d_c );
                        printf("[lit]:%d\n"      , lit );
                        printf("[inn]:%d\n"      , inn );

                        printf("[EXTRACT_TABLE_WRONG:LIT_END]");
                        AAI( lit , inn , "[AAI_LIT_INN_2021]");
                    };;
                }else{
                    ERR("[BAD_BIG_LIT_VALUE_2021]");
                };;
            };;//:NEXT[ d_c ]AKA[ dex_chk ]://

            //:---------------------------------:SANITY_CHECK://

            /** ******************************************** **/
            /** @VID_IID[ 0103 ]TIME[ 01:54:00 ]         *** **/
            /** Logic was getting really hard to follow  *** **/
            /** So we put it all in an include here.     *** **/
            /**                                          *** **/
            /** When you know WHAT you want to do but    *** **/
            /** are unable to do it because you cannot   *** **/
            /** find your way around the code, it is     *** **/
            /** time to break stuff down into smaller    *** **/
            /** chunks.                                  *** **/
                                                             ///
                //[ ACTUAL_TEST_RUNNER_CODE ]//              ///
                #include "./PAINT5D/HAK_001._"               ///
                                                             ///
            /** ******************************************** **/

        };; //: NEXT[ big_lit ]

    LOG("[OH_BOY_THIS_WAS_A_CRAZY_IDEA_JAN_2021:END]\n",0);

    //:----------------------------:MACROS_2020_01_21_0820_PM://
    #undef TAB_INN_WID  //:-----------------------------: 01 ://
    #undef TAB_OUT_WID  //:-----------------------------: 02 ://
    #undef NUM_TESTS    //:-----------------------------: 03 ://
    #undef CUVIPIX      //:-----------------------------: 04 ://
    #undef L_1          //:-----------------------------: 05 ://
    #undef L_2          //:-----------------------------: 06 ://
    #undef BIG_END      //:-----------------------------: 07 ://
    #undef LIT_END      //:-----------------------------: 08 ://
    #undef BIN_011      //:-----------------------------: 09 ://
    #undef    B_00      //:-----------------------------: 10 ://
    #undef    B_01      //:-----------------------------: 11 ://
    #undef    B_10      //:-----------------------------: 12 ://
    #undef    B_11      //:-----------------------------: 13 ://
    #undef     AAI      //:-----------------------------: 14 ://
    //:----------------------------:MACROS_2020_01_21_0820_PM://
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_cuvipix_CTO_cuvbits( 
        I32 corner_to_target
        //: 1 ==> TOP_LEF  @VID_IID[ 0103 ]TIME[ 02:35:42 ]  ://
        //: 2 ==> TOP_RIG  We think targeting different      ://
        //: 3 ==> BOT_LEF  extreme corners to set the data   ://
        //: 4 ==> BOT_RIG  will give use more thural tests   ://
    )
    {
    #define TAB_INN_WID ( 3 * 8 ) /** num columns **/
    #define TAB_OUT_WID (   3   ) /** 3 output columns **/
    #define NUM_TESTS   (   8   ) /** Number Of Tests  **/
    #define CUVIPIX     struct AAC2020_OPEN_GL_PAINT5D_CUVIPIX

        if( corner_to_target ){ /** NOOP **/ };

        //:DEFINE_OR_UNDEF_BINARY_CONSTANTS:-----------------://
        //| #_P5D_UNIT_TEST_COMMENT_2021_01_20_655PM_#       |//

            #define B_00 ( 0 )
            #define B_01 ( 1 )
            #define B_10 ( 2 )
            #define B_11 ( 3 )

            #define B____00_00_00_00____00_00_00_00_____B 0x0000
            #define B____01_01_01_01____01_01_01_01_____B 0x5555
            #define B____00_00_00_00____00_00_00_11_____B (  3 )
            #define B____11_00_11_00____11_00_11_00_____B 0xCCCC
            #define B____11_00_11_00____11_00_11_01_____B 0xCCCD
            #define B____11_11_11_11____11_11_11_11_____B 0xFFFF
            #define B____11_11_11_11____00_00_00_00_____B 0xFF00
            #define B____00_00_00_00____11_11_11_11_____B 0x00FF
            #define B____00_00_11_11____11_11_00_00_____B 0x0FF0

            #define B____00_11_10_00____01_00_11_10_____B 0x384E
            #define B____11_00_00_10____11_01_10_00_____B 0xC2D8
            #define B____00_01_10_11____10_00_11_00_____B 0x1B8C

        //:-----------------:DEFINE_OR_UNDEF_BINARY_CONSTANTS://

        //| #_USUALLY_ONE_TEST_TABLE_DATE_2021_01_20_# ......|//
        U32 tab_utc_inn[ TAB_INN_WID * NUM_TESTS ]={

        //:INPUTS_FOR_TEST[ 01 ]:
            //: All 3 layers
            //: 3 two bit colors because there are 3 layers
            //: for any tile you can set down.
            //: 8 rows because there are 8 tile sizes
            //: (til_exp 0 to 7 )
                B_00,B_00,B_00  //:<--- tile exponent #0 
            ,   B_00,B_00,B_00  //:<--- tile exponent #1 
            ,   B_00,B_00,B_00  //:<--- tile exponent #2 
            ,   B_00,B_00,B_00  //:<--- tile exponent #3 
            ,   B_00,B_00,B_00  //:<--- tile exponent #4
            ,   B_00,B_00,B_00  //:<--- tile exponent #5 
            ,   B_00,B_00,B_00  //:<--- tile exponent #6 
            ,   B_00,B_00,B_00  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //:INPUTS_FOR_TEST[ 02 ]:
        //:@_ONE_OF_THESE_BLOCKS_2021_01_21_@
            ,   B_01,B_01,B_01  //:<--- tile exponent #0 
            ,   B_01,B_01,B_01  //:<--- tile exponent #1 
            ,   B_01,B_01,B_01  //:<--- tile exponent #2 
            ,   B_01,B_01,B_01  //:<--- tile exponent #3 
            ,   B_01,B_01,B_01  //:<--- tile exponent #4
            ,   B_01,B_01,B_01  //:<--- tile exponent #5 
            ,   B_01,B_01,B_01  //:<--- tile exponent #6 
            ,   B_01,B_01,B_01  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //:INPUTS_FOR_TEST[ 03 ]:
            ,   B_00,B_00,B_00  //:<--- tile exponent #0 
            ,   B_11,B_11,B_11  //:<--- tile exponent #1 
            ,   B_00,B_00,B_00  //:<--- tile exponent #2 
            ,   B_11,B_11,B_11  //:<--- tile exponent #3 
            ,   B_00,B_00,B_00  //:<--- tile exponent #4
            ,   B_11,B_11,B_11  //:<--- tile exponent #5 
            ,   B_00,B_00,B_00  //:<--- tile exponent #6 
            ,   B_11,B_11,B_11  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //:INPUTS_FOR_TEST[ 04 ]:
            ,   B_11,B_11,B_11  //:<--- tile exponent #0 
            ,   B_11,B_11,B_11  //:<--- tile exponent #1 
            ,   B_11,B_11,B_11  //:<--- tile exponent #2 
            ,   B_11,B_11,B_11  //:<--- tile exponent #3 
            ,   B_11,B_11,B_11  //:<--- tile exponent #4
            ,   B_11,B_11,B_11  //:<--- tile exponent #5 
            ,   B_11,B_11,B_11  //:<--- tile exponent #6 
            ,   B_11,B_11,B_11  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //| #_TEST_5_IS_TRANSPOSITION_PRECURSOR_# |//
        //:INPUTS_FOR_TEST[ 05 ]:
            ,   B_11,B_00,B_11  //:<--- tile exponent #0 
            ,   B_11,B_00,B_11  //:<--- tile exponent #1 
            ,   B_11,B_00,B_11  //:<--- tile exponent #2 
            ,   B_11,B_00,B_11  //:<--- tile exponent #3 
            ,   B_11,B_00,B_11  //:<--- tile exponent #4
            ,   B_11,B_00,B_11  //:<--- tile exponent #5 
            ,   B_11,B_00,B_11  //:<--- tile exponent #6 
            ,   B_11,B_00,B_11  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        /** Check For Transposition errors related to        **/   
        /** current column layer. @VID_IID[ 0099]T[04:31:42] **/
        //:INPUTS_FOR_TEST[ 06 ]:
            ,   B_11,B_00,B_00  //:<--- tile exponent #0 
            ,   B_11,B_00,B_00  //:<--- tile exponent #1 
            ,   B_11,B_00,B_00  //:<--- tile exponent #2 
            ,   B_11,B_00,B_00  //:<--- tile exponent #3 
            ,   B_11,B_00,B_00  //:<--- tile exponent #4
            ,   B_11,B_00,B_00  //:<--- tile exponent #5 
            ,   B_11,B_00,B_00  //:<--- tile exponent #6 
            ,   B_11,B_00,B_00  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //:INPUTS_FOR_TEST[ 07 ]:
            ,   B_11,B_00,B_00  //:<--- tile exponent #0 
            ,   B_11,B_00,B_00  //:<--- tile exponent #1 
            ,   B_11,B_11,B_00  //:<--- tile exponent #2 
            ,   B_11,B_11,B_00  //:<--- tile exponent #3 
            ,   B_00,B_11,B_11  //:<--- tile exponent #4
            ,   B_00,B_11,B_11  //:<--- tile exponent #5 
            ,   B_00,B_00,B_11  //:<--- tile exponent #6 
            ,   B_00,B_00,B_11  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.

        //:INPUTS_FOR_TEST[ 08 ]:
            ,   B_10,B_00,B_00  //:<--- tile exponent #0 
            ,   B_11,B_10,B_11  //:<--- tile exponent #1 
            ,   B_00,B_01,B_00  //:<--- tile exponent #2 
            ,   B_01,B_11,B_10  //:<--- tile exponent #3 
            ,   B_00,B_10,B_11  //:<--- tile exponent #4
            ,   B_10,B_00,B_10  //:<--- tile exponent #5 
            ,   B_11,B_00,B_01  //:<--- tile exponent #6 
            ,   B_00,B_11,B_00  //:<--- tile exponent #7
            //: |   |    |   |
            //: l_00,l_01,l_02 <-- 3 layers.
        };;

        U32 tab_utc_out[ TAB_OUT_WID * NUM_TESTS ]={

            //:1st : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
            B____00_00_00_00____00_00_00_00_____B  //:<-- l_00  
        ,   B____00_00_00_00____00_00_00_00_____B  //:<-- l_01 
        ,   B____00_00_00_00____00_00_00_00_____B  //:<-- l_02 

            //:2nd : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
        ,   B____01_01_01_01____01_01_01_01_____B  //:<-- l_00  
        ,   B____01_01_01_01____01_01_01_01_____B  //:<-- l_01 
        ,   B____01_01_01_01____01_01_01_01_____B  //:<-- l_02 

            //:3rd : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
        ,   B____11_00_11_00____11_00_11_00_____B  //:<-- l_00
        ,   B____11_00_11_00____11_00_11_00_____B  //:<-- l_01
        ,   B____11_00_11_00____11_00_11_00_____B  //:<-- l_02

            //:4th : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_00
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_01
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_02

            //:5th : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_00
        ,   B____00_00_00_00____00_00_00_00_____B  //:<-- l_01 
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_02

            //:6th : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@
        ,   B____11_11_11_11____11_11_11_11_____B  //:<-- l_00
        ,   B____00_00_00_00____00_00_00_00_____B  //:<-- l_01 
        ,   B____00_00_00_00____00_00_00_00_____B  //:<-- l_02

            //:7th : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@  
        ,   B____00_00_00_00____11_11_11_11_____B  //:<-- l_00
        ,   B____00_00_11_11____11_11_00_00_____B  //:<-- l_01 
        ,   B____11_11_11_11____00_00_00_00_____B  //:<-- l_02


            //:8th : test_expected_output
            //: @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@  
        ,   B____00_11_10_00____01_00_11_10_____B
        ,   B____11_00_00_10____11_01_10_00_____B
        ,   B____00_01_10_11____10_00_11_00_____B

            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
            //# WE NEED TESTS TO MAKE SURE THAT  #//
            //# THE CLUSTERS ARE ACCESSED IN THE #//
            //# CORRECT ORDER                    #//
            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

        };;


        //:Double_Check_Some_Binary_Consts:------------------://
        /** ************************************************ ***
        @VID_IID[ 0099 ]TIME[ 04:53:32 ]
        *** ************************************************ **/

            assert(
                B____00_11_10_00____01_00_11_10_____B
                ==( 0x00  
                    | (B_00)<<(7*2)
                    | (B_11)<<(6*2)
                    | (B_10)<<(5*2)
                    | (B_00)<<(4*2)

                    | (B_01)<<(3*2)
                    | (B_00)<<(2*2)
                    | (B_11)<<(1*2)
                    | (B_10)<<(0*2)
                )
            );;

            assert(
                B____11_00_00_10____11_01_10_00_____B
                ==( 0x00  
                    | (B_11)<<(7*2)
                    | (B_00)<<(6*2)
                    | (B_00)<<(5*2)
                    | (B_10)<<(4*2)
                          
                    | (B_11)<<(3*2)
                    | (B_01)<<(2*2)
                    | (B_10)<<(1*2)
                    | (B_00)<<(0*2)
                )
            );;

            assert(
                B____00_01_10_11____10_00_11_00_____B
                ==( 0x00  
                    | (B_00)<<(7*2)
                    | (B_01)<<(6*2)
                    | (B_10)<<(5*2)
                    | (B_11)<<(4*2)
                         
                    | (B_10)<<(3*2)
                    | (B_00)<<(2*2)
                    | (B_11)<<(1*2)
                    | (B_00)<<(0*2)
                )
            );;
        //:------------------:Double_Check_Some_Binary_Consts://
        //:DECLARE_ALL_VARS_EXCEPT_TABLES:-------------------://

            /** [ITERATOR/LOOP] VARS **/

            I32 t_i     ; //: tes_dex / test index           ://
            I32 mti     ; //: Max___Test___Index             ://
            I32 dex     ; //: Current Index Of Whatever.     ://
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
            I32 t_e     ; //: til_exp / tile_exponent        ://
            I32 lay     ; //: til_lay / tile_layer(enum/dex) ://
            I32 t_q     ; //: til_qua / tile_quadrant        ://
            I32 a_d     ; //: aus_dex / Auset_inDex          ://

            /** Tile Coords. Always [ 0,0 ] for now. ........**/

            I32 t_x     ; //: loc_t_x : local_tile_x  .......://
            I32 t_y     ; //: loc_t_y : local_tile_y  .......://

            /** Test array unpacking calculation vars. ......**/

            I32 bas_tes ; /** BASe_address: TESt #           **/
            I32 bas_tv3 ; /** BASe_address: tile_vals(three) **/
            I32 dexodat ; /** inDEX_Of_DATa( data point )    **/
            U08 put_t_v ; /** PUT_tile_value,TileValueToPut  **/

            /** Canvas_User_View_Pixel (Pixel Location) .....**/

            CUVIPIX cuvipix;

            /** Expected and [ gotten / actual ] outputs. ...**/
            /** cuvbits: Canvas_User_View___BITS ............**/
            /**                                              **/
            /** @VID_IID[ 0098 ]TIME[ 04:05:10 ]             **/
            /** cal_cuvbits: EXPLAINED. .....................**/

            U32 exp_cuvbits   ; /** Expected: cuvbits .......**/
            U32 cal_cuvbits[3]; /** exp_cuvbits:CALCULATED...**/
            U32 got_cuvbits   ; /** Gotten  : cuvbits .......**/

            /** @VID_IID[ 0099 ]TIME[ 02:59:30 ]             **/
            /** Calculate all expected clusters of 16 bits   **/
            /** ahead of time from the test data array.      **/
            U32* arr_cuvbits_003=((U32*)0);
            U32  cur_cuvbits_003=( 0x00  );
            I32  m_i_cuvbits_003=(( TAB_OUT_WID*NUM_TESTS)-1);

        //:-------------------:DECLARE_ALL_VARS_EXCEPT_TABLES://
        //:generated_table_of_expected_outputs:--------------://
        //:calculated_expected_outputs:----------------------://
        /** ************************************************ ***
        @VID_IID[ 0099 ]TIME[ 03:02:02 ]
        Expected output values for every single test. But
        instead of hard coded in the[ tab_utc_out ]table they
        are derived from the input test data table
        [ tab_utc_inn ]
        *** ************************************************ **/

            /** ******************************************** **/
            /** arr_cuvbits_003 ==                  ******** **/
            /** generated_table_of_expected_outputs ******** **/
            /** ******************************************** **/

            /** @VID_IID[ 0103 ]TIME[ 01:43:05 ]    **/
            /** 2nd memory stomp from calloc fixed. **/
            assert( sizeof( U32 )              == 4   );
            assert( sizeof( arr_cuvbits_003[0] == 4 ) );
            arr_cuvbits_003=calloc( 
                (TAB_OUT_WID*NUM_TESTS ) //:NUMBER_OF_ELEMENTS
            ,   sizeof( U32 )            //:SIZE_OF_ONE_ELEMENT
            );;

            mti=( NUM_TESTS - 1 );

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){
            for( lay = 0 ; lay <=(3-1); lay ++ ){

                cur_cuvbits_003=( 0x00 );

                /** Tile Eponent Loop. **/
                for( t_e = 0 ; t_e <=(8-1) ; t_e ++ ){

                    cur_cuvbits_003=(
                    cur_cuvbits_003
                        | //:<-- Smash Together With Or ( | )::/
                        (
                            tab_utc_inn[
                                0
                                /** Base_Index_For_Block **/
                                +  ( t_i * TAB_INN_WID )

                                /** ************************ ***
                                @VID_IID[ 0099 ]T[ 03:49:42]
                                Initial Offset For Layer  
                                Column in the data.       
                                *** ************************ **/
                                +  ( lay * 1 )

                                /** Point to next value in ****/
                                /** current column.        ****/
                                +  ( t_e * 3 )
                            ]
                            <<( t_e * 2 )
                        )
                    );;

                };;//:NEXT[ t_e / til_exp ](TileSizeExponent)://

                dex =(  ( t_i * TAB_OUT_WID ) + lay );
                assert( dex >=0 && dex <= m_i_cuvbits_003 );
                arr_cuvbits_003[ dex ]=(  cur_cuvbits_003 );
                
            };;};;

        //:----------------------:calculated_expected_outputs://
        //:--------------:generated_table_of_expected_outputs://

        //:Cross_Check_Expected_Outputs:---------------------://
        /** ************************************************ ***
        @VID_IID[ 0099 ]TIME[ 03:27:30 ]
        Cross check hard coded expected outputs ( tab_utc_out )
        against the generated table of expected outputs
        ( arr_cuvbits_003 )
        *** ************************************************ **/
        #define DEX_MAX (( TAB_OUT_WID * NUM_TESTS ) - 1 )  
        #define BPRINTF aac2020_paint5d_BinaryPrintf
        LOG("[BEG:Cross_Check_Expected_Outputs:BEG]\n",0);

            mti=( NUM_TESTS - 1 );
            for(    t_i = 0  ;  t_i <= mti ; t_i ++ ){
            assert( t_i >= 0 && t_i <= (NUM_TESTS - 1 ) );

                bas_tes = ( t_i * TAB_OUT_WID );
                
                for(    lay = 0 ;  lay <= (3-1) ; lay++ ){
                assert( lay >=0 && lay <= 2 );
                    
                    dex = ( bas_tes + lay );
                    assert( dex <= DEX_MAX );

                    if(     tab_utc_out[ dex ]
                    !=  arr_cuvbits_003[ dex ]
                    ){
                        U32 h_c=(     tab_utc_out[ dex ] );
                        U32 gen=( arr_cuvbits_003[ dex ] );

                        printf("\n\n");

                        printf("[test__index:t_i]:%d\n", t_i );
                        printf("[layer_index:lay]:%d\n", lay );
                        printf("[data__index:dex]:%d\n", dex );

                        printf("\n\n");

                        /** @VID_IID[099]TIME[03:37:00 ]     **/
                        /** Inspect the bits of non-matching **/
                        /** values.                          **/
                        BPRINTF("[hard_coded:h_c]",    h_c);
                        BPRINTF("[_generated:gen]",    gen);

                        printf("\n\n");

                        /** @VID_IID[ 0099 ]TIME[03:23:42 ]  **/
                        ERR("[BAD_GENERATED_EXPECTED_VALUES]");

                        
                    };;

                };;
            };;
    
        LOG("[END:Cross_Check_Expected_Outputs:END]\n",0);
        #undef  DEX_MAX
        #undef  BPRINTF
        //:---------------------:Cross_Check_Expected_Outputs://

        //:SIMPLE_PUT_GET_TEST:------------------------------://
        /** Loop through all tests, but only use     **/
        /** auset zero. Immediately check values     **/
        /** after setting.                           **/
        mti=( NUM_TESTS - 1 );

        //:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://
        for( t_i = 0 ; t_i <= mti ; t_i ++ ){
        //:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://

        /** @VID_IID[ 0098 ]TIME[ 04:26:42 ] **/
        cal_cuvbits[ 0 ]=( 0x00 ); //:layer #0 (l_00)
        cal_cuvbits[ 1 ]=( 0x00 ); //:layer #1 (l_01)
        cal_cuvbits[ 2 ]=( 0x00 ); //:layer #2 (l_02)

        for( lay = 0 ; lay <=(3-1); lay ++ ){
        for( t_e = 0 ; t_e <=(8-1); t_e ++ ){

            bas_tes = ( t_i * TAB_INN_WID     );
            bas_tv3 = ( bas_tes + ( t_e * 3 ) ); //:3tilevalues
            dexodat = ( bas_tv3 + lay ); //:inDEX_Of_DATum
            assert( dexodat <= ((TAB_INN_WID * NUM_TESTS)-1) );
            put_t_v = tab_utc_inn[ dexodat ];
            assert( put_t_v <= 3 /**BIN_011**/ );
            
            //:calculate:cal_cuvbits:------------------------://

                assert( lay >= 0 && lay <= (3-1) );

                cal_cuvbits[ lay ] =(
                cal_cuvbits[ lay ]
                   |
                (
                    put_t_v <<( t_e * 2 )
                ));;

            //:------------------------:calculate:cal_cuvbits://
            
            for( t_q = 0 ; t_q <=( 4-1) ; t_q ++ ){
            for( a_d = 0 ; a_d <=(16-1) ; a_d ++ ){

                /** **************************************** **/
                /** @VID_IID[ 0097 ]TIME[ 07:36:50 ]         **/
                /** [0,0] is the ONLY local coordinate that  **/
                /** is valid for ALL possible values of      **/
                /** [ til_exp / t_e ]( Tile(size)Exponent )  **/
                t_x =( 0 ); /** t_x === loc_t_x              **/
                t_y =( 0 ); /** t_y === loc_t_y              **/
                /** **************************************** **/

                AAC2020_PAINT5D_Put(
                /**/(U08)    t_q     //: U08  til_qua / t_q  ://
                ,   (U08)    t_e     //: U08  til_exp / t_e  ://
                ,   (U08)    lay     //: U08  til_lay / t_l  ://
                ,   (U08)    t_x     //: U08  loc_t_x / t_x  ://
                ,   (U08)    t_y     //: U08  loc_t_y / t_y  ://
                ,   (U08)    a_d     //: U08  aus_dex / a_d  ://
                ,   (U08)    put_t_v //: U08  til_val / t_v  ://
                );;

            };;};;//:NEXT[ t_q , a_d       ]
        };;};;    //:NEXT[ t_e , lay       ]

        /** Loop through again. Using a triple loop instead  **/
        /** of quadruple loop and check your outputs against **/
        /** expected values. @VID_IID[ 0098 ]TIME[ 04:38:02 ]**/
        /**                                                  **/
        /** @VID_IID[ 0098 ]TIME{ 04:45:10 ]....             **/
        /** UPDATE... make it another quadruple loop.        **/
        /** and include the tile exponent (t_e)              **/

        for( lay = 0 ; lay <=( 3-1) ; lay ++ ){
        for( t_e = 0 ; t_e <=( 8-1) ; t_e ++ ){
        for( t_q = 0 ; t_q <=( 4-1) ; t_q ++ ){
        for( a_d = 0 ; a_d <=(16-1) ; a_d ++ ){

                /** **************************************** **/
                /** @VID_IID[ 0099 ]TIME[ 04:16:30 ]         **/
                /** This assignment was in wrong location.   **/
                //:Get expected output:                      ///
                exp_cuvbits =(                               ///
                    tab_utc_out[ (t_i * TAB_OUT_WID) + lay ] ///
                );;                                          ///
                /** **************************************** **/

                /** @VID_IID[ 0098 ]TIME[ 04:44:00 ] ........**/
                /** As long as all test code in this      ...**/
                /** function uses a [t_x,t_y]==[0,0]      ...**/
                /** the tile exponent (t_e) value should  ...**/
                /** NOT affect the results of the tests.  ...**/
                t_x=( 0 );
                t_y=( 0 );

                /** @VID_IID[0098]TIME[ 04:49:40 ] ......... **/
                /** #_WHY_t_e_DOESNT_CHANGE_TEST_OUTPUTS_#.. **/
                cuvipix=(
                OPEN_GL_PAINT5D_painpix_CTO_cuvipix(
                /**/(I32)    t_q     //: [ til_qua | t_q ]   ://
                ,   (I32)    t_e     //: [ til_exp | t_e ]   ://
                ,   (I32)    lay     //: [ til_lay | t_l ]   ://
                ,   (I32)    t_x     //: [ loc_t_x | t_x ]   ://
                ,   (I32)    t_y     //: [ loc_t_y | t_y ]   ://
                ));;

                got_cuvbits=(
                OPEN_GL_PAINT5D_cuvipix_CTO_cuvbits(
                /**/cuvipix.cuv_i_x  //: I32 cuv_i_x_000_255 ://
                ,   cuvipix.cuv_i_y  //: I32 cuv_i_y_000_255 ://
                ,   (I32)lay         //: I32 lay_dex_000_002 ://
                ,   (I32)a_d         //: I32 aus_dex_000_015 ://
                ));;

                /** @VID_IID[ 0099 ]TIME[ 04:03:30 ] ........**/
                /** Re-calculate index accessor for  ........**/
                /** arr_cuvbits_003                  ........**/
                dex=(
                    0
                    +  ( t_i * TAB_OUT_WID )
                    +  ( lay )
                );;

                if( 0
                /** @VID_IID[ 0098 ]TIME[ 04:13:30 ] **/
                /** Compare exp_cuvbits against both **/
                /** of these things................. **/
                || (got_cuvbits          != exp_cuvbits) 
                || (cal_cuvbits[lay]     != exp_cuvbits)
                || (arr_cuvbits_003[dex] != exp_cuvbits)
                ){

                    /** ************************************ **/
                    /** @VID_IID[ 0099 ]TIME[ 03:58:50 ] ....**/
                    /** If you get this error message,   ....**/
                    /** the mistake is in your test      ....**/
                    /** runner code, and possibly NOT    ....**/
                    /** the function being tested.       ....**/
                    /** Fix your test runner code first. ....**/
                    /** ************************************ **/
                    if( arr_cuvbits_003[dex] //:All_Generated
                    !=      cal_cuvbits[lay] //:3___Generated
                    ){
                    #define BPRINTF aac2020_paint5d_BinaryPrintf

                        printf("\n\n");

                        printf( "[dex]:%d\n", dex );
                        printf( "[lay]:%d\n", lay );

                        printf("\n\n");

                        BPRINTF("[gen]",arr_cuvbits_003[dex]);
                        BPRINTF("[3_X]",    cal_cuvbits[lay]);

                        printf("\n\n");

                        ERR("[CAL_CUVBITS_IS_WRONG]");

                    #undef  BPRINTF
                    };;

                    /** @VID_IID[ 0098 ]TIME[ 05:42:10 ] ... **/
                    /** TCM_BW: TEST_CODE_MIGHT_BE_WRONG     **/
                    /** Because the our calculated expected  **/
                    /** value does not match our hard coded  **/
                    /** expected value. .................... **/
                    if(cal_cuvbits[lay] != exp_cuvbits){
                        printf("\n\n");
                        printf("[************************]\n");
                        printf("[TCM_BW::::::::2021_01_19]\n");
                        printf("[TEST_CODE_PROBABLY_WRONG]\n");
                        printf("[************************]\n");
                        printf("\n\n");
                    };;
    
                    /** Clarify what "lay" is in terms of    **/
                    /** our expected output key.             **/
                    /** @_A_CLUSTER_OF_THREE__IN__P5D_TEST_@ **/
                    printf("[COMPARE_YOUR_BITS_YOU_FOOL!]\n");
                    printf("[EXPECTED_OUTPUT_CLUSTER_DEX]:%d\n"
                            ,lay );;

                    printf("\n");

                    printf("[t_i]:%d\n", t_i );
                    printf("[t_e]:%d\n", t_e );
                    printf("[lay]:%d\n", lay );

                    aac2020_paint5d_BinaryPrintf(
                    "[got_cuvbits]",got_cuvbits  );;

                    aac2020_paint5d_BinaryPrintf(
                    "[exp_cuvbits]",exp_cuvbits  );;

                    /** Generated Expecteds: 3 AT A TIME **/
                    aac2020_paint5d_BinaryPrintf(
                    "[cal_cuvbits[lay]]",cal_cuvbits[lay]  );;

                    /** Generated Expecteds: ALL AT ONCE **/
                    aac2020_paint5d_BinaryPrintf(
                    "[gen_cuvbits[dex]]",arr_cuvbits_003[dex]);;



                    ERR("[CUVBITS_DONT_MATCH_YEAR_2021]");

                };;

        };;};;};;};; //:NEXT[ lay , t_q , a_d ]

        //:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://
        };; //:NEXT[       t_i             ]
        //:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://

        //:------------------------------:SIMPLE_PUT_GET_TEST://
////    //:PUT_ALL_THEN_GET_ALL_TEST:------------------------://
////    /** Same as previous test. But set all values then **/
////    /** check all values. To make sure there are no    **/
////    /** memory stomps.                                 **/
////    for( t_i = 0 ; t_i <= mti ; t_i ++ ){
////
////
////    };;
////    for( t_i = 0 ; t_i <= mti ; t_i ++ ){
////
////
////    };;
////    //:------------------------:PUT_ALL_THEN_GET_ALL_TEST://
////    //:PUT_ALL_GET_ALL_USING_ALL_AUSETS:-----------------://
////    /** Loop through all tests.                  **/
////    /** And set all test values for every auset. **/
////    for( t_i = 0 ; t_i <= mti ; t_i ++ ){
////    for( a_d = 0 ; a_d <= a_d ; a_d ++ ){
////
////
////    };;};;
////    for( t_i = 0 ; t_i <= mti ; t_i ++ ){
////    for( a_d = 0 ; a_d <= a_d ; a_d ++ ){
////
////
////    };;};;
////    //:-----------------:PUT_ALL_GET_ALL_USING_ALL_AUSETS://


        AAC2020_TODOMAN_Vital("[MORE_TEST_CASES_2021_BLUE]");

        /** ************************************************ **/
        /** @VID_IID[ 0103 ]TIME[ 02:03:00 ]                 **/
        /** Double checked. f_r_e_e is in correct location.  **/
        /**                                                  **/
        /** Free the computed expected outputs.      ******* **/
        /** Expected outputs computed from the input ******* **/
        /** data table.                              ******* **/
                                                     /** *** **/
            free( arr_cuvbits_003 );                 /** *** **/
                                                     /** *** **/
        /** ************************************************ **/

        //:DEFINE_OR_UNDEF_BINARY_CONSTANTS:-----------------://

            #undef  B_00                                  //01//
            #undef  B_01                                  //02//
            #undef  B_10                                  //03//
            #undef  B_11                                  //04//
               
            #undef  B____00_00_00_00____00_00_00_00_____B //05//
            #undef  B____01_01_01_01____01_01_01_01_____B //06//
            #undef  B____00_00_00_00____00_00_00_11_____B //07//
            #undef  B____11_00_11_00____11_00_11_00_____B //08//
            #undef  B____11_00_11_00____11_00_11_01_____B //09//
            #undef  B____11_11_11_11____11_11_11_11_____B //10//
            #undef  B____11_11_11_11____00_00_00_00_____B //11//
            #undef  B____00_00_00_00____11_11_11_11_____B //12//
            #undef  B____00_00_11_11____11_11_00_00_____B //13//
            #undef  B____00_11_10_00____01_00_11_10_____B //14//
            #undef  B____11_00_00_10____11_01_10_00_____B //15//
            #undef  B____00_01_10_11____10_00_11_00_____B //16//

        //:-----------------:DEFINE_OR_UNDEF_BINARY_CONSTANTS://

    #undef TAB_INN_WID 
    #undef TAB_OUT_WID 
    #undef NUM_TESTS   
    #undef CUVIPIX
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_PokeAndProd_BitPack_Get( void )
    {
    #define PIX AAC2020_PIXNAME_paint5d_cpu_pix

        AAC2020_TODOMAN_Vital(
            /** @VID_IID[ 0091 ]TIME[ 01:23:50 ] **/
            "[aac2020_paint5d_BitPack_Get:USE_I32_For_glo_dex]"
        );;

        //:declare_vars:-------------------------------------://

            I32 g_c ; //:global_component_index / glo_com
            U08 a_d ; //:auset_dex / aus_dex

            U08 pak_t_v ; //:packed tile value
            U08 got_t_v ; //:gotten tile value

        //:-------------------------------------:declare_vars://
        //:manual_pack_and_unpack_test:001:------------------://
        #define SHOULDNT_MATTER ( 0xFF )

            /** @VID_IID[ 0091 ]TIME[ 01:10:10 ] *********** **/
            /** I suspect aac2020_paint5d_UTC_BitPack_Get    **/
            /** is not well enough tested and missing tests  **/
            /** were we do a SET by manually bit packing.    **/
            /**                                              **/
            /** Pack the tile value directly into the pixel  **/
            /** byte array here and confirm we can get it    **/
            /** back out with the getter method.             **/
            /** ******************************************** **/

            g_c     =( 0 );
            a_d     =( 0 );
            pak_t_v =( 3 ); /** BIN_011 **/

            PIX[ g_c + 0 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 1 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 2 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 3 ] = ( pak_t_v << ( 0 ) );

            /** GET: t_v ( tile value ) **/
            aac2020_paint5d_BitPack_Get(
                        PIX  //: U08* :  CPU_PIX ://
            ,           g_c  //: I32  :  glo_com ://
            ,           a_d  //: U08  :  aus_dex ://
            ,     &(got_t_v) //: U08  :  til_val ://
            );;
        
            if( got_t_v != pak_t_v ){
                //:MPAUT:Manual_Pack_And_Unpack_Test:
                ERR("[MUCH_PROBLEMS_WOW_2021_MPAUT:001]");
            };;

        #undef  SHOULDNT_MATTER
        //:------------------:manual_pack_and_unpack_test:001://
        //:manual_pack_and_unpack_test:002:------------------://
        #define SHOULDNT_MATTER ( 222 )

            g_c     =( 0 );
            a_d     =( 4 ); /** <--CHANGED[ @VID_IID[0091]  ]**/
                            /**             @TIME[ 01:12:55 ]**/
                            /**             @DELTA@          **/
            pak_t_v =( 3 ); /** BIN_011 **/

            PIX[ g_c + 0 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 1 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 2 ] = ( pak_t_v << ( 0 ) ); /**@DELTA@**/
            PIX[ g_c + 3 ] = SHOULDNT_MATTER ;

            /** GET: t_v ( tile value ) **/
            aac2020_paint5d_BitPack_Get(
                        PIX  //: U08* :  CPU_PIX ://
            ,           g_c  //: I32  :  glo_com ://
            ,           a_d  //: U08  :  aus_dex ://
            ,     &(got_t_v) //: U08  :  til_val ://
            );;
        
            if( got_t_v != pak_t_v ){
                //:MPAUT:Manual_Pack_And_Unpack_Test:
                ERR("[MUCH_PROBLEMS_WOW_2021_MPAUT:002]");
            };;

        #undef  SHOULDNT_MATTER
        //:------------------:manual_pack_and_unpack_test:002://
        //:manual_pack_and_unpack_test:003:------------------://
        #define SHOULDNT_MATTER ( 23 )

            g_c     =( 64 * 4 * 7 );
            a_d     =( 4 ); /** <--CHANGED[ @VID_IID[0091]  ]**/
                            /**             @TIME[ 01:12:55 ]**/
                            /**             @DELTA@          **/
            pak_t_v =( 3 ); /** BIN_011 **/

            PIX[ g_c + 0 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 1 ] = SHOULDNT_MATTER ;
            PIX[ g_c + 2 ] = ( pak_t_v << ( 0 ) ); /**@DELTA@**/
            PIX[ g_c + 3 ] = SHOULDNT_MATTER ;

            /** GET: t_v ( tile value ) **/
            aac2020_paint5d_BitPack_Get(
                        PIX  //: U08* :  CPU_PIX ://
            ,           g_c  //: I32  :  glo_com ://
            ,           a_d  //: U08  :  aus_dex ://
            ,     &(got_t_v) //: U08  :  til_val ://
            );;
        
            if( got_t_v != pak_t_v ){
                //:MPAUT:Manual_Pack_And_Unpack_Test:
                ERR("[MUCH_PROBLEMS_WOW_2021_MPAUT:002]");
            };;

        #undef  SHOULDNT_MATTER
        //:------------------:manual_pack_and_unpack_test:003://

    #undef PIX 
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_polyfill_texel_fetch( void )
    {
    #define IV2 struct AAC2020_OPEN_GL_IV2
    #define BIN_011 ( 3 ) /** binary: 11 **/

        /** ************************************************ **/
        /** @VID_IID[ 0088 ]TIME[ 00:53:50 ]                 **/                    
        /** We don't actually have a CPU side texel fetch    **/
        /** function to compare the P5D1OGL._ code against...**/
        /** So I am not sure exactly how we will be testing  **/
        /** this code.                                       **/
        /** ************************************************ **/
        //:..................................................://
        U08*    cpu_pix =( AAC2020_PIXNAME_paint5d_cpu_pix );
        //:..................................................://
        U32     u32_var       ; //:pixel_value_to_store
        U32     u32_got       ; //:value got from texel fetch 
        //:..................................................://
        U32         C_r       ; //:check_what_you_put
        U32         C_g       ; //:check_what_you_put
        U32         C_b       ; //:check_what_you_put
        U32         C_a       ; //:check_what_you_put
        //:..................................................://    
        U32         B_r =( 0 ); //:BYTE: red
        U32         B_g =( 0 ); //:BYTE: green
        U32         B_b =( 0 ); //:BYTE: blue
        U32         B_a =( 0 ); //:BYTE: alpha
        //:..................................................://      
        I32         p_x       ; //:pixel x
        I32         p_y       ; //:pixel y
        I32     glo_com       ; //:global component index
        IV2         glo       ; //:global_xy == [ p_x , p_y ]
        //:..................................................://
        U08         a_d       ; //:Auset_inDex
        U08         t_v       ; //:Tile_Value
        U32     rbp_001       ; //:Re_Built_Pixel: Method #1
        U32     rbp_002       ; //:Re_Built_Pixel: Method #2
        U08         ad2       ; //:Auset_inDex times TWO(2)

        u32_var=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){

            /** Increment with primes. **/
            B_r += 1 ; if( B_r > 255 ){ B_r = B_r - 255; };
            B_g += 3 ; if( B_g > 255 ){ B_g = B_g - 255; };
            B_b += 5 ; if( B_b > 255 ){ B_b = B_b - 255; };
            B_a += 7 ; if( B_a > 255 ){ B_a = B_a - 255; };

            u32_var = ( 0x00
            |   (  ((U08)B_r)  << 24 )
            |   (  ((U08)B_g)  << 16 )
            |   (  ((U08)B_b)  <<  8 )
            |   (  ((U08)B_a)  <<  0 )
            );;

            C_r = ( u32_var >> 24 ) & 0xFF ;
            C_g = ( u32_var >> 16 ) & 0xFF ;
            C_b = ( u32_var >>  8 ) & 0xFF ;
            C_a = ( u32_var >>  0 ) & 0xFF ;

            if(  0
            || ( B_r != C_r )
            || ( B_g != C_g )
            || ( B_b != C_b )
            || ( B_a != C_a )
            ){
                ERR("[YOU_DONT_KNOW_BIT_SHIFTING_2021]");
            };;

            glo_com = ( ( p_y * 512 ) + p_x ) * 4 ;

            cpu_pix[ glo_com + 0 ] = ((U08)B_r);
            cpu_pix[ glo_com + 1 ] = ((U08)B_g);
            cpu_pix[ glo_com + 2 ] = ((U08)B_b);
            cpu_pix[ glo_com + 3 ] = ((U08)B_a);

            glo.x = ( p_x );
            glo.y = ( p_y );
            u32_got=(
                OPEN_GL_PAINT5D_TexelFetch_U32(
                    0 //:Texture Sampler, Not Used in C version.
                , glo //:Global X/Y coordinate of pixel.
                ,   0 //:[ L.O.D. ] Always zero in all code.
                ));;
            
            if( u32_got != u32_var ){
                ERR("[texel_fetch_definitely_broken_2021]");
            };;

            //:double_check:u32_got:-------------------------://

                U32 dub_chk=( 0x00 /**dub_chk==doublecheck**/
                |   cpu_pix[ glo_com + 0 ] << 24 
                |   cpu_pix[ glo_com + 1 ] << 16
                |   cpu_pix[ glo_com + 2 ] <<  8               
                |   cpu_pix[ glo_com + 3 ] <<  0   
                );;
                if( dub_chk != u32_var ){
                    ERR("[MY_OH_MY_2021_01_15_0623PM]");
                };;

            //:-------------------------:double_check:u32_got://

            //: Try Using: aac2020_paint5d_BitPack_Get       ://
            //: To re-build the pixel we put. If that works  ://
            //: Then I am satisfied to maybe... 70% that     ://
            //: the texel fetch code works properly.         ://
            rbp_001 =( 0x00 );
            rbp_002 =( 0x00 );
            for( a_d = 0 ; a_d <= 15 ; a_d ++ ){

                /** GET: t_v ( tile value ) **/
                aac2020_paint5d_BitPack_Get(
                      cpu_pix  //: U08* :  ://
                ,     glo_com  //: I32 <--- #FIXED_IID_0091# ://
                ,         a_d  //: U08  :   @VID_IID[  0091 ]://
                ,       &(t_v) //: U08  :   @TIME[ 01:33:25 ]://
                );;

                ad2=( a_d * 2 );
                rbp_001=( rbp_001 | ( t_v           << ad2 ) );
                rbp_002=( rbp_002 | ((t_v & BIN_011)<< ad2 ) );
                if( rbp_001 != rbp_002 ){
                    ERR("[WTF:rbp_001!=rbp_002]");
                };;
            };;

            if( 0
            ||  ( rbp_001 != u32_got )
            ||  ( rbp_001 != u32_var )
            ){
                printf("[rbp_001]:%d\n" , rbp_001 );
                printf("[u32_got]:%d\n" , u32_got );
                printf("[u32_var]:%d\n" , u32_var );

                /** **************************************** **/
                /** If we are lucky, the hex representation  **/
                /** of number will be enough to figure out   **/
                /** what went wrong. If unlucky, we will need**/
                /** to printf as binary.                     **/
                /** @VID_IID[ 0088 ]TIME[ 01:45:20 ]         **/
                /** **************************************** **/
                printf("[hex:rbp_001]:%08x\n" , rbp_001 );
                printf("[hex:u32_got]:%08x\n" , u32_got );
                printf("[hex:u32_var]:%08x\n" , u32_var );

                aac2020_paint5d_BinaryPrintf(
                    "[BINARY_OF:rbp_001]" , rbp_001 );;
                aac2020_paint5d_BinaryPrintf(
                    "[BINARY_OF:rbp_002]" , rbp_002 );;

                aac2020_paint5d_BinaryPrintf(
                    "[BINARY_OF:u32_got]" , u32_got );;
                aac2020_paint5d_BinaryPrintf(
                    "[BINARY_OF:u32_var]" , u32_var );;

                ERR("[Maybe_BitPacking_Code_Is_Wrong:2021]");
            };;


        };;};;

    #undef IV2
    #undef BIN_011
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_BitPack_Get( void )
    {
        /** @VID_IID[ 0088 ]TIME[ 00:10:08 ] *************** **/
        /** Functions in "OPEN_GL_HAKCODE/P5D1OGL._"   * * * **/
        /** are transcribed versions of functions in   * * * **/
        /** PAINT5D.F._ . The goal is re-write the     * * * **/
        /** code in a way that is more compatible      * * * **/
        /** with GLSL syntax so minimal changes will   * * * **/
        /** need to be done to paste it into our       * * * **/
        /** shader code.                               * * * **/
        /** ************************************************ **/

        I32         p_x; //:Global pixel coordinate on:
        I32         p_y; //:AAC2020_PIXNAME_paint5d_cpu_pix
                         //:SEE[ DIAGRAM[ #DIA_P5D_MAIN# ]  ]
                         //:SEE[    FILE[ PAINT5D.D._    ]  ]

        I32         aus; //:What auto-tile-set (auset) is
                         //:being targeted. Paint5D system
                         //:is configured to store 16 total
                         //:ausets per texture.
                         //:SEE[ DIAGRAM[ #DIA_P5D_U32#  ]  ]
                         //:SEE[    FILE[ PAINT5D.D._    ]  ]

        U08*    cpu_pix =( AAC2020_PIXNAME_paint5d_cpu_pix );
                         //:The system data storing the
                         //:designs Josh will be working on
                         //:in paint5d.

        I32     glo_com; //:Global Component Index (red byte)
        I32     aus_dex; //:Same as [ aus ]
        I32     til_val; //:Tile Value: [ 0 | 1 | 2 | 3 ]
                         //:( 2 bits used to store tile value )
            
        U08 u08_til_val; //:  8 bit version of til_val
        U32 u32_til_val; //: 32 bit version of til_val

        /** @VID_IID[ 0088 ]TIME[ 00:16:50 ] *************** **/
        /** AAC2020_OPEN_GL_IV2 :                            **/
        /** This struct exists to help us make the code      **/
        /** as similiar to GLSL code as possible to          **/
        /** HOPEFULLY make it so ZERO CHANGES need to be     **/
        /** done when pasting this code into our GLSL        **/
        /** shader string.                                   **/
        /** ************************************************ **/

            struct AAC2020_OPEN_GL_IV2
            glo; //:<-- [ glo.x , glo.y ] == [ p_x , p_y ]

        /** ************************************************ **/

        til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:The_Setup:------------------------------------://
            
                /** Set Auset Index **/
                aus_dex =( aus );

                /** Generate Tile Value **/
                til_val++;
                if( til_val >  3 ){ til_val = 0; };

                /** Skip Configuration Pixel **/
                if( 255 == p_x && 255 == p_y ){ continue; };
                if( 511 == p_x && 255 == p_y ){ continue; };
                if( 255 == p_x && 511 == p_y ){ continue; };
                if( 511 == p_x && 511 == p_y ){ continue; };

                /** **************************************** **/
                /** @VID_IID[ 0087 | 0088 ]....Ooops...      **/
                /** @TIME[ 00:22:28 ] ********************** **/
                /** Convert [ p_x , p_y ] to component index **/
                /** Use index to xy formula for a 512x512    **/
                /** bitmap, then multiply by 4 to convert    **/
                /** the pixel location to RED_BYTE location. **/

                    glo_com =( ( p_y * 512 ) + p_x ) * 4 ;

                /** **************************************** **/

            //:------------------------------------:The_Setup://
            //:Test_Original_Code:---------------------------://

                aac2020_paint5d_BitPack_Put(
                         cpu_pix  //:<-- [ Bitmap / Texture ]
                ,   (I32)glo_com   
                ,   (U08)aus_dex   
                ,   (U08)til_val  //:<-- Put this value into
                );;               //:    [ Bitmap / Texture ]

                aac2020_paint5d_BitPack_Get(
                         cpu_pix  //:<-- [ Bitmap / Texture ]
                ,   (I32)glo_com  
                ,   (U08)aus_dex  
                ,  &(u08_til_val) //:<-- Read Value From
                );;               //:    [ Bitmap / Texture ]

                if( (I08)u08_til_val
                !=  (I08)    til_val
                ){
                    /** Hope you never see this error. As it **/
                    /** means you transcribed buggy code.    **/
                    /** @VID_IID[ 0087 ]TIME[ 00:42:30 ]     **/
                    ERR("[PROBLEM_IS_THE_ORIGINAL_CODE_2021]");
                };;

            //:---------------------------:Test_Original_Code://
            //:Cross_Check_New_Code:-------------------------://
            /** ******************************************** **/
            /** OPEN_GL_PAINT5D_BitPack_Get is a re-write    **/
            /** of aac2020_paint5d_BitPack_Get and thus      **/
            /** should have the same exact outputs as        **/
            /** aac2020_paint5d_BitPack_Get for a given set  **/
            /** of inputs. @VID_IID[ 0088 ]TIME[ 00:03:23 ]  **/
            /** ******************************************** **/

                glo.x = p_x;
                glo.y = p_y;

                u32_til_val=(
                    OPEN_GL_PAINT5D_BitPack_Get(
                        glo      //:Pixel Location
                    ,   aus_dex  //:Bit Location To Unpack
                    ));;

                if( (I08)u32_til_val
                !=  (I08)    til_val
                ){
                    printf("\n\n\n");
                    printf("[p_x,p_y,aus]:(%d,%d,%d)\n"
                    ,        p_x,p_y,aus );;
                    printf("[u32_til_val]:%d\n"
                    ,        u32_til_val );;
                    printf("[....til_val]:%d\n"
                    ,            til_val );;

                    /** ************************************ **/
                    /** @VID_IID[ 0088 ]TIME[ 00:06:55 ]     **/
                    /** This is the best case scenario for   **/
                    /** test code failure. Means we did      **/
                    /** something very stupid while transcri-**/
                    /** -bing the code.                      **/
                    ERR("[PROBLEM_IS_THE_TRANSCRIPTION_2021]");
                    /** ************************************ **/
                };;

            //:-------------------------:Cross_Check_New_Code://

        };;};;};; //:NEXT[ p_x , p_y , aus ]://

    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_til_exp_CTO_max_cor( void )
    {
        /** ***************************************** **/
        /** NO_TESTS_NEEDED_BECAUSE MAIN TEST PASSED: **/
        /**(     aac2020_P5D1OGL_UTC_Get     )**/
        /**                                           **/
        /**      @VID_IID[ 0091 ]TIME[ 01:40:00 ]     **/
        /** ***************************************** **/
    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_til_exp_CTO_diagpix( void )
    {
        /** ***************************************** **/
        /** NO_TESTS_NEEDED_BECAUSE MAIN TEST PASSED: **/
        /**(     aac2020_P5D1OGL_UTC_Get     )**/
        /**                                           **/
        /**      @VID_IID[ 0091 ]TIME[ 01:40:00 ]     **/
        /** ***************************************** **/
    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_painpix_CTO_glocpix( void )
    {
        /** ***************************************** **/
        /** NO_TESTS_NEEDED_BECAUSE MAIN TEST PASSED: **/
        /**(     aac2020_P5D1OGL_UTC_Get     )**/
        /**                                           **/
        /**      @VID_IID[ 0091 ]TIME[ 01:40:00 ]     **/
        /** ***************************************** **/
    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D1OGL_UTC_Get( void )
    {
        //:variable_declare:---------------------------------://

            /** iterate over every pixel of bitmap **/
            I32 p_x; //:Pixel X
            I32 p_y; //:Pixel Y
            I32 aus; //:auset index

            /** for original functions **/
            U08 u08_til_qua ;
            U08 u08_til_exp ;
            U08 u08_til_lay ;
            U08 u08_loc_t_x ;
            U08 u08_loc_t_y ;
            I16 i16_glo_t_x ;
            I16 i16_glo_t_y ;

            /** for original functions **/
            U08 u08_aus_dex ;
            U08 u08_til_val ;

            /** for return from GLSL version of function. **/
            U32 u32_til_val ;

            /** for determining if we passed tests or not. **/
            I08 i08_u32_til_val ;
            I08 i08_u08_til_val ;

        //:---------------------------------:variable_declare://

        u08_til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:IDENTICAL_CODE_IN_BOTH_LOOPS:-----------------://
            u08_aus_dex =( (U08)aus );
            u08_til_val++;
            if( u08_til_val >  3 ){ u08_til_val = 0; };
            /** @VID_IID[ 0086 ]TIME[ 01:12:00 ] **/
            /** SKIP THE CONFIGURATION PIXELS.   **/
            if( 255 == p_x && 255 == p_y ){ continue; };
            if( 511 == p_x && 255 == p_y ){ continue; };
            if( 255 == p_x && 511 == p_y ){ continue; };
            if( 511 == p_x && 511 == p_y ){ continue; };
            //:-----------------:IDENTICAL_CODE_IN_BOTH_LOOPS://

            aac2020_paint5d_glocpix_CTO_painpix(
              &(u08_til_qua )            //: U08* ://
            , &(u08_til_exp )            //: U08* ://
            , &(u08_til_lay )            //: U08* ://
            , &(u08_loc_t_x )            //: U08* ://
            , &(u08_loc_t_y )            //: U08* ://
            ,  (i16_glo_t_x = (I16)p_x ) //: I16  ://
            ,  (i16_glo_t_y = (I16)p_y ) //: I16  ://
            );;

            AAC2020_PAINT5D_Put(
               u08_til_qua  //:  U08  ://
            ,  u08_til_exp  //:  U08  ://
            ,  u08_til_lay  //:  U08  ://
            ,  u08_loc_t_x  //:  U08  ://
            ,  u08_loc_t_y  //:  U08  ://
            ,  u08_aus_dex  //:  U08  ://
            ,  u08_til_val  //:  U08  ://
            );;          

            /** Use GLSL version of getter **/
            u32_til_val=(                                    
                OPEN_GL_PAINT5D_Get(                       
                    (I32)u08_til_qua                           
                ,   (I32)u08_til_exp                           
                ,   (I32)u08_til_lay                           
                ,   (I32)u08_loc_t_x                           
                ,   (I32)u08_loc_t_y                           
                ,   (I32)u08_aus_dex   
                ));;

                 i08_u32_til_val = ((I08)u32_til_val) ;
                 i08_u08_til_val = ((I08)u08_til_val) ;
            if(  i08_u32_til_val
            !=   i08_u08_til_val
            ){
                printf("\n\n\n");
                //:Does_Original_Ganster_Get_Fail_Too?:------://
                U08 O_G_til_val;    /** O_G:original_ganster **/
                AAC2020_PAINT5D_Get(
                   u08_til_qua  //:  U08  ://
                ,  u08_til_exp  //:  U08  ://
                ,  u08_til_lay  //:  U08  ://
                ,  u08_loc_t_x  //:  U08  ://
                ,  u08_loc_t_y  //:  U08  ://
                ,  u08_aus_dex  //:  U08  ://
                ,&(O_G_til_val) //:  U08  ://
                );;   
                if( O_G_til_val == u08_til_val ){
                    printf("[TRANSCRIPTION_PROBLEM_RED]\n");
                }else{
                    printf("[THIS_IS_MUCH_MUCH_WORSE_RED]\n");
                };;
                //:------:Does_Original_Ganster_Get_Fail_Too?://

                printf("[p_x,p_y]:(%d,%d)\n",p_x,p_y);

                printf("[O_G_til_val]:%d\n"
                ,        O_G_til_val );;

                printf("[i08_u32_til_val]:%d\n"
                ,        i08_u32_til_val );;

                printf("[i08_u08_til_val]:%d\n"
                ,        i08_u08_til_val );;

                ERR("[FAILED_GLSL_TEST_OF_PAINT5D:001]");
            };;

        };;};;};;

        /** RUN A 2ND TIME WITH ONLY GETTER TO DETECT        **/
        /** MEMORY STOMPS. @VID_IID[ 0086 ]TIME[ 00:37:08 ]  **/

        u08_til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:IDENTICAL_CODE_IN_BOTH_LOOPS:-----------------://
            u08_aus_dex =( (U08)aus );
            u08_til_val++;
            if( u08_til_val >  3 ){ u08_til_val = 0; };
            /** @VID_IID[ 0086 ]TIME[ 01:12:00 ] **/
            /** SKIP THE CONFIGURATION PIXELS.   **/
            if( 255 == p_x && 255 == p_y ){ continue; };
            if( 511 == p_x && 255 == p_y ){ continue; };
            if( 255 == p_x && 511 == p_y ){ continue; };
            if( 511 == p_x && 511 == p_y ){ continue; };
            //:-----------------:IDENTICAL_CODE_IN_BOTH_LOOPS://

            /** Use GLSL version of getter **/
            u32_til_val=(                                    
                OPEN_GL_PAINT5D_Get(                       
                    (I32)u08_til_qua                           
                ,   (I32)u08_til_exp                           
                ,   (I32)u08_til_lay                           
                ,   (I32)u08_loc_t_x                           
                ,   (I32)u08_loc_t_y                           
                ,   (I32)u08_aus_dex   
                ));;

                 i08_u32_til_val = ((I08)u32_til_val) ;
                 i08_u08_til_val = ((I08)u08_til_val) ;
            if(  i08_u32_til_val
            !=   i08_u08_til_val
            ){
                printf("\n\n\n");
                //:Does_Original_Ganster_Get_Fail_Too?:------://
                U08 O_G_til_val;    /** O_G:original_ganster **/
                AAC2020_PAINT5D_Get(
                   u08_til_qua  //:  U08  ://
                ,  u08_til_exp  //:  U08  ://
                ,  u08_til_lay  //:  U08  ://
                ,  u08_loc_t_x  //:  U08  ://
                ,  u08_loc_t_y  //:  U08  ://
                ,  u08_aus_dex  //:  U08  ://
                ,&(O_G_til_val) //:  U08  ://
                );;   
                if( O_G_til_val == u08_til_val ){
                    printf("[TRANSCRIPTION_PROBLEM_BLUE]\n");
                }else{
                    printf("[THIS_IS_MUCH_MUCH_WORSE_BLUE]\n");
                };;
                //:------:Does_Original_Ganster_Get_Fail_Too?://

                printf("[p_x,p_y]:(%d,%d)\n",p_x,p_y);

                printf("[O_G_til_val]:%d\n"
                ,        O_G_til_val );;

                printf("[i08_u32_til_val]:%d\n"
                ,        i08_u32_til_val );;

                printf("[i08_u08_til_val]:%d\n"
                ,        i08_u08_til_val );;

                ERR("[FAILED_GLSL_TEST_OF_PAINT5D:002]");
            };;
    
        };;};;};;

    }

#undef  U08                                           //: 01 ://
#undef  I08                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  I32                                           //: 04 ://
#undef  I16                                           //: 05 ://
#undef  U16                                           //: 06 ://
#undef  ERR                                           //: 07 ://
#undef  LOG                                           //: 08 ://
//:================================:UNIT_TEST_SECTION:P5D1OGL://