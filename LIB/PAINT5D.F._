//: PAINT5D: ( .F._ : FuncFile )
//: #NAMESPACE_PATTERN_BREAKER_PAINT5D#

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://

    void
    aac2020_paint5d_Halt( const char* msg_err )
    {

        printf("[PAINT5D_HALT____MSG_ERR]:%s\n", msg_err );
        fflush(stdout);exit(  11 /** 4*20-69 **/ );         

    }

//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:OKAY_STATUS_INFO_MESSAGE:=================================://

    void
    aac2020_paint5d_Okay( const char* msg_o_k )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Okay]:%s\n", msg_o_k );
        fflush(stdout);    
    };;}

//:=================================:OKAY_STATUS_INFO_MESSAGE://
//:INFO_STATUS_INFO_MESSAGE:=================================://
#define I32 int32_t /** GCC: <stdint.h> **/
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info( const char* msg_inf )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Info]:%s\n", msg_inf );
        fflush(stdout);    
    };;}
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_dec( 
        const char* str_fmt
    ,   I32         val_dec
    )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf( "[aac2020_paint5d_Info_dec]...\n");
        fflush( stdout            ); //:@SAFETY_DOUBLE_FLUSH@://
        printf( str_fmt , val_dec );
        fflush( stdout            );    
    };;}
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_any(
        const char* str_fmt
    ,   void*       dat_any   
    )
    { if( AAC2020_SILENCE.PAINT5D <= 0 ){

        /** Same Line As Next Printf **/
        printf("[paint5d_log]....(   " ); fflush( stdout );
        printf( str_fmt , dat_any      ); fflush( stdout );
        printf(               "   )\n" ); fflush( stdout );

    };; }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32
//:=================================:INFO_STATUS_INFO_MESSAGE://
//:HELPER_FUNCTIONS:GENERIC:=================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U16 uint16_t /** GCC: <stdint.h> **/
#define I16  int16_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I16
    aac2020_paint5d_Min_I16(
        I16 i16_001
    ,   I16 i16_002
    )
    {
        I16 i16_min = ( 0 - 4433 /** @TRAP_VALUE@ **/ );
        if( i16_001 <= i16_002 ){ i16_min = i16_001 ; };
        if( i16_002 <= i16_001 ){ i16_min = i16_002 ; };

        assert( 0 - 4433 != i16_min /** @CHECK_TRAP@ **/ );
        return( i16_min );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_i32_Cap_u32(

        I32 bru_x_y /** [ b_x | b_y ](Brush_X -or- Brush_Y) **/
    ,   U16 cap_min
    ,   U16 cap_max

    )
    {
        assert( cap_min <= cap_max ); /** Sorted/Ordered ? **/

        U32 out_u32 = ( (U32)bru_x_y );

        if( bru_x_y < (I32)cap_min ){ out_u32 =(U32)(cap_min);};
        if( bru_x_y > (I32)cap_max ){ out_u32 =(U32)(cap_max);};

        return( out_u32 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32 
#undef  U32 
#undef  U16 
#undef  I16
//:=================================:HELPER_FUNCTIONS:GENERIC://
//:HELPER_FUNCTIONS:CONVERSION:==============================://
#define POT aac2020_paint5d_POT_diagpix               //: 01 ://
#define T_E til_exp /** Tilesize_Exponent **/         //: 02 ://
#define BRK break                                     //: 03 ://
#define CAS case                                      //: 04 ://
#define DEF default                                   //: 05 ://
#define S_A _Static_assert                            //: 06 ://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 07 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 08 ://
#define ERR aac2020_paint5d_Halt                      //: 09 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_bip_sip(
                U08 til_exp
    )
    {
        /** [bip_sip]:BItmap_Partition____Span_In_Pixels **/

        if( til_exp >= 8 ){

        //    printf("[til_exp]:%d\n" , til_exp );
        //
        //    /** By trying to support the edge-case **/
        //    /** of tile exponent 8 , we have found **/
        //    /** ourselves in a bad place. Remove   **/
        //    /** Uses of [ til_exp == 8 ] ********* **/
        //    ERR("[8_IS_INVALID_DO_NOT_SUPPORT]");
        };;

        #if( AAC2020_CRASH_ON_NIAVE_CODE >= 1 ) //:##########://

            #error "[CODE_BELOW_COULD_USE_A_JUMP_TABLE]"

        #endif //:###########################################://

        U08 bip_sip; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ bip_sip = ( 128 + 0 ); };  //: 1 ://
        if( 1 == til_exp ){ bip_sip = (  64 + 0 ); };  //: 2 ://
        if( 2 == til_exp ){ bip_sip = (  32 + 0 ); };  //: 3 ://
        if( 3 == til_exp ){ bip_sip = (  16 + 0 ); };  //: 4 ://
        if( 4 == til_exp ){ bip_sip = (   8 + 0 ); };  //: 5 ://
        if( 5 == til_exp ){ bip_sip = (   4 + 0 ); };  //: 6 ://
        if( 6 == til_exp ){ bip_sip = (   2 + 0 ); };  //: 7 ://
        if( 7 == til_exp ){ bip_sip = (   1 + 0 ); };  //: 8 ://
        if( 8 == til_exp ){ bip_sip = (     1   ); };  //: 9 ://

        /** @VID_IID[ 0078 ]TIME[ 1H 52M 55S ] ************* **/
        /** This could be a bad idea, but we will allow 8    **/
        /** to be used in some calculations. Hopefully it    **/
        /** does not waterfall out of control in a chain     **/
        /** reaction of edge cases that I will soon regret.  **/
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp + 1);
        assert(   7 + 1  == AAC2020_PAINT5D_MAX_til_exp + 1);
    
        return( bip_sip );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_max_cor(
                U08 til_exp
    )
    {
        /** Why is output U08 ?                **/
        /** @VID_IID[ 0067 ]TIME[ 4H 15M 40S ] **/

        U08 max_cor; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ max_cor = ( 128 - 1 ); };  //: 1 ://
        if( 1 == til_exp ){ max_cor = (  64 - 1 ); };  //: 2 ://
        if( 2 == til_exp ){ max_cor = (  32 - 1 ); };  //: 3 ://
        if( 3 == til_exp ){ max_cor = (  16 - 1 ); };  //: 4 ://
        if( 4 == til_exp ){ max_cor = (   8 - 1 ); };  //: 5 ://
        if( 5 == til_exp ){ max_cor = (   4 - 1 ); };  //: 6 ://
        if( 6 == til_exp ){ max_cor = (   2 - 1 ); };  //: 7 ://
        if( 7 == til_exp ){ max_cor = (   1 - 1 ); };  //: 8 ://

        if( 8 == til_exp ){ max_cor = (     0   ); };  //: 9 ://
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp + 1);
        assert(   7 + 1  == AAC2020_PAINT5D_MAX_til_exp + 1);
    
        return( max_cor );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_diagpix(
            U08     til_exp
    )
    {
        if( til_exp <= 7 ){
            /** Okay. Do nothing. Valid Range. **/
        }else
        if( 8 == til_exp ){
            /** @VID_IID[ 0078 ]TIME[ 00H 24M 22S ] ******** **/
            /** Okay. This tile exponent is outside of our   **/
            /** valid range, but for some reason supporting  **/
            /** it in our lookup table. Returns coordinate   **/
            /** of the bottom-right-most pixel in quarkmap.  **/
            /** ******************************************** **/
        }else{
            ERR("[OOB:til_exp:til_exp_CTO_diagpix]");
        };;

        U08     diagpix =aac2020_paint5d_POT_diagpix[ til_exp ];
        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_til_exp(
            U08     diagpix
    )
    {

        I32       dex = 0;
        I32 found_dex =( 0 - 1 );

        for( dex = 0 ; dex <= 8 ; dex++ ){

            if( diagpix == aac2020_paint5d_POT_diagpix[ dex ] ){
                found_dex =( dex );
            };;
        };;

        /** Pretty sure function needs the EXACT diagonal **/
        /** value. No snapping to nearest is performed.   **/
        if( found_dex < 0 ){
            ERR("[BAD_DIAGPIX_INPUT_MAYBE?]");
        };;

        /** @VID_IID[ 00H 32M 13S ] ************************ **/
        /** For example, if found_dex is 1 , then got   .... **/
        /** 128 for the diagpix. 128 is the origin for  .... **/
        /** the til_exp value AFTER 0, thus til_exp 1.  .... **/
        assert( found_dex >= 0 );     /** ****************** **/
        assert( found_dex <= 8 );     /** ****************** **/
        return( (U08)found_dex     ); /** ****************** **/

//:WTF!? This is the wrong formula. It is the inverse.
//:Delete this sometime. Preferably after PAINT5D is working
////////////////////////////////////////////////////////////////
////    /** In case type signature changes **/
////    assert(  (((I32)diagpix)+0) < 255  );
////
////    /**   T_E  **/
////    U08 til_exp =( 222 /** Invalid Trap Value **/ );
////    /**   T_E  **/
////
////    switch( diagpix ){  
////    //:pyramid_not_of_doom:------------------------------://
////    CAS 0: T_E = ( 0                              );BRK;
////    CAS 1: T_E = ( 0 +128                         );BRK;
////    CAS 2: T_E = ( 0 +128 +64                     );BRK;
////    CAS 3: T_E = ( 0 +128 +64 +32                 );BRK;
////    CAS 4: T_E = ( 0 +128 +64 +32 +16             );BRK;
////    CAS 5: T_E = ( 0 +128 +64 +32 +16 +8          );BRK;
////    CAS 6: T_E = ( 0 +128 +64 +32 +16 +8 +4       );BRK;
////    CAS 7: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2    );BRK;
////    CAS 8: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2 +1 );BRK;
////    //:------------------------------:pyramid_not_of_doom://
////    DEF: 
////        
////        printf("[DP_TO_TE:diagpix]:%d\n" ,  diagpix );
////        ERR("[INVALID_DIAGPIX_INPUT_CANNOT_CONVERT]");
////
////    };; assert( til_exp <= 7 && (((I32)til_exp)+0) >= 0 );
////    S_A( AAC2020_PAINT5D_MAX_til_exp == 7 , "[ERR_MSG]" );
////
////    /** 8 is only 1 pixel, and thus not useful. **/
////    /** @VID_IID[ 0068 ]TIME[ 3H 13M 15S ]      **/
////
////    assert( (&T_E)==(&til_exp)/**@SAME_VAR_SAME_ADDR@**/ );
////    assert(   T_E ==  til_exp /**@SAME_VAR@**/           );
////    return(   T_E /** til_exp **/                        );
////////////////////////////////////////////////////////////////
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_astipix(
            U08     diagpix
    )
    {
        if( diagpix ){ /** @NOOP@ **/ };
        /** ************************************************ ***

            @VID_IID[ 0066 -to- 0071 ]TIME[ 00H 26M 24S ]
            @VID_IID[ 0071           ]TIME[ 03H 32M 30S ]

            Cannot make this function because
            aac2020_paint5d_astipix_CTO_diagpix(...)
            is a one-way conversion.

            BECAUSE WE HAVE INFORMATION LOSS WHEN
            [FUNNELING / CONVERTING] DOWN TO[ diagpix ]
            WE CANNOT DO A @BACK_AND_FORTH_CONVERSION_TEST@

        *** ************************************************ **/
        ERR("[CANNOT_MAKE_SUCH_FUNCTION:diagpix_CTO_astipix]");

        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_astipix_CTO_diagpix(
            U08     astipix
    )
    {
        U08 diagpix=( 0 );

        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 03H 47M 50S ]              **/
        /** SEE:FILE[ PAINT5D.D._]SECTION[ PAINT5D_DATA ]    **/
        /**      VAR[ aac2020_paint5d_POT_diagpix       ]    **/
        /**  DIAGRAM[ #_DIA_SELECTED_TIL_QUA_#          ]    **/
        /**                                                  **/
        /** astipix : Auset_Sub_TIle: PIXel (location:[X|Y]) **/
        /** diagpix : DIAGonal_PIXels .......................**/
        /**                                                  **/
        /** @VID_IID[ 0078 ]TIME[ 00H 49M 03S ]              **/
        /** In retrospect.. You don't know what the hell     **/
        /** you are doing. "lil" (last index less than )     **/
        /** should probably be "fil" (first index less than).**/
        /** ************************************************ **/

        U08 fil  =( 0 ); //: fil == "First_Index_Lessthan"
        U08 found=( 0 ); //: has fil been found yet?

                         
        #if( AAC2020_CRASH_ON_NIAVE_CODE >= 1 ) //:##########://

            #error REWRITE_THIS_WITHOUT_GUESS_AND_CHECK

        #endif //:###########################################://

        for( I32 i = 0 ; i <= 9 ; i++ ){
            if( 0 == found ){
            if( astipix < aac2020_paint5d_POT_diagpix[ i ] ){ 
                fil   =   i    ; 
                found =( 0xFF );
            };;};;
        };;
           
        if( fil >= 1 ){
            /** OKAY! ---------------------- **/
            /** First Comparison Should      **/
            /** never be true, so we should  **/
            /** always have an "fil" of      **/
            /** at least one( 1 )            **/
            /** ---------------------------- **/    

            diagpix=( aac2020_paint5d_POT_diagpix[ fil - 1 ] );
        }else{

            if( 255 == astipix ){

                /** @UGLY_HACK@ ******************* **/
                /** Edge case. Exponent 8 Locates   **/
                /** The config pixel at bottom left **/
                /** ONLY ONE POSSIBLE LOCATION FOR  **/
                /** THIS SINGLE PIXEL... 255        **/
                diagpix = 255; /** **************** **/

            }else{

                printf("[astipix]:%d\n",astipix);
                printf("[::found]:%d\n",  found);
                printf("[::::fil]:%d\n",    fil);
                ERR("[ASSERT_FAIL:fil>=1]");

            };;
        };;

        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  POT                                           //: 01 ://
#undef  T_E                                           //: 02 ://
#undef  BRK                                           //: 03 ://
#undef  CAS                                           //: 04 ://
#undef  DEF                                           //: 05 ://
#undef  S_A                                           //: 06 ://
#undef  U08                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  ERR                                           //: 09 ://
//:==============================:HELPER_FUNCTIONS:CONVERSION://
//:QUARKMAP_COORD_CONVERSIONS:===============================://
#define U08   uint8_t /** GCC: <stdint.h> **/         //: 01 ://
#define U16  uint16_t /** GCC: <stdint.h> **/         //: 02 ://
#define I16   int16_t /** GCC: <stdint.h> **/         //: 03 ://
#define RES  restrict                                 //: 04 ://
#define MIN  aac2020_paint5d_Min_I16                  //: 05 ://
#define ERR  aac2020_paint5d_Halt                     //: 06 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_glocpix_CTO_painpix(
        U08*  RES  til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08*  RES  til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08*  RES  til_lay /** TileLayer .................   **/
    ,   U08*  RES  loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08*  RES  loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16        glo_t_x /** Global Tile X Coord           **/
    ,   I16        glo_t_y /** Global Tile X Coord           **/
    )
    {
        /** Why output parameters at the start of signature? **/
        /** @VID_IID[ 0067]TIME[ 3H 56M 45S ] .............. **/

        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != til_qua ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_exp ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_lay ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_x ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_y ); /** ! OUTPUTS ! **/

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://

            assert( AAC2020_PAINT5D_MAX_glo_t_x >= glo_t_x );
            assert( AAC2020_PAINT5D_MAX_glo_t_y >= glo_t_y );
            assert(                0            <= glo_t_x );
            assert(                0            <= glo_t_y );
  
        //:------------------------------:bounds_check_inputs://
        //:configuration_pixel_coords_are_invalid:-----------://
        #define NOW aac2020_paint5d_unit_test_is_running_now

            U08 ocp =( 0 ); /** On_Configuration_Pixel? **/
            if( 255 == glo_t_x && 255 == glo_t_y ){ ocp=( 1 );};
            if( 511 == glo_t_x && 255 == glo_t_y ){ ocp=( 1 );};
            if( 255 == glo_t_x && 511 == glo_t_y ){ ocp=( 1 );};
            if( 511 == glo_t_x && 511 == glo_t_y ){ ocp=( 1 );};
            if( ocp >= 1 ){
            
                if( NOW >= 1 ){
                    printf("[aac2020_paint5d_CTF]%s\n"
                            ,aac2020_paint5d_CTF );;

                    printf("[aac2020_paint5d_CTS]%s\n"
                            ,aac2020_paint5d_CTS );;
                };;

                ERR("[YOU_ARE_ON_A_CONFIGURATION_PIXEL_2021]");
            };;

        #undef NOW
        //:-----------:configuration_pixel_coords_are_invalid://
        //:Get_Variables_Ready_To_Work_With:-----------------://

            I16 i16_til_qua =( 0 - 1001 );
            I16 i16_til_exp =( 0 - 1001 );
            I16 i16_til_lay =( 0 - 1001 );
            I16 i16_loc_t_x =( 0 - 1001 );
            I16 i16_loc_t_y =( 0 - 1001 );

            I16 i16_gtx =( (I16)( glo_t_x ) );
            I16 i16_gty =( (I16)( glo_t_y ) );

            I16 rem_i_x =( 0 - 2002 ); /** Remainder: X      **/
            I16 rem_i_y =( 0 - 2002 ); /** Remainder: Y      **/

            I16 o_x_qua =( 0 - 2002 ); /** XY Location Of    **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua           **/

            I16 diagp_x =( 0 - 2002 ); /** diagpix.x         **/
            I16 diagp_y =( 0 - 2002 ); /** diagpix.y         **/
            I16 diagpix =( 0 - 2002 ); /** diagonal_pixels   **/

            I16 o_x_lay =( 0 - 2002 ); /** XY Location of    **/
            I16 o_y_lay =( 0 - 2002 ); /** til_lay           **/

            I16 bip_sip =( 0 - 2002 ); /** BItmap_Partition  **/
                                       /** Span_In_Pixels    **/

            I16 max_cor =( 0 - 2002 ); /** Bounds Checking   **/
        
        //:-----------------:Get_Variables_Ready_To_Work_With://
        //:Calculate:2D_XY_LOCATIONS:------------------------://
        #define AST_CTO_DIA  aac2020_paint5d_astipix_CTO_diagpix

            //:CALC_AND_REBASE_LOCAL:til_qua:----------------://
            //:                      o_x_qua                 ://
            //:                      o_y_qua                 ://

                /** @CALC@ **/
                o_x_qua = ( i16_gtx / 256 );
                o_y_qua = ( i16_gty / 256 ); //:<<<<<<<<<<<<<<<<<<<<< o_x , o_y change to c_x , c_y for "cell" instead of offset.

                /** @REBASE_LOCAL@ **/
                rem_i_x = i16_gtx - ( o_x_qua * 256 );
                rem_i_y = i16_gty - ( o_y_qua * 256 );

                assert( rem_i_x >=   0 );
                assert( rem_i_y >=   0 );
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );

                /** **************************************** ***

                [ rem_i_x , rem_i_y ] is now LOCAL to
                #_DIA_SELECTED_TIL_QUA_#
                @VID_IID[ 0068 ]TIME[ 2H 32M 10S ]

                [ rem_i_x , rem_i_y ] == ( astipix )
                At this PLACE in the code.
                @VID_IID[ 0068 ]TIME[ 2H 40M 00S ]

                *** **************************************** **/

            //:                                       o_x_qua://
            //:                                       o_y_qua://
            //:----------------:CALC_AND_REBASE_LOCAL:til_qua://
            //:CALC_AND_REBASE_LOCAL:til_exp:----------------://
            //:                  i16_til_exp                 ://

                /** astipix : Auset_Sub_TIle:PIXel(loc:[X|Y])**/
                /** diagpix : DIAGonal_PIXels ...............**/

                diagp_x = AST_CTO_DIA( rem_i_x ); //:diagpix.x
                diagp_y = AST_CTO_DIA( rem_i_y ); //:diagpix.y
                diagpix = MIN( diagp_x , diagp_y );

                /** @CALC@ **/
                                        i16_til_exp=((U16)(
                aac2020_paint5d_diagpix_CTO_til_exp(
                        (  (U08)diagpix  )        
                )));;

                /** @REBASE_LOCAL@ **/
                rem_i_x =( rem_i_x - diagpix );
                rem_i_y =( rem_i_y - diagpix );

            //:                                   i16_til_exp://
            //:----------------:CALC_AND_REBASE_LOCAL:til_exp://
            //:CALC_AND_REBASE_LOCAL:til_lay:----------------://

                //:  @VID_IID[ 0072 ]TIME[ 01H 00M 15S ]     ://
                //:  1D: [      til_lay      ]   ............://
                //:  2D: [ o_x_lay , o_y_lay ]   ............://

                bip_sip =( 
                    aac2020_paint5d_til_exp_CTO_bip_sip(
                                i16_til_exp             ));;
                
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );
                
                /** @CALC@ **/
                o_x_lay =( rem_i_x / bip_sip );
                o_y_lay =( rem_i_y / bip_sip );
                
                assert( o_x_lay >= 0 && o_x_lay <= 1 );
                assert( o_y_lay >= 0 && o_y_lay <= 1 );
                
                if( 1
                &&  1 == o_x_lay
                &&  1 == o_y_lay
                ){
                    ERR("[DIAGONAL_QUAD_IS_FOR_NESTING]");
                };;

                /** @REBASE_LOCAL@ **/
                rem_i_x = ( rem_i_x - ( o_x_lay * bip_sip ) );
                rem_i_y = ( rem_i_y - ( o_y_lay * bip_sip ) );

            //:----------------:CALC_AND_REBASE_LOCAL:til_lay://
            //:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]:------://

                max_cor =(
                    aac2020_paint5d_til_exp_CTO_max_cor(
                        (  (U08)i16_til_exp  )          ));;
                
                assert( rem_i_x >= 0 );
                assert( rem_i_y >= 0 );
                assert( rem_i_x <= max_cor );
                assert( rem_i_y <= max_cor );

                i16_loc_t_x = ( rem_i_x );
                i16_loc_t_y = ( rem_i_y );

            //:------:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]://

        #undef  AST_CTO_DIA
        //:------------------------:Calculate:2D_XY_LOCATIONS://
        //:Calculate:1D_INDEX_LOCATIONS:---------------------://
        #define TIL_QUA_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/
        #define TIL_LAY_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 00H 08M 40S ] 
                SAN == SPAN , means WID == HIG
                Use this variable to preserve the
                balance of tokens in our code.
            *** ******************************************** **/
        
            i16_til_qua = o_x_qua + ( TIL_QUA_SAN * o_y_qua);
        //: i16_til_exp =( ALREADY_CALCULATED_MY_FRIEND     );
            i16_til_lay = o_x_lay + ( TIL_LAY_SAN * o_y_lay);
        //: i16_loc_t_x =( ALREADY_CALCULATED_MY_FRIEND     );
        //: i16_loc_t_y =( ALREADY_CALCULATED_MY_FRIEND     );

        #undef  TIL_QUA_SAN  
        #undef  TIL_LAY_SAN  
        //:---------------------:Calculate:1D_INDEX_LOCATIONS://
        //:RETURN_VIA_OUTPUT_PARAMETERS:---------------------://

            assert(             i16_til_qua >=   0 ); //: 01 ://
            assert(             i16_til_exp >=   0 ); //: 02 ://
            assert(             i16_til_lay >=   0 ); //: 03 ://
            assert(             i16_loc_t_x >=   0 ); //: 04 ://
            assert(             i16_loc_t_y >=   0 ); //: 05 ://

            assert(             i16_til_qua <= 255 ); //: 01 ://
            assert(             i16_til_exp <= 255 ); //: 02 ://
            assert(             i16_til_lay <= 255 ); //: 03 ://
            assert(             i16_loc_t_x <= 255 ); //: 04 ://
            assert(             i16_loc_t_y <= 255 ); //: 05 ://

            (*til_qua)=(  (U08) i16_til_qua        ); //: 01 ://
            (*til_exp)=(  (U08) i16_til_exp        ); //: 02 ://
            (*til_lay)=(  (U08) i16_til_lay        ); //: 03 ://
            (*loc_t_x)=(  (U08) i16_loc_t_x        ); //: 04 ://
            (*loc_t_y)=(  (U08) i16_loc_t_y        ); //: 05 ://

        //:---------------------:RETURN_VIA_OUTPUT_PARAMETERS://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_painpix_CTO_glocpix(
        U08        til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08        til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08        til_lay /** TileLayer .................   **/
    ,   U08        loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08        loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16*  RES  glo_t_x /** Global Tile X Coord           **/
    ,   I16*  RES  glo_t_y /** Global Tile X Coord           **/
    )
    {
        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != glo_t_x );
            assert( ((void*)0) != glo_t_y );

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://
        #define ASS assert 

            if( 8 == til_exp ){

                //:TODO: Enumeration to tell us what unit
                //:      test is currently being ran.
                printf("[UTS]:%s\n", aac2020_paint5d_CTS );
                printf("[UTF]:%s\n", aac2020_paint5d_CTF );
                printf("[BAD:T_E:painpix_CTO_glocpix]\n");
                ERR("[NOW_CRASHING_2021]");
            };;

            ASS( AAC2020_PAINT5D_MAX_til_qua ==    3    );
            ASS( AAC2020_PAINT5D_MAX_til_exp ==    7    );
            ASS( AAC2020_PAINT5D_MAX_til_lay ==    2    );

            ASS( AAC2020_PAINT5D_MAX_til_qua     >= til_qua );
            ASS( AAC2020_PAINT5D_MAX_til_exp     >= til_exp );
            ASS( AAC2020_PAINT5D_MAX_til_lay     >= til_lay );

            U08  /* max_cor */                max_cor =(
                ( aac2020_paint5d_til_exp_CTO_max_cor( 
                                  til_exp )));;

            ASS( max_cor >=        loc_t_x          );
            ASS( max_cor >=        loc_t_y          );
            ASS(    0    <= (((I16)loc_t_x)+0)      );
            ASS(    0    <= (((I16)loc_t_y)+0)      );

        #undef  ASS   
        //:------------------------------:bounds_check_inputs://
        //:declare_all_variables:----------------------------://

            I16 tempi_x =( 0 - 1001 ); /** temp_integer: x   **/
            I16 tempi_y =( 0 - 1001 ); /** temp_integer: y   **/

            I16 o_x_qua =( 0 - 2002 ); /** til_qua.x **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua.y **/

            I16 diagpix =( 0 - 3003 );

            I16 o_x_lay =( 0 - 4004 ); /** til_lay.x **/
            I16 o_y_lay =( 0 - 4004 ); /** til_lay.y **/

            I16 i16_gtx =( 0 - 5005 ); /** glo_t_x  AS  I16 **/
            I16 i16_gty =( 0 - 5005 ); /** glo_t_y  AS  I16 **/

            /** @VID_IID[ 0067 ]TIME[ 4H 25M 20S ]       **/
            /** I16 is         ENOUGH addressing space.  **/
            /** U08 is __NOT__ ENOUGH addressing space.  **/
    
        //:----------------------------:declare_all_variables://
        //:CALCULATE:painpix_CTO_glocpix:--------------------://

            tempi_x =  til_qua         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_qua-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_qua = ( tempi_x * 256 ); /** offset_x_QUA **/
            o_y_qua = ( tempi_y * 256 ); /** offset_y_QUA **/
            
            /** diagpix: DIAgonal_PIXels (offset) **/
            diagpix =(I16)( aac2020_paint5d_til_exp_CTO_diagpix( 
                                            til_exp ) );;

            tempi_x =  til_lay         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_lay-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_lay = ( tempi_x * ( max_cor + 1 ) );
            o_y_lay = ( tempi_y * ( max_cor + 1 ) );

                //:error_check_range_of_temp:----------------://
                assert( tempi_x >= 0 && tempi_x <= 1 );
                assert( tempi_y >= 0 && tempi_y <= 1 );
                if( 1
                &&  1 == tempi_x
                &&  1 == tempi_y
                ){
                    ERR("[BOTH_CELL_COORDS_CANNOT_BE_ONE]");
                };;
                //:----------------:error_check_range_of_temp://

            i16_gtx=( o_x_qua + diagpix + o_x_lay + loc_t_x );
            i16_gty=( o_y_qua + diagpix + o_y_lay + loc_t_y );
            assert( i16_gtx >= 0 && i16_gtx <= ( 512 - 1 ) );
            assert( i16_gty >= 0 && i16_gty <= ( 512 - 1 ) );
            (*glo_t_x)=(  (U16)( i16_gtx )  );
            (*glo_t_y)=(  (U16)( i16_gty )  );

        //:--------------------:CALCULATE:painpix_CTO_glocpix://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  U16                                           //: 02 ://
#undef  I16                                           //: 03 ://
#undef  RES                                           //: 04 ://
#undef  MIN                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:===============================:QUARKMAP_COORD_CONVERSIONS://
//:PIXEL_BIT_PACKING:========================================://
//:@VID_IID[ 0080 ]TIME[ 01:02:20 ]==========================://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 01 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 02 ://
#define ERR aac2020_paint5d_Halt                      //: 03 ://

    U08
 //:aac2020_paint5d_Put_BitPack <--- @CTRL_F_HELP@
    aac2020_paint5d_BitPack_Put(
        U08* cpu_pix //: AAC2020_PIXNAME_paint5d_cpu_pix     ://
    ,   U08  glo_com //: Component Index. Divisible By 4.    ://
    ,   U08  aus_dex //: Auset Index: 0-to-15 inclusive.     ://
    ,   U08  til_val //: <-- Value To Put                    ://
    )
    {
        //:input_checks:-------------------------------------://
            if( ((U08*)0) == cpu_pix ){
                ERR("[NULL_CPU_PIX_2021_820PM]");
            };;

            /** Assertion is only valid if we are NOT unit   **/
            /** testing. @VID_IID[ 0081 ]TIME[ 00:27:46 ]    **/
            if( aac2020_paint5d_unit_test_is_running_now <= 0 ){

                if( cpu_pix != AAC2020_PIXNAME_paint5d_cpu_pix){
                    /**  NE: Not Equal **/
                    ERR("[CPU_PIX_NE_PAINT5D____BITPACK_PUT]");
                };;
            };;

            if( ( 0 != glo_com % 4 ) ){
                /** @VID_IID[ 0081 ]TIME[ 00:47:40 ]         **/
                /** Component index should be divisible by 4 **/

                printf("[glo_com]:%d\n" , glo_com );

                ERR("[GLO_COM____NOT_DIV_BY_4____BITPACK_PUT]");
            };;

        //:-------------------------------------:input_checks://
        //:variable_declaration(s):--------------------------://

            U08 old_val ; //: <-- previous bit value stored.
            I32 arr_dex ;
            U08 var_u08 ;
            I32 aus_loc ; //: AUSet_LOCal (Bitpacking_Index)
                          //: LOC != LOCATION
                          //: LOC == LOCAL
            /** set trap values **/
            old_val = ( 0 + 202 );
            arr_dex = ( 0 - 333 );
            var_u08 = ( 0 + 202 );
            aus_loc = ( 0 - 333 );

        //:--------------------------:variable_declaration(s)://
        //:bit_packing_stuff:--------------------------------://
        #define BIN_011 3 /** 2 set bits in a row **/
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
                arr_dex =(         glo_com + 3 );
                var_u08 = cpu_pix[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
                arr_dex =(         glo_com + 2 );
                var_u08 = cpu_pix[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
                arr_dex =(         glo_com + 1 );
                var_u08 = cpu_pix[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

                arr_dex =(         glo_com + 0 );
                var_u08 = cpu_pix[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:PUT]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 3H 38M 10S ]BEG
                @VID_IID[ 0072 ]TIME[ 3H 46M 09S ]END
    
                Bit packing logic to ONLY CHANGE the bits
                where the new value needs to be stored.
                We need to erase the bits in the proper
                position by masking ( & ). Then merge the bits
                together by using a bitwise or. ( | )

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );
    
            cpu_pix[ arr_dex ]=(

                /**  11001111 <-- Conceptually:if:aus_loc==2**/
                ( var_u08 &  (~(  BIN_011 << ( aus_loc*2 ) )) )

                |  //:<-- Bitwise Or to merge together

                /**  00110000 <-- Conceptually:if:aus_loc==2**/
                /** Slide Delta Bits Into Position **/
                ( til_val                 << ( aus_loc*2 )    )

            );;

        #undef  BIN_011 /* <-- NEEDED: binary [ 11 ] 2 bits   */
        #undef  CPU_PIX /* <-@KFR@VID_IID[ 0083 ]T[ 1:55:55 ] */
        //:--------------------------------:bit_packing_stuff://

        /** return the value that was overwritten by         **/
        /** til_val. This is necessary for the toggleTile    **/
        /** functionality. @VID_IID[ 0081 ]TIME[ 01:04:33 ]  **/
        return( old_val );
    }
    
    void
 //:aac2020_paint5d_Get_BitPack <--- @CTRL_F_HELP@
    aac2020_paint5d_BitPack_Get(
        U08* cpu_pix //: AAC2020_PIXNAME_paint5d_cpu_pix     ://
    ,   U08  glo_com //: Component Index. Divisible By 4.    ://
    ,   U08  aus_dex //: Auset Index: 0-to-15 inclusive.     ://
    ,   U08* til_val //: <-- Value To Get                    ://
    )
    {
        //:input_checks:-------------------------------------://
       
            //:input_checks:refs_cannot_be_null:-------------://

                if( ((U08*)0) == til_val ){
                    ERR("[NULL_REF:til_val:2021]");
                };;

            //:-------------:input_checks:refs_cannot_be_null://
            //:input_checks:everything_else:-----------------://
            #define ING aac2020_paint5d_unit_test_is_running_now
            #define P5D_CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        
                /** @VID_IID[ 0083 ]TIME[ 1H 45M 35S ]       **/
                /** Cleaned up this section of input checks. **/

                if( ((U08*)0) == cpu_pix ){
                    ERR("[NULL_CPU_PIX_2021_TEN-FOURTEEN_PM]");
                };;

                /** Assertion only valid if we are NOT unit  **/
                /** testing. @VID_IID[ 0081 ]TIME[ 00:27:46 ]**/
                if( ING /** Running ? **/ <= 0 ){

                    if( cpu_pix != P5D_CPU_PIX){
                        /** NE: Not Equal **/
                        ERR("[CPU_PIX_NE_PAINT5D_BITPACK_GET]");
                    };;
                };;

                if( ( 0 != glo_com % 4 ) ){
                    /** @VID_IID[ 0081 ]TIME[ 00:47:40 ]     **/
                    /** Component index is DIVISIBLE by 4    **/
                    ERR("[glo_com__NOT__div_by_4_bitpack_GET]");
                };;

            #undef ING  
            #undef P5D_CPU_PIX
            //:-----------------:input_checks:everything_else://

        //:-------------------------------------:input_checks://
        //:variable_declaration(s):--------------------------://

            U08 old_val ; //: <-- previous bit value stored.
        /// I32 arr_dex ;
            U08 var_u08 ;
            I32 aus_loc ; //: SEE[ @aus_loc ]IN[ PAINT5D.D._ ]
                          //: [ @aus_loc ]IN[ #DIA_P5D_MAIN# ]
                          //: AUSet_LOCal (Bitpacking_Index)
                          //: LOC != LOCATION
                          //: LOC == LOCAL
            /** set trap values **/
            old_val = ( 0 + 202 );
        /// arr_dex = ( 0 - 333 );
            var_u08 = ( 0 + 202 );
            aus_loc = ( 0 - 333 ); 

        //:--------------------------:variable_declaration(s)://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
        ////    arr_dex =(         glo_com + 3 );
                var_u08 = cpu_pix[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
        ////    arr_dex =(         glo_com + 2 );
                var_u08 = cpu_pix[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
        ////    arr_dex =(         glo_com + 1 );
                var_u08 = cpu_pix[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

        ////    arr_dex =(         glo_com + 0 );
                var_u08 = cpu_pix[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:GET]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 4H 08M 50S ]
                We can nuke most of the bit shifting
                code copied from the "Put(..)" function
                and just keep the fetch of "old_val".
                "old_val" is the value we want to load
                into the output parameter "til_val".

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );

        #undef  CPU_PIX //: <-- Reference @VID_IID[ 0083  ]  ://
        #undef  BIN_011 //: <-- Reference @TIME[ 01:53:20 ]  ://
        //:--------------------------------:bit_packing_stuff://
        //:return_old_val:-----------------------------------://

            (*til_val)=( old_val );

        //:-----------------------------------:return_old_val://
        return;
    }

#undef  U08                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
//:=========================:@VID_IID[ 0080 ]TIME[ 01:02:20 ]://
//:========================================:PIXEL_BIT_PACKING://
//:PAINT5D_QUARKMAP_GET_PUT:=================================://
//:PAINT5D_QUARKMAP_PUT_GET:=================================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define I16  int16_t /** GCC: <stdint.h> **/          //: 02 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 03 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 04 ://
#define ERR aac2020_paint5d_Halt                      //: 05 ://

    /** #_WHAT_IS_THE_QUARKMAP_# * * * * *  **/
    /** @VID_IID[ 0067 ]TIME[ 00H 52M 23S ] **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    #if( AAC2020_CRASH_ON_VITAL_TODO >= 1 ) //:##############://

        #error TEST THE BIT PACKING LOGIC IN ISOLATION

    #endif //:###############################################://

    U08
    AAC2020_PAINT5D_Put(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08  til_val   /** [ val_cur / til_val ]          ...**/
        //[ SAME_PARAM_ORDER_AS[ PAINT5D_Put_BrushState ]    ]//
        //[ @VID_IID[ 0076 ]TIME[ 6H 00M 00S ]               ]//
    )
    {
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            /** @VID_IID[ 0072 ]TIME[ 03H 07M 30S ]    ......**/
            /** til_val commentary is the decimal and  ......**/
            /** binary representations of it's values. ......**/

            if( til_exp >= 8 ){

                printf("[aac2020_paint5d_CTF]:%s\n"
                        ,aac2020_paint5d_CTF );;

                printf("[aac2020_paint5d_CTS]:%s\n"
                        ,aac2020_paint5d_CTS );;

                printf("[til_exp]:%d\n", til_exp );
                ERR("[TILE_EXPONENT_IS_OUT_OF_BOUNDS_2021]");
            };;

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );
            assert( til_val <=   3 );/**[  0 |  1 |  2 |  3 ]**/
                                     /**[ 00 | 01 | 10 | 11 ]**/

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );

                /** @VID_IID[ 0078 ]TIME[ 1H 34M 50S ]  **** **/
                /** 16 bits:enough for [ glo_t_x , glo_t_y ] **/
                /** NOT ENOUGH FOR GLOBAL INDEXES.           **/
                /** **************************************** **/

            I32 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I32 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I32 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
    ////    U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
    ////    U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(      111  /** Prev til_val **/ );
                                     /** @TRAP_VALUE@ **/

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            //: CANNOT USE 0xFFFF to store glo_com.
            //: Not enought bits. Not even enough
            //: bits for glo_dex.
            assert( 512 * 512 * 4 > 0xFFFF ); //:max: glo_com
            assert( 512 * 512 * 1 > 0xFFFF ); //:max: glo_dex

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );
    
            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                U08 a_1; /** Assert #1 **/
                U08 a_2; /** Assert #2 **/
                a_1 =(       chk_glo_com  == ((U32)glo_com) );
                a_2 =( ((I32)chk_glo_com) == (     glo_com) );
                if( (!a_1) || (!a_2) ){
                    printf("[a_1]:%d\n", a_1 );
                    printf("[a_2]:%d\n", a_2 );

                    printf("[chk_glo_com]:%d\n" , chk_glo_com);
                    printf("[    glo_com]:%d\n" ,     glo_com);

                    U32 i32_chk =  ((I32)chk_glo_com) ;
                    U32 u32_glo =  ((U32)    glo_com) ;

                    printf("[i32_chk]:%d\n" , i32_chk);
                    printf("[u32_glo]:%d\n" , u32_glo);

                    ERR("[EVERYONE_PANIC_AND_HIT_THE_FLOOR]");
                };;
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM___TAG[ #DIA_P5D_MAIN# ]
                SEE_DIAGRAM_LABEL[ @P5D_AUS_BITS@ ]
                FROM_________FILE[ PAINT5D.D._    ]
            *** ******************************************** **/

            old_val=( 
            aac2020_paint5d_BitPack_Put(
                CPU_PIX //: U08* :  PIXNAME_paint5d_cpu_pix  ://
            ,   glo_com //: U08  :  Component Index. @DIV_B4@://
            ,   aus_dex //: U08  :  Auset Index: [0 - 15]    ://
            ,   til_val //: U08  :  <-- Value To Put         ://    
            ));;
      

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://

        /** If the tile value we set down was different than **/
        /** It was previously, maybe we should return        **/
        /** a ONE( 1 ) to signify that.                      **/
        return( til_val != old_val );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Get(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08* til_val   /** [ val_cur / til_val ]          ...**/
    )
    {
        /** ************************************************ **/
        /** NOTE: This code is almost a cut+paste of         **/
        /**       the "Put" code. The "old_val" variable     **/
        /**       from the "Put" code is what we want        **/
        /**       to return from this function via           **/
        /**       an OUTPUT PARAMETER.                       **/
        /** ************************************************ **/
        //:references_are_never_null:------------------------://

            assert( ((void*)0) != til_val );

        //:------------------------:references_are_never_null://
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            if( til_qua >= 4 ){
            #define NOW aac2020_paint5d_unit_test_is_running_now

                //: @VID_IID[ 0083 ]TIME[ 05:07:40S ]
                //:Valid Quadrants:
                //:   0 : TOP LEFT
                //:   1 : TOP RIGHT
                //:   2 : BOT LEFT
                //:   3 : BOT RIGHT

                printf("[aac2020_paint5d_CTF]:%s\n"
                        ,aac2020_paint5d_CTF );;

                printf("[aac2020_paint5d_CTS]:%s\n"
                        ,aac2020_paint5d_CTS );;

                printf("[AAC2020_PAINT5D_Get:HAS_BAD_NEWS]\n");
                ERR("[TIL_QUA_IS_POSITIVE_OUT_OF_BOUNDS_2021]");

            #undef NOW
            };;

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );

            /** 16 bits is not enough room !!!!!!!!! **/
            I32 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I32 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I32 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
    ////    U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
    ////    U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

    ////    U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );

            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                assert(       chk_glo_com  == ((U32)glo_com) );
                assert( ((I32)chk_glo_com) == (     glo_com) );
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

           aac2020_paint5d_BitPack_Get(
                CPU_PIX //: U08* :  PIXNAME_paint5d_cpu_pix  ://
            ,   glo_com //: U08  :  Component Index. @DIV_B4@://
            ,   aus_dex //: U08  :  Auset Index: [0 - 15]    ://
            ,&(*til_val)//: U08* :  <-- GET OUTPUT PARAMETER ://
            );;

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://
        //:return_via_output_param:--------------------------://

            /** ******************************************** ***
            til_val | old_val : DECIMAL [  0 |  1 |  2 |  3 ]   
            til_val | old_val : BINARY  [ 00 | 01 | 10 | 11 ]   
            *** ******************************************** **/

            //: (*til_val)=( old_val );                      ://
            //: Now set using: aac2020_paint5d_BitPack_Get   ://
 
        //:--------------------------:return_via_output_param://
        
        return; //:<---- Return Via Output Param
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  I16                                           //: 02 ://
#undef  I32                                           //: 03 ://
#undef  U32                                           //: 04 ://
#undef  ERR                                           //: 05 ://
//:=================================:PAINT5D_QUARKMAP_GET_PUT://
//:=================================:PAINT5D_QUARKMAP_PUT_GET://
//:OPEN_GL_PAINT5D_Get:======================================://
//:OPEN_GL_PAINT5D_painpix_CTO_glocpix:======================://

    /** @VID_IID[ 0085 ]TIME[ 01:04:20 ] ************ **/
    /** We want this code to be written in a way that **/
    /** it can be cut+paste easily into our GLSL      **/
    /** shaders with minimal changes.                 **/
    /** ********************************************* **/

    /** contains: aac2020_P5D_OGL_UnitTest **/
    #include "./OPEN_GL_HAKCODE/P5D_OGL._"

//:======================:OPEN_GL_PAINT5D_painpix_CTO_glocpix://
//:======================================:OPEN_GL_PAINT5D_Get://
//:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS:==================://
//:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD:=======================://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 03 ://
#define ERR  aac2020_paint5d_Halt                     //: 04 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Get_BrushState( void )
    {   
        //: @CTRL_F_HELP: aac2020_paint5d_BrushState_Get ://

        //: @VID_IID[ 0077 ]TIME[ 01H 20M 14S ]
        //:IDN_A_HF_FM_HF
        //:I_DONT_NEED_A_HELPER_FUNCTION_FOR_MY_HELPER_FUNCTION
        ERR("[IDN_A_HF_FM_HF:YEAR:2021]");
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Put_BrushState(

        /** @VID_IID[ 0076 ]TIME[ 5H 45M 00S ] ************* **/
        /** Inputs are I32 instead of their range of         **/
        /** U08 because they will have to be upcasted to     **/
        /** U32 anyways, so why not use I32 so we can        **/
        /** have better range checking debugs?               **/
        /** ************************************************ **/
        I32 t_q //: 01 : til_qua  : Tile Quadrant
    ,   I32 t_e //: 02 : til_exp  : Tile Exponent  
    ,   I32 t_l //: 03 : til_lay  : Tile Layer  
    ,   I32 l_x //: 04 : loc_t_x  : Local Tile Location X  
    ,   I32 l_y //: 05 : loc_t_y  : Local Tile Location Y  
    ,   I32 a_d //: 06 : aus_dex  : AUSet_inDEX  
    ,   I32 t_v //: 07 : til_val  : Tile Value  
                //[      til_val is the LAST parameter       ]//
                //[      because this is the parameter order ]//
                //[      of the function AAC2020_PAINT5D_Put ]//
                //[      @VID_IID[ 0076 ]TIME[ 05H 57M 55S ] ]//
    )
    {
        /** @VID_IID[ 0077 ]TIME[ 5H 42M 00S ] ************* **/
        /** Set Unused Values 1,2,3 to ALL ONE BITS  ....... **/
        /** So that they ensure a memory stomp if    ....... **/
        /** our code makes a mistake as to where     ....... **/
        /** to put the bits.                         ....... **/
        /**        0xRrGgBbAb                        ....... **/
        U32 u_1 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #1 **/
        U32 u_2 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #2 **/
        U32 u_3 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #3 **/
        /** ************************************************ **/

        //:7_brush_vars_bounds_check:INPUTS:-----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://

            I32 max_l_x =( 0 - 1230123 );
            I32 max_l_y =( 0 - 1230123 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            assert( t_q >= 0 && t_q <= MAX_t_q );     //: 01 ://
            assert( t_e >= 0 && t_e <= MAX_t_e );     //: 02 ://
            assert( t_l >= 0 && t_l <= MAX_t_l );     //: 03 ://
            assert( l_x >= 0 && l_x <= max_l_x );     //: 04 ://
            assert( l_y >= 0 && l_y <= max_l_y );     //: 05 ://
            assert( a_d >= 0 && a_d <= MAX_a_d );     //: 06 ://
            assert( t_v >= 0 && t_v <= MAX_t_v );     //: 07 ://
                                                             
        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        //////  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        #undef  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:-----------------:7_brush_vars_bounds_check:INPUTS://
        //:7_brush_vars_int_overflow_chk:INPUTS:-------------://

            /** Make sure a DOWNCAST and then UPCAST         **/
            /** truncates the U32 to only 8 set bits max.    **/

            assert(    (U32)(U08)0xFFFFFFFF <= 0xFF  );

            assert(  ( (I32)(U08)t_q ) == t_q );      //: 01 ://
            assert(  ( (I32)(U08)t_e ) == t_e );      //: 02 ://
            assert(  ( (I32)(U08)t_l ) == t_l );      //: 03 ://
            assert(  ( (I32)(U08)l_x ) == l_x );      //: 04 ://
            assert(  ( (I32)(U08)l_y ) == l_y );      //: 05 ://
            assert(  ( (I32)(U08)a_d ) == a_d );      //: 06 ://
            assert(  ( (I32)(U08)t_v ) == t_v );      //: 07 ://

        //:-------------:7_brush_vars_int_overflow_chk:INPUTS://
        //:Put:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   (U32)t_q, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   (U32)t_e, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   (U32)t_l, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   (U32)l_x, u_1,u_2,u_3   //:    L_X ====== B_X
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   (U32)l_y, u_1,u_2,u_3   //:    L_Y ====== B_Y
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   (U32)a_d, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   (U32)t_v, u_1,u_2,u_3
            );;

        //:------------------------------:Put:All_Brush_State://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Put_UsingBrush( void )
    {
        //:Declare_Brush_State_Variables:--------------------://

            /** U32 values used with: "AAC2020_TAUDEPO_Get"  **/

            U32 t_q = ( /** til_qua **/ 1001001 /** @TRAP@ **/);
            U32 t_e = ( /** til_exp **/ 2002002 /** @TRAP@ **/);
            U32 t_l = ( /** til_lay **/ 3003003 /** @TRAP@ **/);
            U32 l_x = ( /** loc_t_x **/ 4004004 /** @TRAP@ **/);
            U32 l_y = ( /** loc_t_y **/ 5005005 /** @TRAP@ **/);
            U32 a_d = ( /** aus_dex **/ 6006006 /** @TRAP@ **/);
            U32 t_v = ( /** til_val **/ 7007007 /** @TRAP@ **/);

            /** U08 values used with: "AAC2020_PAINT5D_Put"  **/

            U08 til_qua = ( /** t_q **/ 101 /** @TRAP@ **/);
            U08 til_exp = ( /** t_e **/ 102 /** @TRAP@ **/);
            U08 til_lay = ( /** t_l **/ 103 /** @TRAP@ **/);
            U08 loc_t_x = ( /** l_x **/ 104 /** @TRAP@ **/);
            U08 loc_t_y = ( /** l_y **/ 105 /** @TRAP@ **/);
            U08 aus_dex = ( /** a_d **/ 106 /** @TRAP@ **/);
            U08 til_val = ( /** t_v **/ 107 /** @TRAP@ **/);

            /** @VID_IID[ 0077 ]TIME[ 2H 19M 50S ] **/
            /** KEEP_U_1_U_2_U_3_INITED_TO_ZERO    **/
            U32 u_1 =( 0 ); //:Unused #1
            U32 u_2 =( 0 ); //:Unused #2
            U32 u_3 =( 0 ); //:Unused #3

        //:--------------------:Declare_Brush_State_Variables://
        //:Get:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Get(        //:  001  ://
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   &(t_q),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  002  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   &(t_e),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  003  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   &(t_l),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  004  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   &(l_x),&(u_1),&(u_2),&(u_3) //:L_X ====== B_X
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  005  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   &(l_y),&(u_1),&(u_2),&(u_3) //:L_Y ====== B_Y
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  006  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   &(a_d),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  007  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   &(t_v),&(u_1),&(u_2),&(u_3)
            );;

        //:------------------------------:Get:All_Brush_State://
        //:7_brush_vars_bounds_check:OUTPUTS:----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://
        
        #define A assert

            U32 max_l_x =( 0 );
            U32 max_l_y =( 0 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            /** Range_Check_Extracted_Variables **/

            A( ((I32)t_q)+0 >= 0 && t_q <= MAX_t_q ); //: 01 ://
            A( ((I32)t_e)+0 >= 0 && t_e <= MAX_t_e ); //: 02 ://
            A( ((I32)t_l)+0 >= 0 && t_l <= MAX_t_l ); //: 03 ://
            A( ((I32)l_x)+0 >= 0 && l_x <= max_l_x ); //: 04 ://
            A( ((I32)l_y)+0 >= 0 && l_y <= max_l_y ); //: 05 ://
            A( ((I32)a_d)+0 >= 0 && a_d <= MAX_a_d ); //: 06 ://
            A( ((I32)t_v)+0 >= 0 && t_v <= MAX_t_v ); //: 07 ://
                        
        #undef  A

        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        #undef  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        //////  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:----------------:7_brush_vars_bounds_check:OUTPUTS://
        //:7_brush_vars_int_overflow_chk:OUTPUTS-------------://

            /** overflow_check___AND___assignment **/

            til_qua = (         (U08)  t_q   );       //: 01 ://
            til_exp = (         (U08)  t_e   );       //: 02 ://
            til_lay = (         (U08)  t_l   );       //: 03 ://
            loc_t_x = (         (U08)  l_x   );       //: 04 ://
            loc_t_y = (         (U08)  l_y   );       //: 05 ://
            aus_dex = (         (U08)  a_d   );       //: 06 ://
            til_val = (         (U08)  t_v   );       //: 07 ://

            assert( til_qua == ( (U32) t_q ) );       //: 01 ://
            assert( til_exp == ( (U32) t_e ) );       //: 02 ://
            assert( til_lay == ( (U32) t_l ) );       //: 03 ://
            assert( loc_t_x == ( (U32) l_x ) );       //: 04 ://
            assert( loc_t_y == ( (U32) l_y ) );       //: 05 ://
            assert( aus_dex == ( (U32) a_d ) );       //: 06 ://
            assert( til_val == ( (U32) t_v ) );       //: 07 ://
     
        //:------------:7_brush_vars_int_overflow_chk:OUTPUTS://
        //:Call_Core_Command:::PUT:--------------------------://
        //:MAIN_DATA_INTERFACE:PUT:--------------------------://

            AAC2020_PAINT5D_Put(
    /*1*/       til_qua    /** Auset Tile Sub Quadrant Index **/
    /*2*/   ,   til_exp    /** TileExponent (TileSizeEnum)   **/
    /*3*/   ,   til_lay    /** TileLayer .................   **/
    /*4*/   ,   loc_t_x    /** Local Tile X Coord / b_x      **/
    /*5*/   ,   loc_t_y    /** Local Tile Y Coord / b_y      **/
    /*6*/   ,   aus_dex    /** AUSet_inDEX (AutoTileSetIndex)**/
    /*7*/   ,   til_val    /** [ val_cur / til_val ]         **/
            );;

        //:--------------------------:MAIN_DATA_INTERFACE:PUT://
        //:--------------------------:Call_Core_Command:::PUT://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  ERR                                           //: 04 ://
//:==================:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS://
//:=======================:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD://
//:FUNCTIONS_WIRED_INTO_KEYBOARD:============================://
//:TAU:UNIFORM_CONTROLLER_FUNCTIONS:=========================://
#define CAP aac2020_paint5d_i32_Cap_u32               //: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 03 ://
#define U16 uint16_t /** GCC: <stdint.h> **/          //: 04 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 05 ://
#define ERR aac2020_paint5d_Halt                      //: 06 ://

    void
    aac2020_paint5d_MoveCamera_XY(
        I32 tra_i_x  //: Amount to translate in pixels: X-axis
    ,   I32 tra_i_y  //: Amount to translate in pixels: Y-axis
    )
    {
        AAC2020_TAUTYPE_rec_inc_Tran_256(
            AAC2020_TAUDEPO.TAU_015  /** TAU Block Index     **/
        ,   AAC2020_TAUDEPO.PAINT5D  /** SubSystem ==PAINT5D **/
        ,   AAC2020_TAUDEPO.P5D_VP1  /** VP1: Viewport #1    **/
        ,   tra_i_x  /** TRAnslation_Integer_amount_X        **/
        ,   tra_i_y  /** TRAnslation_Integer_amount_Y        **/
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ZoomCamera(
        I32 zom_i32 //: Amount To Zoom In And Out In Pixels
    )
    {
        /** ************************************************ **/
        /** @VID_IID[ 0083 ]TIME[ 06:03:59 ]STARTED_COMMENT  **/
        /** @VID_IID[ 0083 ]TIME[ 06:06:10 ]SUMMARY          **/
        /**                                                  **/
        /** Camera for the paint5d editor should             **/
        /** be bounded to an area that is                    **/
        /** 256x256 smallest tiles in size.                  **/
        /** Camera position is going to always be in         **/
        /** units of the smallest tile size so that          **/
        /** the active brush size ( til_exp ) does           **/
        /** not alter the view of the camera.                **/
        /** ************************************************ **/

        AAC2020_TAUTYPE_rec_inc_ZoomPull_256(
            AAC2020_TAUDEPO.TAU_015  
        ,   AAC2020_TAUDEPO.PAINT5D  
        ,   AAC2020_TAUDEPO.P5D_VP1  
        ,   zom_i32  
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_MoveBrush_XY(
        I32 o_x //: offset:X
    ,   I32 o_y //: offset:Y
    )
    {
        U32 b_x =( 0x00 );
        U32 b_y =( 0x00 );
        U32 u_1 ; //:Unused #1
        U32 u_2 ; //:Unused #2
        U32 u_3 ; //:Unused #3

        /** @VID_IID[ 0066 ]TIME[ 03H 59M 25S ]    **/
        /** #_TILE_SIZE_AFFECTS_CAMERA_POSITION_#  **/

        //:brush_coords:READ:--------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

        //:--------------------------------:brush_coords:READ://
        //:brush_coords:TRANSFORM:---------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0066 ]TIME[ 4H 56M 23S ]           **/
            /** The SMALLEST tile value results in a level   **/
            /** map size that is 256x256 tiles.              **/
            /**                                              **/
            /** This is because HALF of 512 is 256.          **/
            /** And we pack our tilemap data in a            **/
            /** mip-map like geometrical packing pattern.    **/
            /**                                              **/
            /** Been referring to that data structure as     **/
            /** a "QUARKMAP" / "QUARK_MAP"                   **/
            /** ******************************************** **/

            /** #_TILE_EXPONENT_AFFECTS_CAMERA_POSITION_#    **/

            U32 til_exp=( 0xFFFFFFFF ); /** TILE_EXPONENT    **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR == til_exp
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

            U16 m_c; /** m_c : Max_Coordinate ( x | y ) **/
            assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
            assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
            m_c = aac2020_paint5d_til_exp_CTO_max_cor(til_exp);

            b_x = CAP( ((I32)b_x) + o_x , (U16)0 , (U16)m_c );
            b_y = CAP( ((I32)b_y) + o_y , (U16)0 , (U16)m_c );

        //:---------------------------:brush_coords:TRANSFORM://
        //:brush_coords:WRITE:-------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X     //:DEX_VAR
            ,   (b_x), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y     //:DEX_VAR
            ,   (b_y), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

        //:-------------------------------:brush_coords:WRITE://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileValue( 
        I32 del_t_v /** Delta: TileValue( t_v ) **/
    )
    {
        /** @VID_IID[ 0066 ]TIME[ 05H 34M 55S ] **/
        /** #_MORE_NAMES_MORE_PROBLEMS_# ...... **/

        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            assert( 3 == AAC2020_PAINT5D_MAX_til_val );

            til_val =CAP( 
                (I32)til_val + del_t_v 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 3 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileExponent( 
        I32 del_t_e /** Delta: TileExponent( t_e ) **/
    )
    {
        U32 til_exp; /** [ Tile_Exponent / til_exp ] **/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : [ TIL_EXP ]
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            //:##############################################://
            #if( AAC2020_PAINT5D_MISC_INLINED_TESTS >= 1 ) 

                U32 original_tile_exponent =( til_exp );

            #endif //:#######################################://
            //:##############################################://

            assert( 15 == AAC2020_PAINT5D_MAX_aus_dex );

            til_exp =CAP( 
                (I32)til_exp + del_t_e 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

            //:##############################################://
            #if( AAC2020_PAINT5D_MISC_INLINED_TESTS >= 1 ) 

                if( 0 == original_tile_exponent ){
                if( 1 == del_t_e ){

                    if( 1 != til_exp ){
                        printf("[til_exp]:%d\n",til_exp);
                        ERR("[YOUR_CAP_FUNCTION_SUCKS_2021]");
                    };;

                };;};;

            #endif //:#######################################://
            //:##############################################://

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : [ TIL_EXP ]
            ,   (til_exp), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileLayer( 
        I32 del_t_l /** DELta_Tile_Layer **/
    )
    {
        U32 til_lay; /** [ TileLayer / Tile_Layer / til_lay ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,  &(til_lay),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://
 
            assert( 2 == AAC2020_PAINT5D_MAX_til_lay );

            til_lay =CAP( 
                (I32)til_lay + del_t_l 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 2 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,   (til_lay), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ToggleTile( void )
    {
        //:variable_declarations:----------------------------://

            /// t_x =  ENDED_UP_USING[ loc_t_x ]INSTEAD ////////
            /// t_y =  ENDED_UP_USING[ loc_t_y ]INSTEAD ////////

            U32 b_x = ( 0 + 123000123 ); /** b_x : brush_x **/
            U32 b_y = ( 0 + 123000123 ); /** b_y : brush_y **/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 04H 23M 45S ]

                val_bru :
                    Current[ til_val ]loaded into Josh's
                    tile brush. This is what he is 
                    currently painting with.

                val_cur :
                    Current[ til_val ]found on the canvas
                    that Josh is painting on. More precisely
                    a[ til_val ]encoded into a section
                    of a BYTE of an RGBA pixel stored in
                    a cpu side bitmap known as:

                    AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/

            U32 til_qua =( 1234 ) ;  /**Tile_Quadrant_000_002**/
            U32 til_exp =( 2345 ) ;  /**EXPONENT ( P5D_T_E ) **/
            U32 til_lay =( 3456 ) ;  /**   LAYER ( P5D_T_L ) **/
            U32 loc_t_x =( 4567 ) ;  /**LOCAL__X ( P5D_B_X ) **/
            U32 loc_t_y =( 5678 ) ;  /**LOCAL__Y ( P5D_B_Y ) **/
            U32 aus_dex =( 6789 ) ;  /**Auset_Index_000_015  **/
        //: U32 til_val =( ---- ) ;  /** THIS IS[ val_bru ]  **/

            U32 val_bru =( 4433 ) ;  /** LOADED INTO BRUSH   **/    
            U32 val_cur =( 3344 ) ;  /** ON THE TILEMAP      **/
            U32 val_put =( 1212 ) ;  /** Actual Value To Put **/

            U08 til_val =(  111 ) ;  /** val_cur BUT 8 bits  **/
            assert( 1 == sizeof( til_val ) ); /** 1 BYTE **/

            U32 u_1 ; //: unused_number_001 ://
            U32 u_2 ; //: unused_number_002 ://
            U32 u_3 ; //: unused_number_003 ://
  
        //:----------------------------:variable_declarations://
        //:GET_STATE:OF_BRUSH:-------------------------------://
        /** ************************************************ ***
        Variables we need from this section:
        1:  til_qua <---- P5D_T_Q
        2:  til_exp <---- P5D_T_E
        3:  til_lay <---- P5D_T_L
        4:  loc_t_x <---- P5D_B_X ( brush.xy === local.xy )
        5:  loc_t_y <---- P5D_B_Y ( brush.xy === local.xy )
        6:  aus_dex <---- P5D_A_D
        7:  val_bru <---- P5D_T_V ( til_val  === val_bru  )
        *** ************************************************ **/
            //:GET_STATE:til_qua:----------------------------://

                //: get_tile_value_loaded_into_brush ://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR : til_qua
                ,  &(til_qua),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_qua://
            //:GET_STATE:til_exp:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : til_exp
                ,  &(til_exp),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_exp://
            //:GET_STATE:til_lay:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : til_lay
                ,  &(til_lay),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_lay://
            //:GET_STATE:loc_t_x:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR : brush_x
                ,  &(loc_t_x),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_x://
            //:GET_STATE:loc_t_y:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR : brush_y
                ,  &(loc_t_y),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_y://
            //:GET_STATE:aus_dex:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR : aus_dex
                ,  &(aus_dex),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:aus_dex://
            //:GET_STATE:val_bru:----------------------------://
            //:GET_STATE:til_val:----------------------------://

                //: get_tile_value_loaded_into_brush ://
                //[  til_val ==== val_bru ]//

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : til_val
                ,  &(val_bru),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_val://
            //:----------------------------:GET_STATE:val_bru://

        //:-------------------------------:GET_STATE:OF_BRUSH://
        //:get_current_value_on_tile_map:--------------------://
    
            /** ******************************************** **/
            /**   @VID_IID[ 0066 ]TIME[ 07H 27M 23S ]        **/
            /**   @_CTRL_F_HELP_@                            **/
            /**   WRONG[ AAC2020_PAINT5D_TileValue_GET ]     **/
            /**   WRONG[ AAC2020_PAINT5D_GetTileValue  ]     **/
            /** CORRECT[ AAC2020_PAINT5D_Get           ]     **/
            /** ******************************************** **/
    
            /** @VID_IID[ 0066 ]TIME[ 08H 14M 15S ] ******* **/
            /** #_WHY_PAINT5D_GET_PARAM_ORDER_# **/
            AAC2020_PAINT5D_Get(
                til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]     **/
            ,   til_exp   /** 02 :  IN[ PAINT5D.D._    ]     **/
            ,   til_lay   /** 03 :                           **/
            ,   loc_t_x   /** 04 : For diagrams explaining   **/
            ,   loc_t_y   /** 05 : these parameters.         **/
            ,   aus_dex   /** 06 : @VID_IID[ 0075 ]          **/
            ,&( til_val ) /** 07 : @TIME[ 2H 46M 20S ]       **/
            );;
                
            /** ******************************************** ***
                @VID_IID[ 0075 ]TIME[ 2H 50M 30S ]       
                Necessary because of the different bit   
                widths required by different functions.  
            *** ******************************************** **/

            val_cur = til_val ;

            /** ******************************************** **/

        //:--------------------:get_current_value_on_tile_map://
        //:brush_coords:READ:--------------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0075 ]TIME[ 01H 41M 32S ]          **/
            /** This is a bit redundant. Looks like we had   **/
            /** some confusion on our variable names.        **/
            /** Lets just use [ b_x , b_y ] as a redundancy  **/
            /** to check our work I guess.                   **/
            /** ******************************************** **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            assert( loc_t_x == b_x ); //:@_IDENTICAL_VALUES_@://
            assert( loc_t_y == b_y ); //:@_IDENTICAL_VALUES_@://

        //:--------------------------------:brush_coords:READ://
        //:SET_OR_UNSET_THE_TILE:----------------------------://

            /** ******************************************** ***
                If the value loaded into the brush is the
                same value as the value currently on the
                tilemap, we will [ UNSET / ERASE ]the tile.

                If the tile values DO NOT MATCH, then
                we will [ SET / OVERWRITE ] the tile.
            *** ******************************************** **/

            if( val_bru != val_cur ){  /** [ OVERWRITE ] **/

                val_put = val_bru; 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]

            }else
            if( val_bru == val_cur ){  /** [ERASE/UNSET] **/

                /** **************************************** **/
                /**                                          **/
                /** @VID_IID[ 0075 ]TIME[ 1H 54M 00S ]       **/
                /**                                          **/
                /** By convention, the zero tile will        **/
                /** mean empty space. However the code       **/
                /** should NOT be like gamemaker. We should  **/
                /** NOT treat tile zero any differently      **/
                /** when running code on it. Thus if we      **/
                /** really wanted to, we could put a         **/
                /** pattern in tile value zero. For          **/
                /** example, the void of space. Like a       **/
                /** "star space" tile or something.          **/
                /**                                          **/
                /** Example Void Of Space Tile:              **/
                /** youtube.com/watch?v=tl40xidKF-4&t=1m25s  **/
                /** **************************************** **/

                val_put = ( 0 ); 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]

            }else{
                ERR("[EDCL:2021_01_02:PAINT5D]");
            };;

            assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                    //:[ 00 | 01 | 10 | 11 ]

            AAC2020_PAINT5D_Put(
                  til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]   **/
            ,     til_exp   /** 02 :  IN[ PAINT5D.D._    ]   **/
            ,     til_lay   /** 03 :                         **/
            ,     loc_t_x   /** 04 : For diagrams explaining **/
            ,     loc_t_y   /** 05 : these parameters.       **/
            ,     aus_dex   /** 06 : @VID_IID[ 0075 ]        **/
            ,(U08)val_put   /** 07 : @TIME[ 2H 44M 48S ]     **/
            );;

        //:----------------------------:SET_OR_UNSET_THE_TILE://
        return;
    }

#undef  CAP                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  U16                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:=========================:TAU:UNIFORM_CONTROLLER_FUNCTIONS://
//:============================:FUNCTIONS_WIRED_INTO_KEYBOARD://
//:KEYBOARD_HANDLER:(KeyInn):================================://
#define I32 int32_t /** GCC: <stdint.h> **/
#define DEX_EDI_paint5d ( 1 )
#define KEY_P5D ( AAC2020_KEYBIND.PAINT5D )
    
    I32
    aac2020_paint5d_KeyInn( signed char chr_key )
    {
        I32 res_var =( 0 );

        //:CAMERA_CONTROL:-----------------------------------://

            //:MoveCamera_XY:--------------------------------://
            /** ******************************************** ***

                #_CTRL_F_HELP_#

                p5d_cam_lef ===> p5d_vp1_lef  
                p5d_cam_rig ===> p5d_vp1_rig  
                p5d_cam_upp ===> p5d_vp1_upp  
                p5d_cam_dow ===> p5d_vp1_dow  
                                              
                p5d_cam_z_o ===> p5d_vp1_z_o  
                p5d_cam_z_i ===> p5d_vp1_z_i  

            *** ******************************************** **/

            if( chr_key == KEY_P5D.p5d_vp1_lef ){
                aac2020_paint5d_MoveCamera_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_rig ){
                aac2020_paint5d_MoveCamera_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_upp ){
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_dow ){         
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 + 1 );
            };;

            //:--------------------------------:MoveCamera_XY://
            //:ZoomCamera:-----------------------------------://

            if( chr_key == KEY_P5D.p5d_vp1_z_o ){
                aac2020_paint5d_ZoomCamera( 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_z_i ){         
                aac2020_paint5d_ZoomCamera( 0 + 1 );
            };;

            //:-----------------------------------:ZoomCamera://

        //:-----------------------------------:CAMERA_CONTROL://
        //:MOVE_BRUSH:---------------------------------------://

            if( chr_key == KEY_P5D.p5d_bru_lef ){
                aac2020_paint5d_MoveBrush_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_rig ){
                aac2020_paint5d_MoveBrush_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_upp ){
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_bru_dow ){         
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 + 1 );
            };;

        //:---------------------------------------:MOVE_BRUSH://
        //:TILE_VALUE(T_V):----------------------------------://
        
            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_V  +//

            /** @VID_IID[ 0066 ]TIME[ 03H 40M 05S ] **/
            /** WHY CALLED: TileValueDeltaMutate    **/

            if( chr_key == KEY_P5D.p5d_v_n ){ //:n:NEXT
                /** HERE[ Bak_Til | PrevTile | PreviousTile ]**/
                aac2020_paint5d_DeltaMutate_TileValue( 0 + 1 );
            }else
            if( chr_key == KEY_P5D.p5d_v_b ){ //:b:BACK
                /** HERE[ Nex_Til() | NextTile(...) ] **/
                aac2020_paint5d_DeltaMutate_TileValue( 0 - 1 );
            };;

        //:----------------------------------:TILE_VALUE(T_V)://
        //:TILE_EXPONENT(T_E):-------------------------------://

            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_E  +//

            if( chr_key == KEY_P5D.p5d_e_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileExponent(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_e_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileExponent(0 -1);
            };;

        //:-------------------------------:TILE_EXPONENT(T_E)://
        //:TILE_LAYER_0_TO_2(T_L):---------------------------://

            if( chr_key == KEY_P5D.p5d_l_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileLayer(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_l_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileLayer(0 -1);
            };;


        //:---------------------------:TILE_LAYER_0_TO_2(T_L)://
        //:TILE_TOGGLE:--------------------------------------://

            if( chr_key == KEY_P5D.p5d_tog ){ //:toggle
                aac2020_paint5d_ToggleTile( );
            };;

        //:--------------------------------------:TILE_TOGGLE://

        return( res_var );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32
    PAINT5D_KeyInn( signed char chr_key )
    {
        I32 res_var=( 0 );

        /** @VID_IID[ 0066 ]TIME[ 0H 19M 48S ] ............. **/
        /** PAINT5D is ALWAYS sub-system #1 which            **/
        /** Is assigned to the number 1, both in code        **/
        /** and in the key on the numpad it corresponds to   **/
        assert( DEX_EDI_paint5d == AAC2020_CEDITOR_paint5d );;
        if(     DEX_EDI_paint5d == AAC2020_CEDITOR_dex_edi ){

            res_var = aac2020_paint5d_KeyInn( chr_key );

        };;
    
        /** @IMPLICIT_INTERFACE[ KeyInn ] ****************** **/
        /** @VID_IID[ 0066 ]TIME[ 0H 30M 30S ] ..............**/
        /** Don't have a use for return code yet.    ........**/
        /** but we should be consistent with all of  ........**/
        /** our different keyboard handlers.         ........**/
        /** ************************************************ **/
        return( res_var );
    }

#undef  DEX_EDI_paint5d
#undef  I32
#undef  KEY_P5D
//:================================:KEYBOARD_HANDLER:(KeyInn)://
//:SUB_SYSTEM_BACKUP_CODE:===================================://
#define U08 uint8_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Backup_taudirt(
        U08* *BYREF_taudirt
    )
    {
        AAC2020_TAUDIRT_Backup_taudirt( BYREF_taudirt );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Restore_taudirt(
        U08* *BYREF_taudirt
    )
    {
        AAC2020_TAUDIRT_Restore_taudirt( BYREF_taudirt );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08
//:===================================:SUB_SYSTEM_BACKUP_CODE://
//:VIEWPORT_HELPER_FUNCTION:=================================://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 02 ://
#define ERR aac2020_paint5d_Halt                      //: 03 ://

    void
    AAC2020_PAINT5D_PUT_rec_inc_ALL(
    #define U U32 /** U is for unsigned **/
    #define I I32 /** I is for integer  **/
    #define T I32 /** T is for type     **/

     T vpc_x_0 , T vpc_x_1 , T vpc_y_0 , T vpc_y_1 //:P5D_VPC://
    ,T vp0_x_0 , T vp0_x_1 , T vp0_y_0 , T vp0_y_1 //:P5D_VP0://
    ,T vp1_x_0 , T vp1_x_1 , T vp1_y_0 , T vp1_y_1 //:P5D_VP1://

    #undef  U
    #undef  I
    #undef  T
    )
    {
        //:bound_check_inputs:-------------------------------://
        #define U 0x7FFFFFFF /**Upper Bound For Signed 32bit **/

            /** PRIA: Put_Rec_In_All **/

            /** lower bounds check **/
            if( vpc_x_0 < 0 ){ ERR("[PRIA:vpc_x_0:OOB_NEG]");};
            if( vpc_y_0 < 0 ){ ERR("[PRIA:vpc_y_0:OOB_NEG]");};
            if( vp0_x_0 < 0 ){ ERR("[PRIA:vp0_x_0:OOB_NEG]");};
            if( vp0_y_0 < 0 ){ ERR("[PRIA:vp0_y_0:OOB_NEG]");};
            if( vp1_x_0 < 0 ){ ERR("[PRIA:vp1_x_0:OOB_NEG]");};
            if( vp1_y_0 < 0 ){ ERR("[PRIA:vp1_y_0:OOB_NEG]");};

            /** Rough out of bounds check **/
            if( vpc_x_1 > U ){ ERR("[PRIA:vpc_x_1:OOB_POS]");};
            if( vpc_y_1 > U ){ ERR("[PRIA:vpc_y_1:OOB_POS]");};
            if( vp0_x_1 > U ){ ERR("[PRIA:vp0_x_1:OOB_POS]");};
            if( vp0_y_1 > U ){ ERR("[PRIA:vp0_y_1:OOB_POS]");};
            if( vp1_x_1 > U ){ ERR("[PRIA:vp1_x_1:OOB_POS]");};
            if( vp1_y_1 > U ){ ERR("[PRIA:vp1_y_1:OOB_POS]");};

            /** Specific out of bounds check   **/
            /** VP1: Offscreen/Source/TileMap  **/
            I32 vp1_max=( 256 - 1 ); /** for paint5d system**/
            if( vp1_x_1 > vp1_max ){ ERR("[vp1_x_1:max]");};
            if( vp1_y_1 > vp1_max ){ ERR("[vp1_y_1:max]");};

        #undef  U
        //:-------------------------------:bound_check_inputs://
        //:call_with_casts_to_u32:---------------------------://
        //:store_viewports:----------------------------------://
        #define T U32 /** T is for type     **/

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VPC //:DEX_VAR
            ,   (T)vpc_x_0 ,(T)vpc_x_1 ,(T)vpc_y_0 ,(T)vpc_y_1
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP0 //:DEX_VAR
            ,   (T)vp0_x_0 ,(T)vp0_x_1 ,(T)vp0_y_0 ,(T)vp0_y_1
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
            ,   (T)vp1_x_0 ,(T)vp1_x_1 ,(T)vp1_y_0 ,(T)vp1_y_1
            );;

        #undef  T
        //:----------------------------------:store_viewports://
        //:---------------------------:call_with_casts_to_u32://
    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
//:=================================:VIEWPORT_HELPER_FUNCTION://
//:IOU:INIT_OR_UPDATE:=======================================://
#define I32 int32_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void        /** IOU:Initialize_Or_Update **/
    AAC2020_PAINT5D_IOU_ViewportRectangles( void )
    {           /** IOU:Initialize_Or_Update **/

        //:  #_GET_SIZE_OF_VIEWPORT_####  ://
        //:  #_DEFAULT_TERMINAL_HEIGHT_#  ://

        I32 cli_wid = AAC2020_GINAWIN_GetClient_WID() ;
        I32 cli_hig = AAC2020_GINAWIN_GetClient_HIG() ;

        I32 ter_hig=( 64 ); //:Default_Terminal_Height

        I32 rec_wid ; /** rectangle width  **/
        I32 rec_hig ; /** rectangle height **/
        I32 rec_min ; /** MIN( rec_wid , rec_hig ) **/

        I32 lover_x ; /** leftovers x **/
        I32 lover_y ; /** leftovers y **/

        rec_wid = cli_wid;
        if( ( cli_hig - ter_hig ) > 0 ){

            rec_hig = cli_hig - ter_hig;

        }else{

            /** Hide terminal if not enough room to display **/
            rec_hig = cli_hig ;

        };;

        /** rec_min =MIN(rec_wid,rec_hig) **/
        if( rec_wid > rec_hig ){
            rec_min = rec_hig;
        }else{
            rec_min = rec_wid;
        };;

        /** get leftovers after accounting for       ........**/
        /** square destination viewport size P5D_VP1 ........**/
        lover_x = ( cli_wid - rec_min );
        lover_y = ( cli_hig - rec_min );
        if( lover_x < 0 ){ lover_x = 0; };
        if( lover_y < 0 ){ lover_y = 0; };
    
        /** calculate canvas viewport that covers context    **/
        I32 vpc_x_0 = 0;
        I32 vpc_x_1 =( cli_wid - 1);
        I32 vpc_y_0 = 0;
        I32 vpc_y_1 =( cli_hig - 1);

        /** calculate destination viewport, square, inside   **/
        /** canvas viewport (P5D_VPC)                        **/
        I32 vp0_x_0 = (    0        ) + (lover_x/2);
        I32 vp0_x_1 = ( cli_wid - 1 ) - (lover_x/2);
        I32 vp0_y_0 = (    0        ) + (lover_y/2);
        I32 vp0_y_1 = ( cli_hig - 1 ) - (lover_y/2);
         
        /** Set the data viewport. Start zoomed all the way  **/
        /** out so that we can see EVERYTHING.               **/
        I32 vp1_x_0 =(     0   );
        I32 vp1_x_1 =( 256 - 1 );
        I32 vp1_y_0 =(     0   );
        I32 vp1_y_1 =( 256 - 1 );

        //:Make_Sure_Nothing_Went_Negative:------------------://
        
            /** @VID_IID[ 0084 ]TIME[ 05:14:30 ] *********** **/
            /** If we end up getting one of these asserts    **/
            /** to fail, we may need to handle things like   **/
            /** resizing viewport to very small to handle    **/
            /** more gracefully if the source is ___NOT___   **/
            /** an error in our logic.                       **/
            /** ******************************************** **/

            assert( vpc_x_0 >= 0 );
            assert( vpc_x_1 >= 0 );
            assert( vpc_y_0 >= 0 );
            assert( vpc_y_1 >= 0 );

            assert( vp0_x_0 >= 0 );
            assert( vp0_x_1 >= 0 );
            assert( vp0_y_0 >= 0 );
            assert( vp0_y_1 >= 0 );

            assert( vp1_x_0 >= 0 );
            assert( vp1_x_1 >= 0 );
            assert( vp1_y_0 >= 0 );
            assert( vp1_y_1 >= 0 );

            /** ******************************************** **/
            /** Don't check upper bounds. Checked in the     **/
            /** helper function that comes next.             **/
            /** ******************************************** **/
 
        //:------------------:Make_Sure_Nothing_Went_Negative://

        //:--------------------------------------------------://
        //: @VID_IID[ 0084 ]TIME[ 04:28:10 ] ................://
        //: Explanation on why viewports are named such.     ://
        //:                                                  ://
        //: VP0 because we always have exactly ONE dest      ://
        //: VP1 because we might want other numbers that     ://
        //: sample from other sources. For example,          ://
        //: VP2 might be the name of our [terminal/console]  ://
        //: data viewport.                                   ://
        //:                                                  ://
        //: VP0:Viewport_Zero(0): (Destination/Screen)       ://
        //: VP1:Viewport_One(1) : (Offscreen/Source/Tilemap) ://
        //: VPC:Viewport_Canvas : (Or: Window/OpenGL)        ://
        //:--------------------------------------------------://

        AAC2020_PAINT5D_PUT_rec_inc_ALL(
            vpc_x_0 , vpc_x_1 , vpc_y_0 , vpc_y_1  //:P5D_VPC://
        ,   vp0_x_0 , vp0_x_1 , vp0_y_0 , vp0_y_1  //:P5D_VP0://
        ,   vp1_x_0 , vp1_x_1 , vp1_y_0 , vp1_y_1  //:P5D_VP1://
        );;

    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void        /** IOU:Initialize_Or_Update **/
    AAC2020_PAINT5D_IOU_DefaultBrushState( void )
    {           /** IOU:Initialize_Or_Update **/

        /** ************************************************ ***

            Initial Values We Have ___STRONG___ opinions about:
            @VID_IID[ 0084 ]TIME[ 02:50:30 ]

            til_qua : NO_STRONG_OPINION
            loc_t_x : NO_STRONG_OPINION
            loc_t_y : NO_STRONG_OPINION

            til_exp = 7 : 
            Start at largest (7) tile exponent to encourage   
            working up the drawing from general vaugness      
            to sharper (smaller tiles) details.               

            til_lay = 0 :                                      
            Start at BACKMOST tile layer (0)                  
            To encourage water color like designing where     
            artist paints in the background first before      
            working up the more detailed foreground.          
            #_WHY_IS_0_THE_BACK_MOST_LAYER_#       

            aus_dex = 0 :
            Start creating the FIRST aus_dex
            (auto tile set) and then work your way forward
            to the other sets. This makes the most sense.

            til_val = 0 :
            Start at the first tile value so that when user
            uses the NEXT_TILE_VALUE button, they get 
            a change in the tile value as expected, and are
            able to immediately cycle through all tile values.

        *** ************************************************ **/

        aac2020_paint5d_Put_BrushState(
            0  //: I32 : [ t_q / til_qua ] : 01 ://
        ,   7  //: I32 : [ t_e / til_exp ] : 02 ://
        ,   0  //: I32 : [ t_l / til_lay ] : 03 ://
        ,   0  //: I32 : [ l_x / loc_t_x ] : 04 ://
        ,   0  //: I32 : [ l_y / loc_t_y ] : 05 ://
        ,   0  //: I32 : [ a_d / aus_dex ] : 06 ://
        ,   0  //: I32 : [ t_v / til_val ] : 07 ://
        );;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32
//:=======================================:IOU:INIT_OR_UPDATE://
//:INITIALIZE_PAINT5D:=======================================://
#define U32  uint32_t /** GCC: <stdint.h> **/         //: 01 ://
#define I32   int32_t /** GCC: <stdint.h> **/         //: 02 ://
#define I16   int16_t /** GCC: <stdint.h> **/         //: 03 ://
#define ERR   aac2020_paint5d_Halt                    //: 04 ://
#define O_K   aac2020_paint5d_Okay                    //: 05 ://
#define I_D   aac2020_paint5d_Info_dec                //: 06 ://
#define INF   aac2020_paint5d_Info                    //: 07 ://
#define LOG   aac2020_paint5d_Info_any                //: 08 ://

    U32
    AAC2020_PAINT5D_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved for future use **/ };

        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

        /** Hackishly debug what is going on. **/
        AAC2020_PAINT5D_init_call_count++;
        I_D("[AAC2020_PAINT5D_init_call_count]:%d\n"
                ,AAC2020_PAINT5D_init_call_count       );;

        if( AAC2020_CEDITOR_dex_ing == 
            AAC2020_CEDITOR_paint5d
        ){  
            /** If not recursion, it might be being called   **/
            /** rapidly from another thread. Re-entering     **/
            /** before it is exiting. But that seems         **/
            /** unlikely. I think that would require         **/
            /** more than one thread to call this function.  **/

            ERR("[LIKELY_UNINTENTIONAL_RECURSION]"); 
        };;

            /** #_EDITOR_INIT_SPAM_GAURD_# **/
            if( AAC2020_CEDITOR_nex_edi 
            ==  AAC2020_CEDITOR_dex_edi
            ){
                O_K("[PAINT5D:Init_Already_Up_To_Date]");
            };;

        /** We are now initilaizing paint5d **/
        AAC2020_CEDITOR_dex_ing=( 
        AAC2020_CEDITOR_paint5d  );;

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://

        /** Early Exit Will Trigger Recursion Guard Error **/
        O_K( "[OH_FUCK...Code_Below_Was_Never_Ran_Before]" );;

        //:ALL_MEMBERS_OF_PAINT5D:---------------------------://

            //:#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#://

        //:---------------------------:ALL_MEMBERS_OF_PAINT5D://
        //:ALLOCATES_OPEN_GL_TEXTURE:------------------------://
    
            //+ #GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER# + + + +//
            //- AAC2020_GPUDATA_InitInstance(  - - - - - - - -//
            //-     ACC2020_PAINT5D_dat      );; - - - - - - -//

        //:------------------------:ALLOCATES_OPEN_GL_TEXTURE://
        //:LOAD_INITIAL_EDITOR_STATE:------------------------://
        LOG("[PAINT5D:LOAD_INITIAL_EDITOR_STATE:BEG]",0);

            //:LIES: Load_Initial_Editor_State
            AAC2020_VITAL_TODO("[P5D_LIES_FROM_SAVE_FILE]");

            /** UPDATES: P5D_VPC , P5D_VP0 , P5D_VP1  **/
            /** IOU: Init_Or_Update  @IOU@            **/
            
            AAC2020_PAINT5D_IOU_DefaultBrushState( );

            /** viewport sizing will depenend on brush **/
            /** state in some cases I think...         **/
            AAC2020_PAINT5D_IOU_ViewportRectangles();

        LOG("[PAINT5D:LOAD_INITIAL_EDITOR_STATE:END]",0);
        //:------------------------:LOAD_INITIAL_EDITOR_STATE://
        //:LOAD_INITIAL_TEXTURE_DATA:------------------------://
        #define DAT gpudata_paint5d
        #define F_S( name ) AAC2020_PIXNAME_##name

            /** #_TODOS_CAN_BREAK_COLUMN_LIMIT_# **/
            /** For now just load a test pattern to confirm we    * * * * * **/
            /** have data. But once that is done, we will want to * * * * * **/
            /** load from a save file on disk on startup.         * * * * * **/
            AAC2020_VITAL_TODO("[Eventually_This_Should_Load_Save_File_Data]");



            struct AAC2020_GPUDATA gpudata_paint5d ={ 0 };



            if( strcmp( &(F_S( paint5d )[0]) ,"paint5d" )!= 0 ){
                aac2020_paint5d_Halt("[BAD_NAME_2020]");
            };;


            
            //: FILE_SCOPE(  F_S  ) --> TEMP_STRUCT(  DAT  );
            DAT.tex_lot =    F_S( paint5d_tex_lot          );
            DAT.tex_han =    F_S( paint5d_tex_han          ); 
            DAT.sam_loc =    F_S( paint5d_tex_sam.sam_loc  );
            DAT.sam_val =    F_S( paint5d_tex_sam.sam_val  );
            DAT.sam_has =    F_S( paint5d_tex_sam_HAS      );
            DAT.pix_wid =  ( 512                           );
            DAT.pix_hig =  ( 512                           );
            DAT.pix_nam = &( F_S( paint5d )[0]             );

            DAT.cpu_pix =&( 
                AAC2020_PIXNAME_paint5d_cpu_pix[0] 
            );;



            AAC2020_PIXLOAD_TestPattern(   &( DAT ) );
            AAC2020_PIXLOAD_UploadTexture( &( DAT ) );
            

            //:get_paint5d_sampler_location:-----------------://
            #define HAS_CHK AAC2020_PIXLOAD_HasSampler
            #define INF_DEC aac2020_paint5d_Info_dec

                //:#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#://
                AAC2020_PIXLOAD_sam_has    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_loc    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_val_PUT( &( DAT ) );

                if( DAT.sam_has >= 1 && DAT.sam_loc <=(0 - 1) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:001]");
                }else 
                if( DAT.sam_has <= 0 && DAT.sam_loc >=(  0  ) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:002]");
                };;

                /** Keep the error prone way of doing this   **/
                /** As a redundancy to check for agreement.  **/

                I32 has = HAS_CHK( "paint5d" );
                if( DAT.sam_has != has ){ ERR("[WTF:0433AM]");};

                INF_DEC( "[DAT.sam_loc]:%d\n" , DAT.sam_loc );
                INF_DEC( "[DAT.sam_val]:%d\n" , DAT.sam_val );

            #undef  HAS_CHK
            #undef  INF_DEC
            //:-----------------:get_paint5d_sampler_location://

            if( has >= 1 ){

                /** Update Texture Sampler Uniform On GPU **/

                aac2020_pixload_PushSampler(  &( DAT ) );

                /** Persist Changes: **/

                //: TEMP_STRUCT(  DAT  ) --> FILE_SCOPE(  F_S  )
                F_S( paint5d_tex_lot         ) = DAT.tex_lot ;
                F_S( paint5d_tex_han         ) = DAT.tex_han ;
                F_S( paint5d_tex_sam.sam_loc ) = DAT.sam_loc ;
                F_S( paint5d_tex_sam.sam_val ) = DAT.sam_val ;
                F_S( paint5d_tex_sam_HAS     ) = DAT.sam_has ;
                //:                    ( 512 ) = DAT.pix_wid ://
                //:                    ( 512 ) = DAT.pix_hig ://
                //:                 "paint5d" ~=~DAT.pix_nam ://
    
                aac2020_paint5d_Okay("[HAS_TEXTURE_SAMPLER]");
            }else{

                /** Whether this is a good or bad message **/
                /** depends on you looking at code and    **/
                /** deciding.                             **/
                INF("[NO_TEXTURE_SAMPLER:PAINT5D]");
    
            };;
           
        #undef DAT
        #undef F_S
        //:------------------------:LOAD_INITIAL_TEXTURE_DATA://
        //:ERROR_CHECK:--------------------------------------://

            //:#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#://
            
        //:--------------------------------------:ERROR_CHECK://
        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

            /** DONE initializing. **/

            AAC2020_CEDITOR_dex_ini=( 
            AAC2020_CEDITOR_paint5d  );;

            /** No editor initializ-ING now. **/
            AAC2020_CEDITOR_dex_ing=( 0xFFFFFFFF );

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://
        //:Run_Unit_Test_If_Never_Ran_Before:----------------://
        #define KIL AAC2020_PAINT5D_unreliable_utc_kill_switch
        #define E_U extern U32

            if( aac2020_paint5d_unit_test_ran_or_running <= 0 ){
                aac2020_paint5d_unit_test_ran_or_running =( 1 );
                aac2020_paint5d_unit_test_is_running_now =( 1 );

                if( KIL >= 1 ){

                    srand(time(NULL)); 
                    I16 rnd_i16 = rand(); //: 0 to 0x7fff
                    if( rnd_i16 < ( 0x7fff / 10 ) ){

                        /** 0x7fff / 20 : Means: 1 in 20 **/

                        E_U AAC2020_PAINT5D_UnitTest( U32  );
                            AAC2020_PAINT5D_UnitTest( 0x00 );
                    };;
                }else{
                    if( 1 == 1 ){

                        E_U AAC2020_PAINT5D_UnitTest( U32  );
                            AAC2020_PAINT5D_UnitTest( 0x00 );
                    };;
                };;

                /** **************************************** **/
                /** @VID_IID[ 0086 ]TIME[ 00:08:40 ]         **/
                /** @VID_IID[ 0086 ]TIME[ 00:45:40 ]         **/
                /** Always run this unit test. Tests  file   **/
                /** OPEN_GL_HAKCODE/P5D_OGL._ ************** **/
                #define E_V extern void

                    E_V aac2020_P5D_OGL_UnitTest( void );
                        aac2020_P5D_OGL_UnitTest(      );

                #undef  E_V
                /** **************************************** **/

                aac2020_paint5d_unit_test_is_running_now =( 0 );
            };;

        #undef KIL
        #undef E_U
        //:----------------:Run_Unit_Test_If_Never_Ran_Before://

        return( 0x00 );

    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  I16                                           //: 03 ://
#undef  ERR                                           //: 04 ://
#undef  O_K                                           //: 05 ://
#undef  I_D                                           //: 06 ://
#undef  INF                                           //: 07 ://
#undef  LOG                                           //: 08 ://
//:=======================================:INITIALIZE_PAINT5D://
//:SECTION_UNIT_TEST:========================================://
//:UNIT_TEST_SECTION:========================================://
#define MAX_EXP AAC2020_PAINT5D_MAX_til_exp           //: 01 ://
#define EXT      extern                               //: 02 ://
#define VOD        void                               //: 03 ://
#define I08      int8_t /** GCC: <stdint.h> **/       //: 04 ://
#define U08     uint8_t /** GCC: <stdint.h> **/       //: 05 ://
#define I16     int16_t /** GCC: <stdint.h> **/       //: 06 ://
#define U16    uint16_t /** GCC: <stdint.h> **/       //: 07 ://
#define I32     int32_t /** GCC: <stdint.h> **/       //: 08 ://
#define U32    uint32_t /** GCC: <stdint.h> **/       //: 09 ://
#define ERR     aac2020_paint5d_Halt                  //: 10 ://
#define LOG     aac2020_paint5d_Info_any              //: 11 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    AAC2020_PAINT5D_UnitTest( U32 u32 )
    {
        aac2020_paint5d_unit_test_ran_or_running =( 1 );
        aac2020_paint5d_unit_test_is_running_now =( 1 );

        extern U32 aac2020_paint5d_UnitTest( U32 );
                   aac2020_paint5d_UnitTest( u32 );

        aac2020_paint5d_unit_test_is_running_now =( 0 );
        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_UnitTest( U32 u32 )
    {
        if( u32 ){  /** Reserved For Future Use **/  };

        /** ************************************************ ***
            ProgControls: 
                Progmattic functions that the end user does
                not directly interface with.

            TestControls: @VID_IID[ 0076 ]T[ 4H 56M 15S ]
                These are controls that may fit into
                the "ProgControls" or the "UserControls"
                category. But the MAIN THING about them
                is that they have been created in order
                to effectively test our "UserControls"
                section. Thus must be called AFTER
                "ProgControls" and BEFORE "UserControls"
            
            UserControls:
                Functions that are directly or near
                directly called as the result of 
                user input such as key presses.
    
                For example( S ):
                    aac2020_paint5d_ToggleTile
                    aac2020_paint5d_MoveBrush_XY
        *** ************************************************ **/
        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/
            
            AAC2020_PAINT5D_Backup_taudirt( &(taudirt) );
            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

            AAC2020_TODOMAN_Vital(
                "[FIX:taudirt_backup_is_invalid_back_reference]"
            );;

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://

            aac2020_paint5d_CTS="[____ProgControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_ProgControls( VOD );
            aac2020_paint5d_UnitTest_ProgControls(     );

            aac2020_paint5d_CTS="[____TestControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_TestControls( VOD );
            aac2020_paint5d_UnitTest_TestControls(     );

            aac2020_paint5d_CTS="[____UserControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_UserControls( VOD );
            aac2020_paint5d_UnitTest_UserControls(     );

        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                AAC2020_PAINT5D_Restore_taudirt( &(taudirt) );
                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://
        //:------------------------------:SYSTEM_DATA:RESTORE://

        return( 0x00 );
    }
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_paint5d_UnitTest_TestControls( void )
    {
        /** @VID_IID[ 0076 ]TIME[ 5H 00M 00S ]               **/
        /** Even if these eventually get wired into          **/
        /** our user controls, they will FOREVER stay        **/
        /** in the "TestControls" category, because that     **/
        /** is what they were initially created for and      **/
        /** also I am lazy and don't see much utility        **/
        /** to refactoring my unit test code for             **/
        /** a NON CODE BREAKING CHANGES                      **/

        aac2020_paint5d_CTF=(     "[Put_BrushState]"          );
        EXT VOD aac2020_paint5d_UTC_Put_BrushState(    void   );
                aac2020_paint5d_UTC_Put_BrushState(/** void**/);

        aac2020_paint5d_CTF=(     "[Put_UsingBrush]"          );
        EXT VOD aac2020_paint5d_UTC_Put_UsingBrush(    void   );
                aac2020_paint5d_UTC_Put_UsingBrush(/** void**/);

    }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_BrushState( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/ 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i =( ROW_S - 1 ); //:m_i: Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]

                    We are NOT going to create a 
                    aac2020_paint5d_Get_BrushState(...)
                    function to help test this code...

                    Because aac2020_paint5d_Put_BrushState
                    itself was created as a HELPER function
                    to help run UNIT TEST code.
                    
                    This has already spiraled enough
                    out of control. I don't want a 
                    Helper function for my helper function
                    that helps test my unit test code
                    for my actual function.
            
                    --------------------------------------------
                    Is this out of control
                    deductive reasonsing?

                    Or is it... "inductive reasoning?"

                    Or is it just "backwards reasoning"
                    because it is a linear chain?
                    --------------------------------------------
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_358AM]");

                    };;

                //:test_table_members:---------------:__chk__://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_UsingBrush( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://
            //:declare:vars_for:AAC2020_PAINT5D_Get:---------://

            /** @VID_IID[ 0083 ]TIME[ 05:28:32 ]             **/
            /** Most of these are commented out because      **/
            /** we decided NOT to create a                   **/
            /** aac2020_paint5d_Get_BrushState(...) func.    **/

            /// U08 til_qua =( 204 );  //: 01 : t_q ://
            /// U08 til_exp =( 204 );  //: 02 : t_e ://
            /// U08 til_lay =( 204 );  //: 03 : t_l ://
            /// U08 loc_t_x =( 204 );  //: 04 : l_x ://
            /// U08 loc_t_y =( 204 );  //: 05 : l_y ://
            /// U08 aus_dex =( 204 );  //: 06 : a_d ://
                U08 til_val =( 204 );  //: 07 : t_v ://

            //:---------:declare:vars_for:AAC2020_PAINT5D_Get://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/  0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i = ( ROW_S - 1 ); //:Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                    if( t_q >=   4 ){ ERR("[BAD__t_q__2021]");};
                    if( t_e >=   8 ){ ERR("[BAD__t_e__2021]");};
                    if( t_l >=   3 ){ ERR("[BAD__t_l__2021]");};
                    if( l_x >= 128 ){ ERR("[BAD__l_x__2021]");};
                    if( l_y >= 128 ){ ERR("[BAD__l_y__2021]");};
                    if( a_d >=  16 ){ ERR("[BAD__a_d__2021]");};
                    if( t_v >=   4 ){ ERR("[BAD__t_v__2021]");};

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]
                    COPIDED_FROM: 
                    aac2020_paint5d_UTC_Put_BrushState
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_410AM]");

                    };;

                //:test_table_members:---------------:__chk__://
                //:ACTUALLY_PUT_USING_THE_BRUSH_STATE:-------://

                    aac2020_paint5d_Put_UsingBrush( );

                //:-------:ACTUALLY_PUT_USING_THE_BRUSH_STATE://
                //:FETCH_TILE_VALUE_PUT:---------------------://


                     AAC2020_PAINT5D_Get(
                           t_q      /** t_q | til_qua : 01 : **/
                     ,     t_e      /** t_e | til_exp : 02 : **/
                     ,     t_l      /** t_l | til_lay : 03 : **/
                     ,     l_x      /** l_x | loc_t_x : 04 : **/
                     ,     l_y      /** l_y | loc_t_y : 05 : **/
                     ,     a_d      /** a_d | aus_dex : 06 : **/
                     , &(til_val)   /** t_v | til_val : 07 : **/
                     );;
    
                    if( til_val != t_v ){
                        ERR("[TIL_VAL_NOT_EQUAL_TO_T_V_2021]");
                    };;

                ///// @VID_IID[ 0083 ]TIME[ 05:23:28 ]
                ///// THIS CODE IS WRONG, close to right...
                /////
                /////    /** get a value encoded in the **/
                /////    /** [bitmap/texture] data      **/
                /////
                /////        AAC2020_PAINT5D_Get(
                /////            til_qua   /** t_q : 01 : **/
                /////        ,   til_exp   /** t_e : 02 : **/
                /////        ,   til_lay   /** t_l : 03 : **/
                /////        ,   loc_t_x   /** l_x : 04 : **/
                /////        ,   loc_t_y   /** l_y : 05 : **/
                /////        ,   aus_dex   /** a_d : 06 : **/
                /////        , &(til_val)  /** t_v : 07 : **/
                /////        );;
                /////
                /////    /** check that proper value was    **/
                /////    /** encoded in the [bitmap/texture **/
                /////
                /////        if( 0
                /////        || til_qua != t_q /** : 01 : **/
                /////        || til_exp != t_e /** : 02 : **/
                /////        || til_lay != t_l /** : 03 : **/
                /////        || loc_t_x != l_x /** : 04 : **/
                /////        || loc_t_y != l_y /** : 05 : **/
                /////        || aus_dex != a_d /** : 06 : **/
                /////        || til_val != t_v /** : 07 : **/
                /////        ){
                /////            ERR("[DO_DRAGONS_LIKE_GOLD_2021]");
                /////        };;
      
                //:---------------------:FETCH_TILE_VALUE_PUT://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UnitTest_UserControls( void )
        {
        #define CTF aac2020_paint5d_CTF

            CTF=("[aac2020_paint5d_UTC_MoveCamera_XY]");
            EXT VOD 
            aac2020_paint5d_UTC_MoveCamera_XY( VOD );
            aac2020_paint5d_UTC_MoveCamera_XY(     );

            CTF=("[aac2020_paint5d_UTC_ZoomCamera]");
            EXT VOD 
            aac2020_paint5d_UTC_ZoomCamera( VOD );
            aac2020_paint5d_UTC_ZoomCamera(     );

            CTF=("[aac2020_paint5d_UTC_MoveBrush_XY]");
            EXT VOD 
            aac2020_paint5d_UTC_MoveBrush_XY( VOD );
            aac2020_paint5d_UTC_MoveBrush_XY(     );

            CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileValue]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileValue( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileValue(     );

            CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileExponent]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileExponent( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileExponent(     );

            CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileLayer]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileLayer( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileLayer(     );

            CTF=("[aac2020_paint5d_UTC_ToggleTile]");
            EXT VOD 
            aac2020_paint5d_UTC_ToggleTile( VOD );
            aac2020_paint5d_UTC_ToggleTile(     );
    
        #undef CTF
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveCamera_XY( void )
        {
        #define NUMBER_OF_TESTS ( 3 )
        #define NUMBER_OF_TEST_ELEMENTS ( 10 )
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 inn_x_0 ; /** INPUTS: Camera Rectangle **/
                U32 inn_x_1 ;
                U32 inn_y_0 ;
                U32 inn_y_1 ;
                            ;
                U32 tra_i_x ; /** INPUTS: Camera Translation **/
                U32 tra_i_y ;
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** **************************************** ***
                    @VID_IID[ 0076 ]TIME[ 1H 58M 30S ]

                    weird_names_because: 
                    We kept confusing

                         "Input And Output"
                    With "Expected And Actual"

                    And tangling our mental understanding
                    between the pairs of words.
                ** ***************************************** **/

                U32 O_A_x_0 ; /** OUTPUTS: Camera Rectangle  **/
                U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL values**/      
                U32 O_A_y_0 ;
                U32 O_A_y_1 ;
                            ;
                U32 exp_x_0 ; /** EXPECTED : Camera Rectangle**/
                U32 exp_x_1 ; /**                            **/
                U32 exp_y_0 ;
                U32 exp_y_1 ;

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://


            /** @VID_IID[ 0076 ]TIME[ 0H 59M 30S ]           **/
            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/

            /** PAB == "position and bounds" **/

            /** @VID_IID[ 0076 ]TIME[ 0H 56M 0S ] . . . . . .**/
            /** First 3 Tests are dead simple.    . . . . . .**/
            U32 tab_utc[ 
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
            0x00,0x00,0x00,0x00 , 0x00,0x00, 0x00,0x00,0x00,0x00
        ,   0x00,0x00,0x00,0x00 ,    1,0x00,    1,   1,0x00,0x00
        ,   0x00,0x00,0x00,0x00 , 0x00,   1, 0x00,0x00,   1,   1
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                tra_i_x = tab_utc[ bas + 4 ]; /**Translation **/
                tra_i_y = tab_utc[ bas + 5 ]; /**Integer:X&Y **/
 
                exp_x_0 = tab_utc[ bas + 6 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 7 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 8 ];
                exp_y_1 = tab_utc[ bas + 9 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 1H 10M 16S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveCamera_XY(
                        tra_i_x  //: Trans:DATAPIXELS: X
                    ,   tra_i_y  //: Trans:DATAPIXELS: Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){

                        failed_unit_test=( 1 );

                        /** ******************************** **/
                        /** @VID_IID[ 02H 13M 20S ]          **/
                        /** We originally decided rectangle  **/
                        /** manipulation was bounded into a  **/
                        /** 512x512 region. However for      **/
                        /** PAINT5D system the camera        **/
                        /** rectangle has a tighter          **/
                        /** 256x256 bounds.                  **/
                        /** SEE[ #_P5D_BOUNDING_#  ]         **/
                        /** ******************************** **/
                        LOG("[VP1_Cam_Bounds_Are_Tighter]",0);

                    };;
    
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[YOU_DONE_FAILED]");

                    };;

                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:MoveCamera_XY]" );
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ZoomCamera( void )
        {
        #define NUMBER_OF_TESTS (        22 ) /**TWENTY_2(22)**/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );

                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: data **/
                                ;
                    U32 inn_x_0 ; /** INPUTS: Camera Rect    **/
                    U32 inn_x_1 ;
                    U32 inn_y_0 ;
                    U32 inn_y_1 ;
                                ;
                    U32 zom_i32 ; /** INPUTS: Camera Zoom **/
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                    /** ************************************ ***
                        @VID_IID[ 0076 ]TIME[ 2H 39M 10S ]

                        weird_names_because: 
                        We kept confusing

                             "Input And Output"
                        With "Expected And Actual"

                        And tangling our mental understanding
                        between the pairs of words.
                    ** ************************************* **/

                    U32 O_A_x_0 ; /** OUT: Camera Rectangle  **/
                    U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL   **/      
                    U32 O_A_y_0 ;
                    U32 O_A_y_1 ;
                                ;
                    U32 exp_x_0 ; /** EXPECTED : Camera Rect **/
                    U32 exp_x_1 ; /**                        **/
                    U32 exp_y_0 ;
                    U32 exp_y_1 ;
                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        //: inn_ inn_ inn_ inn_   zom_i32    exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB     ZOOM     ENDING_CAMERA_PAB

        //: @VID_IID[ 0083 ]TIME[ 05:45:40 ]            .....://
        //: 1x1 viewport in the extreme corners of the  .....://
        //: auset dataset that Josh is looking over.    .....://
        //: 12 viewport smoke tests below.              .....://
        
        //: #TOP_LEF__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
           0x00,0x00,0x00,0x00 ,   0x00   ,  0x00,0x00,0x00,0x00
        ,  0x00,0x00,0x00,0x00 ,0+    1   ,  0x00,0x00,0x00,0x00
        ,  0x00,0x00,0x00,0x00 ,0-    1   ,  0x00,   2,0x00,   2
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #TOP_RIG__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,   255, 255,0x00,0x00 ,   0x00   ,   255, 255,0x00,0x00
        ,   255, 255,0x00,0x00 ,0+    1   ,   255, 255,0x00,0x00
        ,   255, 255,0x00,0x00 ,0-    1   ,   253, 255,0x00,   2
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #BOT_LEF__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,  0x00,0x00, 255, 255 ,   0x00   ,  0x00,0x00, 255, 255
        ,  0x00,0x00, 255, 255 ,0+    1   ,  0x00,0x00, 255, 255
        ,  0x00,0x00, 255, 255 ,0-    1   ,  0x00,   2, 253, 255
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #BOT_RIG__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,   255, 255, 255, 255 ,   0x00   ,   255, 255, 255, 255
        ,   255, 255, 255, 255 ,0+    1   ,   255, 255, 255, 255
        ,   255, 255, 255, 255 ,0-    1   ,   253, 255, 253, 255
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: 9 extra tests where we DONT hit the boarders:
        //: @VID_IID[ 0084 ]TIME[ 00:06:50 ]

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   100, 200, 100, 200 ,   0x00   ,   100, 200, 100, 200
        ,   100, 200, 100, 200 ,0+    1   ,   101, 199, 101, 199
        ,   100, 200, 100, 200 ,0-    1   ,    99, 201,  99, 201

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   100, 200, 0x0, 100 ,   0x00   ,   100, 200, 0x0, 100
        ,   100, 200, 0x0, 100 ,0+    1   ,   101, 199,   1,  99
        ,   100, 200, 0x0, 100 ,0-    1   ,    99, 201, 0x0, 102

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   0x0, 100, 100, 200 ,   0x00   ,   0x0, 100, 100, 200
        ,   0x0, 100, 100, 200 ,0+    1   ,     1,  99, 101, 199
        ,   0x0, 100, 100, 200 ,0-    1   ,   0x0, 102,  99, 201

        //: @VID_IID[ 0084 ]TIME[ 00:18:48 ]
        //: ONE MORE TEST AND THEN FVCK THIS SHIT.

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   0x0,   3, 0x0,   3 , 0-9001   ,   0x0, 255, 0x0, 255

        //: STARTING_CAMERA_PAB     ZOOM     ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                zom_i32 = tab_utc[ bas + 4 ]; /**Zoom_Amount **/
 
                exp_x_0 = tab_utc[ bas + 5 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 6 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 7 ];
                exp_y_1 = tab_utc[ bas + 8 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 2H 40M 00S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_ZoomCamera(
                        zom_i32  //: Trans:DATAPIXELS: X
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:ZOOM]",0);
                    };;
    
                    if( 0 != failed_unit_test ){

                        printf("\n\n\n"); //:Padding for console

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[PAINT5D_ZOOM_TEST_FAILED]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:ZOOMCAMERA]" );
            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveBrush_XY( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 6 ) /**    SIX(6)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                U32     nouse_1         =( 666070666 );
                U32     nouse_2         =( 666070666 );
                U32     nouse_3         =( 666070666 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 bru_i_x ; /** INPUTS: Brush X/Y **/
                U32 bru_i_y ;

                I32 off_i_x ; /** INPUTS: Brush OFFSET X/Y **/
                I32 off_i_y ;  
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** #_WEIRD_UNIT_TEST_VAR_NAMES_O_A_# **/

                U32 O_A_b_x ; /** OUTPUTS: Brush[x,y]        **/
                U32 O_A_b_y ; /** O_A: OUTPUT & ACTUAL values**/      
                            ;
                U32 exp_b_x ; /** EXPECTED : Brush[x,y] .... **/
                U32 exp_b_y ; /**                       .... **/

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
                //: _i_x _i_y     _i_x _i_y     _b_x _b_y
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
                    0x00,0x00  ,  0x00,0x00  ,  0x00,0x00 
                ,   0x00,0x00  ,     1,0x00  ,     1,0x00 
                ,   0x00,0x00  ,  0x00,   1  ,  0x00,   1 
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                bru_i_x = tab_utc[ bas + 0 ]; /** SEEDING    **/
                bru_i_y = tab_utc[ bas + 1 ]; /** INIT_BRUSH **/
                //:                    #                     ://
                off_i_x = tab_utc[ bas + 2 ]; /**Translate   **/
                off_i_y = tab_utc[ bas + 3 ]; /** X & Y      **/
                //:                    #                     ://
                exp_b_x = tab_utc[ bas + 4 ]; /** EXPECTED   **/
                exp_b_y = tab_utc[ bas + 5 ]; /** OUTPUTS    **/
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                        #_WHAT_DOES_VP1_MEAN_IN_PAINT5D_#
                        #_WHAT_DOES_B_X_B_Y_MEAN_IN_PAINT5D_#

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    , ( bru_i_x ), ( nouse_1 )  //:BRUSH:X 
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    , ( bru_i_y ), ( nouse_1 )  //:BRUSH:X
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveBrush_XY(
                        off_i_x //: o_x : brush_OFFSET_integer_X
                    ,   off_i_y //: o_y : brush_OFFSET_integer_Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    ,&( O_A_b_x ),&( nouse_1 )  //:BRUSH:X 
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    ,&( O_A_b_y ),&( nouse_1 )  //:BRUSH:X
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;


                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_b_x  
                    !=  exp_b_x
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_b_y  
                    !=  exp_b_y
                    ){ failed_unit_test =( 1 ); };

                    /** ************************************ **/
                    /** FAIL BECAUSE OUT OF PAINT5D BOUNDS   **/
                    /** Which are tighter than the bounds    **/
                    /** for generic inclusive rectangle type **/
                    /** ************************************ **/
                    if( 0
                    ||  (((I32)  exp_b_x  )+0) < MIN_X_0 
                    ||  (((I32)  exp_b_y  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  exp_b_x  )+0) > MAX_X_1 
                    ||  (((I32)  exp_b_y  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:BRUSH_TRANS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[b_x:A|E]:(%d):(%d)\n"
                        , O_A_b_x , exp_b_x );;

                        printf("[b_y:A|E]:(%d):(%d)\n"
                        , O_A_b_y , exp_b_y );;

                        ERR("[PAINT5D_BRUSH_TRANS_FAIL]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_MORE_TEST_CASES:MoveBrush_XY]"
            );;

            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileValue( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_val ; /** INPUTS: Tile VAL       **/
                    I32 off_val ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_val ; /** EXPECTED : TILE VALUE  **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_val ; /** ACTUAL   : TILE VALUE  **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_val  |  off_val  |  exp_val
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_val  |  off_val  |  exp_val
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_val = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_val = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_val = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    , ( inn_val ), ( nouse_1 )  //:TILE_VALUE
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileValue(
                        off_val //: del_t_v ( Delta Tile Value )
                    );;  

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    ,&( act_val ),&( nouse_1 )  //:TILE_VALUE
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_VAL (            0            ) //01
                #define MAX_VAL AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act_val  
                    !=  exp_val
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_VAL < MAX_VAL );
                    if( 0
                    ||  (((I32)  exp_val  )+0) < MIN_VAL           
                    ||  (((I32)  exp_val  )+0) > MAX_VAL 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_VALUE_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_val:exp_val]:(%d):(%d)\n"
                        , act_val , exp_val );;

                        ERR("[BRUSH_TILE_VALUE_TEST_FAIL]");
                    };;
                #undef  MIN_VAL                       //: 01 ://
                #undef  MAX_VAL                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileValue]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileExponent( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_E ; /** INPUTS: Tile VAL       **/
                    I32 off_T_E ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_E ; /** EXPECTED :TILE EXPONENT**/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_E ; /** ACTUAL   :TILE EXPONENT**/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_E  |  off_T_E  |  exp_T_E
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_E  |  off_T_E  |  exp_T_E
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_E = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_E = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_E = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    , ( inn_T_E ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileExponent(
                        off_T_E //: del_t_e :............
                    );;         //: ( Delta Tile EXPONENT )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    ,&( act_T_E ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_E (            0            ) //01
                #define MAX_T_E AAC2020_PAINT5D_MAX_til_exp //02
 
                    if( act_T_E  
                    !=  exp_T_E
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_T_E < MAX_T_E );
                    if( 0
                    ||  (((I32)  exp_T_E  )+0) < MIN_T_E           
                    ||  (((I32)  exp_T_E  )+0) > MAX_T_E 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_EXPONENT_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("\n\n");
                        printf("[t_i]:%d\n", t_i );

                        printf("[inn_T_E]:%d\n", inn_T_E);
                        printf("[off_T_E]:%d\n", off_T_E);
                        printf("[exp_T_E]:%d\n", exp_T_E);
                        printf("\n\n");

                        printf("[act_T_E:::exp_T_E]:(%d):(%d)\n"
                               , act_T_E , exp_T_E );;

                        ERR("[BRUSH_TILE_EXPONENT_TEST_FAIL]");
                    };;
                #undef  MIN_T_E                       //: 01 ://
                #undef  MAX_T_E                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileExponent]"
            );;
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileLayer( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_L ; /** INPUTS: Tile LAYER     **/
                    I32 off_T_L ; /** INPUTS: LAY OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_L ; /** EXPECTED :TILE LAYER   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_L ; /** ACTUAL   :TILE LAYER   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_L  |  off_T_L  |  exp_T_L
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_L  |  off_T_L  |  exp_T_L
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_L = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_L = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_L = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    , ( inn_T_L ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileLayer(
                        off_T_L //: del_t_l :............
                    );;         //: ( Delta Tile LAYER )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    ,&( act_T_L ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_L (            0            ) //01
                #define MAX_T_L AAC2020_PAINT5D_MAX_til_lay //02
 
                    if( act_T_L  
                    !=  exp_T_L
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_L < MAX_T_L );
                    if( 0
                    ||  (((I32)  exp_T_L  )+0) < MIN_T_L           
                    ||  (((I32)  exp_T_L  )+0) > MAX_T_L 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_LAYER_IS_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_T_L:exp_T_L]:(%d):(%d)\n"
                        , act_T_L , exp_T_L );;

                        ERR("[BRUSH_TILE_LAYER_TEST_FAIL]");
                    };;
                #undef  MIN_T_L                       //: 01 ://
                #undef  MAX_T_L                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileLayer]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ToggleTile( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:misc_test_runner_vars:--------------------://

                    I32     failed_unit_test=( 0 );
 
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/

                //:--------------------:misc_test_runner_vars://
                //:initial_value(s):-------------------------://

                    U08  t_q ; //: til_qua (TILE QUADRANT     )
                    U08  t_e ; //: til_exp (TILE EXPONENT     )   
                    U08  t_l ; //: til_lay (TILE LAYER        )
                    U08  l_x ; //: loc_t_x (LOCAL TILE X      ) 
                    U08  l_y ; //: loc_t_y (LOCAL TILE Y      ) 
                    U08  a_d ; //: aus_dex (AUSET INDEX       )
                    U08  t_v ; //: til_val (INITIAL tile value)   

                //:-------------------------:initial_value(s)://    
                //:mutator_value(s):-------------------------://

                    U08  b_v ; //:MUST_LOAD_INTO_BRUSH!

                //:-------------------------:mutator_value(s)://
                //:expected_value(s):------------------------://

                    U08  exp ; /** EXPECTED :TILE VALUE   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U08  act ; /** ACTUAL   :TILE VALUE   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={                                
                //: t_v : INITIAL                tile_value
                //: exp : EXPECTED after command tile_value
                //: act : ACTUAL     (output)    tile_value
                //:     ( act should not be in this table )
                //: b_v : BRUSH VALUE 
                //:     ( value loaded into brush )
                                               
        //: t_q | t_e | t_l | l_x | l_y | a_d | t_v | b_v | exp
            0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   1 ,   0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   0 ,   0
            };;   //:THREE_ARE_TILE_VALUES: >>> ___ , ___ , ___
        //: 001   002   003   004   005   006   007   008   009

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                //:unpack_test_row_data:---------------------://

                    /** INITIAL_VALUE(S) **/
                    t_q = (U08) ( tab_utc[ bas + 0 ] );
                    t_e = (U08) ( tab_utc[ bas + 1 ] );              
                    t_l = (U08) ( tab_utc[ bas + 2 ] );
                    l_x = (U08) ( tab_utc[ bas + 3 ] );
                    l_y = (U08) ( tab_utc[ bas + 4 ] );
                    a_d = (U08) ( tab_utc[ bas + 5 ] );
                    t_v = (U08) ( tab_utc[ bas + 6 ] );

                    /** mutator_value(s)  **/
                    b_v = (U08) ( tab_utc[ bas + 7 ] );  

                    /** expected_value(s) **/
                    exp = (U08) ( tab_utc[ bas + 8 ] ); 
              
                //:---------------------:unpack_test_row_data://
                //:OVERWRITE_til_val_WITH_BRUSH:-------------://
        
                    /** Seed Tile Data Location With The **/
                    /** Initial Value .................. **/

                        /** Load brush with all of it's state**/
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent)
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   t_v //: INITAL / OVERWRITE VALUE
                        );;

                        /** Like ToggleTile , but is an      **/
                        /** override rather than a toggle.   **/                 
                        aac2020_paint5d_Put_UsingBrush( );

                //:-------------:OVERWRITE_til_val_WITH_BRUSH://
                //:apply_tile_toggle_action:-----------------://

                    /** Set the brush value you want to      **/
                    /** test the ToggleTile( ) command with  **/
                         
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent) 
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   b_v //: <-- t_v __SWAPPED_TO__ b_v
                        );;

                    /** Uses what is loaded into the tilemap **/
                    /** to determine the results.            **/

                        aac2020_paint5d_ToggleTile( );

                //:-----------------:apply_tile_toggle_action://
                //:get_ACTUAL_value_set_into_bitmap:---------://

                    /** @VID_IID[ 2H 55M 40S ] ************* **/
                    /** More abstractly explained:           **/
                    /** Get the tile value at this location  **/
                    /** within the paint5d tilemap data.     **/
                    /** ************************************ **/

                    AAC2020_PAINT5D_Get(
                            t_q   /** 01 :         til_qua   **/  
                    ,       t_e   /** 02 :         til_exp   **/  
                    ,       t_l   /** 03 :         til_lay   **/  
                    ,       l_x   /** 04 :         loc_t_x   **/  
                    ,       l_y   /** 05 :         loc_t_y   **/  
                    ,       a_d   /** 06 :         aus_dex   **/  
                    ,  &(   act ) /** 07 : GET ACT til_val   **/
                    );;

                //:---------:get_ACTUAL_value_set_into_bitmap://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_V (            0            ) //01
                #define MAX_T_V AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act 
                    !=  exp 
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_V < MAX_T_V );
                    if( 0
                    ||  (((I32)  exp   )+0) < MIN_T_V           
                    ||  (((I32)  exp   )+0) > MAX_T_V 

                    ||  (((I32)  act   )+0) < MIN_T_V           
                    ||  (((I32)  act   )+0) > MAX_T_V 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[T_V:OOB:2021:746PM]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act:exp]:(%d):(%d)\n"
                        , act , exp );;

                        ERR("[TILE_TOGGLE_TEST_FAIL:2021]");
                    };;
                #undef  MIN_T_V                       //: 01 ://
                #undef  MAX_T_V                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
                    
            AAC2020_TODOMAN_Vital(
                "[ADD_MORE_TEST_CASES:ToggleTile]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_UnitTest_ProgControls( void )
    {
        //:helper_functions:generic:- - - - - - - - - - - - -://
        aac2020_paint5d_CTF=(     "[Min_I16]"    );
        EXT VOD aac2020_paint5d_UTC_Min_I16( VOD );
                aac2020_paint5d_UTC_Min_I16(     );

        aac2020_paint5d_CTF=(     "[i32_Cap_u32]"    );
        EXT VOD aac2020_paint5d_UTC_i32_Cap_u32( VOD );
                aac2020_paint5d_UTC_i32_Cap_u32(     );

        //:- - - - - - - - - - - - -:helper_functions:generic://
        //:helper_functions::conversion:- - - - - - - - - - -://
 
        aac2020_paint5d_CTF=(     "[til_exp_CTO_bip_sip]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_bip_sip( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_bip_sip(     );

        aac2020_paint5d_CTF=(     "[til_exp_CTO_max_cor]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_max_cor( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_max_cor(     );

        aac2020_paint5d_CTF=(     "[til_exp_CTO_diagpix]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_diagpix(     );

        aac2020_paint5d_CTF=(     "[diagpix_CTO_til_exp]"    );
        EXT VOD aac2020_paint5d_UTC_diagpix_CTO_til_exp( VOD );
                aac2020_paint5d_UTC_diagpix_CTO_til_exp(     );

        /**@DNE aac2020_paint5d_UTC_diagpix_CTO_astipix @DNE **/

        aac2020_paint5d_CTF=(     "[astipix_CTO_diagpix]"    );
        EXT VOD aac2020_paint5d_UTC_astipix_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_astipix_CTO_diagpix(     );

        //:- - - - - - - - - - -:helper_functions::conversion://
        //:paired_unit_tests::- - - - - - - - - - - - - - - -://

        aac2020_paint5d_CTF=(     "[glocpix_CTO_painpix]"    );
        EXT VOD aac2020_paint5d_UTC_glocpix_CTO_painpix( VOD );
                aac2020_paint5d_UTC_glocpix_CTO_painpix(     );

        aac2020_paint5d_CTF=(     "[painpix_CTO_glocpix]"    );
        EXT VOD aac2020_paint5d_UTC_painpix_CTO_glocpix( VOD );
                aac2020_paint5d_UTC_painpix_CTO_glocpix(     );

        /** @VID_IID[ 0080 ]TIME[ 00:33:30 ] *************** **/
        /** Test every single possible conversion value by   **/
        /** doing a [p_x , p_y ] loop over 512x512 pixels.   **/

        aac2020_paint5d_CTF=(     "[pix_CTO_pix_PUT_GET]"    );
        EXT VOD aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET( VOD );
                aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET(     );

        //:- - - - - - - - - - - - - - - -:paired_unit_tests:://
        //:main_get_put_tests::DEPENDS_ON::- - - - - - - - -:://
        /** ************************************************ ***
        @VID_IID[ 0081 ]TIME[ 00:09:58 ]
        Test the bit shifting logic used by 
        AAC2020_PAINT5D_Put & AAC2020_PAINT5D_Get
        because we think the reason tests
        "aac2020_paint5d_UTC_Put" and "aac2020_paint5d_UTC_Get"
        are failing is because the bit shifting logic is wrong.
        We have extracted the bit [ shifting / packing ] logic
        into their own functions to help verify that
        logic is correct.
        *** ************************************************ **/

            aac2020_paint5d_CTF=(     "[BitPack_Put]"    );
            EXT VOD aac2020_paint5d_UTC_BitPack_Put( VOD );
                    aac2020_paint5d_UTC_BitPack_Put(     );

            aac2020_paint5d_CTF=(     "[BitPack_Get]"    );
            EXT VOD aac2020_paint5d_UTC_BitPack_Get( VOD );
                    aac2020_paint5d_UTC_BitPack_Get(     );

        //:- - - - - - - - -::main_get_put_tests::DEPENDS_ON:://
        //:main_get_put_tests::- - - - - - - - - - - - - - -:://

            aac2020_paint5d_CTF=(     "[Put]"    );
            EXT VOD aac2020_paint5d_UTC_Put( VOD );
                    aac2020_paint5d_UTC_Put(     );

            aac2020_paint5d_CTF=(     "[Get]"    );
            EXT VOD aac2020_paint5d_UTC_Get( VOD );
                    aac2020_paint5d_UTC_Get(     );

            /** ******************************************** ***
                @DEP[ aac2020_paint5d_UTC_Get ]               
                @DEP[ aac2020_paint5d_UTC_Put ]               
                @DEP[ aac2020_paint5d_UTC_glocpix_CTO_painpix ]  
            
                @VID_IID[ 0071 ]TIME[ 00H 12M 52S ]  
            *** ******************************************** **/

            aac2020_paint5d_CTF=(     "[Put_Get]"    );
            EXT VOD aac2020_paint5d_UTC_Put_Get( VOD );
                    aac2020_paint5d_UTC_Put_Get(     );

            /** ******************************************** **/

        //:- - - - - - - - - - - - - - -::main_get_put_tests:://
        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:ADDED_FUNC_PAIR_ON_2021_01_09:------------------------://
    #define VERY_SPECIFIC_DEFINES_HERE_ONLY

        void
        aac2020_paint5d_UTC_BitPack_Put( void )
        {
        #define NUM_ELM_001 ( 3 ) /** 3 elements per test    **/
        #define NUM_TES_001 (32 ) /** Total number of tests  **/
        //:                                                  ://
        #define NUM_ELM_002 (16 )  /** Test Table # 2 .......**/
        #define NUM_TES_002 (12 )  /** Sizes.         .......**/

            LOG("[BEG:aac2020_paint5d_UTC_BitPack_Put:BEG]",0);

            I32     bas; //:base offset for current test
            I32     t_i; //:test index
            I32     m_i; //:max test index
            U08 cpu_pix[ 4 * 4 ]={ 0 };

            U08 glo_com;
            U08 aus_dex;
            U08 til_val;

            U32 u32_var; //:<-- 1 pixels worth of data.
            U08 u08_var;

            //:Do all tests in pairs. Set and then erase.
            //:Thus expecting the final array to always be
            //:nothing but zeros. Actually... Don't hard
            //:Code this. Make it a feature of the test....
            U08 tab_utc[ NUM_ELM_001 * NUM_TES_001 ]={

            //: glo_com | aus_dex | til_val //:SUM        DEX://
                   0    ,    0    ,    0    //: 01        00 ://
            ,      0    ,    0    ,    1    //: 02        01 ://
            ,      0    ,    0    ,    2    //: 03        02 ://
            ,      0    ,    0    ,    3    //: 04        03 ://
                                            //: --        -- ://
            ,      0    ,   15    ,    0    //: 05        04 ://
            ,      0    ,   15    ,    1    //: 06        05 ://
            ,      0    ,   15    ,    2    //: 07        06 ://
            ,      0    ,   15    ,    3    //: 08        07 ://
                                            //: --        -- ://
            ,      4    ,    0    ,    0    //: 09        08 ://
            ,      4    ,    0    ,    1    //: 10        09 ://
            ,      4    ,    0    ,    2    //: 11        10 ://
            ,      4    ,    0    ,    3    //: 12        11 ://
                                            //: --        -- ://
            ,      4    ,   15    ,    0    //: 13        12 ://
            ,      4    ,   15    ,    1    //: 14        13 ://
            ,      4    ,   15    ,    2    //: 15        14 ://
            ,      4    ,   15    ,    3    //: 16        15 ://
                                            //: --        -- ://
            ,      8    ,    0    ,    0    //: 17        16 ://
            ,      8    ,    0    ,    1    //: 18        17 ://
            ,      8    ,    0    ,    2    //: 19        18 ://
            ,      8    ,    0    ,    3    //: 20        19 ://
                                            //: --        -- ://
            ,      8    ,   15    ,    0    //: 21        20 ://
            ,      8    ,   15    ,    1    //: 22        21 ://
            ,      8    ,   15    ,    2    //: 23        22 ://
            ,      8    ,   15    ,    3    //: 24        23 ://
                                            //: --        -- ://
            ,     12    ,    0    ,    0    //: 25        24 ://
            ,     12    ,    0    ,    1    //: 26        25 ://
            ,     12    ,    0    ,    2    //: 27        26 ://
            ,     12    ,    0    ,    3    //: 28        27 ://
                                            //: --        -- ://
            ,     12    ,   15    ,    0    //: 29        28 ://
            ,     12    ,   15    ,    1    //: 30        29 ://
            ,     12    ,   15    ,    2    //: 31        30 ://
            ,     12    ,   15    ,    3    //: 32        31 ://
            //: glo_com | aus_dex | til_val //:SUM        DEX://
            };;

            m_i=( NUM_TES_001 - 1 );
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                bas = ( t_i * NUM_ELM_001  ); //:t_i * STRIDE://
                glo_com = tab_utc[ bas + 0 ];
                aus_dex = tab_utc[ bas + 1 ];
                til_val = tab_utc[ bas + 2 ];

                aac2020_paint5d_BitPack_Put(
                    cpu_pix //: PIXEL_BYTE_ARRAY       ..... ://
                ,   glo_com //: GLOBAL_COMPONENT_INDEX ..... ://
                ,   aus_dex //: AUSET_INDEX_00_TO_15   ..... ://
                ,   til_val //: TILE__VALUE_00_TO_03   ..... ://
                );;

                //:manual_check:-----------------------------://

                    u32_var = ( 0x00 ); //:Clear_The_Pixel
                    
                    /** @VID_IID[ 0082 ]TIME[ 01:21:40 ]     **/
                    /** Use "glo_com" to extract the current **/
                    /** pixel we are looking at.             **/
                    /** This is NOT the way we want to do it **/
                    /** in production, because we are looking**/
                    /** at 4 bytes when we only need ONE of  **/
                    /** them. However, the math is more      **/
                    /** straightforward this way and better  **/
                    /** for unit testing.                    **/
                    u32_var=(
                    0x00
                    |   ( cpu_pix[ glo_com + 0 ] << 24 ) //:R://
                    |   ( cpu_pix[ glo_com + 1 ] << 16 ) //:G://
                    |   ( cpu_pix[ glo_com + 2 ] <<  8 ) //:B://
                    |   ( cpu_pix[ glo_com + 3 ] <<  0 ) //:A://
                    );;     

                    //:@VID_IID[ 0082 ]TIME[ 2H 34M 48S ]
                    //:count bits. Should not be more than 2.
                    U32 b_c=( 0 ); /** Bit Count **/
                    for( I32 i = 0; i <= (32-1) ; i++ ){
                        b_c=( b_c + ((u32_var>>i)&1) );
                    };;
                    if( b_c > 2 ){ /** Only 2 bit values! **/
                        ERR("[TOO_MANY_SET_BITS_BAD_BIT_PACK]");
                    };;

                    u08_var=(
                        (U08)(
                            ( u32_var >> ( aus_dex * 2 ) )
                            & //:<-- only ONE "&" symbol.
                            3 //:<-- Binary[ 11 ]MASK
                        )
                    );;
            
                    /**  actual != expected **/
                    if( u08_var != til_val    ){
                
                        U32 pix;
                        I32 n_z=( 0 ); //:non_zero_found?
                        I32 nzi=(0-1); //:index of last[ n_z ]
                        for( I32 i = 0 ; i <= ((4*4)-1) ; i++ ){

                            if( 0x00 != cpu_pix[ i ] ){
                                pix=(   cpu_pix[ i ] );
                                n_z++;
                                nzi=( i );
                                printf("[cur:nzi]:%d\n"   ,nzi);
                                printf("[hex:pix]:%02x\n" ,pix);
                            };;
                        };;

                        printf("[....t_i]:%d\n",     t_i );
                        printf("[u32_var]:%d\n", u32_var );
                        printf("[u08_var]:%d\n", u08_var );
                        printf("[til_val]:%d\n", til_val );
                        printf("[....n_z]:%d\n",     n_z );
            
                        printf("cpu_pix[ glo_com + 0 ]==>%d\n",
                                cpu_pix[ glo_com + 0 ] );;
                        printf("cpu_pix[ glo_com + 1 ]==>%d\n",
                                cpu_pix[ glo_com + 1 ] );;
                        printf("cpu_pix[ glo_com + 2 ]==>%d\n",
                                cpu_pix[ glo_com + 2 ] );;
                        printf("cpu_pix[ glo_com + 3 ]==>%d\n",
                                cpu_pix[ glo_com + 3 ] );;

                            /** MAKE SURE YOUR SHIFT AMOUNT  **/
                            /** IS ON THE RIGHT IN YOUR      **/
                            /** BITPACKING CODE.             **/
                            /**tmu:test_my_understanding**/
                            U32 tmu=( 
                            0x00
                            |   (24 << 0 ) //:R://
                            |   (16 << 0 ) //:G://
                            |   ( 8 << 0 ) //:B://
                            |   ( 0 << 1 ) //:A://
                            );;   
                            if( 24 != tmu ){
                                printf("[tmu]:%d\n", tmu);
                                ERR("[DONT_KNOW_JACK_2021]");
                            };;

                        ERR(
                            "[PUT_HAS_FAILED_2021_01_09_BLUE]"
                        );;
                    };;

                //:-----------------------------:manual_check://

                /** Putting zero should revert the entire    **/
                /** test array to all zeros.                 **/

                aac2020_paint5d_BitPack_Put(
                    cpu_pix //: PIXEL_BYTE_ARRAY       ..... ://
                ,   glo_com //: GLOBAL_COMPONENT_INDEX ..... ://
                ,   aus_dex //: AUSET_INDEX_00_TO_15   ..... ://
                ,      0    //: TILE__VALUE_00_TO_03   ..... ://
                );;

                /** b_i : byte index **/
                for( I32 b_i = 0 ; b_i <= ((4*4)-1) ; b_i ++ ){

                    if( 0x00 != cpu_pix[ b_i ] ){
                        ERR("[PROBLEM_2021_01_09_PUT_TEST]");
                    };;
                };;

            };;

            /** ******************************************** **/
            /** Another Set Of Tests...                      **/
            /** PUT evertything then manually GET everything.**/
            /** So it is like a "Put_Get" test however we    **/
            /** do NOT use the "Getter" function but rather  **/
            /** use manual logic to GET the values.          **/
            /** This is because we want to test the          **/
            /** "get" and "put" functionality in isolation   **/
            /** before we do a real "Put_Get"                **/
            /** integration test.                            **/
            /** @VID_IID[ 0082 ]TIME[ 1H 48M 46S ]           **/
            /** Explaning test table #2 below.               **/
            /** ******************************************** **/

            assert( 16 == NUM_ELM_002 );
            assert( 12 == NUM_TES_002 );
            U08 tab_002[ NUM_ELM_002 * NUM_TES_002 ]={
            //: 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
    /* 01 */     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    /* 02 */,    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 
    /* 03 */,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  
    /* 04 */,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  

    /* 05 */,    0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
    /* 06 */,    3, 2, 1, 0, 3, 2, 1, 0, 3, 2, 1, 0, 3, 2, 1, 0

    /* 07 */,    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3
    /* 08 */,    3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0

    /* 09 */,    3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0
    /* 10 */,    0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3 

                /** Random number test. Keep this one last   **/
                /** because I really don't want to deal with **/
                /** this test case failing as the lack of    **/
                /** a regular pattern makes the data harder  **/
                /** to mentally reason about.                **/
                /** @VID_IID[ 0082 ]TIME[ 01:35:42 ]         **/
    /* 11 */,    1, 3, 2, 0, 3, 2, 1, 2, 3, 0, 1, 2, 0, 3, 1, 2 
    /* 12 */,    0, 3, 1, 2, 0, 3, 0, 1, 2, 3, 1, 2, 0, 3, 1, 0 
            };;

            assert( 16 == NUM_ELM_002     );
            assert( 12 == NUM_TES_002     );
            m_i=(         NUM_TES_002 - 1 );
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                bas =( t_i * NUM_ELM_002 );
            
                /** PUT ALL VALUES FOR CURRENT TEST **/

                for( aus_dex = 0;aus_dex <=(16-1); aus_dex++ ){

                    glo_com = 0;
                    til_val = tab_002[ bas + aus_dex ];

                    aac2020_paint5d_BitPack_Put(
                          cpu_pix  
                    ,     glo_com 
                    ,     aus_dex  
                    ,     til_val 
                    );;
                };;

                /** GET ALL VALUES FOR CURRENT TEST **/

                for( aus_dex = 0;aus_dex <=(16-1); aus_dex++ ){

                    /** expected tile value */
                    til_val = tab_002[ bas + aus_dex ];

                    u32_var=(
                    0x00
                    |   (cpu_pix[ glo_com + 0 ] << 24 ) //:R://
                    |   (cpu_pix[ glo_com + 1 ] << 16 ) //:G://
                    |   (cpu_pix[ glo_com + 2 ] <<  8 ) //:B://
                    |   (cpu_pix[ glo_com + 3 ] <<  0 ) //:A://
                    );;                                  

                    u08_var=( /** <-- ACTUAL tile value **/
                        (U08)(
                            ( u32_var >> ( aus_dex * 2 ) )
                            & //:<-- only ONE "&" symbol.
                            3 //:<-- Binary[ 11 ]MASK
                        )
                    );;

                    if( til_val != u08_var ){
                        /** E_V_A : Expected_Vs_Actual **/
                        ERR( "[E_V_A:til_val:vs:u08_var]" );;
                    };;

                };;

            };;

            LOG("[END:aac2020_paint5d_UTC_BitPack_Put:END]",0);

        #undef NUM_ELM_001                            //: 01 ://
        #undef NUM_TES_001                            //: 02 ://
        //:                                           //: -- ://
        #undef NUM_ELM_002                            //: 03 ://
        #undef NUM_TES_002                            //: 04 ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_BitPack_Get( void )
        {
        #define NUM_ELM (       3      ) /** num    elements **/
        #define NUM_TES (     160      ) /** number of tests **/
        #define BIN_011 (       3      ) /** binary:11       **/

            //:declare_most_variables:-----------------------://

                I32     bas; //:base offset for current test ://
                I32     t_i; //:test index                   ://
                I32     m_i; //:max test index               ://
                U08 cpu_pix[ 4 * 4 ]={ 0 }; //:4 RGBA pixels.://

                U08 glo_com;    /** global component index   **/
                U08 aus_dex;    /** auset number index       **/
                U08 til_val;    /** tile value to set 0-to-3 **/
                U08 got_val;    /** GOTTEN tile value/actual **/

                /** from LSB to MSB                          **/
                /** LSB: Least_Significant_Bit               **/
                /** MSB: Most__Significatn_Bit               **/
                I32     bi0;    /** bit index 0 (1st) LSB    **/
                I32     bi1;    /** bit index 1 (2nd) MSB    **/

                I32     zer;    /** Number of __ZERO__ bytes **/
                I32     non;    /** Number of non-zero bytes **/

                I32     era;    /** Erase Before Next Test?  **/

                U32 u32_var; //:<-- 1 pixels worth of data.  ://
            /// U08 u08_var;

            //:-----------------------:declare_most_variables://
            //:table_of_unit_test_code:----------------------://
            U08 tab_utc[ NUM_ELM * NUM_TES ]={
            //: glo_com | aus_dex | til_val //:SUM        DEX://
                   0    ,    0    ,    0    //: 01        00 ://
            ,      0    ,    0    ,    1    //: 02        01 ://
            ,      0    ,    0    ,    2    //: 03        02 ://
            ,      0    ,    0    ,    3    //: 04        03 ://
                                            //: --        -- ://
            ,      0    ,   15    ,    0    //: 05        04 ://
            ,      0    ,   15    ,    1    //: 06        05 ://
            ,      0    ,   15    ,    2    //: 07        06 ://
            ,      0    ,   15    ,    3    //: 08        07 ://
                                            //: --        -- ://
            ,      4    ,    0    ,    0    //: 09        08 ://
            ,      4    ,    0    ,    1    //: 10        09 ://
            ,      4    ,    0    ,    2    //: 11        10 ://
            ,      4    ,    0    ,    3    //: 12        11 ://
                                            //: --        -- ://
            ,      4    ,   15    ,    0    //: 13        12 ://
            ,      4    ,   15    ,    1    //: 14        13 ://
            ,      4    ,   15    ,    2    //: 15        14 ://
            ,      4    ,   15    ,    3    //: 16        15 ://
                                            //: --        -- ://
            ,      8    ,    0    ,    0    //: 17        16 ://
            ,      8    ,    0    ,    1    //: 18        17 ://
            ,      8    ,    0    ,    2    //: 19        18 ://
            ,      8    ,    0    ,    3    //: 20        19 ://
                                            //: --        -- ://
            ,      8    ,   15    ,    0    //: 21        20 ://
            ,      8    ,   15    ,    1    //: 22        21 ://
            ,      8    ,   15    ,    2    //: 23        22 ://
            ,      8    ,   15    ,    3    //: 24        23 ://
                                            //: --        -- ://
            ,     12    ,    0    ,    0    //: 25        24 ://
            ,     12    ,    0    ,    1    //: 26        25 ://
            ,     12    ,    0    ,    2    //: 27        26 ://
            ,     12    ,    0    ,    3    //: 28        27 ://
                                            //: --        -- ://
            ,     12    ,   15    ,    0    //: 29        28 ://
            ,     12    ,   15    ,    1    //: 30        29 ://
            ,     12    ,   15    ,    2    //: 31        30 ://
            ,     12    ,   15    ,    3    //: 32        31 ://

            /** @VID_IID[ 0083 ]TIME[ 03:52:20 ] *********** **/
            /** Added interlacing tests to further check     **/
            /** our logic is correct.                        **/

            /** @VID_IID[ 0083 ]TIME[ 04:21:28 ]             **/
            /** Anyone who says that TYPING is never the     **/
            /** bottleneck is full of shit!                  **/
            /** For an example, see the checksums            **/
            /** we are writing in the comments below         **/
            /** and to the right. -John Mark 2021_01_11      **/

            /** @VID_IID[ 0083 ]TIME[ 04:30:16 ] FIX #1      **/

            //: 32 + ( 16 * 1 ) TESTS TOTAL AFTER BLOCK BELOW:
            //:                ( T_T_A_B_B )

                                            //:SUM        DEX://
            ,     12    ,    0    ,    3    //: 33        32 ://
            ,     12    ,    1    ,    0    //: 34        33 ://
            ,     12    ,    2    ,    3    //: 35        34 ://
            ,     12    ,    3    ,    0    //: 36        35 ://
            ,     12    ,    4    ,    3    //: 37        36 ://
            ,     12    ,    5    ,    0    //: 38        37 ://
            ,     12    ,    6    ,    3    //: 39        38 ://
            ,     12    ,    7    ,    0    //: 40        39 ://
            ,     12    ,    8    ,    3    //: 41        40 ://
            ,     12    ,    9    ,    0    //: 42        41 ://
            ,     12    ,   10    ,    3    //: 43        42 ://
            ,     12    ,   11    ,    0    //: 44        43 ://
            ,     12    ,   12    ,    3    //: 45        44 ://
            ,     12    ,   13    ,    0    //: 46        45 ://
            ,     12    ,   14    ,    3    //: 47        46 ://
            ,     12    ,   15    ,    0    //: 48        47 ://
            
            //: 32 + ( 16 * 2 ) T_T_A_B_B   //: 33 + 16 == 49
                                            //: 33 + 15 == 48

                                            //:SUM        DEX://
            ,     12    ,    0    ,    0    //: 49        48 ://
            ,     12    ,    1    ,    3    //: 50        49 ://
            ,     12    ,    2    ,    0    //: 51        50 ://
            ,     12    ,    3    ,    3    //: 52        51 ://
            ,     12    ,    4    ,    0    //: 53        52 ://
            ,     12    ,    5    ,    3    //: 54        53 ://
            ,     12    ,    6    ,    0    //: 55        54 ://
            ,     12    ,    7    ,    3    //: 56        55 ://
            ,     12    ,    8    ,    0    //: 57        56 ://
            ,     12    ,    9    ,    3    //: 58        57 ://
            ,     12    ,   10    ,    0    //: 59        58 ://
            ,     12    ,   11    ,    3    //: 60        59 ://
            ,     12    ,   12    ,    0    //: 61        60 ://
            ,     12    ,   13    ,    3    //: 62        61 ://
            ,     12    ,   14    ,    0    //: 63        62 ://
            ,     12    ,   15    ,    3    //: 64        63 ://

            //: 32 + ( 16 * 3 ) T_T_A_B_B   //: 49 + 16 == 65
                                            //: 49 + 15 == 64

            ,     12    ,    0    ,    3    //: 65        64 ://
            ,     12    ,    1    ,    3    //: 66        65 ://
            ,     12    ,    2    ,    3    //: 67        66 ://
            ,     12    ,    3    ,    3    //: 68        67 ://
            ,     12    ,    4    ,    3    //: 69        68 ://
            ,     12    ,    5    ,    3    //: 70        69 ://
            ,     12    ,    6    ,    3    //: 71        70 ://
            ,     12    ,    7    ,    3    //: 72        71 ://
            ,     12    ,    8    ,    3    //: 73        72 ://
            ,     12    ,    9    ,    3    //: 74        73 ://
            ,     12    ,   10    ,    3    //: 75        74 ://
            ,     12    ,   11    ,    3    //: 76        75 ://
            ,     12    ,   12    ,    3    //: 77        76 ://
            ,     12    ,   13    ,    3    //: 78        77 ://
            ,     12    ,   14    ,    3    //: 79        78 ://
            ,     12    ,   15    ,    3    //: 80        79 ://

                                            
            //: 32 + ( 16 * 4 ) T_T_A_B_B   //: 65 + 16 = 81
                                            //: 64 + 16 = 80 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    2    //: 81        80 ://
            ,     12    ,    1    ,    2    //: 82        81 ://
            ,     12    ,    2    ,    2    //: 83        82 ://
            ,     12    ,    3    ,    2    //: 84        83 ://
            ,     12    ,    4    ,    2    //: 85        84 ://
            ,     12    ,    5    ,    2    //: 86        85 ://
            ,     12    ,    6    ,    2    //: 87        86 ://
            ,     12    ,    7    ,    2    //: 88        87 ://
            ,     12    ,    8    ,    2    //: 89        88 ://
            ,     12    ,    9    ,    2    //: 90        89 ://
            ,     12    ,   10    ,    2    //: 91        90 ://
            ,     12    ,   11    ,    2    //: 92        91 ://
            ,     12    ,   12    ,    2    //: 93        92 ://
            ,     12    ,   13    ,    2    //: 94        93 ://
            ,     12    ,   14    ,    2    //: 95        94 ://
            ,     12    ,   15    ,    2    //: 96        95 ://

            //: 32 + ( 16 * 5 ) T_T_A_B_B   //: 81 + 16 = 97
                                            //: 80 + 16 = 96 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    1    //: 97        96 ://
            ,     12    ,    1    ,    1    //: 98        97 ://
            ,     12    ,    2    ,    1    //: 99        98 ://
            ,     12    ,    3    ,    1    //:100        99 ://
            ,     12    ,    4    ,    1    //:101       100 ://
            ,     12    ,    5    ,    1    //:102       101 ://
            ,     12    ,    6    ,    1    //:103       102 ://
            ,     12    ,    7    ,    1    //:104       103 ://
            ,     12    ,    8    ,    1    //:105       104 ://
            ,     12    ,    9    ,    1    //:106       105 ://
            ,     12    ,   10    ,    1    //:107       106 ://
            ,     12    ,   11    ,    1    //:108       107 ://
            ,     12    ,   12    ,    1    //:109       108 ://
            ,     12    ,   13    ,    1    //:110       109 ://
            ,     12    ,   14    ,    1    //:111       110 ://
            ,     12    ,   15    ,    1    //:112       111 ://

            //: 32 + ( 16 * 6 ) T_T_A_B_B   //:97 + 16 = 113
                                            //:96 + 16 = 112 
                                         
                                            //:SUM        DEX://
            ,     12    ,    0    ,    0    //:113        112://
            ,     12    ,    1    ,    0    //:114        112://
            ,     12    ,    2    ,    0    //:115        113://
            ,     12    ,    3    ,    0    //:116        114://
            ,     12    ,    4    ,    0    //:117        115://
            ,     12    ,    5    ,    0    //:118        117://
            ,     12    ,    6    ,    0    //:119        118://
            ,     12    ,    7    ,    0    //:120        119://
            ,     12    ,    8    ,    0    //:121        120://
            ,     12    ,    9    ,    0    //:122        121://
            ,     12    ,   10    ,    0    //:123        122://
            ,     12    ,   11    ,    0    //:124        123://
            ,     12    ,   12    ,    0    //:125        124://
            ,     12    ,   13    ,    0    //:126        125://
            ,     12    ,   14    ,    0    //:127        126://
            ,     12    ,   15    ,    0    //:128        127://

            //: 32 + ( 16 * 7 ) T_T_A_B_B   //:113 + 16 = 129
                                            //:112 + 16 = 128 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    3    //:129        128://
            ,     12    ,    1    ,    2    //:130        129://
            ,     12    ,    2    ,    3    //:131        130://
            ,     12    ,    3    ,    2    //:132        131://
            ,     12    ,    4    ,    3    //:133        132://
            ,     12    ,    5    ,    2    //:134        133://
            ,     12    ,    6    ,    3    //:135        134://
            ,     12    ,    7    ,    2    //:136        135://
            ,     12    ,    8    ,    3    //:137        136://
            ,     12    ,    9    ,    2    //:138        137://
            ,     12    ,   10    ,    3    //:139        138://
            ,     12    ,   11    ,    2    //:140        139://
            ,     12    ,   12    ,    3    //:141        140://
            ,     12    ,   13    ,    2    //:142        141://
            ,     12    ,   14    ,    3    //:143        142://
            ,     12    ,   15    ,    2    //:144        143://

            //: 32 + ( 16 * 8 ) T_T_A_B_B   //:129 + 16 = 145
                                            //:128 + 16 = 144 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    2    //:145        144://
            ,     12    ,    1    ,    3    //:146        145://
            ,     12    ,    2    ,    2    //:147        146://
            ,     12    ,    3    ,    3    //:148        147://
            ,     12    ,    4    ,    2    //:149        148://
            ,     12    ,    5    ,    3    //:150        149://
            ,     12    ,    6    ,    2    //:151        150://
            ,     12    ,    7    ,    3    //:152        151://
            ,     12    ,    8    ,    2    //:153        152://
            ,     12    ,    9    ,    3    //:154        153://
            ,     12    ,   10    ,    2    //:155        154://
            ,     12    ,   11    ,    3    //:156        155://
            ,     12    ,   12    ,    2    //:157        156://
            ,     12    ,   13    ,    3    //:158        157://
            ,     12    ,   14    ,    2    //:159        158://
            ,     12    ,   15    ,    3    //:160        159://
            //: glo_com | aus_dex | til_val //:SUM        DEX://

            //: 32 + ( 16 * 8 )==160             ............://
            //: @VID_IID[ 0083 ]TIME[ 04:28:12 ] ............://
            //: Checksum looks good to me!       ............://

            //: glo_com | aus_dex | til_val //:SUM        DEX://
            };;
            //:----------------------:table_of_unit_test_code://
            //:helper_table:---------------------------------://
            //:convert_aus_dex_to_bit_indexes:---------------://
            U08 tab_hel[ 32 ]={ /** hel:HELper **/
                0 , 1  //: 01  -  aus_dex # 0 ==> [  0 , 1 ] ://
            ,   2 , 3  //: 02  -  aus_dex # 1 ==> [  2 , 3 ] ://
            ,   4 , 5  //: 03  -  aus_dex # 2 ==> [  4 , 5 ] ://
            ,   6 , 7  //: 04  -  aus_dex # 3 ==> [  6 , 7 ] ://
            ,   8 , 9  //: 05  -  aus_dex # 4 ==> [  8 , 9 ] ://
            ,  10 ,11  //: 06  -  aus_dex # 5 ==> [ 10 ,11 ] ://
            ,  12 ,13  //: 07  -  aus_dex # 6 ==> [ 12 ,13 ] ://
            ,  14 ,15  //: 08  -  aus_dex # 7 ==> [ 14 ,15 ] ://
            ,  16 ,17  //: 09  -  aus_dex # 8 ==> [ 16 ,17 ] ://
            ,  18 ,19  //: 10  -  aus_dex # 9 ==> [ 18 ,19 ] ://
            ,  20 ,21  //: 11  -  aus_dex #10 ==> [ 20 ,21 ] ://
            ,  22 ,23  //: 12  -  aus_dex #11 ==> [ 22 ,23 ] ://
            ,  24 ,25  //: 13  -  aus_dex #12 ==> [ 24 ,25 ] ://
            ,  26 ,27  //: 14  -  aus_dex #13 ==> [ 26 ,27 ] ://
            ,  28 ,29  //: 15  -  aus_dex #14 ==> [ 28 ,29 ] ://
            ,  30 ,31  //: 16  -  aus_dex #15 ==> [ 30 ,31 ] ://
            };;
            //:---------------:convert_aus_dex_to_bit_indexes://
            //:---------------------------------:helper_table://
            //:test_loop:------------------------------------://
            m_i=( NUM_TES - 1 ); //:max_test_index
            for( era = 1 ; era <=  2  ; era ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                if( 1 == era ){

                    /** @VID_IID[ 0083 ]TIME[ 02:08:55 ]     **/
                    /** erase cpu_pix before next test       **/

                    for( I32 b = 0 ; b <= ((4*4)-1) ; b++ ){    
                        cpu_pix[ b ] = ( 0x00 );//:erase_byte
                    };;
            
                }else
                if( 2 == era ){

                    /**  OKAY! DO ____NOTHING____ .......... **/
                    
                    /**   @VID_IID[ 0083 ]TIME[ 02:06:55 ]   **/
                    /**   Do NOT erase previous set values.  **/
                    /**   Our getter logic might be reading  **/
                    /**   MORE BITS than it should be .      **/

                }else{
                    ERR("BAD_ERA_VALUE:2021]");
                };;

                //:get_base_data_offset:---------------------://

                bas = ( t_i * NUM_ELM ); //:t_i times stride
                
                //:---------------------:get_base_data_offset://
                //:extract_test_table_values:----------------://

                glo_com = tab_utc[ bas + 0 ];
                aus_dex = tab_utc[ bas + 1 ];
                til_val = tab_utc[ bas + 2 ];
                assert( glo_com % 4 == 0   ); //:Divisible_by_4
                assert( glo_com <= ( 16-1) ); //:4 pixels only.
                assert( aus_dex <= ( 16-1) ); //:Ausets 0-to-15
                assert( til_val <= (    3) ); //: 11 10 01 00

                //:----------------:extract_test_table_values://
                //:manually_pack_data_to_get:----------------://

                /** What bit indexes are we looking at       **/
                /** if data where crammed into 32 bit integer**/
                bi0 = (  tab_hel[ ( aus_dex*2) + 0 ] );
                bi1 = (  tab_hel[ ( aus_dex*2) + 1 ] );
                if( bi0 + 1 != bi1 ){ ERR("[BAD_BIT_ONE]"); };

                /** extract what is already there **/
                u32_var=( 0x00
                | ( cpu_pix[ glo_com + 0 ] << 24 ) //: R ://
                | ( cpu_pix[ glo_com + 1 ] << 16 ) //: G ://
                | ( cpu_pix[ glo_com + 2 ] <<  8 ) //: B ://
                | ( cpu_pix[ glo_com + 3 ] <<  0 ) //: A ://
                );;  /** @PAIRED_BITPACKING_CODE_2021_01_14@ **/

                /** replace correct 2 bits within u32_var **/
                u32_var=(

                    /** erase 2-bit slot in u32_var **/
                    ( u32_var &  (~(BIN_011 << bi0 )) )

                | //:<-- or to merge together bit patterns

                    /** insert 2-bit value into u32_var **/
                    (            (til_val << bi0 ) )

                );;

                /** @VID_IID[ 0083 ]TIME[ 03:43:32 ] **/
                /** Test specific test case.         **/
                if( 1 == era && 2 == t_i ){
                    if( u32_var != 2 ){
                        ERR("[u32_var_improper_packing]");
                    };;
                };;

                /** Overwrite the original uint32 value that **/
                /** is stored as 4 bytes. .................. **/
                /** @VID_IID[ 0083 ]TIME[ 1H 17M 22S ] ..... **/
                /** @VID_IID[ 0083 ]TIME[ 03:38:50   ]FIXED  **/
                /** @VID_IID[ 0083 ]TIME[ 03:44:55   ]FIX_02 **/
                
                cpu_pix[ glo_com  +  0 ]=( //: R ://
                      (( u32_var >> 24 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  1 ]=( //: G ://
                      (( u32_var >> 16 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  2 ]=( //: B ://
                      (( u32_var >>  8 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  3 ]=( //: A ://
                      (( u32_var >>  0 ) &  0xFF)//: 8 bit mask
                );;

                //:----------------:manually_pack_data_to_get://
                //:run_getter_being_tested:------------------://
                #define GOT_VAL_TRAP ( 123 )

                got_val=( GOT_VAL_TRAP /** @TRAP_VALUE@ **/ );
                aac2020_paint5d_BitPack_Get(
                    cpu_pix //: U08* :  pixel byte array     ://
                ,   glo_com //: U08  :  red byte component   ://
                ,   aus_dex //: U08  :  auset index #        ://
                , &(got_val)//: U08* :  tile value to GET    ://
                );;

                if( GOT_VAL_TRAP == got_val ){
                    /** @VID_IID[ 0083 ]TIME[ 1H 38M 52S ] **/
                    ERR("[GETTER_IS_NOT_TOUCHING_OUT_PARAM]");
                };;

                #undef GOT_VAL_TRAP
                //:------------------:run_getter_being_tested://
                //:compare_actual_vs_expected:---------------://

                if( got_val != til_val ){

                    printf("\n\n");
                    printf("[TEST_FAILED_CHECK_THE_BINARY...]");
                    printf("\n\n");

                    printf("[....era]:%d\n" ,     era );
                    printf("[....t_i]:%d\n" ,     t_i );
                    printf("[got_val]:%d\n" , got_val );
                    printf("[til_val]:%d\n" , til_val );
                    
                    /** @VID_IID[ 0083 ]TIME[ 1H 30M 40S ]   **/
                    /** loop over cpu_pix and count number   **/
                    /** of NON_ZERO bytes within array.      **/
                    zer=( 0 );
                    non=( 0 );
                    for( I32 B_i = 0 ; B_i <= (16-1) ; B_i++ ){

                        if( 0x00 == cpu_pix[ B_i ] ){ zer++; };
                        if( 0x00 != cpu_pix[ B_i ] ){ non++; };

                    };;

                    /** Print off binary of all 4 pixels     **/
                    /** to visually confirm correct data.    **/
                    printf("\n");
                    printf("[PIXEL_PRINTOFF:BEG]\n");
                    U32 bit        =( 0 ); //:binary bit value
                    I32 make_space =( 0 );
                    I32 make_newline=( 0 );
                    I32 g_i_chk =( 32 ); //:global_bit_index_chk
                    I32 l_i_chk =(  8 ); //:local__bit_index_chk
                    for( I32 pix = 0 ; pix <= (4 -1) ; pix++ ){
                    for( I32 b_i = 0 ; b_i <= (32-1) ; b_i++ ){

                        make_space  =( 0 );
                        make_newline=( 0 );

                        /** @VID_IID[ 02:42:01 ] ........... **/
                        g_i_chk--; /** 31 to 0 counting down.**/
                        if( g_i_chk <= (0-1) ){ g_i_chk = 31; };

                        l_i_chk--; /** 7 to 0 counting down. **/
                        if( l_i_chk <= (0-1) ){ l_i_chk =  7; };
    
                        /** Inverted bit index. MSB first. **/
                        I32 inv_b_i = ( 31 - b_i );
                        I32     l_i ; /** Local Bit Index **/
                        I32     cmp ; /** Component Index **/

                        //:get_local_bit_index:--------------://

                        //:@VID_IID[ 0083 ]TIME[ 02:30:30 ]  ://
                        //:@VID_IID[ 0083 ]TIME[ 02:37:00 ]  ://
                        //:SEE_DIAGRAM[ #DIA_P5D_U32#     ]  ://
                        //:SEE_FILE[    PAINT5D.D._       ]  ://

                        assert( inv_b_i == g_i_chk );

                        if(    inv_b_i <= 31    
                        &&     inv_b_i >= 24 ){ 
                        l_i =( inv_b_i  - 24 );
                        cmp =(    0    ); //:RED    COMPONENT
                        }else

                        if(    inv_b_i <= 23    
                        &&     inv_b_i >= 16 ){ 
                        l_i =( inv_b_i  - 16 );
                        cmp =(    1    ); //:GREEN  COMPONENT
                        }else

                        if(    inv_b_i <= 15   
                        &&     inv_b_i >=  8 ){ 
                        l_i =( inv_b_i  -  8 );
                        cmp =(    2    ); //:BLUE   COMPONENT
                        }else

                        if(    inv_b_i <= 7   
                        &&     inv_b_i >= 0 ){ 
                        l_i =( inv_b_i  - 0 );
                        cmp =(    3    ); //:ALPHA  COMPONENT
                        }else

                        { ERR("[BAD_INVERTED_BIT_INDEX]"); }
                        //:--------------:get_local_bit_index://

                        assert( l_i <= ( 8-1)  );
                        assert( l_i >=    0    );
                        if(     l_i != l_i_chk ){
                            ERR("[l_i_CHECK_FAIL_2021]");
                        };;

                        /** @VID_IID[ 0083 ]TIME[ 02:33:50 ] **/
                        bit =( 
                        ( cpu_pix[ ( pix * 4 ) + cmp ] >> l_i )
                            & 1 //:Masked with binary "1"
                        );;

                        

                        if( 0 == b_i && 0 == pix ){
                            make_newline=( 1 );
                        };;
                        if( 31 == inv_b_i ){
                            make_newline=( 1 );
                        };;
                

                        if( 0
                        ||  ( 24 - 1) == inv_b_i
                        ||  ( 16 - 1) == inv_b_i
                        ||  (  8 - 1) == inv_b_i
                        //  (  0 - 1) == inv_b_i
                        ){
                            make_space=( 1 );
                        };;

                        if( make_space   ){ printf(" | "); };
                        if( make_newline ){ 

                            if( 0 != pix ){ printf(" | " ); };

                            printf("\n" ); 
                            printf("[pix#]:(%d) | " , pix);
                        };;

                        if( 0 == bit ){ printf("0"); }else
                        if( 1 == bit ){ printf("1"); }else
                        {
                            ERR("[BAD_BIT_VALUE_2021]");
                        };;
                        if( 0
                        ||  ( 28  ) == inv_b_i //: R dash
                        ||  ( 20  ) == inv_b_i //: G dash
                        ||  ( 12  ) == inv_b_i //: B dash
                        ||  (  4  ) == inv_b_i //: A dash
                        ){
                            printf(" - ");
                        };;

                    };;};;

                    printf(" | "); //:Get that last bar in.

                    printf("\n\n[PIXEL_PRINTOFF:END]\n");
                    printf("\n");

                    assert( ( zer + non ) == 16 ); //:16 bytes
                    printf("[....zer]:%d\n" ,     zer );
                    printf("[....non]:%d\n" ,     non );

                    ERR("[GET_FAIL_2021_got_val_NOT_til_val]");
                };;

                //:---------------:compare_actual_vs_expected://
            };;};; //:Next[ era , t_i ]
            //:------------------------------------:test_loop://

        #undef  BIN_011 /** Binary: 11 **/            //: 01 ://
        #undef  NUM_ELM                               //: 02 ://
        #undef  NUM_TES                               //: 03 ://
        }                                          

    #undef  VERY_SPECIFIC_DEFINES_HERE_ONLY
    //:------------------------:ADDED_FUNC_PAIR_ON_2021_01_09://
    //:ADDED_FUNCTION_ON_DATE_2021_01_07:--------------------://
    #define VERY_SPECIFIC_DEFINES_HERE_ONLY

        void
        aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET( void )
        {
            /** This function was added on:     **/
            /** DATE[  2021_01_07 ]             **/
            /** VID_IID[ 0080 ]TIME[ 00:36:20 ] **/

            I32 p_x;
            I32 p_y;

            U08 til_qua ;
            U08 til_exp ;
            U08 til_lay ;
            U08 loc_t_x ;
            U08 loc_t_y ;
            I16 glo_t_x ;
            I16 glo_t_y ;
    
            for( p_x = 0 ; p_x <= ( 512 - 1 ); p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ); p_y ++ ){

                /** Skip over the configuration pixels.      **/
                /** @VID_IID[ 00:39:20 ]                     **/
                if((256-1)==p_x && ( 256-1)==p_y ){ continue; };
                if((512-1)==p_x && ( 256-1)==p_y ){ continue; };
                if((256-1)==p_x && ( 512-1)==p_y ){ continue; };
                if((512-1)==p_x && ( 512-1)==p_y ){ continue; };

                glo_t_x =( p_x );
                glo_t_y =( p_y );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(til_qua)  //: Auset Tile Sub Quad Index  ://
                , &(til_exp)  //: TileSizeExponentEnum       ://
                , &(til_lay)  //: TileLayer ...............  ://
                , &(loc_t_x)  //: Local  Tile X Coord / b_x  ://
                , &(loc_t_y)  //: Local  Tile Y Coord / b_y  ://
                ,   glo_t_x   //: Global Tile X Coord        ://
                ,   glo_t_y   //: Global Tile X Coord        ://
                );;

                /** Make absolutely sure that           .....**/
                /** aac2020_paint5d_painpix_CTO_glocpix .....**/
                /** is actually setting these values.   .....**/
                glo_t_x=( 0 - 333 );
                glo_t_y=( 0 - 222 );

                aac2020_paint5d_painpix_CTO_glocpix(
                    til_qua   //: Auset Tile Sub Quad Index  ://
                ,   til_exp   //: TileSizeExponentEnum       ://
                ,   til_lay   //: TileLayer ...............  ://
                ,   loc_t_x   //: Local  Tile X Coord / b_x  ://
                ,   loc_t_y   //: Local  Tile Y Coord / b_y  ://
                , &(glo_t_x)  //: Global Tile X Coord        ://
                , &(glo_t_y)  //: Global Tile X Coord        ://
                );;

                if( 0
                || ( glo_t_x != p_x )
                || ( glo_t_y != p_y )
                ){
                    ERR("[YOU_DONE_FAILED_2021_SUPER]");
                };;

            };;};;

            LOG("[99%_SURE_WORKS:painpix_CTO_glocpix]", 0);
            LOG("[99%_SURE_WORKS:glocpix_CTO_painpix]", 0);
        }

    #undef  VERY_SPECIFIC_DEFINES_HERE_ONLY
    //:--------------------:ADDED_FUNCTION_ON_DATE_2021_01_07://
    //:MAIN_GET_PUT_TESTS:-----------------------------------://
    #define NUM_TEST_CASES_put (  8  )                  //:01://
    #define NUM_TEST_COLMS_put (  7  ) /**COLUMNS**/    //:02://
    #define NUM_TEST_CASES_get (  8  )                  //:03://
    #define NUM_TEST_COLMS_get (  7  ) /**COLUMNS**/    //:04://

        void aac2020_paint5d_UTC_Put( void )
        {

            /** @VID_IID[ 0070 ]TIME[ 1H 9M 50S ] .......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  p_g ; /** Put( 0 ) or Get( 1 ) Loop. .......**/
            I32  t_i ; /** Test_row_Index             .......**/
            I32  bas ; /** BASe_offset_of_test_data   .......**/
            I32  m_i =( NUM_TEST_CASES_put - 1);

            /* Input VALUES:@VID_IID[ 0071 ]T[ 1H 57M 17S ] */
            U08     til_qua ;   //:--------------------------://
            U08     til_exp ;   //:                          ://
            U08     til_lay ;   //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08     loc_t_x ;   //:                          ://
            U08     loc_t_y ;   //:--------------------------://
                                //:--------------------------://
            U08     aus_dex ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
            U08 put_til_val ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
                                //:--------------------------://

            /** Output Value:@VID_IID[ 0071 ]T[ 1H 57M 17S ] **/

            U08 got_til_val ;

            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 NUM_TEST_CASES_put
                            *
                 NUM_TEST_COLMS_put
            ]={
            /**8 smoke tests. @VID_IID[ 0071 ]T[ 1H 40M 20S ]**/
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   aus_   _val
/*  00  01  */  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
/*  01  02  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    0
/*  02  03  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    0
/*  03  04  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    0
/*  04  05  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    3
/*  05  06  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    3
/*  06  07  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    3  
/*  07  08  */,    1 ,    1 ,    1 ,    1 ,    1 ,    1 ,    1
/// --  --    : _qua   _exp   _lay   loc_   loc_   aus_   _val
/// --  --    : 0001   0002   0003   0004   0005   0006   0007

                /** TODO: More tests **/
            };;
            AAC2020_TODOMAN_Vital("[MORE_TESTS!!!!2021]");

            for( p_g = 0 ; p_g <=( 1 ); p_g ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * NUM_TEST_COLMS_put );

                /** Setting @TRAP_VALUES               * * * **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 53S ] * * * **/

                til_qua=( 101 );  /** @TRAP_VALUES@ **/
                til_exp=( 102 );  /** @TRAP_VALUES@ **/
                til_lay=( 103 );  /** @TRAP_VALUES@ **/
                loc_t_x=( 104 );  /** @TRAP_VALUES@ **/
                loc_t_y=( 105 );  /** @TRAP_VALUES@ **/
                aus_dex=( 106 );  /** @TRAP_VALUES@ **/
            put_til_val=( 107 );  /** @TRAP_VALUES@ **/

                /** Extracted Values For The Current Test    **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 24S ] * * * **/

                til_qua=(         (U08)tab_utc[ bas + 0 ] );
                til_exp=(         (U08)tab_utc[ bas + 1 ] );
                til_lay=(         (U08)tab_utc[ bas + 2 ] );
                loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                aus_dex=(         (U08)tab_utc[ bas + 5 ] );
            put_til_val=(         (U08)tab_utc[ bas + 6 ] );

                /** Integer Overflow Dectection.             **/
                /** @VID_IID[ 0071 ]TIME[ 1H 46M 08S ]       **/
                #define      TIL_VAL put_til_val
                assert(((I16)til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)aus_dex)==tab_utc[ bas + 5 ] );
                assert(((I16)TIL_VAL)==tab_utc[ bas + 6 ] );
                #undef       TIL_VAL

                //:all_puts_before_all_gets:-----------------://
                //:                                          ://
                //: @VID_IID[ 0071 ]TIME[ 02H 03M 44S ]      ://
                //: We do all of the AAC2020_PAINT5D_Put(..) ://
                //: calls BEFORE all of the                  ://
                //: AAC2020_PAINT5D_Get(...) calls in case   ://
                //: we have overlapping [ memory / pixel ]   ://
                //: locations where the data is being stored.://
                //:                                          ://
                //: If we do interlaced                      ://
                //:"get(..) then put(..)" calls, we may      ://
                //: end up with a "FALSE UNIT TEST PASS"     ://
                //:                                          ://
                //:all_puts_before_all_gets:- - - - - - - - -://

                if( 0 == p_g ){
                AAC2020_PAINT5D_Put(
                        til_qua    /* AusetTile SubQuad Index */
                ,       til_exp    /* TileExponent            */
                ,       til_lay    /* TileLayer ..............*/
                ,       loc_t_x    /* LocalTile X Coord / b_x */
                ,       loc_t_y    /* LocalTile Y Coord / b_y */
                ,       aus_dex    /* AUSet_inDEX             */
                ,   put_til_val    /* [ val_cur / til_val ]   */
                );; };;

                if( 1 == p_g ){
                AAC2020_PAINT5D_Get(
                        til_qua    /** Same exact variables  **/
                ,       til_exp    /** as "Put(..)" function **/
                ,       til_lay    /** but last parameter is **/
                ,       loc_t_x    /** an OUTPUT parameter.  **/
                ,       loc_t_y    /** @VID_IID[ 0071 ]      **/
                ,       aus_dex    /** @TIME[ 2H 00M 50S ]   **/
                ,&( got_til_val )  
                );; };;

                assert( ( 1 == p_g ) || ( 0 == p_g ) );
 
                //:-----------------:all_puts_before_all_gets://

            };;};; //:NEXT[ p_g , t_i ]
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( 
                "[MORE_TESTS:aac2020_paint5d_UTC_Put]"
            );;

        }  //:[ END: paint5d_UTC_Put ]://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get( void )
        {

            U08     t_i; //:Test Index
            U08     bas; //:Base Offset To Test Data Points

            U08 til_qua;
            U08 til_exp;
            U08 til_lay;
            U08 loc_t_x;
            U08 loc_t_y;
            U08 aus_dex;

            U08 exp_til_val; //:EXPECTED: til_val
            U08 act_til_val; //:ACTUAL::: til_val

            //:meddling_test:001:----------------------------://
            /** @VID_IID[ 0071 ]TIME[ 2H 31M 03S ]           **/
            //:meddling_test:001::- - - - - - - - - - - - - -://

                AAC2020_PIXNAME_paint5d_cpu_pix[ 0 ]=(
                    0x11 /** RED   BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 1 ]=(
                    0x22 /** GREEN BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 2 ]=(
                    0x33 /** BLUE  BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 3 ]=(
                    0x44 /** ALPHA BITS **/
                );;
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ]
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ]
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ]
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ]

                //: @VID_IID[ 0071 ]TIME[ 2H 42M 21S ]       ://
                //: Overlay the[ aus_dex ] over the correct  ://
                //: 2-bit pattern ( til_val ) it should      ://
                //: be paired with.                          ://
                //:                            15 14 13 12   ://
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ] ://
                //:                                          ://
                //:                            11 10 09 08   ://
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ] ://
                //:                                          ://
                //:                            07 06 05 04   ://
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ] ://
                //:                                          ://
                //:                            03 02 01 00   ://
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ] ://
 
                /** Test Table #001 for meddling test #001   **/
                /** @VID_IID[ 0071 ]TIME[ 2H 59M 10S ]       **/

                U08 tab_001[ 16 * 2 ]={
                //:          aus_dex | til_val
                  /** 00 **/   0x0   ,   0x0
                , /** 01 **/     1   ,     1  /* 1 : BIN[ 01 ]*/
                , /** 02 **/     2   ,     0
                , /** 03 **/     3   ,     1
                , /** 04 **/     4   ,     3  /* 3 : BIN[ 11 ]*/
                , /** 05 **/     5   ,     0
                , /** 06 **/     6   ,     3
                , /** 07 **/     7   ,     0
                , /** 08 **/     8   ,     2 /** 2 : BIN[ 10 ]*/
                , /** 09 **/     9   ,     0
                , /** 10 **/    10   ,     2
                , /** 11 **/    11   ,     0
                , /** 12 **/    12   ,     1
                , /** 13 **/    13   ,     0
                , /** 14 **/    14   ,     1
                , /** 15 **/    15   ,     0 /** 0 : BIN[ 00 ]*/
                };;
       
                /** **************************************** ***
                    @VID_IID[ 0071 ]TIME[ 02H 55M 20S ] 
                    The first meddling test using
                    table[ tab_001 ] only looks at data
                    we set on the very first pixel.
                    
                    This is because we want to confirm
                    our [ bit shifting & bit packing ]
                    logic is correct and don't want the
                    mistake in this test to be looking
                    at the WRONG PIXEL LOCATION.

                *** **************************************** **/

                for( t_i = 0 ; t_i <= 15 ; t_i ++ ){

                        bas =( t_i * 2 );  /*2 colums per test*/
                    aus_dex = tab_001[ bas + 0 ];
                exp_til_val = tab_001[ bas + 1 ];

                    /** Might not be true for other meddling **/
                    /** tests. But true for this one.        **/
                    assert( t_i == aus_dex );

                    AAC2020_PAINT5D_Get(
                        ( til_qua = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_exp = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_lay = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_x = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_y = 0 )  //: <-- FIRST_PIXEL
                    ,   ( aus_dex     )  
                    ,  &( act_til_val )  
                    );;

                    if( exp_til_val != act_til_val ){
                        ERR("[MEDDLING_TEST_NUMBER_001]");
                    };;

                };;

            //:----------------------------:meddling_test:001://
            //:meddling_Test:002:----------------------------://

                /** **************************************** **/
                /** @VID_IID[ 0071 ]TIME[ 03H 06M 49S        **/
                /** Now that we know our bit shifting math   **/
                /** is working, test with a pixel that is    **/
                /** NOT at [ 0,0 ] on our bitmap to verify   **/
                /** physical locations of pixel data are     **/
                /** also correct.                            **/
                /** **************************************** **/

                AAC2020_TODOMAN_Vital("[TestWithAnotherPixel]");
    
            //:----------------------------:meddling_test:002://

            AAC2020_TODOMAN_Vital("[FINISH_THIS_CODE!!!!!!!]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Put_Get( void )
        {
            /** PUT & GET test for the MAIN functionality.   **/
            /** 1: AAC2020_PAINT5D_Put( ... )                **/
            /** 2: AAC2020_PAINT5D_Get( ... )                **/

            /** ******************************************** ***
                About THIS[ paint5d_UTC_Put_Get ]FUNCTION:

                Tests every single possible value there
                is by iterating over the entire 512x512
                bitmap in a double nested [ p_x , p_y ]
                loop. 
            *** ******************************************** **/

            I16 p_x; /** pixel x location **/
            I16 p_y; /** pixel y location **/
            /** ******************************************** ***
                @VID_IID[ 0071 ]TIME[ 00H 07M 54S  ]
                [p_x ,p_y ] == [ glo_t_x , glo_t_y ]
                Located On: AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/

            //:@VID_IID[ 0079 ]TIME[ 00H 36M 05S ] ://
            //:#skipped_configuration_pixels#      ://
            U08 skipped_configuration_pixels = ( 0 );
            
            U08 til_qua    ; //:-----------------------------://
            U08 til_exp    ; //:                             ://
            U08 til_lay    ; //:                             ://
            U08 loc_t_x    ; //: FOR: glocpix_CTO_painpix    ://
            U08 loc_t_y    ; //:                             ://
                             //:                             ://
            I16 glo_t_x_001; //: Expected & Actual are       ://
            I16 glo_t_y_001; //: meaningless terms for       ://
                             //: these variables.            ://
            I16 glo_t_x_002; //: @VID_IID[ 0071 ]            ://
            I16 glo_t_y_002; //: TIME[ 01H 18M 07 ]          ://
                             //:_____________________________://

            til_exp=( 232 /** @TRAP_VALUE@ **/ );

            /** Before Testing "GET" and "PUT" functions     **/
            /** we will test the uderlying conversion        **/
            /** functions first.                             **/

            for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                glo_t_x_001 = p_x; /** Load Function Inputs **/
                glo_t_y_001 = p_y; /** Load Function Inputs **/

                //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:--------://
                if( 255 == p_x && 255 == p_y ){ //:T_L:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 511 == p_x && 255 == p_y ){ //:T_R:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 255 == p_x && 511 == p_y ){ //:B_L:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 511 == p_x && 511 == p_y ){ //:B_R:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                };;
                //:----------:_SKIP_CONFIG_PIXELS_P5D_PUTGET_://

                aac2020_paint5d_glocpix_CTO_painpix(
                   &( til_qua     )    /// Auset Sub Quad    ///
                ,  &( til_exp     )    /// Size_Exponent     ///
                ,  &( til_lay     )    /// TileLayer ........///
                ,  &( loc_t_x     )    /// Local  Tile X     ///
                ,  &( loc_t_y     )    /// Local  Tile Y     ///
                ,   ( glo_t_x_001 )    /// Global Tile X     ///
                ,   ( glo_t_y_001 )    /// Global Tile X     ///
                );;

                if( til_exp >= 8 ){
                    ERR("[BAD_TIL_EXP_2021_547PM:AYE]");
                };;

                aac2020_paint5d_painpix_CTO_glocpix(
                    ( til_qua )        /// Auset Sub Quad    ///
                ,   ( til_exp )        /// Size_Exponent     ///
                ,   ( til_lay )        /// TileLayer ........///
                ,   ( loc_t_x )        /// Local  Tile X     ///
                ,   ( loc_t_y )        /// Local  Tile Y     ///
                ,  &( glo_t_x_002 )    /// Global Tile X     ///
                ,  &( glo_t_y_002 )    /// Global Tile X     ///
                );;

                if( 0
                || glo_t_x_001 != glo_t_x_002
                || glo_t_y_001 != glo_t_y_002
                ){
                    ERR("[GET_PUT_TEST_FAILED:YEAR_2021]");
                };;

            };;};;
            if( 4 != skipped_configuration_pixels ){
                ERR("[BAD_SKIP_AMOUNT_2021:A]");
            };;

            //:Declare_Vars:Put_Get_Tests:-------------------://

                U08 ptg_put_val; //:PutThenGet_PUT_VALue
                U08 ptg_got_val; //:PutThenGet_GOT_VALue

                U32 val_gen; //:Used to generate val_til
                U08 val_til;
                U08     aus; //:Auset_Index_0_to_15
                U08     p_g; //:Put(0) or Get(1)

            //:-------------------:Declare_Vars:Put_Get_Tests://
            //:Put_Then_Get_Test_Interlaced:001:-------------://
            /** ********************************************* **

                @VID_IID[ 0079 ]TIME[ 02H 36M 30S ]

                If this section passes [ Put_Then_Get_Tests ]
                But the next section FAILS
                [ Put_Everything_Then_Get_Everything ]
                That is definitely indicative of some
                type of memory-stomping situation.

                Memory Stomps:
                    1. Storing data in same pixel.
                    2. Storing data in same bits of pixel.

                    If the coordinates are not wrong (#1), it
                    could be the BITPACKING and BITUNPACKING
                    (#2) that is wrong.
            
                Investigate BITPACKING if you need to.

            *** ******************************************** **/
             
                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                    skipped_configuration_pixels=( 0 );
                    val_gen =( 0 );

                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    val_gen = ( val_gen + 7 );
                    val_til = (U08)( val_gen % 4 );
                    assert( val_til <= 3 /* Max val_til :3 */);;

                    //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:----://
                    if( 0
                    ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                    ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                    ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                    ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                    ){
                        skipped_configuration_pixels++;
                        continue;
                    };;
                    //:-----#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:BEE]");
                    };;

                    ptg_put_val =( val_til );

                    AAC2020_PAINT5D_Put(
                            til_qua    
                    ,       til_exp    
                    ,       til_lay    
                    ,       loc_t_x    
                    ,       loc_t_y    
                    ,           aus  //: aus_dex ://  
                    ,   ptg_put_val  //: til_val / put_val ://
                    );;   

                    AAC2020_PAINT5D_Get(
                            til_qua    
                    ,       til_exp    
                    ,       til_lay    
                    ,       loc_t_x    
                    ,       loc_t_y    
                    ,           aus  //: aus_dex ://  
                    , &(ptg_got_val) //: til_val / put_val ://
                    );;    

                    if( ptg_put_val != ptg_got_val ){

                        ERR("[You_Done_Got_Some_Problems]");
            
                    };;

                };;};;

                    if( 4 != skipped_configuration_pixels ){
                        ERR("[WeHaveAproblem:2021_01_07]");
                    };;

                };; //:NEXT[ aus ](AUto_tile_Set)

            //:-------------:Put_Then_Get_Test_Interlaced:001://
            //:Put_Then_Get_Test_Interlaced:002:-------------://
            /** ********************************************* **

                @VID_IID[ 0080 ]TIME[ 00H 04M 53S ]
                
                The previous test passed. I am guessing
                the problem I am currently looking for is
                because of bitpacking. If the inner most
                loop loops through all possible "aus" values
                I bet we will have a problem on the 2nd
                aus interation.

            *** ******************************************** **/   
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                /** @VID_IID[ 0080 ]TIME[ 00:16:57 ]         **/
                /** PUT all values packed into same uint32   **/
                /** THEN try to get all values packed into   **/
                /** the uint32. Thus "p_g" must be outer     **/
                /** loop and "aus" the inner loop.           **/
                for( p_g = 0 ; p_g <= (     1   ) ; p_g ++ ){
                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                    if( 0 == aus ){ val_til = ( 0 ); }else
                    if( 1 == aus ){ val_til = ( 1 ); }else
                    if( 2 == aus ){ val_til = ( 2 ); }else
                    if( 3 == aus ){ val_til = ( 3 ); }else
                    if( 4 == aus ){ val_til = ( 0 ); }else
                    if( 5 == aus ){ val_til = ( 1 ); }else
                    if( 6 == aus ){ val_til = ( 2 ); }else
                    if( 7 == aus ){ val_til = ( 3 ); }else
                    if( 8 == aus ){ val_til = ( 0 ); }else
                    if( 9 == aus ){ val_til = ( 1 ); }else
                    if(10 == aus ){ val_til = ( 2 ); }else
                    if(11 == aus ){ val_til = ( 3 ); }else
                    if(12 == aus ){ val_til = ( 2 ); }else
                    if(13 == aus ){ val_til = ( 1 ); }else
                    if(14 == aus ){ val_til = ( 0 ); }else
                    if(15 == aus ){ val_til = ( 0 ); }else
                    { ERR("[INVALID_AUS_VALUE_FOR_TEST]"); };
                    assert( val_til <= 3 );

                    //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:----://
                    if( 0
                    ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                    ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                    ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                    ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                    ){
                        skipped_configuration_pixels++;
                        continue;
                    };;
                    //:-----#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:CEE]");
                    };;

                    ptg_put_val =( val_til );

                    if( 0 == p_g ){

                        AAC2020_PAINT5D_Put(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus  
                        ,   ptg_put_val  
                        );;   

                        AAC2020_PAINT5D_Get(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus   
                        , &(ptg_got_val)  
                        );;    

                        if( ptg_put_val != ptg_got_val ){

                            ERR("[OH_MY_FUCKING_GOD_123]");
            
                        };;

                    }else
                    if( 1 == p_g ){

                        AAC2020_PAINT5D_Get(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus   
                        , &(ptg_got_val)  
                        );;    

                        if( ptg_put_val != ptg_got_val ){

                            /** If this error gets triggered **/
                            /** Then I am 90% certain the    **/
                            /** problem is in how bits are   **/
                            /** being packed.                **/

                            ERR("[OH_MY_FUCKING_GOD_123]");
            
                        };;
                    }else{
                        ERR("[Neither_Put_Nore_Get]");
                    };;

                };;};; //:NEXT[ aus , p_g ]
                };;};; //:NEXT[ p_x , p_y ]

            //:-------------:Put_Then_Get_Test_Interlaced:002://
            //:Put_Everything_Then_Get_Everything:-----------://

            //: U08 p_g     =( 0 ); //:Put(0) or Get(1)
            //: U08 aus     =( 0 ); //:Auset_Index_0_to_15
            //: U32 val_gen =( 0 );
            //: U08 org_val =( 0 ); //:OriginalValue
                U08 got_val =( 0 ); //:GOTEN_VALUE
                U08 val     =( 0 ); //:Tile_value_0_1_2_or_3

                skipped_configuration_pixels=( 0 );

                for( p_g = 0 ; p_g <= (    1    ) ; p_g ++ ){
                
                    if( 
                        (  0 != skipped_configuration_pixels)
                    &&
                        ( 64 != skipped_configuration_pixels)
                    &&
                        (128 != skipped_configuration_pixels)
                    ){
                        printf("[scp]:%d\n"
                        ,skipped_configuration_pixels);;
                        ERR("[BAD_SKIP:P_G:...]");
                    };;

                    val_gen =( 0 );

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                //: val_gen = ( val_gen + 7 );
                //: val     = (U08)( val_gen % 4 );
                //: assert( val <= 3 /** Max Tile Val :3 **/ );

                    if(  0 == aus ){ val = 0; };  
                    if(  1 == aus ){ val = 1; };  
                    if(  2 == aus ){ val = 2; };  
                    if(  3 == aus ){ val = 3; };  
                    if(  4 == aus ){ val = 0; };  
                    if(  5 == aus ){ val = 0; };  
                    if(  6 == aus ){ val = 1; };  
                    if(  7 == aus ){ val = 2; };  
                    if(  8 == aus ){ val = 3; };  
                    if(  9 == aus ){ val = 0; };  
                    if( 10 == aus ){ val = 1; };  
                    if( 11 == aus ){ val = 2; };  
                    if( 12 == aus ){ val = 3; };  
                    if( 13 == aus ){ val = 3; };  
                    if( 14 == aus ){ val = 3; };  
                    if( 15 == aus ){ val = 3; };  

                //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:--------://
                if( 0
                ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                ){
                    skipped_configuration_pixels++;
                    continue;
                };;
                //:----------:_SKIP_CONFIG_PIXELS_P5D_PUTGET_://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:DEE]");
                    };;

                    if( 0 == p_g ){
 
                        AAC2020_PAINT5D_Put(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        ,       val  //: til_val / put_val ://
                        );;    

                        /** nic_val:                         **/
                        /**     NON_Interlaced_Check____VALUE**/
                        /** @VID_IID[ 0083 ]TIME[ 04:34:58 ] **/

                        U08 nic_val=( 222 /**@TRAP_VALUE@**/ );
                        AAC2020_PAINT5D_Get(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        , &(nic_val) //:Tile value to get.
                        );;    

                        if( nic_val != val ){
                            ERR("[NIC_VAL_TEST_FAIL_2021]");
                        };;
      
                    }else
                    if( 1 == p_g ){

                        AAC2020_PAINT5D_Get(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        , &(got_val )//: til_val ://
                        );;
                    }else{
                        ERR("[PG_OUT_OF_BOUNDS:2021]");
                    };;

                    if(    1    == p_g ){
                    if( got_val != val ){

                        printf("\n\n\n");
                        printf("[one:p_g]%d:\n"  ,     p_g );
                        printf("[....p_x]%d:\n"  ,     p_x );
                        printf("[....p_y]%d:\n"  ,     p_y );
                        printf("[....aus]%d:\n"  ,     aus );
                        printf("[got_val]%d:\n"  , got_val );
                        printf("[....val]%d:\n"  ,     val );

                        ERR("[TEST_DEF_FAIL_2021_HELLO_KITTY]");
                    };;};;

                };;};; //: [ p_x , p_y ] ::::::::::::::::::: ://

                };;};; //: [ p_g , aus ] ::::::::::::::::::: ://

            //:-----------:Put_Everything_Then_Get_Everything://
            //:ALL_ONES_AND_ALL_ZEROS_TEST_VARS:-------------://

                /** **************************************** ***

                    @VID_IID[ 0077 ]TIME[ 05H 21M 12S ]

                    The last two loops are pidgeon hole
                    smoke tests. 

                    [00] #_P5D_BINARY_TEST_00_#

                        IF: We set the binary tile value as
                        "[00]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ZEROS except for last 4 bytes.

                    [11] #_P5D_BINARY_TEST_11_#

                        IF: We set the binary tile value as
                        "[11]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ONES except for last 4 bytes.

                    WHY EVERYTHING BUT LAST 4 BYTES ?

                        The last pixel cannot encode 3 layers
                        and thus is not used in the data
                        structure to encode tile values.

                        The last pixel of the
                        [quarkmap / mipmap ] structure
                        is used as a special settings
                        preset number pixel
                
                *** **************************************** **/

                I32  b_i; //:Byte_Index
                I32  mpi; //:Max_PIXEL_Index
                I32  mbi; //:Max_Byte_Index

                U08  p_c ; /** Pixel_Component_Byte **/

            //:-------------:ALL_ONES_AND_ALL_ZEROS_TEST_VARS://
            //:Loop_Through_Set_All:1s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 1 bit.                              **/

                /** #_P5D_BINARY_TEST_11_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    /** Skip configuration pixels.           **/
                    /** @VID_IID[ 0083 ]TIME[ 05:04:10 ]     **/
                    if( 255 == p_x && 255 == p_y ){ continue; };
                    if( 511 == p_x && 255 == p_y ){ continue; };
                    if( 255 == p_x && 511 == p_y ){ continue; };
                    if( 511 == p_x && 511 == p_y ){ continue; };

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        printf("[p_x,p_y]:( %d , %d )\n",
                                 p_x,p_y );;
                        ERR("[BAD_TIL_EXP_2021_547PM:EEE]");
                    };;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         3  //: BINARY[ 11 ] ://
                    );;   //: 3  ://
                    //: DELTA[ Loop_Through_Set_All ]
                    //: DELTA_3

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0xFF_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0xFF != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ONE]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:1s://
            //:Loop_Through_Set_All:0s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 0 bit.                              **/

                /** #_P5D_BINARY_TEST_00_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    /** Skip configuration pixels.           **/
                    if( 255 == p_x && 255 == p_y ){ continue; };
                    if( 511 == p_x && 255 == p_y ){ continue; };
                    if( 255 == p_x && 511 == p_y ){ continue; };
                    if( 511 == p_x && 511 == p_y ){ continue; };

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:EFF]");
                    };;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         0  //: BINARY[ 00 ] ://
                    );;  //:  0   ://
                    //: DELTA[ Loop_Through_Set_All ]

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0x00_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0x00 != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ZER]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:0s://
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get_Put( void )
        {
            /** ******************************************** **/
            /** @VID_IID[ 0070 ]TIME[ 1H 19M 32S ]           **/  
            /** Make note of what is NOT done so that        **/
            /** no one comes along later and adds this       **/
            /** function.                                    **/
            /** CANNOT GET WHAT WAS NEVER PUT!!!!!!!!!!!!!!  **/
            /** ******************************************** **/

            ERR("[THERE_IS_ONLY:PUT_GET:NEVER:GET_PUT]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

    #undef  NUM_TEST_CASES_put                          //:01://
    #undef  NUM_TEST_COLMS_put                          //:02://
    #undef  NUM_TEST_CASES_get                          //:03://
    #undef  NUM_TEST_COLMS_get                          //:04://
    //:-----------------------------------:MAIN_GET_PUT_TESTS://
    //:paired_unit_tests::- - - ---- - - - - - - - - - - - - ://
    //:1: glocpix_CTO_painpix : ---- - - - - - - - - - - - - ://
    //:2: painpix_CTO_glocpix : ---- - - - - - - - - - - - - ://
    #define glocpix_CTO_painpix_CASES (  4  )         //: 01 ://
    #define glocpix_CTO_painpix_DATUM (  7  )         //: 02 ://
    #define painpix_CTO_glocpix_CASES (  4  )         //: 03 ://
    #define painpix_CTO_glocpix_DATUM (  7  )         //: 04 ://

        void
        aac2020_paint5d_UTC_glocpix_CTO_painpix( void )
        {

            /** @VID_IID[ 0069 ]TIME[ 1H 52M 50S ] ......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( glocpix_CTO_painpix_CASES - 1);

            /* ACTUAL(act_*)VALUES:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  act_til_qua ;  //:--------------------------://
            U08  act_til_exp ;  //:                          ://
            U08  act_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  act_loc_t_x ;  //:                          ://
            U08  act_loc_t_y ;  //:--------------------------://
                 
            /* EXPECTED(exp_*)VALS:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  exp_til_qua ;  //:--------------------------://
            U08  exp_til_exp ;  //:                          ://
            U08  exp_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  exp_loc_t_x ;  //:                          ://
            U08  exp_loc_t_y ;  //:--------------------------://
 
            /* INPUT VALUES(inn_*):@VID_IID[ 0069]T[ 1H 45M ] */
            I16  inn_glo_t_x ;  //:                          ://
            I16  inn_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 glocpix_CTO_painpix_CASES
                            *
                 glocpix_CTO_painpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * glocpix_CTO_painpix_DATUM );

                /** @VID_IID[ 0069 ]TIME[ 1H 36M 33S ]    **/
                /** Most are expected ("exp_*") values    **/
                /** Except the global values which are    **/
                /** actual ("act_*") values.              **/

                exp_til_qua=(   201 );  /** @TRAP_VALUES@ **/
                exp_til_exp=(   202 );  /** @TRAP_VALUES@ **/
                exp_til_lay=(   203 );  /** @TRAP_VALUES@ **/
                exp_loc_t_x=(   204 );  /** @TRAP_VALUES@ **/
                exp_loc_t_y=(   205 );  /** @TRAP_VALUES@ **/
                inn_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                inn_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                /** @VID_IID[ 0070 ]TIME[ 00H 20M 50S ]   **/
                /** Checking for integer overflow .       **/

                exp_til_qua=(         (U08)tab_utc[ bas + 0 ] );
                exp_til_exp=(         (U08)tab_utc[ bas + 1 ] );
                exp_til_lay=(         (U08)tab_utc[ bas + 2 ] );
                exp_loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                exp_loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                inn_glo_t_x=(              tab_utc[ bas + 5 ] );
                inn_glo_t_y=(              tab_utc[ bas + 6 ] );

                assert(((I16)exp_til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)exp_til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)exp_til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)exp_loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)exp_loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)inn_glo_t_x)==tab_utc[ bas + 5 ] );
                assert(((I16)inn_glo_t_y)==tab_utc[ bas + 6 ] );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(act_til_qua)  //:<-- OUTPUTS -------
                , &(act_til_exp)  //:<-- OUTPUTS -------
                , &(act_til_lay)  //:<-- OUTPUTS -------
                , &(act_loc_t_x)  //:<-- OUTPUTS -------
                , &(act_loc_t_y)  //:<-- OUTPUTS -------
                ,   inn_glo_t_x   //:<----------INPUTS--
                ,   inn_glo_t_y   //:<----------INPUTS--
                );;
 
                if( 0
                ||  exp_til_qua != act_til_qua
                ||  exp_til_exp != act_til_exp
                ||  exp_til_lay != act_til_lay
                ||  exp_loc_t_x != act_loc_t_x
                ||  exp_loc_t_y != act_loc_t_y
                ){
                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_qua  , act_til_qua );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_exp  , act_til_exp );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_lay  , act_til_lay );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_x  , act_loc_t_x );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_y  , act_loc_t_y );

                    ERR("[FAIL:glocpix_CTO_painpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_316PM]" );
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void
        aac2020_paint5d_UTC_painpix_CTO_glocpix( void )
        {
            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( painpix_CTO_glocpix_CASES - 1);

            /** ******************************************** **/
            /** @VID_IID[ 0069 ]TIME[ 02H 05M 55S ]     .....**/
            /**  inn_*  : Input    Values                    **/
            /**  exp_*  : EXPECTED outputs                   **/
            /**  act_*  : ACTUAL   outputs                   **/
            /** ******************************************** **/
                                                      
            U08  inn_til_qua ;  //:--------------------------://
            U08  inn_til_exp ;  //:                          ://
            U08  inn_til_lay ;  //:--------------------------://
            U08  inn_loc_t_x ;  //:                          ://
            U08  inn_loc_t_y ;  //:                          ://
                                //:   SEE[ #DIA_GLO_PIX# ]   ://
            I16  exp_glo_t_x ;  //:                          ://
            I16  exp_glo_t_y ;  //:                          ://
                                //:--------------------------://
            I16  act_glo_t_x ;  //:                          ://
            I16  act_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 painpix_CTO_glocpix_CASES
                            *
                 painpix_CTO_glocpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * painpix_CTO_glocpix_DATUM );

                inn_til_qua=(    11 );  /** @TRAP_VALUES@ **/
                inn_til_exp=(    22 );  /** @TRAP_VALUES@ **/
                inn_til_lay=(    33 );  /** @TRAP_VALUES@ **/
                inn_loc_t_x=(    44 );  /** @TRAP_VALUES@ **/
                inn_loc_t_y=(    55 );  /** @TRAP_VALUES@ **/
                exp_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                exp_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                inn_til_qua=( (U08) tab_utc[ bas + 0 ] );
                inn_til_exp=( (U08) tab_utc[ bas + 1 ] );
                inn_til_lay=( (U08) tab_utc[ bas + 2 ] );
                inn_loc_t_x=( (U08) tab_utc[ bas + 3 ] );
                inn_loc_t_y=( (U08) tab_utc[ bas + 4 ] );
                exp_glo_t_x=(       tab_utc[ bas + 5 ] );
                exp_glo_t_y=(       tab_utc[ bas + 6 ] );

                /** @VID_IID[ 0070 ]TIME[ 00H 16M 22S ]      **/
                /** Check for integer overflow.              **/
                assert(((I16)inn_til_qua)==tab_utc[ bas +0 ]);
                assert(((I16)inn_til_exp)==tab_utc[ bas +1 ]);
                assert(((I16)inn_til_lay)==tab_utc[ bas +2 ]);
                assert(((I16)inn_loc_t_x)==tab_utc[ bas +3 ]);
                assert(((I16)inn_loc_t_y)==tab_utc[ bas +4 ]);
                assert(((I16)exp_glo_t_x)==tab_utc[ bas +5 ]);
                assert(((I16)exp_glo_t_y)==tab_utc[ bas +6 ]);

                aac2020_paint5d_painpix_CTO_glocpix(
                    inn_til_qua   //:<-- INPUTS -----------
                ,   inn_til_exp   //:<-- INPUTS -----------
                ,   inn_til_lay   //:<-- INPUTS -----------
                ,   inn_loc_t_x   //:<-- INPUTS -----------
                ,   inn_loc_t_y   //:<-- INPUTS -----------
                , &(act_glo_t_x)  //:<---------- OUTPUTS --
                , &(act_glo_t_y)  //:<---------- OUTPUTS --
                );;
 
                if( 0
                ||  exp_glo_t_x != act_glo_t_x
                ||  exp_glo_t_y != act_glo_t_y
                ){
                    printf("[glo_t_x]:(%d)(%d)\n",
                    exp_glo_t_x  , act_glo_t_x );

                    printf("[glo_t_y]:(%d)(%d)\n",
                    exp_glo_t_y  , act_glo_t_y );

                    ERR("[FAIL:painpix_CTO_glocpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_504PM]" );

        }

    #undef  glocpix_CTO_painpix_CASES                 //: 01 ://
    #undef  glocpix_CTO_painpix_DATUM                 //: 02 ://
    #undef  painpix_CTO_glocpix_CASES                 //: 03 ://
    #undef  painpix_CTO_glocpix_DATUM                 //: 04 ://
    //: - - - - - - - - - - - - ---- - 1: glocpix_CTO_painpix://
    //: - - - - - - - - - - - - ---- - 2: painpix_CTO_glocpix://
    //: - - - - - - - - - - - - ---- - - -::paired_unit_tests://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://



    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://
//:helper_functions:generic:|||||||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_Min_I16( void )
    {
        #define FUN aac2020_paint5d_Min_I16

        assert( FUN(    3  ,    7  ) ==      3 );
        assert( FUN( 0x00FF,0x7FFF ) == 0x00FF );
        assert( FUN( 0x0001,0x7FFF ) == 0x0001 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_i32_Cap_u32( void )
    {

        I32 bru_x_y = 0x0F00 ; /** brush [X|Y] location     **/
        U16 cap_min = 0x000F ; /** Minimum Boundary         **/
        U16 cap_max = 0xF000 ; /** Maximum Boundary         **/
        U32 u32_x_y           ; /** U32 output of function   **/

        #define FUN aac2020_paint5d_i32_Cap_u32

            /** First test to formalize what the parameter   **/
            /** names we are working with are............... **/

            u32_x_y = FUN( bru_x_y , cap_min , cap_max );

            assert( u32_x_y == 0x0F00 );

            /** Tests where input doesn't change **/
            assert( FUN(   0 ,   0 ,   0 ) ==   0 );
            assert( FUN(   2 ,   1 ,   3 ) ==   2 );
            assert( FUN(  50 ,   0 , 100 ) ==  50 );
            assert( FUN( 200 , 100 , 300 ) == 200 );

            /** Tests where capped to max value **/
            assert( FUN( 300 , 100,  200 ) == 200 );
            assert( FUN(   4 ,   1 ,   3 ) ==   3 );
            assert( FUN( 200 ,   0 , 100 ) == 100 );
            assert( FUN( 400 , 100 , 300 ) == 300 );

            /** Tests where capped to min value **/
            assert( FUN(  50 , 100,  200 ) == 100 );
            assert( FUN(   0 ,   1 ,   3 ) ==   1 );
            assert( FUN(   0 ,   0 , 100 ) ==   0 );
            assert( FUN(  50 , 100 , 300 ) == 100 );

            /** capped to min using NEGATIVES **/
            assert( FUN( -12345678 , 100,  200 ) == 100 );
            assert( FUN( -23456789 ,   1 ,   3 ) ==   1 );
            assert( FUN( -34567890 ,   0 , 100 ) ==   0 );
            assert( FUN( -45678901 , 100 , 300 ) == 100 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    

//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||||||:helper_functions:generic://
//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://
//:helper_functions::conversion:|||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_bip_sip( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_bip_sip
        assert( FUN(0) == 128 );
        assert( FUN(1) ==  64 );
        assert( FUN(2) ==  32 );
        assert( FUN(3) ==  16 );
        assert( FUN(4) ==   8 );
        assert( FUN(5) ==   4 );
        assert( FUN(6) ==   2 );
        assert( FUN(7) ==   1 );
        assert( FUN(8) ==   1 ); //:EDGE_CASE_SINGLE_PIXEL://
        #undef  FUN              //:BOTTOM_RIGHT_CORNER:::://
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_max_cor( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_max_cor
        assert( FUN(0) == 127 );
        assert( FUN(1) ==  63 );
        assert( FUN(2) ==  31 );
        assert( FUN(3) ==  15 );
        assert( FUN(4) ==   7 );
        assert( FUN(5) ==   3 );
        assert( FUN(6) ==   1 );
        assert( FUN(7) ==   0 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_diagpix

        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 00H 44M 10M ]    * * * * * **/
        /** What we were thinking when we started  * * * * * **/
        /** creating entries for tab_utc below.    * * * * * **/
        /**                                                  **/
        /** @VID_IID[ 0071 ]TIME[ 00H 54M 37S ]              **/
        /** 7 is the last useful index (til_exp)             **/
        /** because 8 can only store 1 pixel instead         **/
        /** of 3 groups of pixels.                           **/
        /** ************************************************ **/

        /** tab_utc[  row(s)  col(s) **/
        I32 num_tes=( (9*2)          );;
        I16 tab_utc[  (9*2)  * 2     ]={           //:C_S DEX://
            0 ,   0                                //: 1   0 ://
        ,   1 , 128                                //: 2   1 ://
        ,   2 , 128 + 64                           //: 3   2 ://
        ,   3 , 128 + 64 + 32                      //: 4   3 ://
        ,   4 , 128 + 64 + 32 + 16                 //: 5   4 ://
        ,   5 , 128 + 64 + 32 + 16 + 8             //: 6   5 ://
        ,   6 , 128 + 64 + 32 + 16 + 8 + 4         //: 7   6 ://
        ,   7 , 128 + 64 + 32 + 16 + 8 + 4 + 2     //: 8   7 ://
        ,   8 , 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 //: 9   8 ://
        //:- - - - - - - - - - - - - - - - - - - - - : ----- ://
        ,   0 ,   0                                //: 1   9 ://
        ,   1 , 128                                //: 2  10 ://
        ,   2 , 192                                //: 3  11 ://
        ,   3 , 224                                //: 4  12 ://
        ,   4 , 240                                //: 5  13 ://
        ,   5 , 248                                //: 6  14 ://
        ,   6 , 252                                //: 7  15 ://
        ,   7 , 254                                //: 8  16 ://
        ,   8 , 255                                //: 9  17 ://
        };;                                        

        I32 dex ; //: Current Test Index
        I32 bas ; //: Base Offset Value For Test Data.

        U08 act_til_exp;
        U08 exp_diagpix;
        U08 act_diagpix;

        for( dex = 0; dex <= ( num_tes - 1); dex++ ){

            bas = ( dex * 2 ); //:Multiply Testindex by stride

            /** Extract Data From Table             **/
            /** @VID_IID[ 0071 ]TIME[ 01H 05M 21S ] **/

            act_til_exp = tab_utc[ bas + 0 ]; 
            exp_diagpix = tab_utc[ bas + 1 ];

            act_diagpix = FUN( act_til_exp );

            if( exp_diagpix != act_diagpix ){

                printf("[u_test::dex]:%d\n" , dex         );
                printf("[exp_diagpix]:%d\n" , exp_diagpix );
                printf("[act_diagpix]:%d\n" , act_diagpix );

                ERR("[FAIL_ACTDIAGNOTEQUALEXPDIAG]");
            };;
        };;

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_diagpix_CTO_til_exp( void )
    {
        U08 til_exp    ;
        U08 til_exp_chk;
        U08 diagpix    ;

        for( til_exp = 0 ; til_exp <= MAX_EXP ; til_exp ++ ){

            diagpix=(
            aac2020_paint5d_til_exp_CTO_diagpix( til_exp ));;

            til_exp_chk=(
            aac2020_paint5d_diagpix_CTO_til_exp( diagpix ));;

            if( til_exp != til_exp_chk ){

                printf("[::::til_exp]:%d\n" ,     til_exp );
                printf("[::::diagpix]:%d\n" ,     diagpix );
                printf("[til_exp_chk]:%d\n" , til_exp_chk );

                ERR("[diagpix_CTO_til_exp:UNIT_TEST_FAIL]");
            };;
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /**     @DNE aac2020_paint5d_UTC_diagpix_CTO_astipix     **/
    /**     @DNE == @DOES_NOT_EXIST                          **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void 
    aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK(
        U08 dia_act //:diagpix_actual
    ,   U08 dia_exp //:diagpix_expected
    )
    {
        /** THIS_FUNCTION: ......................... **/
        /** Helper function check test table results **/
        /** @VID_IID[ 0078 ]TIME[ 00H 41M 24S ] .... **/

        if( dia_act != dia_exp ){
            printf("[dia_act]:%d\n" , dia_act );
            printf("[dia_exp]:%d\n" , dia_exp );
            ERR("[OH_NO_MY_FRIEND_UTTER_FAILURE]");
        };;
        
    }
    void 
    aac2020_paint5d_UTC_astipix_CTO_diagpix_C_2(
        U08         dia_act //:diagpix_actual
    ,   U08         dia_exp //:diagpix_expected
    ,   const char* tracebk //:traceback message
    )
    {
       /** Same as:                                     **/
       /** aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK  **/
       /** But pass 3rd param traceback string.         **/

        if( dia_act != dia_exp ){
            printf("[dia_act]:%d\n" , dia_act );
            printf("[dia_exp]:%d\n" , dia_exp );
            printf("[tracebk]:%s\n" , tracebk );
            ERR("[OH_NO_MY_FRIEND_UTTER_FAILURE]");
        };;
        
    }
    void
    aac2020_paint5d_UTC_astipix_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_astipix_CTO_diagpix
        #define CHK aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK
        #define C_2 aac2020_paint5d_UTC_astipix_CTO_diagpix_C_2

               CHK( FUN( 127              ) ,    0            );
               CHK( FUN( 128              ) ,  128            );
               CHK( FUN( 128+64-1         ) ,  128            );
               CHK( FUN( 128+64+0         ) ,  192            );
               CHK( FUN( 128+64+0         ) ,  128+64         );
               CHK( FUN( 128+64+1         ) ,  128+64         );
            assert(      128+64+0           == 192            );
               CHK( FUN( 128+64+32-1      ) ,  192            );
               CHK( FUN( 128+64+32+0      ) ,  128+64+32      );
               CHK( FUN( 128+64+32+1      ) ,  128+64+32      );
               CHK( FUN( 128+64+32+16-1   ) ,  128+64+32      );
               CHK( FUN( 128+64+32+16+0   ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+1   ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+8-1 ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+8+0 ) ,  128+64+32+16+8 );

            /** ******************************************** **/
            /** Previous test, but collapsing numbers so we  **/
            /** don't run out of column space in source code.**/
            /** ******************************************** **/

            assert( FUN( 248 ) == 248 ); //:#_DONT_TOUCH_ME_#://

            /** ******************************************** **/

            C_2( FUN( 248       ) , 248       , "[X_X]"   );
            C_2( FUN( 248+4-1   ) , 248       , "[0_0]"   );
            C_2( FUN( 248+4+0   ) , 248+4     , "[._.]"   );
            C_2( FUN( 248+4+1   ) , 248+4     , "[T_T]"   );
            C_2( FUN( 248+4+2   ) , 248+4+2   , "[0_X]"   );
            C_2( FUN( 248+4+2+1 ) , 248+4+2+1 , "[*_*]"   );

            //:Use some explicit edge case values:           ://
            //:If 255 fails because it is out of bounds, then://
            //:Just comment out that test, as the case has   ://
            //:been properly handled by runtime asserts in   ://
            //:the function being tested.                    ://
            assert( FUN( 0 ) ==   0 );
            assert( FUN(255) == 255 ); //:<--ShouldNeverUse
            assert( FUN(254) == 254 );
            assert( FUN(253) == 252 );

        #undef  FUN
        #undef  CHK
        #undef  C_2
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||:helper_functions::conversion://
//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://

    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://

#undef  MAX_EXP                                       //: 01 ://
#undef  EXT                                           //: 02 ://
#undef  VOD                                           //: 03 ://
#undef  I08                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  I16                                           //: 06 ://
#undef  U16                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  U32                                           //: 09 ://
#undef  ERR                                           //: 10 ://
#undef  LOG                                           //: 11 ://
//:========================================:UNIT_TEST_SECTION://
//:========================================:SECTION_UNIT_TEST://
//:UNIT_TEST_SECTION:P5D_OGL:================================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define I08   int8_t /** GCC: <stdint.h> **/          //: 02 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 03 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 04 ://
#define I16  int16_t /** GCC: <stdint.h> **/          //: 05 ://
#define ERR  aac2020_paint5d_Halt                     //: 06 ://

    void
    aac2020_P5D_OGL_UnitTest( void )
    {

        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/

            extern void 
            AAC2020_PAINT5D_Backup_taudirt( U08** );;
            AAC2020_PAINT5D_Backup_taudirt( &(taudirt) );

            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

            AAC2020_TODOMAN_Vital(
                "[FIX:taudirt_backup_is_invalid_back_reference]"
            );;

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://

            /** utc: unit test code **/
            extern void aac2020_P5D_OGL_utc_private( void );
                        aac2020_P5D_OGL_utc_private( );

        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                extern void
                AAC2020_PAINT5D_Restore_taudirt( U08** );
                AAC2020_PAINT5D_Restore_taudirt( &(taudirt) );

                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://
        //:------------------------------:SYSTEM_DATA:RESTORE://
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_P5D_OGL_utc_private( void )
    {
    #define E_V extern void
    #define   V        void

        /** ************************************************ **/
        /** Functions are tested in order:               * * **/
        /** Lowest Level --> to --> Highest Level        * * **/
        /** AKA: Most depended on to least depended on.  * * **/
        /** @VID_IID[ 0087 ]TIME[ 00:23:32 ] *************** **/
        /** ************************************************ **/

        E_V aac2020_P5D_OGL_utc_polyfill_texel_fetch( void );
            aac2020_P5D_OGL_utc_polyfill_texel_fetch(      );

        /** TEST:       OPEN_GL_PAINT5D_BitPack_Get( )**/
        E_V aac2020_P5D_OGL_utc_PAINT5D_BitPack_Get(V);
            aac2020_P5D_OGL_utc_PAINT5D_BitPack_Get( );

        /** TEST:       OPEN_GL_PAINT5D_til_exp_CTO_max_cor()**/
        E_V aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_max_cor(V);
            aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_max_cor( );

        /** TEST:       OPEN_GL_PAINT5D_til_exp_CTO_diagpix()**/
        E_V aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_diagpix(V);
            aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_diagpix( );

        /** TEST:       OPEN_GL_PAINT5D_painpix_CTO_glocpix()**/
        E_V aac2020_P5D_OGL_utc_PAINT5D_painpix_CTO_glocpix(V);
            aac2020_P5D_OGL_utc_PAINT5D_painpix_CTO_glocpix( );
    
        /** @VID_IID[ 0086 ]TIME[ 01:06:55 ] *************** **/
        /** We only care that this test passes. So only      **/
        /** write enough test code for OTHER functions in    **/
        /** P5D_OGL._ as to figure out how to fix the        **/
        /** code and get this function working properly.     **/

        /** TEST:       OPEN_GL_PAINT5D_Get(......); ******* **/
        E_V aac2020_P5D_OGL_utc_PAINT5D_Get( void );
            aac2020_P5D_OGL_utc_PAINT5D_Get(      );

        /** ************************************************ **/

    #undef  E_V
    #undef    V
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_polyfill_texel_fetch( void )
    {
    #define IV2 struct AAC2020_OPEN_GL_IV2
    #define BIN_011 ( 3 ) /** binary: 11 **/

        /** ************************************************ **/
        /** @VID_IID[ 0088 ]TIME[ 00:53:50 ]                 **/                    
        /** We don't actually have a CPU side texel fetch    **/
        /** function to compare the P5D_OGL._ code against...**/
        /** So I am not sure exactly how we will be testing  **/
        /** this code.                                       **/
        /** ************************************************ **/
        //:..................................................://
        U08*    cpu_pix =( AAC2020_PIXNAME_paint5d_cpu_pix );
        //:..................................................://
        U32     u32_var       ; //:pixel_value_to_store
        U32     u32_got       ; //:value got from texel fetch 
        //:..................................................://
        U32         C_r       ; //:check_what_you_put
        U32         C_g       ; //:check_what_you_put
        U32         C_b       ; //:check_what_you_put
        U32         C_a       ; //:check_what_you_put
        //:..................................................://    
        U32         B_r =( 0 ); //:BYTE: red
        U32         B_g =( 0 ); //:BYTE: green
        U32         B_b =( 0 ); //:BYTE: blue
        U32         B_a =( 0 ); //:BYTE: alpha
        //:..................................................://      
        I32         p_x       ; //:pixel x
        I32         p_y       ; //:pixel y
        I32     glo_com       ; //:global component index
        IV2         glo       ; //:global_xy == [ p_x , p_y ]
        //:..................................................://
        U08         a_d       ; //:Auset_inDex
        U08         t_v       ; //:Tile_Value
        U32     rbp_001       ; //:Re_Built_Pixel: Method #1
        U32     rbp_002       ; //:Re_Built_Pixel: Method #2
        U08         ad2       ; //:Auset_inDex times TWO(2)

        u32_var=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){

            /** Increment with primes. **/
            B_r += 1 ; if( B_r > 255 ){ B_r = B_r - 255; };
            B_g += 3 ; if( B_g > 255 ){ B_g = B_g - 255; };
            B_b += 5 ; if( B_b > 255 ){ B_b = B_b - 255; };
            B_a += 7 ; if( B_a > 255 ){ B_a = B_a - 255; };

            u32_var = ( 0x00
            |   (  ((U08)B_r)  << 24 )
            |   (  ((U08)B_g)  << 16 )
            |   (  ((U08)B_b)  <<  8 )
            |   (  ((U08)B_a)  <<  0 )
            );;

            C_r = ( u32_var >> 24 ) & 0xFF ;
            C_g = ( u32_var >> 16 ) & 0xFF ;
            C_b = ( u32_var >>  8 ) & 0xFF ;
            C_a = ( u32_var >>  0 ) & 0xFF ;

            if(  0
            || ( B_r != C_r )
            || ( B_g != C_g )
            || ( B_b != C_b )
            || ( B_a != C_a )
            ){
                ERR("[YOU_DONT_KNOW_BIT_SHIFTING_2021]");
            };;

            glo_com = ( ( p_y * 512 ) + p_x ) * 4 ;

            cpu_pix[ glo_com + 0 ] = ((U08)B_r);
            cpu_pix[ glo_com + 1 ] = ((U08)B_g);
            cpu_pix[ glo_com + 2 ] = ((U08)B_b);
            cpu_pix[ glo_com + 3 ] = ((U08)B_a);

            glo.x = ( p_x );
            glo.y = ( p_y );
            u32_got=(
                aac2020_polyfill_texel_fetch(
                    0 //:Texture Sampler, Not Used in C version.
                , glo //:Global X/Y coordinate of pixel.
                ,   0 //:[ L.O.D. ] Always zero in all code.
                ));;
            
            if( u32_got != u32_var ){
                ERR("[texel_fetch_definitely_broken_2021]");
            };;

            //: Try Using: aac2020_paint5d_BitPack_Get       ://
            //: To re-build the pixel we put. If that works  ://
            //: Then I am satisfied to maybe... 70% that     ://
            //: the texel fetch code works properly.         ://
            rbp_001 =( 0x00 );
            rbp_002 =( 0x00 );
            for( a_d = 0 ; a_d <= 15 ; a_d ++ ){

                /** GET: t_v ( tile value ) **/
                aac2020_paint5d_BitPack_Get(
                      cpu_pix  //: U08* :  ://
                ,(U08)glo_com  //: U08  :  ://
                ,         a_d  //: U08  :  ://
                ,       &(t_v) //: U08  :  ://
                );;

                ad2=( a_d * 2 );
                rbp_001=( rbp_001 | ( t_v           << ad2 ) );
                rbp_002=( rbp_002 | ((t_v & BIN_011)<< ad2 ) );
                if( rbp_001 != rbp_002 ){
                    ERR("[WTF:rbp_001!=rbp_002]");
                };;
            };;

            if( 0
            ||  ( rbp_001 != u32_got )
            ||  ( rbp_001 != u32_var )
            ){
                printf("[rbp_001]:%d\n" , rbp_001 );
                printf("[u32_got]:%d\n" , u32_got );
                printf("[u32_var]:%d\n" , u32_var );

                /** **************************************** **/
                /** If we are lucky, the hex representation  **/
                /** of number will be enough to figure out   **/
                /** what went wrong. If unlucky, we will need**/
                /** to printf as binary.                     **/
                /** @VID_IID[ 0088 ]TIME[ 01:45:20 ]         **/
                /** **************************************** **/
                printf("[hex:rbp_001]:%08x\n" , rbp_001 );
                printf("[hex:u32_got]:%08x\n" , u32_got );
                printf("[hex:u32_var]:%08x\n" , u32_var );

                ERR("[Maybe_BitPacking_Code_Is_Wrong:2021]");
            };;


        };;};;

    #undef IV2
    #undef BIN_011
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_PAINT5D_BitPack_Get( void )
    {
        /** @VID_IID[ 0088 ]TIME[ 00:10:08 ] *************** **/
        /** Functions in "OPEN_GL_HAKCODE/P5D_OGL._"   * * * **/
        /** are transcribed versions of functions in   * * * **/
        /** PAINT5D.F._ . The goal is re-write the     * * * **/
        /** code in a way that is more compatible      * * * **/
        /** with GLSL syntax so minimal changes will   * * * **/
        /** need to be done to paste it into our       * * * **/
        /** shader code.                               * * * **/
        /** ************************************************ **/

        I32         p_x; //:Global pixel coordinate on:
        I32         p_y; //:AAC2020_PIXNAME_paint5d_cpu_pix
                         //:SEE[ DIAGRAM[ #DIA_P5D_MAIN# ]  ]
                         //:SEE[    FILE[ PAINT5D.D._    ]  ]

        I32         aus; //:What auto-tile-set (auset) is
                         //:being targeted. Paint5D system
                         //:is configured to store 16 total
                         //:ausets per texture.
                         //:SEE[ DIAGRAM[ #DIA_P5D_U32#  ]  ]
                         //:SEE[    FILE[ PAINT5D.D._    ]  ]

        U08*    cpu_pix =( AAC2020_PIXNAME_paint5d_cpu_pix );
                         //:The system data storing the
                         //:designs Josh will be working on
                         //:in paint5d.

        I32     glo_com; //:Global Component Index (red byte)
        I32     aus_dex; //:Same as [ aus ]
        I32     til_val; //:Tile Value: [ 0 | 1 | 2 | 3 ]
                         //:( 2 bits used to store tile value )
            
        U08 u08_til_val; //:  8 bit version of til_val
        U32 u32_til_val; //: 32 bit version of til_val

        /** @VID_IID[ 0088 ]TIME[ 00:16:50 ] *************** **/
        /** AAC2020_OPEN_GL_IV2 :                            **/
        /** This struct exists to help us make the code      **/
        /** as similiar to GLSL code as possible to          **/
        /** HOPEFULLY make it so ZERO CHANGES need to be     **/
        /** done when pasting this code into our GLSL        **/
        /** shader string.                                   **/
        /** ************************************************ **/

            struct AAC2020_OPEN_GL_IV2
            glo; //:<-- [ glo.x , glo.y ] == [ p_x , p_y ]

        /** ************************************************ **/

        til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:The_Setup:------------------------------------://
            
                /** Set Auset Index **/
                aus_dex =( aus );

                /** Generate Tile Value **/
                til_val++;
                if( til_val >  3 ){ til_val = 0; };

                /** Skip Configuration Pixel **/
                if( 255 == p_x && 255 == p_y ){ continue; };
                if( 511 == p_x && 255 == p_y ){ continue; };
                if( 255 == p_x && 511 == p_y ){ continue; };
                if( 511 == p_x && 511 == p_y ){ continue; };

                /** **************************************** **/
                /** @VID_IID[ 0087 | 0088 ]....Ooops...      **/
                /** @TIME[ 00:22:28 ] ********************** **/
                /** Convert [ p_x , p_y ] to component index **/
                /** Use index to xy formula for a 512x512    **/
                /** bitmap, then multiply by 4 to convert    **/
                /** the pixel location to RED_BYTE location. **/

                    glo_com =( ( p_y * 512 ) + p_x ) * 4 ;

                /** **************************************** **/

            //:------------------------------------:The_Setup://
            //:Test_Original_Code:---------------------------://

                aac2020_paint5d_BitPack_Put(
                         cpu_pix  //:<-- [ Bitmap / Texture ]
                ,   (U08)glo_com   
                ,   (U08)aus_dex   
                ,   (U08)til_val  //:<-- Put this value into
                );;               //:    [ Bitmap / Texture ]

                aac2020_paint5d_BitPack_Get(
                         cpu_pix  //:<-- [ Bitmap / Texture ]
                ,   (U08)glo_com  
                ,   (U08)aus_dex  
                ,  &(u08_til_val) //:<-- Read Value From
                );;               //:    [ Bitmap / Texture ]

                if( (I08)u08_til_val
                !=  (I08)    til_val
                ){
                    /** Hope you never see this error. As it **/
                    /** means you transcribed buggy code.    **/
                    /** @VID_IID[ 0087 ]TIME[ 00:42:30 ]     **/
                    ERR("[PROBLEM_IS_THE_ORIGINAL_CODE_2021]");
                };;

            //:---------------------------:Test_Original_Code://
            //:Cross_Check_New_Code:-------------------------://
            /** ******************************************** **/
            /** OPEN_GL_PAINT5D_BitPack_Get is a re-write    **/
            /** of aac2020_paint5d_BitPack_Get and thus      **/
            /** should have the same exact outputs as        **/
            /** aac2020_paint5d_BitPack_Get for a given set  **/
            /** of inputs. @VID_IID[ 0088 ]TIME[ 00:03:23 ]  **/
            /** ******************************************** **/

                glo.x = p_x;
                glo.y = p_y;

                u32_til_val=(
                    OPEN_GL_PAINT5D_BitPack_Get(
                        glo      //:Pixel Location
                    ,   aus_dex  //:Bit Location To Unpack
                    ));;

                if( (I08)u32_til_val
                !=  (I08)    til_val
                ){
                    printf("\n\n\n");
                    printf("[p_x,p_y,aus]:(%d,%d,%d)\n"
                    ,        p_x,p_y,aus );;
                    printf("[u32_til_val]:%d\n"
                    ,        u32_til_val );;
                    printf("[....til_val]:%d\n"
                    ,            til_val );;

                    /** ************************************ **/
                    /** @VID_IID[ 0088 ]TIME[ 00:06:55 ]     **/
                    /** This is the best case scenario for   **/
                    /** test code failure. Means we did      **/
                    /** something very stupid while transcri-**/
                    /** -bing the code.                      **/
                    ERR("[PROBLEM_IS_THE_TRANSCRIPTION_2021]");
                    /** ************************************ **/
                };;

            //:-------------------------:Cross_Check_New_Code://

        };;};;};; //:NEXT[ p_x , p_y , aus ]://

    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_max_cor( void )
    {



    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_PAINT5D_til_exp_CTO_diagpix( void )
    {



    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_PAINT5D_painpix_CTO_glocpix( void )
    {



    return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_P5D_OGL_utc_PAINT5D_Get( void )
    {
        //:variable_declare:---------------------------------://

            /** iterate over every pixel of bitmap **/
            I32 p_x; //:Pixel X
            I32 p_y; //:Pixel Y
            I32 aus; //:auset index

            /** for original functions **/
            U08 u08_til_qua ;
            U08 u08_til_exp ;
            U08 u08_til_lay ;
            U08 u08_loc_t_x ;
            U08 u08_loc_t_y ;
            I16 i16_glo_t_x ;
            I16 i16_glo_t_y ;

            /** for original functions **/
            U08 u08_aus_dex ;
            U08 u08_til_val ;

            /** for return from GLSL version of function. **/
            U32 u32_til_val ;

            /** for determining if we passed tests or not. **/
            I08 i08_u32_til_val ;
            I08 i08_u08_til_val ;

        //:---------------------------------:variable_declare://

        u08_til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:IDENTICAL_CODE_IN_BOTH_LOOPS:-----------------://
            u08_aus_dex =( (U08)aus );
            u08_til_val++;
            if( u08_til_val >  3 ){ u08_til_val = 0; };
            /** @VID_IID[ 0086 ]TIME[ 01:12:00 ] **/
            /** SKIP THE CONFIGURATION PIXELS.   **/
            if( 255 == p_x && 255 == p_y ){ continue; };
            if( 511 == p_x && 255 == p_y ){ continue; };
            if( 255 == p_x && 511 == p_y ){ continue; };
            if( 511 == p_x && 511 == p_y ){ continue; };
            //:-----------------:IDENTICAL_CODE_IN_BOTH_LOOPS://

            aac2020_paint5d_glocpix_CTO_painpix(
              &(u08_til_qua )            //: U08* ://
            , &(u08_til_exp )            //: U08* ://
            , &(u08_til_lay )            //: U08* ://
            , &(u08_loc_t_x )            //: U08* ://
            , &(u08_loc_t_y )            //: U08* ://
            ,  (i16_glo_t_x = (I16)p_x ) //: I16  ://
            ,  (i16_glo_t_y = (I16)p_y ) //: I16  ://
            );;

            AAC2020_PAINT5D_Put(
               u08_til_qua  //:  U08  ://
            ,  u08_til_exp  //:  U08  ://
            ,  u08_til_lay  //:  U08  ://
            ,  u08_loc_t_x  //:  U08  ://
            ,  u08_loc_t_y  //:  U08  ://
            ,  u08_aus_dex  //:  U08  ://
            ,  u08_til_val  //:  U08  ://
            );;          

            /** Use GLSL version of getter **/
            u32_til_val=(                                    
                OPEN_GL_PAINT5D_Get(                       
                    (I32)u08_til_qua                           
                ,   (I32)u08_til_exp                           
                ,   (I32)u08_til_lay                           
                ,   (I32)u08_loc_t_x                           
                ,   (I32)u08_loc_t_y                           
                ,   (I32)u08_aus_dex   
                ));;

                 i08_u32_til_val = ((I08)u32_til_val) ;
                 i08_u08_til_val = ((I08)u08_til_val) ;
            if(  i08_u32_til_val
            !=   i08_u08_til_val
            ){
                printf("\n\n\n");
                //:Does_Original_Ganster_Get_Fail_Too?:------://
                U08 O_G_til_val;    /** O_G:original_ganster **/
                AAC2020_PAINT5D_Get(
                   u08_til_qua  //:  U08  ://
                ,  u08_til_exp  //:  U08  ://
                ,  u08_til_lay  //:  U08  ://
                ,  u08_loc_t_x  //:  U08  ://
                ,  u08_loc_t_y  //:  U08  ://
                ,  u08_aus_dex  //:  U08  ://
                ,&(O_G_til_val) //:  U08  ://
                );;   
                if( O_G_til_val == u08_til_val ){
                    printf("[TRANSCRIPTION_PROBLEM_RED]\n");
                }else{
                    printf("[THIS_IS_MUCH_MUCH_WORSE_RED]\n");
                };;
                //:------:Does_Original_Ganster_Get_Fail_Too?://

                printf("[p_x,p_y]:(%d,%d)\n",p_x,p_y);

                printf("[O_G_til_val]:%d\n"
                ,        O_G_til_val );;

                printf("[i08_u32_til_val]:%d\n"
                ,        i08_u32_til_val );;

                printf("[i08_u08_til_val]:%d\n"
                ,        i08_u08_til_val );;

                ERR("[FAILED_GLSL_TEST_OF_PAINT5D:001]");
            };;

        };;};;};;

        /** RUN A 2ND TIME WITH ONLY GETTER TO DETECT        **/
        /** MEMORY STOMPS. @VID_IID[ 0086 ]TIME[ 00:37:08 ]  **/

        u08_til_val=( 0 );
        for( p_y = 0 ; p_y <= ( 512-1 ) ; p_y ++ ){
        for( p_x = 0 ; p_x <= ( 512-1 ) ; p_x ++ ){
        for( aus = 0 ; aus <= (   15  ) ; aus ++ ){
        /** #_SCANLINE_ORDER_MEANS_Y_IS_THE_OUTER_LOOP_# **/

            //:IDENTICAL_CODE_IN_BOTH_LOOPS:-----------------://
            u08_aus_dex =( (U08)aus );
            u08_til_val++;
            if( u08_til_val >  3 ){ u08_til_val = 0; };
            /** @VID_IID[ 0086 ]TIME[ 01:12:00 ] **/
            /** SKIP THE CONFIGURATION PIXELS.   **/
            if( 255 == p_x && 255 == p_y ){ continue; };
            if( 511 == p_x && 255 == p_y ){ continue; };
            if( 255 == p_x && 511 == p_y ){ continue; };
            if( 511 == p_x && 511 == p_y ){ continue; };
            //:-----------------:IDENTICAL_CODE_IN_BOTH_LOOPS://

            /** Use GLSL version of getter **/
            u32_til_val=(                                    
                OPEN_GL_PAINT5D_Get(                       
                    (I32)u08_til_qua                           
                ,   (I32)u08_til_exp                           
                ,   (I32)u08_til_lay                           
                ,   (I32)u08_loc_t_x                           
                ,   (I32)u08_loc_t_y                           
                ,   (I32)u08_aus_dex   
                ));;

                 i08_u32_til_val = ((I08)u32_til_val) ;
                 i08_u08_til_val = ((I08)u08_til_val) ;
            if(  i08_u32_til_val
            !=   i08_u08_til_val
            ){
                printf("\n\n\n");
                //:Does_Original_Ganster_Get_Fail_Too?:------://
                U08 O_G_til_val;    /** O_G:original_ganster **/
                AAC2020_PAINT5D_Get(
                   u08_til_qua  //:  U08  ://
                ,  u08_til_exp  //:  U08  ://
                ,  u08_til_lay  //:  U08  ://
                ,  u08_loc_t_x  //:  U08  ://
                ,  u08_loc_t_y  //:  U08  ://
                ,  u08_aus_dex  //:  U08  ://
                ,&(O_G_til_val) //:  U08  ://
                );;   
                if( O_G_til_val == u08_til_val ){
                    printf("[TRANSCRIPTION_PROBLEM_BLUE]\n");
                }else{
                    printf("[THIS_IS_MUCH_MUCH_WORSE_BLUE]\n");
                };;
                //:------:Does_Original_Ganster_Get_Fail_Too?://

                printf("[p_x,p_y]:(%d,%d)\n",p_x,p_y);

                printf("[O_G_til_val]:%d\n"
                ,        O_G_til_val );;

                printf("[i08_u32_til_val]:%d\n"
                ,        i08_u32_til_val );;

                printf("[i08_u08_til_val]:%d\n"
                ,        i08_u08_til_val );;

                ERR("[FAILED_GLSL_TEST_OF_PAINT5D:002]");
            };;
    
        };;};;};;

    }

#undef  U08                                           //: 01 ://
#undef  I08                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  I32                                           //: 04 ://
#undef  I16                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:================================:UNIT_TEST_SECTION:P5D_OGL://
