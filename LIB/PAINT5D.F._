//: PAINT5D: ( .F._ : FuncFile )
//: #NAMESPACE_PATTERN_BREAKER_PAINT5D#

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://

    void
    aac2020_paint5d_Halt( const char* msg_err )
    {

        printf("[FATAL_2020_12_04_076PM]:%s\n", msg_err );
        fflush(stdout);exit(  11 /** 4*20-69 **/ );         

    }

//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:OKAY_STATUS_INFO_MESSAGE:=================================://

    void
    aac2020_paint5d_Okay( const char* msg_o_k )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Okay]:%s\n", msg_o_k );
        fflush(stdout);    
    };;}

//:=================================:OKAY_STATUS_INFO_MESSAGE://
//:INFO_STATUS_INFO_MESSAGE:=================================://
#define I32 int32_t /** GCC: <stdint.h> **/

    void
    aac2020_paint5d_Info( const char* msg_inf )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Info]:%s\n", msg_inf );
        fflush(stdout);    
    };;}

    void
    aac2020_paint5d_Info_dec( 
        const char* str_fmt
    ,   I32         val_dec
    )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf( "[aac2020_paint5d_Info_dec]...\n");
        fflush( stdout            ); //:@SAFETY_DOUBLE_FLUSH@://
        printf( str_fmt , val_dec );
        fflush( stdout            );    
    };;}

#undef  I32
//:=================================:INFO_STATUS_INFO_MESSAGE://
//:INITIALIZE_PAINT5D:=======================================://
#define U32  uint32_t /** GCC: <stdint.h> **/         //: 01 ://
#define I32   int32_t /** GCC: <stdint.h> **/         //: 02 ://
#define ERR   aac2020_paint5d_Halt                    //: 03 ://
#define O_K   aac2020_paint5d_Okay                    //: 04 ://
#define I_D   aac2020_paint5d_Info_dec                //: 05 ://
#define INF   aac2020_paint5d_Info                    //: 06 ://

    U32
    AAC2020_PAINT5D_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved for future use **/ };

        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

        /** Hackishly debug what is going on. **/
        AAC2020_PAINT5D_init_call_count++;
        I_D("[AAC2020_PAINT5D_init_call_count]:%d\n"
                ,AAC2020_PAINT5D_init_call_count       );;

        if( AAC2020_CEDITOR_dex_ing == 
            AAC2020_CEDITOR_paint5d
        ){  
            /** If not recursion, it might be being called   **/
            /** rapidly from another thread. Re-entering     **/
            /** before it is exiting. But that seems         **/
            /** unlikely. I think that would require         **/
            /** more than one thread to call this function.  **/

            ERR("[LIKELY_UNINTENTIONAL_RECURSION]"); 
        };;

            /** #_EDITOR_INIT_SPAM_GAURD_# **/
            if( AAC2020_CEDITOR_nex_edi 
            ==  AAC2020_CEDITOR_dex_edi
            ){
                O_K("[PAINT5D:Init_Already_Up_To_Date]");
            };;

        /** We are now initilaizing paint5d **/
        AAC2020_CEDITOR_dex_ing=( 
        AAC2020_CEDITOR_paint5d  );;

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://

        /** Early Exit Will Trigger Recursion Guard Error **/
        O_K( "[OH_FUCK...Code_Below_Was_Never_Ran_Before]" );;

        //:ALL_MEMBERS_OF_PAINT5D:---------------------------://

            //:#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#://

        //:---------------------------:ALL_MEMBERS_OF_PAINT5D://
        //:ALLOCATES_OPEN_GL_TEXTURE:------------------------://
    
            //+ #GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER# + + + +//
            //- AAC2020_GPUDATA_InitInstance(  - - - - - - - -//
            //-     ACC2020_PAINT5D_dat      );; - - - - - - -//

        //:------------------------:ALLOCATES_OPEN_GL_TEXTURE://
        //:LOAD_INITIAL_TEXTURE_DATA:------------------------://
        #define DAT gpudata_paint5d
        #define F_S( name ) AAC2020_PIXNAME_##name

            /** #_TODOS_CAN_BREAK_COLUMN_LIMIT_# **/
            /** For now just load a test pattern to confirm we    * * * * * **/
            /** have data. But once that is done, we will want to * * * * * **/
            /** load from a save file on disk on startup.         * * * * * **/
            AAC2020_VITAL_TODO("[Eventually_This_Should_Load_Save_File_Data]");



            struct AAC2020_GPUDATA gpudata_paint5d ={ 0 };



            if( strcmp( &(F_S( paint5d )[0]) ,"paint5d" )!= 0 ){
                aac2020_paint5d_Halt("[BAD_NAME_2020]");
            };;


            
            //: FILE_SCOPE(  F_S  ) --> TEMP_STRUCT(  DAT  );
            DAT.tex_lot =    F_S( paint5d_tex_lot          );
            DAT.tex_han =    F_S( paint5d_tex_han          ); 
            DAT.sam_loc =    F_S( paint5d_tex_sam.sam_loc  );
            DAT.sam_val =    F_S( paint5d_tex_sam.sam_val  );
            DAT.sam_has =    F_S( paint5d_tex_sam_HAS      );
            DAT.pix_wid =  ( 512                           );
            DAT.pix_hig =  ( 512                           );
            DAT.pix_nam = &( F_S( paint5d )[0]             );

            DAT.cpu_pix =&( 
                AAC2020_PIXNAME_paint5d_cpu_pix[0] 
            );;



            AAC2020_PIXLOAD_TestPattern(   &( DAT ) );
            AAC2020_PIXLOAD_UploadTexture( &( DAT ) );
            

            //:get_paint5d_sampler_location:-----------------://
            #define HAS_CHK AAC2020_PIXLOAD_HasSampler
            #define INF_DEC aac2020_paint5d_Info_dec

                //:#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#://
                AAC2020_PIXLOAD_sam_has    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_loc    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_val_PUT( &( DAT ) );

                if( DAT.sam_has >= 1 && DAT.sam_loc <=(0 - 1) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:001]");
                }else 
                if( DAT.sam_has <= 0 && DAT.sam_loc >=(  0  ) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:002]");
                };;

                /** Keep the error prone way of doing this   **/
                /** As a redundancy to check for agreement.  **/

                I32 has = HAS_CHK( "paint5d" );
                if( DAT.sam_has != has ){ ERR("[WTF:0433AM]");};

                INF_DEC( "[DAT.sam_loc]:%d\n" , DAT.sam_loc );
                INF_DEC( "[DAT.sam_val]:%d\n" , DAT.sam_val );

            #undef  HAS_CHK
            #undef  INF_DEC
            //:-----------------:get_paint5d_sampler_location://

            if( has >= 1 ){

                /** Update Texture Sampler Uniform On GPU **/

                aac2020_pixload_PushSampler(  &( DAT ) );

                /** Persist Changes: **/

                //: TEMP_STRUCT(  DAT  ) --> FILE_SCOPE(  F_S  )
                F_S( paint5d_tex_lot         ) = DAT.tex_lot ;
                F_S( paint5d_tex_han         ) = DAT.tex_han ;
                F_S( paint5d_tex_sam.sam_loc ) = DAT.sam_loc ;
                F_S( paint5d_tex_sam.sam_val ) = DAT.sam_val ;
                F_S( paint5d_tex_sam_HAS     ) = DAT.sam_has ;
                //:                    ( 512 ) = DAT.pix_wid ://
                //:                    ( 512 ) = DAT.pix_hig ://
                //:                 "paint5d" ~=~DAT.pix_nam ://
    
                aac2020_paint5d_Okay("[HAS_TEXTURE_SAMPLER]");
            }else{

                /** Whether this is a good or bad message **/
                /** depends on you looking at code and    **/
                /** deciding.                             **/
                INF("[NO_TEXTURE_SAMPLER:PAINT5D]");
    
            };;
           
        #undef DAT
        #undef F_S
        //:------------------------:LOAD_INITIAL_TEXTURE_DATA://
        //:ERROR_CHECK:--------------------------------------://

            //:#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#://
            

        //:--------------------------------------:ERROR_CHECK://


        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

            /** DONE initializing. **/

            AAC2020_CEDITOR_dex_ini=( 
            AAC2020_CEDITOR_paint5d  );;

            /** No editor initializ-ING now. **/
            AAC2020_CEDITOR_dex_ing=( 0xFFFFFFFF );

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://

        return( 0x00 );

    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
#undef  O_K                                           //: 04 ://
#undef  I_D                                           //: 05 ://
#undef  INF                                           //: 06 ://
//:=======================================:INITIALIZE_PAINT5D://
//:HELPER_FUNCTIONS:GENERIC:=================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U16 uint16_t /** GCC: <stdint.h> **/
#define I16  int16_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I16
    aac2020_paint5d_Min_I16(
        I16 i16_001
    ,   I16 i16_002
    )
    {
        I16 i16_min = ( 0 - 4433 /** @TRAP_VALUE@ **/ );
        if( i16_001 <= i16_002 ){ i16_min = i16_001 ; };
        if( i16_002 <= i16_001 ){ i16_min = i16_002 ; };

        assert( 0 - 4433 != i16_min /** @CHECK_TRAP@ **/ );
        return( i16_min );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_i32_Cap_u32(

        I32 bru_x_y /** [ b_x | b_y ](Brush_X -or- Brush_Y) **/
    ,   U16 cap_min
    ,   U16 cap_max

    )
    {
        assert( cap_min <= cap_max ); /** Sorted/Ordered ? **/

        U32 out_u32 = ( (U32)bru_x_y );

        if( bru_x_y < (I32)cap_min ){ out_u32 =(U32)(cap_min);};
        if( bru_x_y > (I32)cap_max ){ out_u32 =(U32)(cap_max);};

        return( out_u32 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32 
#undef  U32 
#undef  U16 
#undef  I16
//:=================================:HELPER_FUNCTIONS:GENERIC://
//:HELPER_FUNCTIONS:CONVERSION:==============================://
#define POT aac2020_paint5d_POT_diagpix               //: 01 ://
#define T_E til_exp /** Tilesize_Exponent **/         //: 02 ://
#define BRK break                                     //: 03 ://
#define CAS case                                      //: 04 ://
#define DEF default                                   //: 05 ://
#define S_A _Static_assert                            //: 06 ://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 07 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 08 ://
#define ERR aac2020_paint5d_Halt                      //: 09 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_bip_sip(
                U08 til_exp
    )
    {
        U08 bip_sip; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ bip_sip = ( 128 + 0 ); };  //: 1 ://
        if( 1 == til_exp ){ bip_sip = (  64 + 0 ); };  //: 2 ://
        if( 2 == til_exp ){ bip_sip = (  32 + 0 ); };  //: 3 ://
        if( 3 == til_exp ){ bip_sip = (  16 + 0 ); };  //: 4 ://
        if( 4 == til_exp ){ bip_sip = (   8 + 0 ); };  //: 5 ://
        if( 5 == til_exp ){ bip_sip = (   4 + 0 ); };  //: 6 ://
        if( 6 == til_exp ){ bip_sip = (   2 + 0 ); };  //: 7 ://
        if( 7 == til_exp ){ bip_sip = (   1 + 0 ); };  //: 8 ://
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
        assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
    
        return( bip_sip );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_max_cor(
                U08 til_exp
    )
    {
        /** Why is output U08 ?                **/
        /** @VID_IID[ 0067 ]TIME[ 4H 15M 40S ] **/

        U08 max_cor; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ max_cor = ( 128 - 1 ); };  //: 1 ://
        if( 1 == til_exp ){ max_cor = (  64 - 1 ); };  //: 2 ://
        if( 2 == til_exp ){ max_cor = (  32 - 1 ); };  //: 3 ://
        if( 3 == til_exp ){ max_cor = (  16 - 1 ); };  //: 4 ://
        if( 4 == til_exp ){ max_cor = (   8 - 1 ); };  //: 5 ://
        if( 5 == til_exp ){ max_cor = (   4 - 1 ); };  //: 6 ://
        if( 6 == til_exp ){ max_cor = (   2 - 1 ); };  //: 7 ://
        if( 7 == til_exp ){ max_cor = (   1 - 1 ); };  //: 8 ://
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
        assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
    
        return( max_cor );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_diagpix(
            U08     til_exp
    )
    {
        U08     diagpix =aac2020_paint5d_POT_diagpix[ til_exp ];
        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_til_exp(
            U08     diagpix
    )
    {
        /** In case type signature changes **/
        assert(  (((I32)diagpix)+0) < 255  );

        /**   T_E  **/
        U08 til_exp =( 222 /** Invalid Trap Value **/ );
        /**   T_E  **/

        switch( diagpix ){  
        //:pyramid_not_of_doom:------------------------------://
        CAS 0: T_E = ( 0                              );BRK;
        CAS 1: T_E = ( 0 +128                         );BRK;
        CAS 2: T_E = ( 0 +128 +64                     );BRK;
        CAS 3: T_E = ( 0 +128 +64 +32                 );BRK;
        CAS 4: T_E = ( 0 +128 +64 +32 +16             );BRK;
        CAS 5: T_E = ( 0 +128 +64 +32 +16 +8          );BRK;
        CAS 6: T_E = ( 0 +128 +64 +32 +16 +8 +4       );BRK;
        CAS 7: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2    );BRK;
        CAS 8: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2 +1 );BRK;
        //:------------------------------:pyramid_not_of_doom://
        DEF: ERR("[INVALID_DIAGPIX_INPUT_CANNOT_CONVERT]");
        };; assert( til_exp <= 7 && (((I32)til_exp)+0) >= 0 );
        S_A( AAC2020_PAINT5D_MAX_til_exp == 7 , "[ERR_MSG]" );

        /** 8 is only 1 pixel, and thus not useful. **/
        /** @VID_IID[ 0068 ]TIME[ 3H 13M 15S ]      **/

        assert( (&T_E)==(&til_exp)/**@SAME_VAR_SAME_ADDR@**/ );
        assert(   T_E ==  til_exp /**@SAME_VAR@**/           );
        return(   T_E /** til_exp **/                        );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_astipix(
            U08     diagpix
    )
    {
        if( diagpix ){ /** @NOOP@ **/ };
        /** ************************************************ ***

            @VID_IID[ 0066 -to- 0071 ]TIME[ 00H 26M 24S ]
            @VID_IID[ 0071           ]TIME[ 03H 32M 30S ]

            Cannot make this function because
            aac2020_paint5d_astipix_CTO_diagpix(...)
            is a one-way conversion.

            BECAUSE WE HAVE INFORMATION LOSS WHEN
            [FUNNELING / CONVERTING] DOWN TO[ diagpix ]
            WE CANNOT DO A @BACK_AND_FORTH_CONVERSION_TEST@

        *** ************************************************ **/
        ERR("[CANNOT_MAKE_SUCH_FUNCTION:diagpix_CTO_astipix]");

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_astipix_CTO_diagpix(
            U08     astipix
    )
    {
        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 03H 47M 50S ]              **/
        /** SEE:FILE[ PAINT5D.D._]SECTION[ PAINT5D_DATA ]    **/
        /**      VAR[ aac2020_paint5d_POT_diagpix       ]    **/
        /**  DIAGRAM[ #_DIA_SELECTED_TIL_QUA_#          ]    **/
        /**                                                  **/
        /** astipix : Auset_Sub_TIle: PIXel (location:[X|Y]) **/
        /** diagpix : DIAGonal_PIXels .......................**/
        /** ************************************************ **/

        U08 lil=( 0 ); //: lil == "Largest_Index_Lessthan"

        for( I32 i = 0 ; i <= 9 ; i++ ){
            if( astipix < aac2020_paint5d_POT_diagpix[ i ] ){ 

                lil = i; 
            };;
        };;

        assert( lil >= 1 ); /** First Comparison Should      **/
                          /** never be true, so we should    **/
                          /** always have an "lil" of        **/
                          /** at least one( 1 )              **/

        U08 diagpix=( aac2020_paint5d_POT_diagpix[ lil - 1 ] );

        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  POT                                           //: 01 ://
#undef  T_E                                           //: 02 ://
#undef  BRK                                           //: 03 ://
#undef  CAS                                           //: 04 ://
#undef  DEF                                           //: 05 ://
#undef  S_A                                           //: 06 ://
#undef  U08                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  ERR                                           //: 09 ://
//:==============================:HELPER_FUNCTIONS:CONVERSION://
//:QUARKMAP_COORD_CONVERSIONS:===============================://
#define U08   uint8_t /** GCC: <stdint.h> **/         //: 01 ://
#define U16  uint16_t /** GCC: <stdint.h> **/         //: 02 ://
#define I16   int16_t /** GCC: <stdint.h> **/         //: 03 ://
#define RES  restrict                                 //: 04 ://
#define MIN  aac2020_paint5d_Min_I16                  //: 05 ://
#define ERR  aac2020_paint5d_Halt                     //: 06 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_glocpix_CTO_painpix(
        U08*  RES  til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08*  RES  til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08*  RES  til_lay /** TileLayer .................   **/
    ,   U08*  RES  loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08*  RES  loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16        glo_t_x /** Global Tile X Coord           **/
    ,   I16        glo_t_y /** Global Tile X Coord           **/
    )
    {
        /** Why output parameters at the start of signature? **/
        /** @VID_IID[ 0067]TIME[ 3H 56M 45S ] .............. **/

        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != til_qua ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_exp ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_lay ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_x ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_y ); /** ! OUTPUTS ! **/

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://

            assert( AAC2020_PAINT5D_MAX_glo_t_x >= glo_t_x );
            assert( AAC2020_PAINT5D_MAX_glo_t_y >= glo_t_y );
            assert(                0            <= glo_t_x );
            assert(                0            <= glo_t_y );
  
        //:------------------------------:bounds_check_inputs://
        //:Get_Variables_Ready_To_Work_With:-----------------://

            I16 i16_til_qua =( 0 - 1001 );
            I16 i16_til_exp =( 0 - 1001 );
            I16 i16_til_lay =( 0 - 1001 );
            I16 i16_loc_t_x =( 0 - 1001 );
            I16 i16_loc_t_y =( 0 - 1001 );

            I16 i16_gtx =( (I16)( glo_t_x ) );
            I16 i16_gty =( (I16)( glo_t_y ) );

            I16 rem_i_x =( 0 - 2002 ); /** Remainder: X      **/
            I16 rem_i_y =( 0 - 2002 ); /** Remainder: Y      **/

            I16 o_x_qua =( 0 - 2002 ); /** XY Location Of    **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua           **/

            I16 diagp_x =( 0 - 2002 ); /** diagpix.x         **/
            I16 diagp_y =( 0 - 2002 ); /** diagpix.y         **/
            I16 diagpix =( 0 - 2002 ); /** diagonal_pixels   **/

            I16 o_x_lay =( 0 - 2002 ); /** XY Location of    **/
            I16 o_y_lay =( 0 - 2002 ); /** til_lay           **/

            I16 bip_sip =( 0 - 2002 ); /** BItmap_Partition  **/
                                       /** Span_In_Pixels    **/

            I16 max_cor =( 0 - 2002 ); /** Bounds Checking   **/
        
        //:-----------------:Get_Variables_Ready_To_Work_With://
        //:Calculate:2D_XY_LOCATIONS:------------------------://
        #define AST_CTO_DIA  aac2020_paint5d_astipix_CTO_diagpix

            //:CALC_AND_REBASE_LOCAL:til_qua:----------------://
            //:                      o_x_qua                 ://
            //:                      o_y_qua                 ://

                /** @CALC@ **/
                o_x_qua = ( i16_gtx / 256 );
                o_y_qua = ( i16_gty / 256 ); //:<<<<<<<<<<<<<<<<<<<<< o_x , o_y change to c_x , c_y for "cell" instead of offset.

                /** @REBASE_LOCAL@ **/
                rem_i_x = i16_gtx - ( o_x_qua * 256 );
                rem_i_y = i16_gty - ( o_y_qua * 256 );

                assert( rem_i_x >=   0 );
                assert( rem_i_y >=   0 );
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );

                /** **************************************** ***

                [ rem_i_x , rem_i_y ] is now LOCAL to
                #_DIA_SELECTED_TIL_QUA_#
                @VID_IID[ 0068 ]TIME[ 2H 32M 10S ]

                [ rem_i_x , rem_i_y ] == ( astipix )
                At this PLACE in the code.
                @VID_IID[ 0068 ]TIME[ 2H 40M 00S ]

                *** **************************************** **/

            //:                                       o_x_qua://
            //:                                       o_y_qua://
            //:----------------:CALC_AND_REBASE_LOCAL:til_qua://
            //:CALC_AND_REBASE_LOCAL:til_exp:----------------://
            //:                  i16_til_exp                 ://

                /** astipix : Auset_Sub_TIle:PIXel(loc:[X|Y])**/
                /** diagpix : DIAGonal_PIXels ...............**/

                diagp_x = AST_CTO_DIA( rem_i_x ); //:diagpix.x
                diagp_y = AST_CTO_DIA( rem_i_y ); //:diagpix.y
                diagpix = MIN( diagp_x , diagp_y );

                /** @CALC@ **/
                                        i16_til_exp=((U16)(
                aac2020_paint5d_diagpix_CTO_til_exp(
                        (  (U08)diagpix  )        
                )));;

                /** @REBASE_LOCAL@ **/
                rem_i_x =( rem_i_x - diagpix );
                rem_i_y =( rem_i_y - diagpix );

            //:                                   i16_til_exp://
            //:----------------:CALC_AND_REBASE_LOCAL:til_exp://
            //:CALC_AND_REBASE_LOCAL:til_lay:----------------://

                //:  @VID_IID[ 0072 ]TIME[ 01H 00M 15S ]     ://
                //:  1D: [      til_lay      ]   ............://
                //:  2D: [ o_x_lay , o_y_lay ]   ............://

                bip_sip =( 
                    aac2020_paint5d_til_exp_CTO_bip_sip(
                                i16_til_exp             ));;
                
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );
                
                /** @CALC@ **/
                o_x_lay =( rem_i_x / bip_sip );
                o_y_lay =( rem_i_y / bip_sip );
                
                assert( o_x_lay >= 0 && o_x_lay <= 1 );
                assert( o_y_lay >= 0 && o_y_lay <= 1 );
                
                if( 1
                &&  1 == o_x_lay
                &&  1 == o_y_lay
                ){
                    ERR("[DIAGONAL_QUAD_IS_FOR_NESTING]");
                };;

                /** @REBASE_LOCAL@ **/
                rem_i_x = ( rem_i_x - ( o_x_lay * bip_sip ) );
                rem_i_y = ( rem_i_y - ( o_y_lay * bip_sip ) );

            //:----------------:CALC_AND_REBASE_LOCAL:til_lay://
            //:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]:------://

                max_cor =(
                    aac2020_paint5d_til_exp_CTO_max_cor(
                        (  (U08)i16_til_exp  )          ));;
                
                assert( rem_i_x >= 0 );
                assert( rem_i_y >= 0 );
                assert( rem_i_x <= max_cor );
                assert( rem_i_y <= max_cor );

                i16_loc_t_x = ( rem_i_x );
                i16_loc_t_y = ( rem_i_y );

            //:------:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]://

        #undef  AST_CTO_DIA
        //:------------------------:Calculate:2D_XY_LOCATIONS://
        //:Calculate:1D_INDEX_LOCATIONS:---------------------://
        #define TIL_QUA_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/
        #define TIL_LAY_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 00H 08M 40S ] 
                SAN == SPAN , means WID == HIG
                Use this variable to preserve the
                balance of tokens in our code.
            *** ******************************************** **/
        
            i16_til_qua = o_x_qua + ( TIL_QUA_SAN * o_y_qua);
        //: i16_til_exp =( ALREADY_CALCULATED_MY_FRIEND     );
            i16_til_lay = o_x_lay + ( TIL_LAY_SAN * o_y_lay);
        //: i16_loc_t_x =( ALREADY_CALCULATED_MY_FRIEND     );
        //: i16_loc_t_y =( ALREADY_CALCULATED_MY_FRIEND     );

        #undef  TIL_QUA_SAN  
        #undef  TIL_LAY_SAN  
        //:---------------------:Calculate:1D_INDEX_LOCATIONS://
        //:RETURN_VIA_OUTPUT_PARAMETERS:---------------------://

            assert(             i16_til_qua >=   0 ); //: 01 ://
            assert(             i16_til_exp >=   0 ); //: 02 ://
            assert(             i16_til_lay >=   0 ); //: 03 ://
            assert(             i16_loc_t_x >=   0 ); //: 04 ://
            assert(             i16_loc_t_y >=   0 ); //: 05 ://

            assert(             i16_til_qua <= 255 ); //: 01 ://
            assert(             i16_til_exp <= 255 ); //: 02 ://
            assert(             i16_til_lay <= 255 ); //: 03 ://
            assert(             i16_loc_t_x <= 255 ); //: 04 ://
            assert(             i16_loc_t_y <= 255 ); //: 05 ://

            (*til_qua)=(  (U08) i16_til_qua        ); //: 01 ://
            (*til_exp)=(  (U08) i16_til_exp        ); //: 02 ://
            (*til_lay)=(  (U08) i16_til_lay        ); //: 03 ://
            (*loc_t_x)=(  (U08) i16_loc_t_x        ); //: 04 ://
            (*loc_t_y)=(  (U08) i16_loc_t_y        ); //: 05 ://

        //:---------------------:RETURN_VIA_OUTPUT_PARAMETERS://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_painpix_CTO_glocpix(
        U08        til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08        til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08        til_lay /** TileLayer .................   **/
    ,   U08        loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08        loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16*  RES  glo_t_x /** Global Tile X Coord           **/
    ,   I16*  RES  glo_t_y /** Global Tile X Coord           **/
    )
    {
        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != glo_t_x );
            assert( ((void*)0) != glo_t_y );

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://

            assert( AAC2020_PAINT5D_MAX_til_qua ==    3    );
            assert( AAC2020_PAINT5D_MAX_til_exp ==    7    );
            assert( AAC2020_PAINT5D_MAX_til_lay ==    2    );

            assert( AAC2020_PAINT5D_MAX_til_qua >= til_qua );
            assert( AAC2020_PAINT5D_MAX_til_exp >= til_exp );
            assert( AAC2020_PAINT5D_MAX_til_lay >= til_lay );

            U08  /* max_cor */                max_cor =(
                ( aac2020_paint5d_til_exp_CTO_max_cor( 
                                  til_exp )));;

            assert( max_cor >=        loc_t_x          );
            assert( max_cor >=        loc_t_y          );
            assert(    0    <= (((I16)loc_t_x)+0)      );
            assert(    0    <= (((I16)loc_t_y)+0)      );

        //:------------------------------:bounds_check_inputs://
        //:declare_all_variables:----------------------------://

            I16 tempi_x =( 0 - 1001 ); /** temp_integer: x   **/
            I16 tempi_y =( 0 - 1001 ); /** temp_integer: y   **/

            I16 o_x_qua =( 0 - 2002 ); /** til_qua.x **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua.y **/

            I16 diagpix =( 0 - 3003 );

            I16 o_x_lay =( 0 - 4004 ); /** til_lay.x **/
            I16 o_y_lay =( 0 - 4004 ); /** til_lay.y **/

            I16 i16_gtx =( 0 - 5005 ); /** glo_t_x  AS  I16 **/
            I16 i16_gty =( 0 - 5005 ); /** glo_t_y  AS  I16 **/

            /** @VID_IID[ 0067 ]TIME[ 4H 25M 20S ]       **/
            /** I16 is         ENOUGH addressing space.  **/
            /** U08 is __NOT__ ENOUGH addressing space.  **/
    
        //:----------------------------:declare_all_variables://
        //:CALCULATE:painpix_CTO_glocpix:--------------------://

            tempi_x =  til_qua         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_qua-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_qua = ( tempi_x * 256 ); /** offset_x_QUA **/
            o_y_qua = ( tempi_y * 256 ); /** offset_y_QUA **/
            
            /** diagpix: DIAgonal_PIXels (offset) **/
            diagpix =(I16)( aac2020_paint5d_til_exp_CTO_diagpix( 
                                            til_exp ) );;

            tempi_x =  til_lay         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_lay-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_lay = ( tempi_x * ( max_cor + 1 ) );
            o_y_lay = ( tempi_y * ( max_cor + 1 ) );

                //:error_check_range_of_temp:----------------://
                assert( tempi_x >= 0 && tempi_x <= 1 );
                assert( tempi_y >= 0 && tempi_y <= 1 );
                if( 1
                &&  1 == tempi_x
                &&  1 == tempi_y
                ){
                    ERR("[BOTH_CELL_COORDS_CANNOT_BE_ONE]");
                };;
                //:----------------:error_check_range_of_temp://

            i16_gtx=( o_x_qua + diagpix + o_x_lay + loc_t_x );
            i16_gty=( o_y_qua + diagpix + o_y_lay + loc_t_y );
            assert( i16_gtx >= 0 && i16_gtx <= ( 512 - 1 ) );
            assert( i16_gty >= 0 && i16_gty <= ( 512 - 1 ) );
            (*glo_t_x)=(  (U16)( i16_gtx )  );
            (*glo_t_y)=(  (U16)( i16_gty )  );

        //:--------------------:CALCULATE:painpix_CTO_glocpix://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  U16                                           //: 02 ://
#undef  I16                                           //: 03 ://
#undef  RES                                           //: 04 ://
#undef  MIN                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:===============================:QUARKMAP_COORD_CONVERSIONS://
//:PAINT5D_QUARKMAP_GET_PUT:=================================://
//:PAINT5D_QUARKMAP_PUT_GET:=================================://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 01 ://
#define I16 int16_t /** GCC: <stdint.h> **/           //: 02 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 03 ://
#define ERR aac2020_paint5d_Halt                      //: 04 ://

    /** #_WHAT_IS_THE_QUARKMAP_# * * * * *  **/
    /** @VID_IID[ 0067 ]TIME[ 00H 52M 23S ] **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    AAC2020_PAINT5D_Put(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08  til_val   /** [ val_cur / til_val ]          ...**/
    )
    {
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            /** @VID_IID[ 0072 ]TIME[ 03H 07M 30S ]    ......**/
            /** til_val commentary is the decimal and  ......**/
            /** binary representations of it's values. ......**/

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );
            assert( til_val <=   3 );/**[  0 |  1 |  2 |  3 ]**/
                                     /**[ 00 | 01 | 10 | 11 ]**/

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );
            I16 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I16 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
            I16 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
            U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
            U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
                arr_dex =(         glo_com + 3 );
                var_u08 = CPU_PIX[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
                arr_dex =(         glo_com + 2 );
                var_u08 = CPU_PIX[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
                arr_dex =(         glo_com + 1 );
                var_u08 = CPU_PIX[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

                arr_dex =(         glo_com + 0 );
                var_u08 = CPU_PIX[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:PUT]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 3H 38M 10S ]BEG
                @VID_IID[ 0072 ]TIME[ 3H 46M 09S ]END
    
                Bit packing logic to ONLY CHANGE the bits
                where the new value needs to be stored.
                We need to erase the bits in the proper
                position by masking ( & ). Then merge the bits
                together by using a bitwise or. ( | )

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );
    
            CPU_PIX[ arr_dex ]=(

                /**  11001111 <-- Conceptually:if:aus_loc==2**/
                ( var_u08 &  (~(  BIN_011 << ( aus_loc*2 ) )) )

                |  //:<-- Bitwise Or to merge together

                /**  00110000 <-- Conceptually:if:aus_loc==2**/
                /** Slide Delta Bits Into Position **/
                ( til_val                 << ( aus_loc*2 )    )

            );;

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://

        /** If the tile value we set down was different than **/
        /** It was previously, maybe we should return        **/
        /** a ONE( 1 ) to signify that.                      **/
        return( til_val != old_val );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Get(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08* til_val   /** [ val_cur / til_val ]          ...**/
    )
    {
        /** ************************************************ **/
        /** NOTE: This code is almost a cut+paste of         **/
        /**       the "Put" code. The "old_val" variable     **/
        /**       from the "Put" code is what we want        **/
        /**       to return from this function via           **/
        /**       an OUTPUT PARAMETER.                       **/
        /** ************************************************ **/
        //:references_are_never_null:------------------------://

            assert( ((void*)0) != til_val );

        //:------------------------:references_are_never_null://
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );
            I16 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I16 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I16 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
            U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
            U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
        ////    arr_dex =(         glo_com + 3 );
                var_u08 = CPU_PIX[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
        ////    arr_dex =(         glo_com + 2 );
                var_u08 = CPU_PIX[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
        ////    arr_dex =(         glo_com + 1 );
                var_u08 = CPU_PIX[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

        ////    arr_dex =(         glo_com + 0 );
                var_u08 = CPU_PIX[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:GET]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 4H 08M 50S ]
                We can nuke most of the bit shifting
                code copied from the "Put(..)" function
                and just keep the fetch of "old_val".
                "old_val" is the value we want to load
                into the output parameter "til_val".

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://
        //:return_via_output_param:--------------------------://

            /** ******************************************** ***
            til_val | old_val : DECIMAL [  0 |  1 |  2 |  3 ]   
            til_val | old_val : BINARY  [ 00 | 01 | 10 | 11 ]   
            *** ******************************************** **/

            (*til_val)=( old_val );

        //:--------------------------:return_via_output_param://
        
        return; //:<---- Return Via Output Param
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  I16                                           //: 02 ://
#undef  I32                                           //: 03 ://
#undef  ERR                                           //: 04 ://
//:=================================:PAINT5D_QUARKMAP_GET_PUT://
//:=================================:PAINT5D_QUARKMAP_PUT_GET://
//:TAU:UNIFORM_CONTROLLER_FUNCTIONS:=========================://
#define CAP aac2020_paint5d_i32_Cap_u32 /** Cap as in CLAMP **/
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U16 uint16_t /** GCC: <stdint.h> **/

    void
    aac2020_paint5d_MoveCamera_XY(
        I32 tra_i_x  //: Amount to translate in pixels: X-axis
    ,   I32 tra_i_y  //: Amount to translate in pixels: Y-axis
    )
    {
        AAC2020_TAUTYPE_rec_inc_Tran(
            AAC2020_TAUDEPO.TAU_015  /** TAU Block Index     **/
        ,   AAC2020_TAUDEPO.PAINT5D  /** SubSystem ==PAINT5D **/
        ,   AAC2020_TAUDEPO.P5D_VP1  /** VP1: Viewport #1    **/
        ,   tra_i_x  /** TRAnslation_Integer_amount_X        **/
        ,   tra_i_y  /** TRAnslation_Integer_amount_Y        **/
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ZoomCamera(
        I32 zom_i32 //: Amount To Zoom In And Out In Pixels
    )
    {
        AAC2020_TAUTYPE_rec_inc_ZoomPull(
            AAC2020_TAUDEPO.TAU_015  
        ,   AAC2020_TAUDEPO.PAINT5D  
        ,   AAC2020_TAUDEPO.P5D_VP1  
        ,   zom_i32  
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_MoveBrush_XY(
        I32 o_x //: offset:X
    ,   I32 o_y //: offset:Y
    )
    {
        U32 b_x =( 0x00 );
        U32 b_y =( 0x00 );
        U32 u_1 ; //:Unused #1
        U32 u_2 ; //:Unused #2
        U32 u_3 ; //:Unused #3

        /** @VID_IID[ 0066 ]TIME[ 03H 59M 25S ]    **/
        /** #_TILE_SIZE_AFFECTS_CAMERA_POSITION_#  **/

        //:brush_coords:READ:--------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

        //:--------------------------------:brush_coords:READ://
        //:brush_coords:TRANSFORM:---------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0066 ]TIME[ 4H 56M 23S ]           **/
            /** The SMALLEST tile value results in a level   **/
            /** map size that is 256x256 tiles.              **/
            /**                                              **/
            /** This is because HALF of 512 is 256.          **/
            /** And we pack our tilemap data in a            **/
            /** mip-map like geometrical packing pattern.    **/
            /**                                              **/
            /** Been referring to that data structure as     **/
            /** a "QUARKMAP" / "QUARK_MAP"                   **/
            /** ******************************************** **/

            /** #_TILE_EXPONENT_AFFECTS_CAMERA_POSITION_#    **/

            U32 til_exp=( 0xFFFFFFFF ); /** TILE_EXPONENT    **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR == til_exp
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

            U16 m_c; /** m_c : Max_Coordinate ( x | y ) **/
            assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
            assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
            m_c = aac2020_paint5d_til_exp_CTO_max_cor(til_exp);

            b_x = CAP( ((I32)b_x) + o_x , (U16)0 , (U16)m_c );
            b_y = CAP( ((I32)b_y) + o_y , (U16)0 , (U16)m_c );

        //:---------------------------:brush_coords:TRANSFORM://
        //:brush_coords:WRITE:-------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X     //:DEX_VAR
            ,   (b_x), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y     //:DEX_VAR
            ,   (b_y), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

        //:-------------------------------:brush_coords:WRITE://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileValue( 
        I32 del_t_v /** Delta: TileValue( t_v ) **/
    )
    {
        /** @VID_IID[ 0066 ]TIME[ 05H 34M 55S ] **/
        /** #_MORE_NAMES_MORE_PROBLEMS_# ...... **/

        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            til_val =CAP( 
                (I32)til_val + del_t_v 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileExponent( 
        I32 del_t_e /** Delta: TileExponent( t_e ) **/
    )
    {
        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            til_val =CAP( 
                (I32)til_val + del_t_e 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileLayer( 
        I32 del_t_l /** DELta_Tile_Layer **/
    )
    {
        U32 til_lay; /** [ TileLayer / Tile_Layer / til_lay ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,  &(til_lay),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://
 
            til_lay =CAP( 
                (I32)til_lay + del_t_l 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 2 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,   (til_lay), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ToggleTile( void )
    {
        //:variable_declarations:----------------------------://

            I32 t_x = ( 0 -   7770777 ); /** t_x : tile_x  **/
            I32 t_y = ( 0 -   8880888 ); /** t_y : tile_y  **/

            U32 b_x = ( 0 + 123000123 ); /** b_x : brush_x **/
            U32 b_y = ( 0 + 123000123 ); /** b_y : brush_y **/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 04H 23M 45S ]

                val_bru :
                    Current[ til_val ]loaded into Josh's
                    tile brush. This is what he is 
                    currently painting with.

                val_cur :
                    Current[ til_val ]found on the canvas
                    that Josh is painting on. More precisely
                    a[ til_val ]encoded into a section
                    of a BYTE of an RGBA pixel stored in
                    a cpu side bitmap known as:

                    AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/
                    
            U32 val_bru =( 4433 ) ;  
            U32 val_cur =( 3344 ) ;  

            U32 u_1 ; //: unused_number_001 ://
            U32 u_2 ; //: unused_number_002 ://
            U32 u_3 ; //: unused_number_003 ://
        
        //:----------------------------:variable_declarations://
        //:GET_STATE:OF_BRUSH:-------------------------------://
        /** ************************************************ ***
        Variables we need from this section:
        1:  val_bru 
        2:  til_exp
        3:  til_lay
        4:  loc_t_x
        5:  loc_t_y
        *** ************************************************ **/

            //:GET_STATE:val_bru:----------------------------://

                //: get_tile_value_loaded_into_brush ://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_V //:[ TIL_VAL ]
                ,  &(val_bru),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:val_bru://
            //:GET_STATE:til_exp:----------------------------://

                #error "[GET_STATE:til_exp]"

            //:----------------------------:GET_STATE:til_exp://
            //:GET_STATE:til_lay:----------------------------://

                #error "[GET_STATE:til_lay]"

            //:----------------------------:GET_STATE:til_lay://
            //:GET_STATE:loc_t_x:----------------------------://

                #error "[GET_STATE:loc_t_x]"

            //:----------------------------:GET_STATE:loc_t_x://
            //:GET_STATE:loc_t_y:----------------------------://

                #error "[GET_STATE:loc_t_y]"

            //:----------------------------:GET_STATE:loc_t_y://

        //:-------------------------------:GET_STATE:OF_BRUSH://
        //:get_current_value_on_tile_map:--------------------://
    
            /** ******************************************** **/
            /**   @VID_IID[ 0066 ]TIME[ 07H 27M 23S ]        **/
            /**   @_CTRL_F_HELP_@                            **/
            /**   WRONG[ AAC2020_PAINT5D_TileValue_GET ]     **/
            /**   WRONG[ AAC2020_PAINT5D_GetTileValue  ]     **/
            /** CORRECT[ AAC2020_PAINT5D_Get           ]     **/
            /** ******************************************** **/
    
            /** @VID_IID[ 0066 ]TIME[ 08H 14M 15S ] ******* **/
            /** #_WHY_PAINT5D_GET_PARAM_ORDER_# **/
            AAC2020_PAINT5D_Get(
                til_exp   /** TileExponent (TileSizeEnum) **/
            ,   til_lay   /** TileLayer ................. **/
            ,   loc_t_x   /** Local Tile X Coord / b_x    **/
            ,   loc_t_y   /** Local Tile Y Coord / b_y    **/
            ,&( val_cur ) /** [ val_cur / til_val ]       **/
            );;

        //:--------------------:get_current_value_on_tile_map://
        //:brush_coords:READ:--------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

        //:--------------------------------:brush_coords:READ://
        //:SET_OR_UNSET_THE_TILE:----------------------------://

            /** ******************************************** ***
                If the value loaded into the brush is the
                same value as the value currently on the
                tilemap, we will [ UNSET / ERASE ]the tile.

                If the tile values DO NOT MATCH, then
                we will [ SET / OVERWRITE ] the tile.
            *** ******************************************** **/

            #error SET_OR_UNSET_THE_TILE

        //:----------------------------:SET_OR_UNSET_THE_TILE://

        return;
    }

#undef  CAP
#undef  I32
#undef  U32
#undef  U16
//:=========================:TAU:UNIFORM_CONTROLLER_FUNCTIONS://
//:KEYBOARD_HANDLER:(KeyInn):================================://
#define I32 int32_t /** GCC: <stdint.h> **/
#define DEX_EDI_paint5d ( 1 )
#define KEY_P5D ( AAC2020_KEYBIND.PAINT5D )
    
    I32
    aac2020_paint5d_KeyInn( signed char chr_key )
    {
        I32 res_var =( 0 );

        //:CAMERA_CONTROL:-----------------------------------://

            //:MoveCamera_XY:--------------------------------://
            /** ******************************************** ***

                #_CTRL_F_HELP_#

                p5d_cam_lef ===> p5d_vp1_lef  
                p5d_cam_rig ===> p5d_vp1_rig  
                p5d_cam_upp ===> p5d_vp1_upp  
                p5d_cam_dow ===> p5d_vp1_dow  
                                              
                p5d_cam_z_o ===> p5d_vp1_z_o  
                p5d_cam_z_i ===> p5d_vp1_z_i  

            *** ******************************************** **/

            if( chr_key == KEY_P5D.p5d_vp1_lef ){
                aac2020_paint5d_MoveCamera_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_rig ){
                aac2020_paint5d_MoveCamera_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_upp ){
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_dow ){         
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 + 1 );
            };;

            //:--------------------------------:MoveCamera_XY://
            //:ZoomCamera:-----------------------------------://

            if( chr_key == KEY_P5D.p5d_vp1_z_o ){
                aac2020_paint5d_ZoomCamera( 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_z_i ){         
                aac2020_paint5d_ZoomCamera( 0 + 1 );
            };;

            //:-----------------------------------:ZoomCamera://

        //:-----------------------------------:CAMERA_CONTROL://
        //:MOVE_BRUSH:---------------------------------------://

            if( chr_key == KEY_P5D.p5d_bru_lef ){
                aac2020_paint5d_MoveBrush_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_rig ){
                aac2020_paint5d_MoveBrush_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_upp ){
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_bru_dow ){         
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 + 1 );
            };;

        //:---------------------------------------:MOVE_BRUSH://
        //:TILE_VALUE(T_V):----------------------------------://
        
            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_V  +//

            /** @VID_IID[ 0066 ]TIME[ 03H 40M 05S ] **/
            /** WHY CALLED: TileValueDeltaMutate    **/

            if( chr_key == KEY_P5D.p5d_v_n ){ //:n:NEXT
                /** HERE[ Bak_Til | PrevTile | PreviousTile ]**/
                aac2020_paint5d_DeltaMutate_TileValue( 0 + 1 );
            }else
            if( chr_key == KEY_P5D.p5d_v_b ){ //:b:BACK
                /** HERE[ Nex_Til() | NextTile(...) ] **/
                aac2020_paint5d_DeltaMutate_TileValue( 0 - 1 );
            };;

        //:----------------------------------:TILE_VALUE(T_V)://
        //:TILE_EXPONENT(T_E):-------------------------------://

            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_E  +//

            if( chr_key == KEY_P5D.p5d_e_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileExponent(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_e_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileExponent(0 -1);
            };;

        //:-------------------------------:TILE_EXPONENT(T_E)://
        //:TILE_LAYER_0_TO_2(T_L):---------------------------://

            if( chr_key == KEY_P5D.p5d_l_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileLayer(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_l_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileLayer(0 -1);
            };;


        //:---------------------------:TILE_LAYER_0_TO_2(T_L)://
        //:TILE_TOGGLE:--------------------------------------://

            if( chr_key == KEY_P5D.p5d_tog ){ //:toggle
                aac2020_paint5d_ToggleTile( );
            };;

        //:--------------------------------------:TILE_TOGGLE://

        return( res_var );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32
    PAINT5D_KeyInn( signed char chr_key )
    {
        I32 res_var=( 0 );

        /** @VID_IID[ 0066 ]TIME[ 0H 19M 48S ] ............. **/
        /** PAINT5D is ALWAYS sub-system #1 which            **/
        /** Is assigned to the number 1, both in code        **/
        /** and in the key on the numpad it corresponds to   **/
        assert( DEX_EDI_paint5d == AAC2020_CEDITOR_paint5d );;
        if(     DEX_EDI_paint5d == AAC2020_CEDITOR_dex_edi ){

            res_var = aac2020_paint5d_KeyInn( chr_key );

        };;
    
        /** @IMPLICIT_INTERFACE[ KeyInn ] ****************** **/
        /** @VID_IID[ 0066 ]TIME[ 0H 30M 30S ] ..............**/
        /** Don't have a use for return code yet.    ........**/
        /** but we should be consistent with all of  ........**/
        /** our different keyboard handlers.         ........**/
        /** ************************************************ **/
        return( res_var );
    }

#undef  DEX_EDI_paint5d
#undef  I32
#undef  KEY_P5D
//:================================:KEYBOARD_HANDLER:(KeyInn)://
//:UNIT_TEST:================================================://
#define MAX_EXP AAC2020_PAINT5D_MAX_til_exp           //: 01 ://
#define EXT      extern                               //: 02 ://
#define VOD        void                               //: 03 ://
#define I08      int8_t /** GCC: <stdint.h> **/       //: 04 ://
#define U08     uint8_t /** GCC: <stdint.h> **/       //: 05 ://
#define I16     int16_t /** GCC: <stdint.h> **/       //: 06 ://
#define U16    uint16_t /** GCC: <stdint.h> **/       //: 07 ://
#define I32     int32_t /** GCC: <stdint.h> **/       //: 08 ://
#define U32    uint32_t /** GCC: <stdint.h> **/       //: 09 ://
#define ERR     aac2020_paint5d_Halt                  //: 10 ://

    U32
    aac2020_paint5d_UnitTest( U32 u32 )
    {
        if( u32 ){  /** Reserved For Future Use **/  };

        /** ************************************************ ***
            ProgControls: 
                Progmattic functions that the end user does
                not directly interface with.
            
            UserControls:
                Functions that are directly or near
                directly called as the result of 
                user input such as key presses.
    
                For example( S ):
                    aac2020_paint5d_ToggleTile
                    aac2020_paint5d_MoveBrush_XY
        *** ************************************************ **/
        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/
            
            AAC2020_PIXBACK_Backup_taudirt( &(taudirt) );
            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://

            EXT VOD 
            aac2020_paint5d_UnitTest_ProgControls( VOD );
            aac2020_paint5d_UnitTest_ProgControls(     );

            EXT VOD 
            aac2020_paint5d_UnitTest_UserControls( VOD );
            aac2020_paint5d_UnitTest_UserControls(     );

        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                AAC2020_PIXBACK_Restore_taudirt( &(taudirt) );
                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://
        //:------------------------------:SYSTEM_DATA:RESTORE://
    }
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:         UNIT_TEST : USERCONTROLS : BELOW             ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UnitTest_ProgControls( void )
        {

            EXT VOD 
            aac2020_paint5d_UTC_MoveCamera_XY( VOD );
            aac2020_paint5d_UTC_MoveCamera_XY(     );

            EXT VOD 
            aac2020_paint5d_UTC_ZoomCamera( VOD );
            aac2020_paint5d_UTC_ZoomCamera(     );

            EXT VOD 
            aac2020_paint5d_UTC_MoveBrush_XY( VOD );
            aac2020_paint5d_UTC_MoveBrush_XY(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileValue( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileValue(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileExponent( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileExponent(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileLayer( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileLayer(     );

            EXT VOD 
            aac2020_paint5d_UTC_ToggleTile( VOD );
            aac2020_paint5d_UTC_ToggleTile(     );
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveCamera_XY( void )
        {

            #error "[TODO_FINISH_TEST:MoveCamera_XY]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ZoomCamera( void )
        {

            #error "[TODO_FINISH_TEST:ZoomCamera]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveBrush_XY( void )
        {

            #error "[TODO_FINISH_TEST:MoveBrush_XY]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileValue( void )
        {

            #error "[TODO_FINISH_TEST:DeltaMutate_TileValue]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileExponent( void )
        {

            #error "[TODO_FINISH_TEST:DeltaMutate_TileExponent]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileLayer( void )
        {

            #error "[TODO_FINISH_TEST:DeltaMutate_TileLayer]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ToggleTile( void )
        {

            #error "[TODO_FINISH_TEST:ToggleTile]"
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:         UNIT_TEST : USERCONTROLS : ABOVE             ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:         UNIT_TEST : PROGCONTROLS : BELOW             ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_UnitTest_ProgControls( void )
    {
        //:helper_functions:generic:- - - - - - - - - - - - -://

        EXT VOD aac2020_paint5d_UTC_Min_I16( VOD );
                aac2020_paint5d_UTC_Min_I16(     );

        EXT VOD aac2020_paint5d_UTC_i32_Cap_u32( VOD );
                aac2020_paint5d_UTC_i32_Cap_u32(     );

        //:- - - - - - - - - - - - -:helper_functions:generic://
        //:helper_functions::conversion:- - - - - - - - - - -://
 
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_bip_sip( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_bip_sip(     );

        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_max_cor( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_max_cor(     );

        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_diagpix(     );

        EXT VOD aac2020_paint5d_UTC_diagpix_CTO_til_exp( VOD );
                aac2020_paint5d_UTC_diagpix_CTO_til_exp(     );

        /**@DNE aac2020_paint5d_UTC_diagpix_CTO_astipix @DNE **/

        EXT VOD aac2020_paint5d_UTC_astipix_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_astipix_CTO_diagpix(     );

        //:- - - - - - - - - - -:helper_functions::conversion://
        //:paired_unit_tests::- - - - - - - - - - - - - - - -://

        EXT VOD aac2020_paint5d_UTC_glocpix_CTO_painpix( VOD );
                aac2020_paint5d_UTC_glocpix_CTO_painpix(     );

        EXT VOD aac2020_paint5d_UTC_painpix_CTO_glocpix( VOD );
                aac2020_paint5d_UTC_painpix_CTO_glocpix(     );

        //:- - - - - - - - - - - - - - - -:paired_unit_tests:://
        //:main_get_put_tests::- - - - - - - - - - - - - - -:://

            EXT VOD aac2020_paint5d_UTC_Put( VOD );
                    aac2020_paint5d_UTC_Put(     );

            EXT VOD aac2020_paint5d_UTC_Get( VOD );
                    aac2020_paint5d_UTC_Get(     );

            /** ******************************************** ***
                @DEP[ aac2020_paint5d_UTC_Get ]               
                @DEP[ aac2020_paint5d_UTC_Put ]               
                @DEP[ aac2020_paint5d_UTC_glocpix_CTO_painpix ]  
            
                @VID_IID[ 0071 ]TIME[ 00H 12M 52S ]  
            *** ******************************************** **/

            EXT VOD aac2020_paint5d_UTC_Put_Get( VOD );
                    aac2020_paint5d_UTC_Put_Get(     );

            /** ******************************************** **/

        //:- - - - - - - - - - - - - - -::main_get_put_tests:://
        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:MAIN_GET_PUT_TESTS:-----------------------------------://
    #define NUM_TEST_CASES_put (  8  )                  //:01://
    #define NUM_TEST_COLMS_put (  7  ) /**COLUMNS**/    //:02://
    #define NUM_TEST_CASES_get (  8  )                  //:03://
    #define NUM_TEST_COLMS_get (  7  ) /**COLUMNS**/    //:04://

        void aac2020_paint5d_UTC_Put( void )
        {

            #error MUST_BACKUP_DATA_FOR_TESTS
            #error MUST_USE: PIXBACK backup and restore

            /** @VID_IID[ 0070 ]TIME[ 1H 9M 50S ] .......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  p_g ; /** Put( 0 ) or Get( 1 ) Loop. .......**/
            I32  t_i ; /** Test_row_Index             .......**/
            I32  bas ; /** BASe_offset_of_test_data   .......**/
            I32  m_i =( NUM_TEST_CASES_put - 1);

            /* Input VALUES:@VID_IID[ 0071 ]T[ 1H 57M 17S ] */
            U08     til_qua ;   //:--------------------------://
            U08     til_exp ;   //:                          ://
            U08     til_lay ;   //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08     loc_t_x ;   //:                          ://
            U08     loc_t_y ;   //:--------------------------://
                                //:--------------------------://
            U08     aus_dex ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
            U08 put_til_val ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
                                //:--------------------------://

            /** Output Value:@VID_IID[ 0071 ]T[ 1H 57M 17S ] **/

            U08 got_til_val ;

            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 NUM_TEST_CASES_put
                            *
                 NUM_TEST_COLMS_put
            ]={
            /**8 smoke tests. @VID_IID[ 0071 ]T[ 1H 40M 20S ]**/
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   aus_   _val
/*  00  01  */  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
/*  01  02  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    0
/*  02  03  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    0
/*  03  04  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    0
/*  04  05  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    3
/*  05  06  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    3
/*  06  07  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    3  
/*  07  08  */,    1 ,    1 ,    1 ,    1 ,    1 ,    1 ,    1
/// --  --    : _qua   _exp   _lay   loc_   loc_   aus_   _val
/// --  --    : 0001   0002   0003   0004   0005   0006   0007

                /** TODO: More tests **/
            };;
            AAC2020_TODOMAN_Vital("[MORE_TESTS!!!!2021]");

            for( p_g = 0 ; p_g <=( 1 ); p_g ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * NUM_TEST_COLMS_put );

                /** Setting @TRAP_VALUES               * * * **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 53S ] * * * **/

                til_qua=( 101 );  /** @TRAP_VALUES@ **/
                til_exp=( 102 );  /** @TRAP_VALUES@ **/
                til_lay=( 103 );  /** @TRAP_VALUES@ **/
                loc_t_x=( 104 );  /** @TRAP_VALUES@ **/
                loc_t_y=( 105 );  /** @TRAP_VALUES@ **/
                aus_dex=( 106 );  /** @TRAP_VALUES@ **/
            put_til_val=( 107 );  /** @TRAP_VALUES@ **/

                /** Extracted Values For The Current Test    **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 24S ] * * * **/

                til_qua=(         (U08)tab_utc[ bas + 0 ] );
                til_exp=(         (U08)tab_utc[ bas + 1 ] );
                til_lay=(         (U08)tab_utc[ bas + 2 ] );
                loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                aus_dex=(         (U08)tab_utc[ bas + 5 ] );
            put_til_val=(         (U08)tab_utc[ bas + 6 ] );

                /** Integer Overflow Dectection.             **/
                /** @VID_IID[ 0071 ]TIME[ 1H 46M 08S ]       **/
                assert(((I16)til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)aus_dex)==tab_utc[ bas + 5 ] );
                assert(((I16)til_val)==tab_utc[ bas + 6 ] );

                //:all_puts_before_all_gets:-----------------://
                //:                                          ://
                //: @VID_IID[ 0071 ]TIME[ 02H 03M 44S ]      ://
                //: We do all of the AAC2020_PAINT5D_Put(..) ://
                //: calls BEFORE all of the                  ://
                //: AAC2020_PAINT5D_Get(...) calls in case   ://
                //: we have overlapping [ memory / pixel ]   ://
                //: locations where the data is being stored.://
                //:                                          ://
                //: If we do interlaced                      ://
                //:"get(..) then put(..)" calls, we may      ://
                //: end up with a "FALSE UNIT TEST PASS"     ://
                //:                                          ://
                //:all_puts_before_all_gets:- - - - - - - - -://

                if( 0 == p_g ){
                AAC2020_PAINT5D_Put(
                        til_qua    /* AusetTile SubQuad Index */
                ,       til_exp    /* TileExponent            */
                ,       til_lay    /* TileLayer ..............*/
                ,       loc_t_x    /* LocalTile X Coord / b_x */
                ,       loc_t_y    /* LocalTile Y Coord / b_y */
                ,       aus_dex    /* AUSet_inDEX             */
                ,   put_til_val    /* [ val_cur / til_val ]   */
                );; };;

                if( 1 == p_g ){
                AAC2020_PAINT5D_Get(
                        til_qua    /** Same exact variables  **/
                ,       til_exp    /** as "Put(..)" function **/
                ,       til_lay    /** but last parameter is **/
                ,       loc_t_x    /** an OUTPUT parameter.  **/
                ,       loc_t_y    /** @VID_IID[ 0071 ]      **/
                ,       aus_dex    /** @TIME[ 2H 00M 50S ]   **/
                ,&( got_til_val )  
                );; };;

                assert( ( 1 == p_g ) || ( 0 == p_g ) );
 
                //:-----------------:all_puts_before_all_gets://

    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_720PM]" );

        };;};;

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get( void )
        {

            U08     t_i; //:Test Index
            U08     bas; //:Base Offset To Test Data Points

            U08 til_qua;
            U08 til_exp;
            U08 til_lay;
            U08 loc_t_x;
            U08 loc_t_y;
            U08 aus_dex;

            U08 exp_til_val; //:EXPECTED: til_val
            U08 act_til_val; //:ACTUAL::: til_val

            //:meddling_test:001:----------------------------://
            /** @VID_IID[ 0071 ]TIME[ 2H 31M 03S ]           **/
            //:meddling_test:001::- - - - - - - - - - - - - -://

                AAC2020_PIXNAME_paint5d_cpu_pix[ 0 ]=(
                    0x11 /** RED   BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 1 ]=(
                    0x22 /** GREEN BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 2 ]=(
                    0x33 /** BLUE  BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 3 ]=(
                    0x44 /** ALPHA BITS **/
                );;
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ]
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ]
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ]
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ]

                //: @VID_IID[ 0071 ]TIME[ 2H 42M 21S ]       ://
                //: Overlay the[ aus_dex ] over the correct  ://
                //: 2-bit pattern ( til_val ) it should      ://
                //: be paired with.                          ://
                //:                            15 14 13 12   ://
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ] ://
                //:                                          ://
                //:                            11 10 09 08   ://
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ] ://
                //:                                          ://
                //:                            07 06 05 04   ://
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ] ://
                //:                                          ://
                //:                            03 02 01 00   ://
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ] ://
 
                /** Test Table #001 for meddling test #001   **/
                /** @VID_IID[ 0071 ]TIME[ 2H 59M 10S ]       **/

                U08 tab_001[ 16 * 2 ]={
                //:          aus_dex | til_val
                  /** 00 **/   0x0   ,   0x0
                , /** 01 **/     1   ,     1  /* 1 : BIN[ 01 ]*/
                , /** 02 **/     2   ,     0
                , /** 03 **/     3   ,     1
                , /** 04 **/     4   ,     3  /* 3 : BIN[ 11 ]*/
                , /** 05 **/     5   ,     0
                , /** 06 **/     6   ,     3
                , /** 07 **/     7   ,     0
                , /** 08 **/     8   ,     2 /** 2 : BIN[ 10 ]*/
                , /** 09 **/     9   ,     0
                , /** 10 **/    10   ,     2
                , /** 11 **/    11   ,     0
                , /** 12 **/    12   ,     1
                , /** 13 **/    13   ,     0
                , /** 14 **/    14   ,     1
                , /** 15 **/    15   ,     0 /** 0 : BIN[ 00 ]*/
                };;
       
                /** **************************************** ***
                    @VID_IID[ 0071 ]TIME[ 02H 55M 20S ] 
                    The first meddling test using
                    table[ tab_001 ] only looks at data
                    we set on the very first pixel.
                    
                    This is because we want to confirm
                    our [ bit shifting & bit packing ]
                    logic is correct and don't want the
                    mistake in this test to be looking
                    at the WRONG PIXEL LOCATION.

                *** **************************************** **/

                for( t_i = 0 ; t_i <= 15 ; t_i ++ ){

                        bas =( t_i * 2 );  /*2 colums per test*/
                    aus_dex = tab_001[ bas + 0 ];
                exp_til_val = tab_001[ bas + 1 ];

                    /** Might not be true for other meddling **/
                    /** tests. But true for this one.        **/
                    assert( t_i == aus_dex );

                    AAC2020_PAINT5D_Get(
                        ( til_qua = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_exp = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_lay = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_x = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_y = 0 )  //: <-- FIRST_PIXEL
                    ,   ( aus_dex     )  
                    ,  &( act_til_val )  
                    );;

                    if( exp_til_val != act_til_val ){
                        ERR("[MEDDLING_TEST_NUMBER_001]");
                    };;

                };;

            //:----------------------------:meddling_test:001://
            //:meddling_Test:002:----------------------------://

                /** **************************************** **/
                /** @VID_IID[ 0071 ]TIME[ 03H 06M 49S        **/
                /** Now that we know our bit shifting math   **/
                /** is working, test with a pixel that is    **/
                /** NOT at [ 0,0 ] on our bitmap to verify   **/
                /** physical locations of pixel data are     **/
                /** also correct.                            **/
                /** **************************************** **/

                AAC2020_TODOMAN_Vital("[TestWithAnotherPixel]");
    
            //:----------------------------:meddling_test:002://


            AAC2020_TODOMAN_Vital("[FINISH_THIS_CODE!!!!!!!]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Put_Get( void )
        {
            /** PUT & GET test for the MAIN functionality.   **/
            /** 1: AAC2020_PAINT5D_Put( ... )                **/
            /** 2: AAC2020_PAINT5D_Get( ... )                **/

            ajflsjfljasfjslfjs
            TEST ALL THE VALUES ON THE 512x512 bitmap!

            I16 p_x; /** pixel x location **/
            I16 p_y; /** pixel y location **/
            /** ******************************************** ***
                @VID_IID[ 0071 ]TIME[ 00H 07M 54S  ]
                [p_x ,p_y ] == [ glo_t_x , glo_t_y ]
                Located On: AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/
            
            U08 til_qua    ; //:-----------------------------://
            U08 til_exp    ; //:                             ://
            U08 til_lay    ; //:                             ://
            U08 loc_t_x    ; //: FOR: glocpix_CTO_painpix    ://
            U08 loc_t_y    ; //:                             ://
                             //:                             ://
            I16 glo_t_x_001; //: Expected & Actual are       ://
            I16 glo_t_y_001; //: meaningless terms for       ://
                             //: these variables.            ://
            I16 glo_t_x_002; //: @VID_IID[ 0071 ]            ://
            I16 glo_t_y_002; //: TIME[ 01H 18M 07 ]          ://
                             //:_____________________________://

            for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                glo_t_x_001 = p_x; /** Load Function Inputs **/
                glo_t_y_001 = p_y; /** Load Function Inputs **/

                aac2020_paint5d_glocpix_CTO_painpix(
                   &( til_qua     )    /// Auset Sub Quad    ///
                ,  &( til_exp     )    /// Size_Exponent     ///
                ,  &( til_lay     )    /// TileLayer ........///
                ,  &( loc_t_x     )    /// Local  Tile X     ///
                ,  &( loc_t_y     )    /// Local  Tile Y     ///
                ,   ( glo_t_x_001 )    /// Global Tile X     ///
                ,   ( glo_t_y_001 )    /// Global Tile X     ///
                );;

                aac2020_paint5d_painpix_CTO_glocpix(
                    ( til_qua )        /// Auset Sub Quad    ///
                ,   ( til_exp )        /// Size_Exponent     ///
                ,   ( til_lay )        /// TileLayer ........///
                ,   ( loc_t_x )        /// Local  Tile X     ///
                ,   ( loc_t_y )        /// Local  Tile Y     ///
                ,  &( glo_t_x_002 )    /// Global Tile X     ///
                ,  &( glo_t_y_002 )    /// Global Tile X     ///
                );;

                if( 0
                || glo_t_x_001 != glo_t_x_002
                || glo_t_y_001 != glo_t_y_002
                ){
                    ERR("[GET_PUT_TEST_FAILED:YEAR_2021]");
                };;

            };;};;
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get_Put( void )
        {
            /** ******************************************** **/
            /** @VID_IID[ 0070 ]TIME[ 1H 19M 32S ]           **/  
            /** Make note of what is NOT done so that        **/
            /** no one comes along later and adds this       **/
            /** function.                                    **/
            /** CANNOT GET WHAT WAS NEVER PUT!!!!!!!!!!!!!!  **/
            /** ******************************************** **/

            ERR("[THERE_IS_ONLY:PUT_GET:NEVER:GET_PUT]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

    #undef  NUM_TEST_CASES_put                          //:01://
    #undef  NUM_TEST_COLMS_put                          //:02://
    #undef  NUM_TEST_CASES_get                          //:03://
    #undef  NUM_TEST_COLMS_get                          //:04://
    //:-----------------------------------:MAIN_GET_PUT_TESTS://
    //:paired_unit_tests::- - - ---- - - - - - - - - - - - - ://
    //:1: glocpix_CTO_painpix : ---- - - - - - - - - - - - - ://
    //:2: painpix_CTO_glocpix : ---- - - - - - - - - - - - - ://
    #define glocpix_CTO_painpix_CASES (  4  )         //: 01 ://
    #define glocpix_CTO_painpix_DATUM (  7  )         //: 02 ://
    #define painpix_CTO_glocpix_CASES (  4  )         //: 03 ://
    #define painpix_CTO_glocpix_DATUM (  7  )         //: 04 ://

        void
        aac2020_paint5d_UTC_glocpix_CTO_painpix( void )
        {

            /** @VID_IID[ 0069 ]TIME[ 1H 52M 50S ] ......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( glocpix_CTO_painpix_CASES - 1);

            /* ACTUAL(act_*)VALUES:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  act_til_qua ;  //:--------------------------://
            U08  act_til_exp ;  //:                          ://
            U08  act_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  act_loc_t_x ;  //:                          ://
            U08  act_loc_t_y ;  //:--------------------------://
                 
            /* EXPECTED(exp_*)VALS:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  exp_til_qua ;  //:--------------------------://
            U08  exp_til_exp ;  //:                          ://
            U08  exp_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  exp_loc_t_x ;  //:                          ://
            U08  exp_loc_t_y ;  //:--------------------------://
 
            /* INPUT VALUES(inn_*):@VID_IID[ 0069]T[ 1H 45M ] */
            I16  inn_glo_t_x ;  //:                          ://
            I16  inn_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 glocpix_CTO_painpix_CASES
                            *
                 glocpix_CTO_painpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * glocpix_CTO_painpix_DATUM );

                /** @VID_IID[ 0069 ]TIME[ 1H 36M 33S ]    **/
                /** Most are expected ("exp_*") values    **/
                /** Except the global values which are    **/
                /** actual ("act_*") values.              **/

                exp_til_qua=(   201 );  /** @TRAP_VALUES@ **/
                exp_til_exp=(   202 );  /** @TRAP_VALUES@ **/
                exp_til_lay=(   203 );  /** @TRAP_VALUES@ **/
                exp_loc_t_x=(   204 );  /** @TRAP_VALUES@ **/
                exp_loc_t_y=(   205 );  /** @TRAP_VALUES@ **/
                inn_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                inn_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                /** @VID_IID[ 0070 ]TIME[ 00H 20M 50S ]   **/
                /** Checking for integer overflow .       **/

                exp_til_qua=(         (U08)tab_utc[ bas + 0 ] );
                exp_til_exp=(         (U08)tab_utc[ bas + 1 ] );
                exp_til_lay=(         (U08)tab_utc[ bas + 2 ] );
                exp_loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                exp_loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                inn_glo_t_x=(              tab_utc[ bas + 5 ] );
                inn_glo_t_y=(              tab_utc[ bas + 6 ] );

                assert(((I16)exp_til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)exp_til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)exp_til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)exp_loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)exp_loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)inn_glo_t_x)==tab_utc[ bas + 5 ] );
                assert(((I16)inn_glo_t_y)==tab_utc[ bas + 6 ] );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(act_til_qua)  //:<-- OUTPUTS -------
                , &(act_til_exp)  //:<-- OUTPUTS -------
                , &(act_til_lay)  //:<-- OUTPUTS -------
                , &(act_loc_t_x)  //:<-- OUTPUTS -------
                , &(act_loc_t_y)  //:<-- OUTPUTS -------
                ,   inn_glo_t_x   //:<----------INPUTS--
                ,   inn_glo_t_y   //:<----------INPUTS--
                );;
 
                if( 0
                ||  exp_til_qua != act_til_qua
                ||  exp_til_exp != act_til_exp
                ||  exp_til_lay != act_til_lay
                ||  exp_loc_t_x != act_loc_t_x
                ||  exp_loc_t_y != act_loc_t_y
                ){
                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_qua  , act_til_qua );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_exp  , act_til_exp );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_lay  , act_til_lay );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_x  , act_loc_t_x );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_y  , act_loc_t_y );

                    ERR("[FAIL:glocpix_CTO_painpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_316PM]" );
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void
        aac2020_paint5d_UTC_painpix_CTO_glocpix( void )
        {
            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( painpix_CTO_glocpix_CASES - 1);

            /** ******************************************** **/
            /** @VID_IID[ 0069 ]TIME[ 02H 05M 55S ]     .....**/
            /**  inn_*  : Input    Values                    **/
            /**  exp_*  : EXPECTED outputs                   **/
            /**  act_*  : ACTUAL   outputs                   **/
            /** ******************************************** **/
                                                      
            U08  inn_til_qua ;  //:--------------------------://
            U08  inn_til_exp ;  //:                          ://
            U08  inn_til_lay ;  //:--------------------------://
            U08  inn_loc_t_x ;  //:                          ://
            U08  inn_loc_t_y ;  //:                          ://
                                //:   SEE[ #DIA_GLO_PIX# ]   ://
            I16  exp_glo_t_x ;  //:                          ://
            I16  exp_glo_t_y ;  //:                          ://
                                //:--------------------------://
            I16  act_glo_t_x ;  //:                          ://
            I16  act_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 painpix_CTO_glocpix_CASES
                            *
                 painpix_CTO_glocpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * painpix_CTO_glocpix_DATUM );

                inn_til_qua=(    11 );  /** @TRAP_VALUES@ **/
                inn_til_exp=(    22 );  /** @TRAP_VALUES@ **/
                inn_til_lay=(    33 );  /** @TRAP_VALUES@ **/
                inn_loc_t_x=(    44 );  /** @TRAP_VALUES@ **/
                inn_loc_t_y=(    55 );  /** @TRAP_VALUES@ **/
                exp_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                exp_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                inn_til_qua=( (U08) tab_utc[ bas + 0 ] );
                inn_til_exp=( (U08) tab_utc[ bas + 1 ] );
                inn_til_lay=( (U08) tab_utc[ bas + 2 ] );
                inn_loc_t_x=( (U08) tab_utc[ bas + 3 ] );
                inn_loc_t_y=( (U08) tab_utc[ bas + 4 ] );
                exp_glo_t_x=(       tab_utc[ bas + 5 ] );
                exp_glo_t_y=(       tab_utc[ bas + 6 ] );

                /** @VID_IID[ 0070 ]TIME[ 00H 16M 22S ]      **/
                /** Check for integer overflow.              **/
                assert(((I16)inn_til_qua)==tab_utc[ bas +0 ]);
                assert(((I16)inn_til_exp)==tab_utc[ bas +1 ]);
                assert(((I16)inn_til_lay)==tab_utc[ bas +2 ]);
                assert(((I16)inn_loc_t_x)==tab_utc[ bas +3 ]);
                assert(((I16)inn_loc_t_y)==tab_utc[ bas +4 ]);
                assert(((I16)exp_glo_t_x)==tab_utc[ bas +5 ]);
                assert(((I16)exp_glo_t_y)==tab_utc[ bas +6 ]);

                aac2020_paint5d_painpix_CTO_glocpix(
                    inn_til_qua   //:<-- INPUTS -----------
                ,   inn_til_exp   //:<-- INPUTS -----------
                ,   inn_til_lay   //:<-- INPUTS -----------
                ,   inn_loc_t_x   //:<-- INPUTS -----------
                ,   inn_loc_t_y   //:<-- INPUTS -----------
                , &(act_glo_t_x)  //:<---------- OUTPUTS --
                , &(act_glo_t_y)  //:<---------- OUTPUTS --
                );;
 
                if( 0
                ||  exp_glo_t_x != act_glo_t_x
                ||  exp_glo_t_y != act_glo_t_y
                ){
                    printf("[glo_t_x]:(%d)(%d)\n",
                    exp_glo_t_x  , act_glo_t_x );

                    printf("[glo_t_y]:(%d)(%d)\n",
                    exp_glo_t_y  , act_glo_t_y );

                    ERR("[FAIL:painpix_CTO_glocpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_504PM]" );

        }

    #undef  glocpix_CTO_painpix_CASES                 //: 01 ://
    #undef  glocpix_CTO_painpix_DATUM                 //: 02 ://
    #undef  painpix_CTO_glocpix_CASES                 //: 03 ://
    #undef  painpix_CTO_glocpix_DATUM                 //: 04 ://
    //: - - - - - - - - - - - - ---- - 1: glocpix_CTO_painpix://
    //: - - - - - - - - - - - - ---- - 2: painpix_CTO_glocpix://
    //: - - - - - - - - - - - - ---- - - -::paired_unit_tests://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://



    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://
//:helper_functions:generic:|||||||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_Min_I16( void )
    {
        #define FUN aac2020_paint5d_Min_I16

        assert( FUN(   3  ,   7  ) ==      3 );
        assert( FUN(0x00FF,0xFFFF) == 0x00FF );
        assert( FUN(0x0001,0xFFFF) == 0x0001 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_i32_Cap_u32( void )
    {

        I32 bru_x_y = 0x0F000 ; /** brush [X|Y] location     **/
        U16 cap_min = 0x0000F ; /** Minimum Boundary         **/
        U16 cap_max = 0xF0000 ; /** Maximum Boundary         **/
        U32 u32_x_y           ; /** U32 output of function   **/

        #define FUN aac2020_paint5d_i32_Cap_u32

            /** First test to formalize what the parameter   **/
            /** names we are working with are............... **/

            u32_x_y = FUN( bru_x_y , cap_min , cap_max );

            assert( u32_x_y == 0x0F000 );

            /** Tests where input doesn't change **/
            assert( FUN(   0 ,   0 ,   0 ) ==   0 );
            assert( FUN(   2 ,   1 ,   3 ) ==   2 );
            assert( FUN(  50 ,   0 , 100 ) ==  50 );
            assert( FUN( 200 , 100 , 300 ) == 200 );

            /** Tests where capped to max value **/
            assert( FUN( 300 , 100,  200 ) == 200 );
            assert( FUN(   4 ,   1 ,   3 ) ==   3 );
            assert( FUN( 200 ,   0 , 100 ) == 100 );
            assert( FUN( 400 , 100 , 300 ) == 300 );

            /** Tests where capped to min value **/
            assert( FUN(  50 , 100,  200 ) == 100 );
            assert( FUN(   0 ,   1 ,   3 ) ==   1 );
            assert( FUN(   0 ,   0 , 100 ) ==   0 );
            assert( FUN(  50 , 100 , 300 ) == 100 );

            /** capped to min using NEGATIVES **/
            assert( FUN( -12345678 , 100,  200 ) == 100 );
            assert( FUN( -23456789 ,   1 ,   3 ) ==   1 );
            assert( FUN( -34567890 ,   0 , 100 ) ==   0 );
            assert( FUN( -45678901 , 100 , 300 ) == 100 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    

//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||||||:helper_functions:generic://
//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://
//:helper_functions::conversion:|||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_bip_sip( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_bip_sip
        assert( FUN(0) == 128 );
        assert( FUN(1) ==  64 );
        assert( FUN(2) ==  32 );
        assert( FUN(3) ==  16 );
        assert( FUN(4) ==   8 );
        assert( FUN(5) ==   4 );
        assert( FUN(6) ==   2 );
        assert( FUN(7) ==   1 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_max_cor( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_max_cor
        assert( FUN(0) == 127 );
        assert( FUN(1) ==  63 );
        assert( FUN(2) ==  31 );
        assert( FUN(3) ==  15 );
        assert( FUN(4) ==   7 );
        assert( FUN(5) ==   3 );
        assert( FUN(6) ==   1 );
        assert( FUN(7) ==   0 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_diagpix

        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 00H 44M 10M ]    * * * * * **/
        /** What we were thinking when we started  * * * * * **/
        /** creating entries for tab_utc below.    * * * * * **/
        /**                                                  **/
        /** @VID_IID[ 0071 ]TIME[ 00H 54M 37S ]              **/
        /** 7 is the last useful index (til_exp)             **/
        /** because 8 can only store 1 pixel instead         **/
        /** of 3 groups of pixels.                           **/
        /** ************************************************ **/

        /** tab_utc[  row(s)  col(s) **/
        I32 num_tes=( (9*2)  * 2       );;
        I16 tab_utc[  (9*2)  * 2     ]={           //:C_S DEX://
            0 ,   0                                //: 1   0 ://
        ,   1 , 128                                //: 2   1 ://
        ,   2 , 128 + 64                           //: 3   2 ://
        ,   3 , 128 + 64 + 32                      //: 4   3 ://
        ,   4 , 128 + 64 + 32 + 16                 //: 5   4 ://
        ,   5 , 128 + 64 + 32 + 16 + 8             //: 6   5 ://
        ,   6 , 128 + 64 + 32 + 16 + 8 + 4         //: 7   6 ://
        ,   7 , 128 + 64 + 32 + 16 + 8 + 4 + 2     //: 8   7 ://
        ,   8 , 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 //: 9   8 ://
        //:- - - - - - - - - - - - - - - - - - - - - : ----- ://
        ,   0 ,   0                                //: 1   9 ://
        ,   1 , 128                                //: 2  10 ://
        ,   2 , 192                                //: 3  11 ://
        ,   3 , 224                                //: 4  12 ://
        ,   4 , 240                                //: 5  13 ://
        ,   5 , 248                                //: 6  14 ://
        ,   6 , 252                                //: 7  15 ://
        ,   7 , 254                                //: 8  16 ://
        ,   8 , 255                                //: 9  17 ://
        };;                                        

        I32 dex ; //: Current Test Index
        I32 bas ; //: Base Offset Value For Test Data.

        U08 act_til_exp;
        U08 exp_diagpix;
        U08 act_diagpix;

        for( dex = 0; dex <= ( num_tes - 1); dex++ ){

            bas = ( dex * 2 ); //:Multiply Testindex by stride

            /** Extract Data From Table             **/
            /** @VID_IID[ 0071 ]TIME[ 01H 05M 21S ] **/

            act_til_exp = tab_utc[ bas + 0 ]; 
            exp_diagpix = tab_utc[ bas + 1 ];

            act_diagpix = FUN( act_til_exp );

            if( exp_diagpix != act_diagpix ){
                ERR("[FAIL_ACTDIAGNOTEQUALEXPDIAG]");
            };;
        };;

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_diagpix_CTO_til_exp( void )
    {
        U08 til_exp    ;
        U08 til_exp_chk;
        U08 diagpix    ;

        for( til_exp = 0 ; til_exp <= MAX_EXP ; til_exp ++ ){

            diagpix=(
            aac2020_paint5d_til_exp_CTO_diagpix( til_exp ));;

            til_exp_chk=(
            aac2020_paint5d_diagpix_CTO_til_exp( diagpix ));;

            if( til_exp != til_exp_chk ){
                ERR("[diagpix_CTO_til_exp:UNIT_TEST_FAIL]");
            };;
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /**     @DNE aac2020_paint5d_UTC_diagpix_CTO_astipix     **/
    /**     @DNE == @DOES_NOT_EXIST                          **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_astipix_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_astipix_CTO_diagpix

            assert( FUN( 127              ) ==   0            );
            assert( FUN( 128              ) == 128            );
            assert( FUN( 128+64-1         ) == 128            );
            assert( FUN( 128+64+0         ) == 192            );
            assert( FUN( 128+64+0         ) == 128+64         );
            assert( FUN( 128+64+1         ) == 128+64         );
            assert(      128+64+0           == 192            );
            assert( FUN( 128+64+32-1      ) == 192            );
            assert( FUN( 128+64+32+0      ) == 128+64+32      );
            assert( FUN( 128+64+32+1      ) == 128+64+32      );
            assert( FUN( 128+64+32+16-1   ) == 128+64+32      );
            assert( FUN( 128+64+32+16+0   ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+1   ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+8-1 ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+8+0 ) == 128+64+32+16+8 );

            /** ******************************************** **/
            /** Previous test, but collapsing numbers so we  **/
            /** don't run out of column space in source code.**/
            /** ******************************************** **/

            assert( FUN( 248 ) == 248 ); //:#_DONT_TOUCH_ME_#://

            /** ******************************************** **/

            assert( FUN( 248              ) == 248            );
            assert( FUN( 248+4-1          ) == 248            );
            assert( FUN( 248+4+0          ) == 248+4          );
            assert( FUN( 248+4+1          ) == 248+4          );
            assert( FUN( 248+4+2          ) == 248+4+2        );
            assert( FUN( 248+4+2+1        ) == 248+4+2+1      );

            //:Use some explicit edge case values:           ://
            //:If 255 fails because it is out of bounds, then://
            //:Just comment out that test, as the case has   ://
            //:been properly handled by runtime asserts in   ://
            //:the function being tested.                    ://
            assert( FUN( 0 ) ==   0 );
            assert( FUN(255) == 255 ); //:<--ShouldNeverUse
            assert( FUN(254) == 254 );
            assert( FUN(253) == 252 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||:helper_functions::conversion://
//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://

    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:         UNIT_TEST : PROGCONTROLS : ABOVE             ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://

#undef  MAX_EXP                                       //: 01 ://
#undef  EXT                                           //: 02 ://
#undef  VOD                                           //: 03 ://
#undef  I08                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  I16                                           //: 06 ://
#undef  U16                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  U32                                           //: 09 ://
#undef  ERR                                           //: 10 ://
//:================================================:UNIT_TEST://