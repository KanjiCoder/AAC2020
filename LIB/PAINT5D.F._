//: PAINT5D: ( .F._ : FuncFile )
//: #NAMESPACE_PATTERN_BREAKER_PAINT5D#

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://

    void
    aac2020_paint5d_Halt( const char* msg_err )
    {

        printf("[FATAL_2020_12_04_076PM]:%s\n", msg_err );
        fflush(stdout);exit(  11 /** 4*20-69 **/ );         

    }

//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:OKAY_STATUS_INFO_MESSAGE:=================================://

    void
    aac2020_paint5d_Okay( const char* msg_o_k )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Okay]:%s\n", msg_o_k );
        fflush(stdout);    
    };;}

//:=================================:OKAY_STATUS_INFO_MESSAGE://
//:INFO_STATUS_INFO_MESSAGE:=================================://
#define I32 int32_t /** GCC: <stdint.h> **/
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info( const char* msg_inf )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf("[aac2020_paint5d_Info]:%s\n", msg_inf );
        fflush(stdout);    
    };;}
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_dec( 
        const char* str_fmt
    ,   I32         val_dec
    )
    {   if( AAC2020_SILENCE.PAINT5D <= 0 ){
        printf( "[aac2020_paint5d_Info_dec]...\n");
        fflush( stdout            ); //:@SAFETY_DOUBLE_FLUSH@://
        printf( str_fmt , val_dec );
        fflush( stdout            );    
    };;}
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_any(
        const char* str_fmt
    ,   void*       dat_any   
    )
    { if( AAC2020_SILENCE.PAINT5D <= 0 ){

        /** Same Line As Next Printf **/
        printf("[paint5d_log]....(   " ); fflush( stdout );
        printf( str_fmt , dat_any      ); fflush( stdout );
        printf(               "   )\n" ); fflush( stdout );

    };; }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32
//:=================================:INFO_STATUS_INFO_MESSAGE://
//:INITIALIZE_PAINT5D:=======================================://
#define U32  uint32_t /** GCC: <stdint.h> **/         //: 01 ://
#define I32   int32_t /** GCC: <stdint.h> **/         //: 02 ://
#define ERR   aac2020_paint5d_Halt                    //: 03 ://
#define O_K   aac2020_paint5d_Okay                    //: 04 ://
#define I_D   aac2020_paint5d_Info_dec                //: 05 ://
#define INF   aac2020_paint5d_Info                    //: 06 ://

    U32
    AAC2020_PAINT5D_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved for future use **/ };

        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

        /** Hackishly debug what is going on. **/
        AAC2020_PAINT5D_init_call_count++;
        I_D("[AAC2020_PAINT5D_init_call_count]:%d\n"
                ,AAC2020_PAINT5D_init_call_count       );;

        if( AAC2020_CEDITOR_dex_ing == 
            AAC2020_CEDITOR_paint5d
        ){  
            /** If not recursion, it might be being called   **/
            /** rapidly from another thread. Re-entering     **/
            /** before it is exiting. But that seems         **/
            /** unlikely. I think that would require         **/
            /** more than one thread to call this function.  **/

            ERR("[LIKELY_UNINTENTIONAL_RECURSION]"); 
        };;

            /** #_EDITOR_INIT_SPAM_GAURD_# **/
            if( AAC2020_CEDITOR_nex_edi 
            ==  AAC2020_CEDITOR_dex_edi
            ){
                O_K("[PAINT5D:Init_Already_Up_To_Date]");
            };;

        /** We are now initilaizing paint5d **/
        AAC2020_CEDITOR_dex_ing=( 
        AAC2020_CEDITOR_paint5d  );;

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://

        /** Early Exit Will Trigger Recursion Guard Error **/
        O_K( "[OH_FUCK...Code_Below_Was_Never_Ran_Before]" );;

        //:ALL_MEMBERS_OF_PAINT5D:---------------------------://

            //:#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#://

        //:---------------------------:ALL_MEMBERS_OF_PAINT5D://
        //:ALLOCATES_OPEN_GL_TEXTURE:------------------------://
    
            //+ #GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER# + + + +//
            //- AAC2020_GPUDATA_InitInstance(  - - - - - - - -//
            //-     ACC2020_PAINT5D_dat      );; - - - - - - -//

        //:------------------------:ALLOCATES_OPEN_GL_TEXTURE://
        //:LOAD_INITIAL_TEXTURE_DATA:------------------------://
        #define DAT gpudata_paint5d
        #define F_S( name ) AAC2020_PIXNAME_##name

            /** #_TODOS_CAN_BREAK_COLUMN_LIMIT_# **/
            /** For now just load a test pattern to confirm we    * * * * * **/
            /** have data. But once that is done, we will want to * * * * * **/
            /** load from a save file on disk on startup.         * * * * * **/
            AAC2020_VITAL_TODO("[Eventually_This_Should_Load_Save_File_Data]");



            struct AAC2020_GPUDATA gpudata_paint5d ={ 0 };



            if( strcmp( &(F_S( paint5d )[0]) ,"paint5d" )!= 0 ){
                aac2020_paint5d_Halt("[BAD_NAME_2020]");
            };;


            
            //: FILE_SCOPE(  F_S  ) --> TEMP_STRUCT(  DAT  );
            DAT.tex_lot =    F_S( paint5d_tex_lot          );
            DAT.tex_han =    F_S( paint5d_tex_han          ); 
            DAT.sam_loc =    F_S( paint5d_tex_sam.sam_loc  );
            DAT.sam_val =    F_S( paint5d_tex_sam.sam_val  );
            DAT.sam_has =    F_S( paint5d_tex_sam_HAS      );
            DAT.pix_wid =  ( 512                           );
            DAT.pix_hig =  ( 512                           );
            DAT.pix_nam = &( F_S( paint5d )[0]             );

            DAT.cpu_pix =&( 
                AAC2020_PIXNAME_paint5d_cpu_pix[0] 
            );;



            AAC2020_PIXLOAD_TestPattern(   &( DAT ) );
            AAC2020_PIXLOAD_UploadTexture( &( DAT ) );
            

            //:get_paint5d_sampler_location:-----------------://
            #define HAS_CHK AAC2020_PIXLOAD_HasSampler
            #define INF_DEC aac2020_paint5d_Info_dec

                //:#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#://
                AAC2020_PIXLOAD_sam_has    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_loc    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_val_PUT( &( DAT ) );

                if( DAT.sam_has >= 1 && DAT.sam_loc <=(0 - 1) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:001]");
                }else 
                if( DAT.sam_has <= 0 && DAT.sam_loc >=(  0  ) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:002]");
                };;

                /** Keep the error prone way of doing this   **/
                /** As a redundancy to check for agreement.  **/

                I32 has = HAS_CHK( "paint5d" );
                if( DAT.sam_has != has ){ ERR("[WTF:0433AM]");};

                INF_DEC( "[DAT.sam_loc]:%d\n" , DAT.sam_loc );
                INF_DEC( "[DAT.sam_val]:%d\n" , DAT.sam_val );

            #undef  HAS_CHK
            #undef  INF_DEC
            //:-----------------:get_paint5d_sampler_location://

            if( has >= 1 ){

                /** Update Texture Sampler Uniform On GPU **/

                aac2020_pixload_PushSampler(  &( DAT ) );

                /** Persist Changes: **/

                //: TEMP_STRUCT(  DAT  ) --> FILE_SCOPE(  F_S  )
                F_S( paint5d_tex_lot         ) = DAT.tex_lot ;
                F_S( paint5d_tex_han         ) = DAT.tex_han ;
                F_S( paint5d_tex_sam.sam_loc ) = DAT.sam_loc ;
                F_S( paint5d_tex_sam.sam_val ) = DAT.sam_val ;
                F_S( paint5d_tex_sam_HAS     ) = DAT.sam_has ;
                //:                    ( 512 ) = DAT.pix_wid ://
                //:                    ( 512 ) = DAT.pix_hig ://
                //:                 "paint5d" ~=~DAT.pix_nam ://
    
                aac2020_paint5d_Okay("[HAS_TEXTURE_SAMPLER]");
            }else{

                /** Whether this is a good or bad message **/
                /** depends on you looking at code and    **/
                /** deciding.                             **/
                INF("[NO_TEXTURE_SAMPLER:PAINT5D]");
    
            };;
           
        #undef DAT
        #undef F_S
        //:------------------------:LOAD_INITIAL_TEXTURE_DATA://
        //:ERROR_CHECK:--------------------------------------://

            //:#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#://
            

        //:--------------------------------------:ERROR_CHECK://


        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

            /** DONE initializing. **/

            AAC2020_CEDITOR_dex_ini=( 
            AAC2020_CEDITOR_paint5d  );;

            /** No editor initializ-ING now. **/
            AAC2020_CEDITOR_dex_ing=( 0xFFFFFFFF );

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://

        //:Run_Unit_Test_If_Never_Ran_Before:----------------://

            if( aac2020_paint5d_unit_test_ran_or_running <= 0 ){
                aac2020_paint5d_unit_test_ran_or_running =( 1 );

                extern U32 AAC2020_PAINT5D_UnitTest( U32  );
                           AAC2020_PAINT5D_UnitTest( 0x00 );

            };;

        //:----------------:Run_Unit_Test_If_Never_Ran_Before://

        return( 0x00 );

    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
#undef  O_K                                           //: 04 ://
#undef  I_D                                           //: 05 ://
#undef  INF                                           //: 06 ://
//:=======================================:INITIALIZE_PAINT5D://
//:HELPER_FUNCTIONS:GENERIC:=================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U16 uint16_t /** GCC: <stdint.h> **/
#define I16  int16_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I16
    aac2020_paint5d_Min_I16(
        I16 i16_001
    ,   I16 i16_002
    )
    {
        I16 i16_min = ( 0 - 4433 /** @TRAP_VALUE@ **/ );
        if( i16_001 <= i16_002 ){ i16_min = i16_001 ; };
        if( i16_002 <= i16_001 ){ i16_min = i16_002 ; };

        assert( 0 - 4433 != i16_min /** @CHECK_TRAP@ **/ );
        return( i16_min );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_i32_Cap_u32(

        I32 bru_x_y /** [ b_x | b_y ](Brush_X -or- Brush_Y) **/
    ,   U16 cap_min
    ,   U16 cap_max

    )
    {
        assert( cap_min <= cap_max ); /** Sorted/Ordered ? **/

        U32 out_u32 = ( (U32)bru_x_y );

        if( bru_x_y < (I32)cap_min ){ out_u32 =(U32)(cap_min);};
        if( bru_x_y > (I32)cap_max ){ out_u32 =(U32)(cap_max);};

        return( out_u32 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32 
#undef  U32 
#undef  U16 
#undef  I16
//:=================================:HELPER_FUNCTIONS:GENERIC://
//:HELPER_FUNCTIONS:CONVERSION:==============================://
#define POT aac2020_paint5d_POT_diagpix               //: 01 ://
#define T_E til_exp /** Tilesize_Exponent **/         //: 02 ://
#define BRK break                                     //: 03 ://
#define CAS case                                      //: 04 ://
#define DEF default                                   //: 05 ://
#define S_A _Static_assert                            //: 06 ://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 07 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 08 ://
#define ERR aac2020_paint5d_Halt                      //: 09 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_bip_sip(
                U08 til_exp
    )
    {
        U08 bip_sip; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ bip_sip = ( 128 + 0 ); };  //: 1 ://
        if( 1 == til_exp ){ bip_sip = (  64 + 0 ); };  //: 2 ://
        if( 2 == til_exp ){ bip_sip = (  32 + 0 ); };  //: 3 ://
        if( 3 == til_exp ){ bip_sip = (  16 + 0 ); };  //: 4 ://
        if( 4 == til_exp ){ bip_sip = (   8 + 0 ); };  //: 5 ://
        if( 5 == til_exp ){ bip_sip = (   4 + 0 ); };  //: 6 ://
        if( 6 == til_exp ){ bip_sip = (   2 + 0 ); };  //: 7 ://
        if( 7 == til_exp ){ bip_sip = (   1 + 0 ); };  //: 8 ://
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
        assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
    
        return( bip_sip );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_max_cor(
                U08 til_exp
    )
    {
        /** Why is output U08 ?                **/
        /** @VID_IID[ 0067 ]TIME[ 4H 15M 40S ] **/

        U08 max_cor; /** m_c : Max_Coordinate ( x | y ) **/
        if( 0 == til_exp ){ max_cor = ( 128 - 1 ); };  //: 1 ://
        if( 1 == til_exp ){ max_cor = (  64 - 1 ); };  //: 2 ://
        if( 2 == til_exp ){ max_cor = (  32 - 1 ); };  //: 3 ://
        if( 3 == til_exp ){ max_cor = (  16 - 1 ); };  //: 4 ://
        if( 4 == til_exp ){ max_cor = (   8 - 1 ); };  //: 5 ://
        if( 5 == til_exp ){ max_cor = (   4 - 1 ); };  //: 6 ://
        if( 6 == til_exp ){ max_cor = (   2 - 1 ); };  //: 7 ://
        if( 7 == til_exp ){ max_cor = (   1 - 1 ); };  //: 8 ://
        assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
        assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
    
        return( max_cor );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_til_exp_CTO_diagpix(
            U08     til_exp
    )
    {
        U08     diagpix =aac2020_paint5d_POT_diagpix[ til_exp ];
        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_til_exp(
            U08     diagpix
    )
    {
        /** In case type signature changes **/
        assert(  (((I32)diagpix)+0) < 255  );

        /**   T_E  **/
        U08 til_exp =( 222 /** Invalid Trap Value **/ );
        /**   T_E  **/

        switch( diagpix ){  
        //:pyramid_not_of_doom:------------------------------://
        CAS 0: T_E = ( 0                              );BRK;
        CAS 1: T_E = ( 0 +128                         );BRK;
        CAS 2: T_E = ( 0 +128 +64                     );BRK;
        CAS 3: T_E = ( 0 +128 +64 +32                 );BRK;
        CAS 4: T_E = ( 0 +128 +64 +32 +16             );BRK;
        CAS 5: T_E = ( 0 +128 +64 +32 +16 +8          );BRK;
        CAS 6: T_E = ( 0 +128 +64 +32 +16 +8 +4       );BRK;
        CAS 7: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2    );BRK;
        CAS 8: T_E = ( 0 +128 +64 +32 +16 +8 +4 +2 +1 );BRK;
        //:------------------------------:pyramid_not_of_doom://
        DEF: ERR("[INVALID_DIAGPIX_INPUT_CANNOT_CONVERT]");
        };; assert( til_exp <= 7 && (((I32)til_exp)+0) >= 0 );
        S_A( AAC2020_PAINT5D_MAX_til_exp == 7 , "[ERR_MSG]" );

        /** 8 is only 1 pixel, and thus not useful. **/
        /** @VID_IID[ 0068 ]TIME[ 3H 13M 15S ]      **/

        assert( (&T_E)==(&til_exp)/**@SAME_VAR_SAME_ADDR@**/ );
        assert(   T_E ==  til_exp /**@SAME_VAR@**/           );
        return(   T_E /** til_exp **/                        );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_diagpix_CTO_astipix(
            U08     diagpix
    )
    {
        if( diagpix ){ /** @NOOP@ **/ };
        /** ************************************************ ***

            @VID_IID[ 0066 -to- 0071 ]TIME[ 00H 26M 24S ]
            @VID_IID[ 0071           ]TIME[ 03H 32M 30S ]

            Cannot make this function because
            aac2020_paint5d_astipix_CTO_diagpix(...)
            is a one-way conversion.

            BECAUSE WE HAVE INFORMATION LOSS WHEN
            [FUNNELING / CONVERTING] DOWN TO[ diagpix ]
            WE CANNOT DO A @BACK_AND_FORTH_CONVERSION_TEST@

        *** ************************************************ **/
        ERR("[CANNOT_MAKE_SUCH_FUNCTION:diagpix_CTO_astipix]");

        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    aac2020_paint5d_astipix_CTO_diagpix(
            U08     astipix
    )
    {
        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 03H 47M 50S ]              **/
        /** SEE:FILE[ PAINT5D.D._]SECTION[ PAINT5D_DATA ]    **/
        /**      VAR[ aac2020_paint5d_POT_diagpix       ]    **/
        /**  DIAGRAM[ #_DIA_SELECTED_TIL_QUA_#          ]    **/
        /**                                                  **/
        /** astipix : Auset_Sub_TIle: PIXel (location:[X|Y]) **/
        /** diagpix : DIAGonal_PIXels .......................**/
        /** ************************************************ **/

        U08 lil=( 0 ); //: lil == "Largest_Index_Lessthan"

        for( I32 i = 0 ; i <= 9 ; i++ ){
            if( astipix < aac2020_paint5d_POT_diagpix[ i ] ){ 

                lil = i; 
            };;
        };;

        assert( lil >= 1 ); /** First Comparison Should      **/
                          /** never be true, so we should    **/
                          /** always have an "lil" of        **/
                          /** at least one( 1 )              **/

        U08 diagpix=( aac2020_paint5d_POT_diagpix[ lil - 1 ] );

        return( diagpix );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  POT                                           //: 01 ://
#undef  T_E                                           //: 02 ://
#undef  BRK                                           //: 03 ://
#undef  CAS                                           //: 04 ://
#undef  DEF                                           //: 05 ://
#undef  S_A                                           //: 06 ://
#undef  U08                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  ERR                                           //: 09 ://
//:==============================:HELPER_FUNCTIONS:CONVERSION://
//:QUARKMAP_COORD_CONVERSIONS:===============================://
#define U08   uint8_t /** GCC: <stdint.h> **/         //: 01 ://
#define U16  uint16_t /** GCC: <stdint.h> **/         //: 02 ://
#define I16   int16_t /** GCC: <stdint.h> **/         //: 03 ://
#define RES  restrict                                 //: 04 ://
#define MIN  aac2020_paint5d_Min_I16                  //: 05 ://
#define ERR  aac2020_paint5d_Halt                     //: 06 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_glocpix_CTO_painpix(
        U08*  RES  til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08*  RES  til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08*  RES  til_lay /** TileLayer .................   **/
    ,   U08*  RES  loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08*  RES  loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16        glo_t_x /** Global Tile X Coord           **/
    ,   I16        glo_t_y /** Global Tile X Coord           **/
    )
    {
        /** Why output parameters at the start of signature? **/
        /** @VID_IID[ 0067]TIME[ 3H 56M 45S ] .............. **/

        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != til_qua ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_exp ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != til_lay ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_x ); /** ! OUTPUTS ! **/
            assert( ((void*)0) != loc_t_y ); /** ! OUTPUTS ! **/

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://

            assert( AAC2020_PAINT5D_MAX_glo_t_x >= glo_t_x );
            assert( AAC2020_PAINT5D_MAX_glo_t_y >= glo_t_y );
            assert(                0            <= glo_t_x );
            assert(                0            <= glo_t_y );
  
        //:------------------------------:bounds_check_inputs://
        //:Get_Variables_Ready_To_Work_With:-----------------://

            I16 i16_til_qua =( 0 - 1001 );
            I16 i16_til_exp =( 0 - 1001 );
            I16 i16_til_lay =( 0 - 1001 );
            I16 i16_loc_t_x =( 0 - 1001 );
            I16 i16_loc_t_y =( 0 - 1001 );

            I16 i16_gtx =( (I16)( glo_t_x ) );
            I16 i16_gty =( (I16)( glo_t_y ) );

            I16 rem_i_x =( 0 - 2002 ); /** Remainder: X      **/
            I16 rem_i_y =( 0 - 2002 ); /** Remainder: Y      **/

            I16 o_x_qua =( 0 - 2002 ); /** XY Location Of    **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua           **/

            I16 diagp_x =( 0 - 2002 ); /** diagpix.x         **/
            I16 diagp_y =( 0 - 2002 ); /** diagpix.y         **/
            I16 diagpix =( 0 - 2002 ); /** diagonal_pixels   **/

            I16 o_x_lay =( 0 - 2002 ); /** XY Location of    **/
            I16 o_y_lay =( 0 - 2002 ); /** til_lay           **/

            I16 bip_sip =( 0 - 2002 ); /** BItmap_Partition  **/
                                       /** Span_In_Pixels    **/

            I16 max_cor =( 0 - 2002 ); /** Bounds Checking   **/
        
        //:-----------------:Get_Variables_Ready_To_Work_With://
        //:Calculate:2D_XY_LOCATIONS:------------------------://
        #define AST_CTO_DIA  aac2020_paint5d_astipix_CTO_diagpix

            //:CALC_AND_REBASE_LOCAL:til_qua:----------------://
            //:                      o_x_qua                 ://
            //:                      o_y_qua                 ://

                /** @CALC@ **/
                o_x_qua = ( i16_gtx / 256 );
                o_y_qua = ( i16_gty / 256 ); //:<<<<<<<<<<<<<<<<<<<<< o_x , o_y change to c_x , c_y for "cell" instead of offset.

                /** @REBASE_LOCAL@ **/
                rem_i_x = i16_gtx - ( o_x_qua * 256 );
                rem_i_y = i16_gty - ( o_y_qua * 256 );

                assert( rem_i_x >=   0 );
                assert( rem_i_y >=   0 );
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );

                /** **************************************** ***

                [ rem_i_x , rem_i_y ] is now LOCAL to
                #_DIA_SELECTED_TIL_QUA_#
                @VID_IID[ 0068 ]TIME[ 2H 32M 10S ]

                [ rem_i_x , rem_i_y ] == ( astipix )
                At this PLACE in the code.
                @VID_IID[ 0068 ]TIME[ 2H 40M 00S ]

                *** **************************************** **/

            //:                                       o_x_qua://
            //:                                       o_y_qua://
            //:----------------:CALC_AND_REBASE_LOCAL:til_qua://
            //:CALC_AND_REBASE_LOCAL:til_exp:----------------://
            //:                  i16_til_exp                 ://

                /** astipix : Auset_Sub_TIle:PIXel(loc:[X|Y])**/
                /** diagpix : DIAGonal_PIXels ...............**/

                diagp_x = AST_CTO_DIA( rem_i_x ); //:diagpix.x
                diagp_y = AST_CTO_DIA( rem_i_y ); //:diagpix.y
                diagpix = MIN( diagp_x , diagp_y );

                /** @CALC@ **/
                                        i16_til_exp=((U16)(
                aac2020_paint5d_diagpix_CTO_til_exp(
                        (  (U08)diagpix  )        
                )));;

                /** @REBASE_LOCAL@ **/
                rem_i_x =( rem_i_x - diagpix );
                rem_i_y =( rem_i_y - diagpix );

            //:                                   i16_til_exp://
            //:----------------:CALC_AND_REBASE_LOCAL:til_exp://
            //:CALC_AND_REBASE_LOCAL:til_lay:----------------://

                //:  @VID_IID[ 0072 ]TIME[ 01H 00M 15S ]     ://
                //:  1D: [      til_lay      ]   ............://
                //:  2D: [ o_x_lay , o_y_lay ]   ............://

                bip_sip =( 
                    aac2020_paint5d_til_exp_CTO_bip_sip(
                                i16_til_exp             ));;
                
                assert( rem_i_x <= 255 );
                assert( rem_i_y <= 255 );
                
                /** @CALC@ **/
                o_x_lay =( rem_i_x / bip_sip );
                o_y_lay =( rem_i_y / bip_sip );
                
                assert( o_x_lay >= 0 && o_x_lay <= 1 );
                assert( o_y_lay >= 0 && o_y_lay <= 1 );
                
                if( 1
                &&  1 == o_x_lay
                &&  1 == o_y_lay
                ){
                    ERR("[DIAGONAL_QUAD_IS_FOR_NESTING]");
                };;

                /** @REBASE_LOCAL@ **/
                rem_i_x = ( rem_i_x - ( o_x_lay * bip_sip ) );
                rem_i_y = ( rem_i_y - ( o_y_lay * bip_sip ) );

            //:----------------:CALC_AND_REBASE_LOCAL:til_lay://
            //:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]:------://

                max_cor =(
                    aac2020_paint5d_til_exp_CTO_max_cor(
                        (  (U08)i16_til_exp  )          ));;
                
                assert( rem_i_x >= 0 );
                assert( rem_i_y >= 0 );
                assert( rem_i_x <= max_cor );
                assert( rem_i_y <= max_cor );

                i16_loc_t_x = ( rem_i_x );
                i16_loc_t_y = ( rem_i_y );

            //:------:CALC_AND_REBASE_LOCAL:[loc_t_x,loc_t_y]://

        #undef  AST_CTO_DIA
        //:------------------------:Calculate:2D_XY_LOCATIONS://
        //:Calculate:1D_INDEX_LOCATIONS:---------------------://
        #define TIL_QUA_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/
        #define TIL_LAY_SAN ( 2 ) /** 2x2 cells( WID == HIG )**/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 00H 08M 40S ] 
                SAN == SPAN , means WID == HIG
                Use this variable to preserve the
                balance of tokens in our code.
            *** ******************************************** **/
        
            i16_til_qua = o_x_qua + ( TIL_QUA_SAN * o_y_qua);
        //: i16_til_exp =( ALREADY_CALCULATED_MY_FRIEND     );
            i16_til_lay = o_x_lay + ( TIL_LAY_SAN * o_y_lay);
        //: i16_loc_t_x =( ALREADY_CALCULATED_MY_FRIEND     );
        //: i16_loc_t_y =( ALREADY_CALCULATED_MY_FRIEND     );

        #undef  TIL_QUA_SAN  
        #undef  TIL_LAY_SAN  
        //:---------------------:Calculate:1D_INDEX_LOCATIONS://
        //:RETURN_VIA_OUTPUT_PARAMETERS:---------------------://

            assert(             i16_til_qua >=   0 ); //: 01 ://
            assert(             i16_til_exp >=   0 ); //: 02 ://
            assert(             i16_til_lay >=   0 ); //: 03 ://
            assert(             i16_loc_t_x >=   0 ); //: 04 ://
            assert(             i16_loc_t_y >=   0 ); //: 05 ://

            assert(             i16_til_qua <= 255 ); //: 01 ://
            assert(             i16_til_exp <= 255 ); //: 02 ://
            assert(             i16_til_lay <= 255 ); //: 03 ://
            assert(             i16_loc_t_x <= 255 ); //: 04 ://
            assert(             i16_loc_t_y <= 255 ); //: 05 ://

            (*til_qua)=(  (U08) i16_til_qua        ); //: 01 ://
            (*til_exp)=(  (U08) i16_til_exp        ); //: 02 ://
            (*til_lay)=(  (U08) i16_til_lay        ); //: 03 ://
            (*loc_t_x)=(  (U08) i16_loc_t_x        ); //: 04 ://
            (*loc_t_y)=(  (U08) i16_loc_t_y        ); //: 05 ://

        //:---------------------:RETURN_VIA_OUTPUT_PARAMETERS://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_painpix_CTO_glocpix(
        U08        til_qua /** Auset Tile Sub Quadrant Index **/
    ,   U08        til_exp /** TileExponent (TileSizeEnum)   **/
    ,   U08        til_lay /** TileLayer .................   **/
    ,   U08        loc_t_x /** Local  Tile X Coord / b_x     **/
    ,   U08        loc_t_y /** Local  Tile Y Coord / b_y     **/
    ,   I16*  RES  glo_t_x /** Global Tile X Coord           **/
    ,   I16*  RES  glo_t_y /** Global Tile X Coord           **/
    )
    {
        //:references_can_never_be_null:---------------------://

            assert( ((void*)0) != glo_t_x );
            assert( ((void*)0) != glo_t_y );

        //:---------------------:references_can_never_be_null://
        //:bounds_check_inputs:------------------------------://

            assert( AAC2020_PAINT5D_MAX_til_qua ==    3    );
            assert( AAC2020_PAINT5D_MAX_til_exp ==    7    );
            assert( AAC2020_PAINT5D_MAX_til_lay ==    2    );

            assert( AAC2020_PAINT5D_MAX_til_qua >= til_qua );
            assert( AAC2020_PAINT5D_MAX_til_exp >= til_exp );
            assert( AAC2020_PAINT5D_MAX_til_lay >= til_lay );

            U08  /* max_cor */                max_cor =(
                ( aac2020_paint5d_til_exp_CTO_max_cor( 
                                  til_exp )));;

            assert( max_cor >=        loc_t_x          );
            assert( max_cor >=        loc_t_y          );
            assert(    0    <= (((I16)loc_t_x)+0)      );
            assert(    0    <= (((I16)loc_t_y)+0)      );

        //:------------------------------:bounds_check_inputs://
        //:declare_all_variables:----------------------------://

            I16 tempi_x =( 0 - 1001 ); /** temp_integer: x   **/
            I16 tempi_y =( 0 - 1001 ); /** temp_integer: y   **/

            I16 o_x_qua =( 0 - 2002 ); /** til_qua.x **/
            I16 o_y_qua =( 0 - 2002 ); /** til_qua.y **/

            I16 diagpix =( 0 - 3003 );

            I16 o_x_lay =( 0 - 4004 ); /** til_lay.x **/
            I16 o_y_lay =( 0 - 4004 ); /** til_lay.y **/

            I16 i16_gtx =( 0 - 5005 ); /** glo_t_x  AS  I16 **/
            I16 i16_gty =( 0 - 5005 ); /** glo_t_y  AS  I16 **/

            /** @VID_IID[ 0067 ]TIME[ 4H 25M 20S ]       **/
            /** I16 is         ENOUGH addressing space.  **/
            /** U08 is __NOT__ ENOUGH addressing space.  **/
    
        //:----------------------------:declare_all_variables://
        //:CALCULATE:painpix_CTO_glocpix:--------------------://

            tempi_x =  til_qua         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_qua-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_qua = ( tempi_x * 256 ); /** offset_x_QUA **/
            o_y_qua = ( tempi_y * 256 ); /** offset_y_QUA **/
            
            /** diagpix: DIAgonal_PIXels (offset) **/
            diagpix =(I16)( aac2020_paint5d_til_exp_CTO_diagpix( 
                                            til_exp ) );;

            tempi_x =  til_lay         % ( 2 /** @WID@ **/ ) ;
            tempi_y = (til_lay-tempi_x)/ ( 2 /** @WID@ **/ ) ;
            o_x_lay = ( tempi_x * ( max_cor + 1 ) );
            o_y_lay = ( tempi_y * ( max_cor + 1 ) );

                //:error_check_range_of_temp:----------------://
                assert( tempi_x >= 0 && tempi_x <= 1 );
                assert( tempi_y >= 0 && tempi_y <= 1 );
                if( 1
                &&  1 == tempi_x
                &&  1 == tempi_y
                ){
                    ERR("[BOTH_CELL_COORDS_CANNOT_BE_ONE]");
                };;
                //:----------------:error_check_range_of_temp://

            i16_gtx=( o_x_qua + diagpix + o_x_lay + loc_t_x );
            i16_gty=( o_y_qua + diagpix + o_y_lay + loc_t_y );
            assert( i16_gtx >= 0 && i16_gtx <= ( 512 - 1 ) );
            assert( i16_gty >= 0 && i16_gty <= ( 512 - 1 ) );
            (*glo_t_x)=(  (U16)( i16_gtx )  );
            (*glo_t_y)=(  (U16)( i16_gty )  );

        //:--------------------:CALCULATE:painpix_CTO_glocpix://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  U16                                           //: 02 ://
#undef  I16                                           //: 03 ://
#undef  RES                                           //: 04 ://
#undef  MIN                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:===============================:QUARKMAP_COORD_CONVERSIONS://
//:PAINT5D_QUARKMAP_GET_PUT:=================================://
//:PAINT5D_QUARKMAP_PUT_GET:=================================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define I16  int16_t /** GCC: <stdint.h> **/          //: 02 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 03 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 04 ://
#define ERR aac2020_paint5d_Halt                      //: 05 ://

    /** #_WHAT_IS_THE_QUARKMAP_# * * * * *  **/
    /** @VID_IID[ 0067 ]TIME[ 00H 52M 23S ] **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U08
    AAC2020_PAINT5D_Put(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08  til_val   /** [ val_cur / til_val ]          ...**/
        //[ SAME_PARAM_ORDER_AS[ PAINT5D_Put_BrushState ]    ]//
        //[ @VID_IID[ 0076 ]TIME[ 6H 00M 00S ]               ]//
    )
    {
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            /** @VID_IID[ 0072 ]TIME[ 03H 07M 30S ]    ......**/
            /** til_val commentary is the decimal and  ......**/
            /** binary representations of it's values. ......**/

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );
            assert( til_val <=   3 );/**[  0 |  1 |  2 |  3 ]**/
                                     /**[ 00 | 01 | 10 | 11 ]**/

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );
            I16 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I16 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
            I16 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
            U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
            U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );
    
            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                assert(       chk_glo_com  == ((U32)glo_com) );
                assert( ((I16)chk_glo_com) == (     glo_com) );
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
                arr_dex =(         glo_com + 3 );
                var_u08 = CPU_PIX[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
                arr_dex =(         glo_com + 2 );
                var_u08 = CPU_PIX[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
                arr_dex =(         glo_com + 1 );
                var_u08 = CPU_PIX[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

                arr_dex =(         glo_com + 0 );
                var_u08 = CPU_PIX[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:PUT]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 3H 38M 10S ]BEG
                @VID_IID[ 0072 ]TIME[ 3H 46M 09S ]END
    
                Bit packing logic to ONLY CHANGE the bits
                where the new value needs to be stored.
                We need to erase the bits in the proper
                position by masking ( & ). Then merge the bits
                together by using a bitwise or. ( | )

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );
    
            CPU_PIX[ arr_dex ]=(

                /**  11001111 <-- Conceptually:if:aus_loc==2**/
                ( var_u08 &  (~(  BIN_011 << ( aus_loc*2 ) )) )

                |  //:<-- Bitwise Or to merge together

                /**  00110000 <-- Conceptually:if:aus_loc==2**/
                /** Slide Delta Bits Into Position **/
                ( til_val                 << ( aus_loc*2 )    )

            );;

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://

        /** If the tile value we set down was different than **/
        /** It was previously, maybe we should return        **/
        /** a ONE( 1 ) to signify that.                      **/
        return( til_val != old_val );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Get(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08* til_val   /** [ val_cur / til_val ]          ...**/
    )
    {
        /** ************************************************ **/
        /** NOTE: This code is almost a cut+paste of         **/
        /**       the "Put" code. The "old_val" variable     **/
        /**       from the "Put" code is what we want        **/
        /**       to return from this function via           **/
        /**       an OUTPUT PARAMETER.                       **/
        /** ************************************************ **/
        //:references_are_never_null:------------------------://

            assert( ((void*)0) != til_val );

        //:------------------------:references_are_never_null://
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );
            I16 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I16 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I16 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
            U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
            U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );

            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                assert(       chk_glo_com  == ((U32)glo_com) );
                assert( ((I16)chk_glo_com) == (     glo_com) );
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
        ////    arr_dex =(         glo_com + 3 );
                var_u08 = CPU_PIX[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
        ////    arr_dex =(         glo_com + 2 );
                var_u08 = CPU_PIX[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
        ////    arr_dex =(         glo_com + 1 );
                var_u08 = CPU_PIX[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

        ////    arr_dex =(         glo_com + 0 );
                var_u08 = CPU_PIX[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:GET]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 4H 08M 50S ]
                We can nuke most of the bit shifting
                code copied from the "Put(..)" function
                and just keep the fetch of "old_val".
                "old_val" is the value we want to load
                into the output parameter "til_val".

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://
        //:return_via_output_param:--------------------------://

            /** ******************************************** ***
            til_val | old_val : DECIMAL [  0 |  1 |  2 |  3 ]   
            til_val | old_val : BINARY  [ 00 | 01 | 10 | 11 ]   
            *** ******************************************** **/

            (*til_val)=( old_val );

        //:--------------------------:return_via_output_param://
        
        return; //:<---- Return Via Output Param
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  I16                                           //: 02 ://
#undef  I32                                           //: 03 ://
#undef  U32                                           //: 04 ://
#undef  ERR                                           //: 05 ://
//:=================================:PAINT5D_QUARKMAP_GET_PUT://
//:=================================:PAINT5D_QUARKMAP_PUT_GET://
//:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS:==================://
//:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD:=======================://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 03 ://
#define ERR  aac2020_paint5d_Halt                     //: 04 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Get_BrushState( void )
    {   
        //: @VID_IID[ 0077 ]TIME[ 01H 20M 14S ]
        //:IDN_A_HF_FM_HF
        //:I_DONT_NEED_A_HELPER_FUNCTION_FOR_MY_HELPER_FUNCTION
        ERR("[IDN_A_HF_FM_HF:YEAR:2021]");
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Put_BrushState(

        /** @VID_IID[ 0076 ]TIME[ 5H 45M 00S ] ************* **/
        /** Inputs are I32 instead of their range of         **/
        /** U08 because they will have to be upcasted to     **/
        /** U32 anyways, so why not use I32 so we can        **/
        /** have better range checking debugs?               **/
        /** ************************************************ **/
        I32 t_q //: 01 : til_qua  : Tile Quadrant
    ,   I32 t_e //: 02 : til_exp  : Tile Exponent  
    ,   I32 t_l //: 03 : til_lay  : Tile Layer  
    ,   I32 l_x //: 04 : loc_t_x  : Local Tile Location X  
    ,   I32 l_y //: 05 : loc_t_y  : Local Tile Location Y  
    ,   I32 a_d //: 06 : aus_dex  : AUSet_inDEX  
    ,   I32 t_v //: 07 : til_val  : Tile Value  
                //[      til_val is the LAST parameter       ]//
                //[      because this is the parameter order ]//
                //[      of the function AAC2020_PAINT5D_Put ]//
                //[      @VID_IID[ 0076 ]TIME[ 05H 57M 55S ] ]//
    )
    {
        /** @VID_IID[ 0077 ]TIME[ 5H 42M 00S ] ************* **/
        /** Set Unused Values 1,2,3 to ALL ONE BITS  ....... **/
        /** So that they ensure a memory stomp if    ....... **/
        /** our code makes a mistake as to where     ....... **/
        /** to put the bits.                         ....... **/
        /**        0xRrGgBbAb                        ....... **/
        U32 u_1 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #1 **/
        U32 u_2 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #2 **/
        U32 u_3 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #3 **/
        /** ************************************************ **/

        //:7_brush_vars_bounds_check:INPUTS:-----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://

            I32 max_l_x =( 0 - 1230123 );
            I32 max_l_y =( 0 - 1230123 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            assert( t_q >= 0 && t_q <= MAX_t_q );     //: 01 ://
            assert( t_e >= 0 && t_e <= MAX_t_e );     //: 02 ://
            assert( t_l >= 0 && t_l <= MAX_t_l );     //: 03 ://
            assert( l_x >= 0 && l_x <= max_l_x );     //: 04 ://
            assert( l_y >= 0 && l_y <= max_l_y );     //: 05 ://
            assert( a_d >= 0 && a_d <= MAX_a_d );     //: 06 ://
            assert( t_v >= 0 && t_v <= MAX_t_v );     //: 07 ://
                                                             
        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        //////  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        #undef  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:-----------------:7_brush_vars_bounds_check:INPUTS://
        //:7_brush_vars_int_overflow_chk:INPUTS:-------------://

            /** Make sure a DOWNCAST and then UPCAST         **/
            /** truncates the U32 to only 8 set bits max.    **/

            assert(    (U32)(U08)0xFFFFFFFF <= 0xFF  );

            assert(  ( (I32)(U08)t_q ) == t_q );      //: 01 ://
            assert(  ( (I32)(U08)t_e ) == t_e );      //: 02 ://
            assert(  ( (I32)(U08)t_l ) == t_l );      //: 03 ://
            assert(  ( (I32)(U08)l_x ) == l_x );      //: 04 ://
            assert(  ( (I32)(U08)l_y ) == l_y );      //: 05 ://
            assert(  ( (I32)(U08)a_d ) == a_d );      //: 06 ://
            assert(  ( (I32)(U08)t_v ) == t_v );      //: 07 ://

        //:-------------:7_brush_vars_int_overflow_chk:INPUTS://
        //:Put:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   (U32)t_q, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   (U32)t_e, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   (U32)t_l, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   (U32)l_x, u_1,u_2,u_3   //:    L_X ====== B_X
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   (U32)l_y, u_1,u_2,u_3   //:    L_Y ====== B_Y
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   (U32)a_d, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   (U32)t_v, u_1,u_2,u_3
            );;

        //:------------------------------:Put:All_Brush_State://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Put_UsingBrush( void )
    {
        //:Declare_Brush_State_Variables:--------------------://

            /** U32 values used with: "AAC2020_TAUDEPO_Get"  **/

            U32 t_q = ( /** til_qua **/ 1001001 /** @TRAP@ **/);
            U32 t_e = ( /** til_exp **/ 2002002 /** @TRAP@ **/);
            U32 t_l = ( /** til_lay **/ 3003003 /** @TRAP@ **/);
            U32 l_x = ( /** loc_t_x **/ 4004004 /** @TRAP@ **/);
            U32 l_y = ( /** loc_t_y **/ 5005005 /** @TRAP@ **/);
            U32 a_d = ( /** aus_dex **/ 6006006 /** @TRAP@ **/);
            U32 t_v = ( /** til_val **/ 7007007 /** @TRAP@ **/);

            /** U08 values used with: "AAC2020_PAINT5D_Put"  **/

            U08 til_qua = ( /** t_q **/ 101 /** @TRAP@ **/);
            U08 til_exp = ( /** t_e **/ 102 /** @TRAP@ **/);
            U08 til_lay = ( /** t_l **/ 103 /** @TRAP@ **/);
            U08 loc_t_x = ( /** l_x **/ 104 /** @TRAP@ **/);
            U08 loc_t_y = ( /** l_y **/ 105 /** @TRAP@ **/);
            U08 aus_dex = ( /** a_d **/ 106 /** @TRAP@ **/);
            U08 til_val = ( /** t_v **/ 107 /** @TRAP@ **/);

            /** @VID_IID[ 0077 ]TIME[ 2H 19M 50S ] **/
            /** KEEP_U_1_U_2_U_3_INITED_TO_ZERO    **/
            U32 u_1 =( 0 ); //:Unused #1
            U32 u_2 =( 0 ); //:Unused #2
            U32 u_3 =( 0 ); //:Unused #3

        //:--------------------:Declare_Brush_State_Variables://
        //:Get:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Get(        //:  001  ://
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   &(t_q),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  002  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   &(t_e),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  003  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   &(t_l),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  004  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   &(l_x),&(u_1),&(u_2),&(u_3) //:L_X ====== B_X
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  005  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   &(l_y),&(u_1),&(u_2),&(u_3) //:L_Y ====== B_Y
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  006  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   &(a_d),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  007  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   &(t_v),&(u_1),&(u_2),&(u_3)
            );;

        //:------------------------------:Get:All_Brush_State://
        //:7_brush_vars_bounds_check:OUTPUTS:----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://
        
        #define A assert

            U32 max_l_x =( 0 );
            U32 max_l_y =( 0 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            /** Range_Check_Extracted_Variables **/

            A( ((I32)t_q)+0 >= 0 && t_q <= MAX_t_q ); //: 01 ://
            A( ((I32)t_e)+0 >= 0 && t_e <= MAX_t_e ); //: 02 ://
            A( ((I32)t_l)+0 >= 0 && t_l <= MAX_t_l ); //: 03 ://
            A( ((I32)l_x)+0 >= 0 && l_x <= max_l_x ); //: 04 ://
            A( ((I32)l_y)+0 >= 0 && l_y <= max_l_y ); //: 05 ://
            A( ((I32)a_d)+0 >= 0 && a_d <= MAX_a_d ); //: 06 ://
            A( ((I32)t_v)+0 >= 0 && t_v <= MAX_t_v ); //: 07 ://
                        
        #undef  A

        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        #undef  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        //////  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:----------------:7_brush_vars_bounds_check:OUTPUTS://
        //:7_brush_vars_int_overflow_chk:OUTPUTS-------------://

            /** overflow_check___AND___assignment **/

            til_qua = (         (U08)  t_q   );       //: 01 ://
            til_exp = (         (U08)  t_e   );       //: 02 ://
            til_lay = (         (U08)  t_l   );       //: 03 ://
            loc_t_x = (         (U08)  l_x   );       //: 04 ://
            loc_t_y = (         (U08)  l_y   );       //: 05 ://
            aus_dex = (         (U08)  a_d   );       //: 06 ://
            til_val = (         (U08)  t_v   );       //: 07 ://

            assert( til_qua == ( (U32) t_q ) );       //: 01 ://
            assert( til_exp == ( (U32) t_e ) );       //: 02 ://
            assert( til_lay == ( (U32) t_l ) );       //: 03 ://
            assert( loc_t_x == ( (U32) l_x ) );       //: 04 ://
            assert( loc_t_y == ( (U32) l_y ) );       //: 05 ://
            assert( aus_dex == ( (U32) a_d ) );       //: 06 ://
            assert( til_val == ( (U32) t_v ) );       //: 07 ://
     
        //:------------:7_brush_vars_int_overflow_chk:OUTPUTS://
        //:Call_Core_Command:::PUT:--------------------------://
        //:MAIN_DATA_INTERFACE:PUT:--------------------------://

            AAC2020_PAINT5D_Put(
    /*1*/       til_qua    /** Auset Tile Sub Quadrant Index **/
    /*2*/   ,   til_exp    /** TileExponent (TileSizeEnum)   **/
    /*3*/   ,   til_lay    /** TileLayer .................   **/
    /*4*/   ,   loc_t_x    /** Local Tile X Coord / b_x      **/
    /*5*/   ,   loc_t_y    /** Local Tile Y Coord / b_y      **/
    /*6*/   ,   aus_dex    /** AUSet_inDEX (AutoTileSetIndex)**/
    /*7*/   ,   til_val    /** [ val_cur / til_val ]         **/
            );;

        //:--------------------------:MAIN_DATA_INTERFACE:PUT://
        //:--------------------------:Call_Core_Command:::PUT://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  ERR                                           //: 04 ://
//:==================:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS://
//:=======================:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD://
//:FUNCTIONS_WIRED_INTO_KEYBOARD:============================://
//:TAU:UNIFORM_CONTROLLER_FUNCTIONS:=========================://
#define CAP aac2020_paint5d_i32_Cap_u32               //: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 03 ://
#define U16 uint16_t /** GCC: <stdint.h> **/          //: 04 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 05 ://
#define ERR aac2020_paint5d_Halt                      //: 06 ://

    void
    aac2020_paint5d_MoveCamera_XY(
        I32 tra_i_x  //: Amount to translate in pixels: X-axis
    ,   I32 tra_i_y  //: Amount to translate in pixels: Y-axis
    )
    {
        AAC2020_TAUTYPE_rec_inc_Tran(
            AAC2020_TAUDEPO.TAU_015  /** TAU Block Index     **/
        ,   AAC2020_TAUDEPO.PAINT5D  /** SubSystem ==PAINT5D **/
        ,   AAC2020_TAUDEPO.P5D_VP1  /** VP1: Viewport #1    **/
        ,   tra_i_x  /** TRAnslation_Integer_amount_X        **/
        ,   tra_i_y  /** TRAnslation_Integer_amount_Y        **/
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ZoomCamera(
        I32 zom_i32 //: Amount To Zoom In And Out In Pixels
    )
    {
        AAC2020_TAUTYPE_rec_inc_ZoomPull(
            AAC2020_TAUDEPO.TAU_015  
        ,   AAC2020_TAUDEPO.PAINT5D  
        ,   AAC2020_TAUDEPO.P5D_VP1  
        ,   zom_i32  
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_MoveBrush_XY(
        I32 o_x //: offset:X
    ,   I32 o_y //: offset:Y
    )
    {
        U32 b_x =( 0x00 );
        U32 b_y =( 0x00 );
        U32 u_1 ; //:Unused #1
        U32 u_2 ; //:Unused #2
        U32 u_3 ; //:Unused #3

        /** @VID_IID[ 0066 ]TIME[ 03H 59M 25S ]    **/
        /** #_TILE_SIZE_AFFECTS_CAMERA_POSITION_#  **/

        //:brush_coords:READ:--------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

        //:--------------------------------:brush_coords:READ://
        //:brush_coords:TRANSFORM:---------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0066 ]TIME[ 4H 56M 23S ]           **/
            /** The SMALLEST tile value results in a level   **/
            /** map size that is 256x256 tiles.              **/
            /**                                              **/
            /** This is because HALF of 512 is 256.          **/
            /** And we pack our tilemap data in a            **/
            /** mip-map like geometrical packing pattern.    **/
            /**                                              **/
            /** Been referring to that data structure as     **/
            /** a "QUARKMAP" / "QUARK_MAP"                   **/
            /** ******************************************** **/

            /** #_TILE_EXPONENT_AFFECTS_CAMERA_POSITION_#    **/

            U32 til_exp=( 0xFFFFFFFF ); /** TILE_EXPONENT    **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR == til_exp
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

            U16 m_c; /** m_c : Max_Coordinate ( x | y ) **/
            assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
            assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
            m_c = aac2020_paint5d_til_exp_CTO_max_cor(til_exp);

            b_x = CAP( ((I32)b_x) + o_x , (U16)0 , (U16)m_c );
            b_y = CAP( ((I32)b_y) + o_y , (U16)0 , (U16)m_c );

        //:---------------------------:brush_coords:TRANSFORM://
        //:brush_coords:WRITE:-------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X     //:DEX_VAR
            ,   (b_x), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y     //:DEX_VAR
            ,   (b_y), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

        //:-------------------------------:brush_coords:WRITE://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileValue( 
        I32 del_t_v /** Delta: TileValue( t_v ) **/
    )
    {
        /** @VID_IID[ 0066 ]TIME[ 05H 34M 55S ] **/
        /** #_MORE_NAMES_MORE_PROBLEMS_# ...... **/

        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            til_val =CAP( 
                (I32)til_val + del_t_v 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileExponent( 
        I32 del_t_e /** Delta: TileExponent( t_e ) **/
    )
    {
        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            til_val =CAP( 
                (I32)til_val + del_t_e 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileLayer( 
        I32 del_t_l /** DELta_Tile_Layer **/
    )
    {
        U32 til_lay; /** [ TileLayer / Tile_Layer / til_lay ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,  &(til_lay),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://
 
            til_lay =CAP( 
                (I32)til_lay + del_t_l 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 2 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,   (til_lay), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ToggleTile( void )
    {
        //:variable_declarations:----------------------------://

            /// t_x =  ENDED_UP_USING[ loc_t_x ]INSTEAD ////////
            /// t_y =  ENDED_UP_USING[ loc_t_y ]INSTEAD ////////

            U32 b_x = ( 0 + 123000123 ); /** b_x : brush_x **/
            U32 b_y = ( 0 + 123000123 ); /** b_y : brush_y **/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 04H 23M 45S ]

                val_bru :
                    Current[ til_val ]loaded into Josh's
                    tile brush. This is what he is 
                    currently painting with.

                val_cur :
                    Current[ til_val ]found on the canvas
                    that Josh is painting on. More precisely
                    a[ til_val ]encoded into a section
                    of a BYTE of an RGBA pixel stored in
                    a cpu side bitmap known as:

                    AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/

            U32 til_qua =( 1234 ) ;  /**Tile_Quadrant_000_002**/
            U32 til_exp =( 2345 ) ;  /**EXPONENT ( P5D_T_E ) **/
            U32 til_lay =( 3456 ) ;  /**   LAYER ( P5D_T_L ) **/
            U32 loc_t_x =( 4567 ) ;  /**LOCAL__X ( P5D_B_X ) **/
            U32 loc_t_y =( 5678 ) ;  /**LOCAL__Y ( P5D_B_Y ) **/
            U32 aus_dex =( 6789 ) ;  /**Auset_Index_000_015  **/
        //: U32 til_val =( ---- ) ;  /** THIS IS[ val_bru ]  **/

            U32 val_bru =( 4433 ) ;  /** LOADED INTO BRUSH   **/    
            U32 val_cur =( 3344 ) ;  /** ON THE TILEMAP      **/
            U32 val_put =( 1212 ) ;  /** Actual Value To Put **/

            U08 til_val =(  111 ) ;  /** val_cur BUT 8 bits  **/
            assert( 1 == sizeof( til_val ) ); /** 1 BYTE **/

            U32 u_1 ; //: unused_number_001 ://
            U32 u_2 ; //: unused_number_002 ://
            U32 u_3 ; //: unused_number_003 ://
  
        //:----------------------------:variable_declarations://
        //:GET_STATE:OF_BRUSH:-------------------------------://
        /** ************************************************ ***
        Variables we need from this section:
        1:  til_qua <---- P5D_T_Q
        2:  til_exp <---- P5D_T_E
        3:  til_lay <---- P5D_T_L
        4:  loc_t_x <---- P5D_B_X ( brush.xy === local.xy )
        5:  loc_t_y <---- P5D_B_Y ( brush.xy === local.xy )
        6:  aus_dex <---- P5D_A_D
        7:  val_bru <---- P5D_T_V ( til_val  === val_bru  )
        *** ************************************************ **/
            //:GET_STATE:til_qua:----------------------------://

                //: get_tile_value_loaded_into_brush ://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR : til_qua
                ,  &(til_qua),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_qua://
            //:GET_STATE:til_exp:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : til_exp
                ,  &(til_exp),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_exp://
            //:GET_STATE:til_lay:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : til_lay
                ,  &(til_lay),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_lay://
            //:GET_STATE:loc_t_x:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR : brush_x
                ,  &(loc_t_x),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_x://
            //:GET_STATE:loc_t_y:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR : brush_y
                ,  &(loc_t_y),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_y://
            //:GET_STATE:aus_dex:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR : aus_dex
                ,  &(aus_dex),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:aus_dex://
            //:GET_STATE:val_bru:----------------------------://
            //:GET_STATE:til_val:----------------------------://

                //: get_tile_value_loaded_into_brush ://
                //[  til_val ==== val_bru ]//

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : til_val
                ,  &(val_bru),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_val://
            //:----------------------------:GET_STATE:val_bru://

        //:-------------------------------:GET_STATE:OF_BRUSH://
        //:get_current_value_on_tile_map:--------------------://
    
            /** ******************************************** **/
            /**   @VID_IID[ 0066 ]TIME[ 07H 27M 23S ]        **/
            /**   @_CTRL_F_HELP_@                            **/
            /**   WRONG[ AAC2020_PAINT5D_TileValue_GET ]     **/
            /**   WRONG[ AAC2020_PAINT5D_GetTileValue  ]     **/
            /** CORRECT[ AAC2020_PAINT5D_Get           ]     **/
            /** ******************************************** **/
    
            /** @VID_IID[ 0066 ]TIME[ 08H 14M 15S ] ******* **/
            /** #_WHY_PAINT5D_GET_PARAM_ORDER_# **/
            AAC2020_PAINT5D_Get(
                til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]     **/
            ,   til_exp   /** 02 :  IN[ PAINT5D.D._    ]     **/
            ,   til_lay   /** 03 :                           **/
            ,   loc_t_x   /** 04 : For diagrams explaining   **/
            ,   loc_t_y   /** 05 : these parameters.         **/
            ,   aus_dex   /** 06 : @VID_IID[ 0075 ]          **/
            ,&( til_val ) /** 07 : @TIME[ 2H 46M 20S ]       **/
            );;
                
            /** ******************************************** ***
                @VID_IID[ 0075 ]TIME[ 2H 50M 30S ]       
                Necessary because of the different bit   
                widths required by different functions.  
            *** ******************************************** **/

            val_cur = til_val ;

            /** ******************************************** **/

        //:--------------------:get_current_value_on_tile_map://
        //:brush_coords:READ:--------------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0075 ]TIME[ 01H 41M 32S ]          **/
            /** This is a bit redundant. Looks like we had   **/
            /** some confusion on our variable names.        **/
            /** Lets just use [ b_x , b_y ] as a redundancy  **/
            /** to check our work I guess.                   **/
            /** ******************************************** **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            assert( loc_t_x == b_x ); //:@_IDENTICAL_VALUES_@://
            assert( loc_t_y == b_y ); //:@_IDENTICAL_VALUES_@://

        //:--------------------------------:brush_coords:READ://
        //:SET_OR_UNSET_THE_TILE:----------------------------://

            /** ******************************************** ***
                If the value loaded into the brush is the
                same value as the value currently on the
                tilemap, we will [ UNSET / ERASE ]the tile.

                If the tile values DO NOT MATCH, then
                we will [ SET / OVERWRITE ] the tile.
            *** ******************************************** **/

            if( val_bru != val_cur ){  /** [ OVERWRITE ] **/

                val_put = val_bru; 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]

            }else
            if( val_bru == val_cur ){  /** [ERASE/UNSET] **/

                /** **************************************** **/
                /**                                          **/
                /** @VID_IID[ 0075 ]TIME[ 1H 54M 00S ]       **/
                /**                                          **/
                /** By convention, the zero tile will        **/
                /** mean empty space. However the code       **/
                /** should NOT be like gamemaker. We should  **/
                /** NOT treat tile zero any differently      **/
                /** when running code on it. Thus if we      **/
                /** really wanted to, we could put a         **/
                /** pattern in tile value zero. For          **/
                /** example, the void of space. Like a       **/
                /** "star space" tile or something.          **/
                /**                                          **/
                /** Example Void Of Space Tile:              **/
                /** youtube.com/watch?v=tl40xidKF-4&t=1m25s  **/
                /** **************************************** **/

                val_put = ( 0 ); 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]

            }else{
                ERR("[EDCL:2021_01_02:PAINT5D]");
            };;

            assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                    //:[ 00 | 01 | 10 | 11 ]

            AAC2020_PAINT5D_Put(
                  til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]   **/
            ,     til_exp   /** 02 :  IN[ PAINT5D.D._    ]   **/
            ,     til_lay   /** 03 :                         **/
            ,     loc_t_x   /** 04 : For diagrams explaining **/
            ,     loc_t_y   /** 05 : these parameters.       **/
            ,     aus_dex   /** 06 : @VID_IID[ 0075 ]        **/
            ,(U08)val_put   /** 07 : @TIME[ 2H 44M 48S ]     **/
            );;

        //:----------------------------:SET_OR_UNSET_THE_TILE://
        return;
    }

#undef  CAP                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  U16                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  ERR                                           //: 06 ://
//:=========================:TAU:UNIFORM_CONTROLLER_FUNCTIONS://
//:============================:FUNCTIONS_WIRED_INTO_KEYBOARD://
//:KEYBOARD_HANDLER:(KeyInn):================================://
#define I32 int32_t /** GCC: <stdint.h> **/
#define DEX_EDI_paint5d ( 1 )
#define KEY_P5D ( AAC2020_KEYBIND.PAINT5D )
    
    I32
    aac2020_paint5d_KeyInn( signed char chr_key )
    {
        I32 res_var =( 0 );

        //:CAMERA_CONTROL:-----------------------------------://

            //:MoveCamera_XY:--------------------------------://
            /** ******************************************** ***

                #_CTRL_F_HELP_#

                p5d_cam_lef ===> p5d_vp1_lef  
                p5d_cam_rig ===> p5d_vp1_rig  
                p5d_cam_upp ===> p5d_vp1_upp  
                p5d_cam_dow ===> p5d_vp1_dow  
                                              
                p5d_cam_z_o ===> p5d_vp1_z_o  
                p5d_cam_z_i ===> p5d_vp1_z_i  

            *** ******************************************** **/

            if( chr_key == KEY_P5D.p5d_vp1_lef ){
                aac2020_paint5d_MoveCamera_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_rig ){
                aac2020_paint5d_MoveCamera_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_vp1_upp ){
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_dow ){         
                aac2020_paint5d_MoveCamera_XY( 0 * 0 , 0 + 1 );
            };;

            //:--------------------------------:MoveCamera_XY://
            //:ZoomCamera:-----------------------------------://

            if( chr_key == KEY_P5D.p5d_vp1_z_o ){
                aac2020_paint5d_ZoomCamera( 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_vp1_z_i ){         
                aac2020_paint5d_ZoomCamera( 0 + 1 );
            };;

            //:-----------------------------------:ZoomCamera://

        //:-----------------------------------:CAMERA_CONTROL://
        //:MOVE_BRUSH:---------------------------------------://

            if( chr_key == KEY_P5D.p5d_bru_lef ){
                aac2020_paint5d_MoveBrush_XY( 0 - 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_rig ){
                aac2020_paint5d_MoveBrush_XY( 0 + 1 , 0 * 0 );
            }else
            if( chr_key == KEY_P5D.p5d_bru_upp ){
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 - 1 );
            }else                                     
            if( chr_key == KEY_P5D.p5d_bru_dow ){         
                aac2020_paint5d_MoveBrush_XY( 0 * 0 , 0 + 1 );
            };;

        //:---------------------------------------:MOVE_BRUSH://
        //:TILE_VALUE(T_V):----------------------------------://
        
            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_V  +//

            /** @VID_IID[ 0066 ]TIME[ 03H 40M 05S ] **/
            /** WHY CALLED: TileValueDeltaMutate    **/

            if( chr_key == KEY_P5D.p5d_v_n ){ //:n:NEXT
                /** HERE[ Bak_Til | PrevTile | PreviousTile ]**/
                aac2020_paint5d_DeltaMutate_TileValue( 0 + 1 );
            }else
            if( chr_key == KEY_P5D.p5d_v_b ){ //:b:BACK
                /** HERE[ Nex_Til() | NextTile(...) ] **/
                aac2020_paint5d_DeltaMutate_TileValue( 0 - 1 );
            };;

        //:----------------------------------:TILE_VALUE(T_V)://
        //:TILE_EXPONENT(T_E):-------------------------------://

            //+  DATA : AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_E  +//

            if( chr_key == KEY_P5D.p5d_e_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileExponent(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_e_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileExponent(0 -1);
            };;

        //:-------------------------------:TILE_EXPONENT(T_E)://
        //:TILE_LAYER_0_TO_2(T_L):---------------------------://

            if( chr_key == KEY_P5D.p5d_l_n ){ //:n:NEXT
                aac2020_paint5d_DeltaMutate_TileLayer(0 +1);
            }else
            if( chr_key == KEY_P5D.p5d_l_b ){ //:b:BACK
                aac2020_paint5d_DeltaMutate_TileLayer(0 -1);
            };;


        //:---------------------------:TILE_LAYER_0_TO_2(T_L)://
        //:TILE_TOGGLE:--------------------------------------://

            if( chr_key == KEY_P5D.p5d_tog ){ //:toggle
                aac2020_paint5d_ToggleTile( );
            };;

        //:--------------------------------------:TILE_TOGGLE://

        return( res_var );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32
    PAINT5D_KeyInn( signed char chr_key )
    {
        I32 res_var=( 0 );

        /** @VID_IID[ 0066 ]TIME[ 0H 19M 48S ] ............. **/
        /** PAINT5D is ALWAYS sub-system #1 which            **/
        /** Is assigned to the number 1, both in code        **/
        /** and in the key on the numpad it corresponds to   **/
        assert( DEX_EDI_paint5d == AAC2020_CEDITOR_paint5d );;
        if(     DEX_EDI_paint5d == AAC2020_CEDITOR_dex_edi ){

            res_var = aac2020_paint5d_KeyInn( chr_key );

        };;
    
        /** @IMPLICIT_INTERFACE[ KeyInn ] ****************** **/
        /** @VID_IID[ 0066 ]TIME[ 0H 30M 30S ] ..............**/
        /** Don't have a use for return code yet.    ........**/
        /** but we should be consistent with all of  ........**/
        /** our different keyboard handlers.         ........**/
        /** ************************************************ **/
        return( res_var );
    }

#undef  DEX_EDI_paint5d
#undef  I32
#undef  KEY_P5D
//:================================:KEYBOARD_HANDLER:(KeyInn)://
//:SECTION_UNIT_TEST:========================================://
//:UNIT_TEST_SECTION:========================================://
#define MAX_EXP AAC2020_PAINT5D_MAX_til_exp           //: 01 ://
#define EXT      extern                               //: 02 ://
#define VOD        void                               //: 03 ://
#define I08      int8_t /** GCC: <stdint.h> **/       //: 04 ://
#define U08     uint8_t /** GCC: <stdint.h> **/       //: 05 ://
#define I16     int16_t /** GCC: <stdint.h> **/       //: 06 ://
#define U16    uint16_t /** GCC: <stdint.h> **/       //: 07 ://
#define I32     int32_t /** GCC: <stdint.h> **/       //: 08 ://
#define U32    uint32_t /** GCC: <stdint.h> **/       //: 09 ://
#define ERR     aac2020_paint5d_Halt                  //: 10 ://
#define LOG     aac2020_paint5d_Info_any              //: 11 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    AAC2020_PAINT5D_UnitTest( U32 u32 )
    {
        extern U32 aac2020_paint5d_UnitTest( U32 );
                   aac2020_paint5d_UnitTest( u32 );

        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_UnitTest( U32 u32 )
    {
        if( u32 ){  /** Reserved For Future Use **/  };

        /** ************************************************ ***
            ProgControls: 
                Progmattic functions that the end user does
                not directly interface with.

            TestControls: @VID_IID[ 0076 ]T[ 4H 56M 15S ]
                These are controls that may fit into
                the "ProgControls" or the "UserControls"
                category. But the MAIN THING about them
                is that they have been created in order
                to effectively test our "UserControls"
                section. Thus must be called AFTER
                "ProgControls" and BEFORE "UserControls"
            
            UserControls:
                Functions that are directly or near
                directly called as the result of 
                user input such as key presses.
    
                For example( S ):
                    aac2020_paint5d_ToggleTile
                    aac2020_paint5d_MoveBrush_XY
        *** ************************************************ **/
        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/
            
            AAC2020_PIXBACK_Backup_taudirt( &(taudirt) );
            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

            AAC2020_TODOMAN_Vital(
                "[FIX:taudirt_backup_is_invalid_back_reference]"
            );;

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://

            EXT VOD 
            aac2020_paint5d_UnitTest_ProgControls( VOD );
            aac2020_paint5d_UnitTest_ProgControls(     );

            EXT VOD 
            aac2020_paint5d_UnitTest_TestControls( VOD );
            aac2020_paint5d_UnitTest_TestControls(     );

            EXT VOD 
            aac2020_paint5d_UnitTest_UserControls( VOD );
            aac2020_paint5d_UnitTest_UserControls(     );

        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                AAC2020_PIXBACK_Restore_taudirt( &(taudirt) );
                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://
        //:------------------------------:SYSTEM_DATA:RESTORE://

        return( 0x00 );
    }
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_paint5d_UnitTest_TestControls( void )
    {
        /** @VID_IID[ 0076 ]TIME[ 5H 00M 00S ]               **/
        /** Even if these eventually get wired into          **/
        /** our user controls, they will FOREVER stay        **/
        /** in the "TestControls" category, because that     **/
        /** is what they were initially created for and      **/
        /** also I am lazy and don't see much utility        **/
        /** to refactoring my unit test code for             **/
        /** a NON CODE BREAKING CHANGES                      **/

        EXT VOD aac2020_paint5d_UTC_Put_BrushState(    void   );
                aac2020_paint5d_UTC_Put_BrushState(/** void**/);

        EXT VOD aac2020_paint5d_UTC_Put_UsingBrush(    void   );
                aac2020_paint5d_UTC_Put_UsingBrush(/** void**/);

    }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_BrushState( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/ 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i =( ROW_S - 1 ); //:m_i: Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]

                    We are NOT going to create a 
                    aac2020_paint5d_Get_BrushState(...)
                    function to help test this code...

                    Because aac2020_paint5d_Put_BrushState
                    itself was created as a HELPER function
                    to help run UNIT TEST code.
                    
                    This has already spiraled enough
                    out of control. I don't want a 
                    Helper function for my helper function
                    that helps test my unit test code
                    for my actual function.
            
                    --------------------------------------------
                    Is this out of control
                    deductive reasonsing?

                    Or is it... "inductive reasoning?"

                    Or is it just "backwards reasoning"
                    because it is a linear chain?
                    --------------------------------------------
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_358AM]");

                    };;

                //:test_table_members:---------------:__chk__://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_UsingBrush( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://
            //:declare:vars_for:AAC2020_PAINT5D_Get:---------://


                U08 til_qua =( 204 );  //: 01 : t_q ://
                U08 til_exp =( 204 );  //: 02 : t_e ://
                U08 til_lay =( 204 );  //: 03 : t_l ://
                U08 loc_t_x =( 204 );  //: 04 : l_x ://
                U08 loc_t_y =( 204 );  //: 05 : l_y ://
                U08 aus_dex =( 204 );  //: 06 : a_d ://
                U08 til_val =( 204 );  //: 07 : t_v ://

            //:---------:declare:vars_for:AAC2020_PAINT5D_Get://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/  0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i = ( ROW_S - 1 ); //:Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]
                    COPIDED_FROM: 
                    aac2020_paint5d_UTC_Put_BrushState
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_410AM]");

                    };;

                //:test_table_members:---------------:__chk__://
                //:ACTUALLY_PUT_USING_THE_BRUSH_STATE:-------://

                    aac2020_paint5d_Put_UsingBrush( );

                //:-------:ACTUALLY_PUT_USING_THE_BRUSH_STATE://
                //:FETCH_TILE_VALUE_PUT:---------------------://

                    /** get a value encoded in the **/
                    /** [bitmap/texture] data      **/

                        AAC2020_PAINT5D_Get(
                            til_qua   /** t_q : 01 : **/
                        ,   til_exp   /** t_e : 02 : **/
                        ,   til_lay   /** t_l : 03 : **/
                        ,   loc_t_x   /** l_x : 04 : **/
                        ,   loc_t_y   /** l_y : 05 : **/
                        ,   aus_dex   /** a_d : 06 : **/
                        , &(til_val)  /** t_v : 07 : **/
                        );;

                    /** check that proper value was    **/
                    /** encoded in the [bitmap/texture **/

                        if( 0
                        || til_qua != t_q /** : 01 : **/
                        || til_exp != t_e /** : 02 : **/
                        || til_lay != t_l /** : 03 : **/
                        || loc_t_x != l_x /** : 04 : **/
                        || loc_t_y != l_y /** : 05 : **/
                        || aus_dex != a_d /** : 06 : **/
                        || til_val != t_v /** : 07 : **/
                        ){
                            ERR("[DO_DRAGONS_LIKE_GOLD_2021]");
                        };;
      
                //:---------------------:FETCH_TILE_VALUE_PUT://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UnitTest_UserControls( void )
        {

            EXT VOD 
            aac2020_paint5d_UTC_MoveCamera_XY( VOD );
            aac2020_paint5d_UTC_MoveCamera_XY(     );

            EXT VOD 
            aac2020_paint5d_UTC_ZoomCamera( VOD );
            aac2020_paint5d_UTC_ZoomCamera(     );

            EXT VOD 
            aac2020_paint5d_UTC_MoveBrush_XY( VOD );
            aac2020_paint5d_UTC_MoveBrush_XY(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileValue( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileValue(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileExponent( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileExponent(     );

            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileLayer( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileLayer(     );

            EXT VOD 
            aac2020_paint5d_UTC_ToggleTile( VOD );
            aac2020_paint5d_UTC_ToggleTile(     );
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveCamera_XY( void )
        {
        #define NUMBER_OF_TESTS ( 3 )
        #define NUMBER_OF_TEST_ELEMENTS ( 10 )
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 inn_x_0 ; /** INPUTS: Camera Rectangle **/
                U32 inn_x_1 ;
                U32 inn_y_0 ;
                U32 inn_y_1 ;
                            ;
                U32 tra_i_x ; /** INPUTS: Camera Translation **/
                U32 tra_i_y ;
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** **************************************** ***
                    @VID_IID[ 0076 ]TIME[ 1H 58M 30S ]

                    weird_names_because: 
                    We kept confusing

                         "Input And Output"
                    With "Expected And Actual"

                    And tangling our mental understanding
                    between the pairs of words.
                ** ***************************************** **/

                U32 O_A_x_0 ; /** OUTPUTS: Camera Rectangle  **/
                U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL values**/      
                U32 O_A_y_0 ;
                U32 O_A_y_1 ;
                            ;
                U32 exp_x_0 ; /** EXPECTED : Camera Rectangle**/
                U32 exp_x_1 ; /**                            **/
                U32 exp_y_0 ;
                U32 exp_y_1 ;

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://


            /** @VID_IID[ 0076 ]TIME[ 0H 59M 30S ]           **/
            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/

            /** PAB == "position and bounds" **/

            /** @VID_IID[ 0076 ]TIME[ 0H 56M 0S ] . . . . . .**/
            /** First 3 Tests are dead simple.    . . . . . .**/
            U32 tab_utc[ 
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
            0x00,0x00,0x00,0x00 , 0x00,0x00, 0x00,0x00,0x00,0x00
        ,   0x00,0x00,0x00,0x00 ,    1,0x00,    1,   1,0x00,0x00
        ,   0x00,0x00,0x00,0x00 , 0x00,   1, 0x00,0x00,   1,   1
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                tra_i_x = tab_utc[ bas + 4 ]; /**Translation **/
                tra_i_y = tab_utc[ bas + 5 ]; /**Integer:X&Y **/
 
                exp_x_0 = tab_utc[ bas + 6 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 7 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 8 ];
                exp_y_1 = tab_utc[ bas + 9 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 1H 10M 16S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveCamera_XY(
                        tra_i_x  //: Trans:DATAPIXELS: X
                    ,   tra_i_y  //: Trans:DATAPIXELS: Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){

                        failed_unit_test=( 1 );

                        /** ******************************** **/
                        /** @VID_IID[ 02H 13M 20S ]          **/
                        /** We originally decided rectangle  **/
                        /** manipulation was bounded into a  **/
                        /** 512x512 region. However for      **/
                        /** PAINT5D system the camera        **/
                        /** rectangle has a tighter          **/
                        /** 256x256 bounds.                  **/
                        /** SEE[ #_P5D_BOUNDING_#  ]         **/
                        /** ******************************** **/
                        LOG("[VP1_Cam_Bounds_Are_Tighter]",0);

                    };;
    
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[YOU_DONE_FAILED]");

                    };;

                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:MoveCamera_XY]" );
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ZoomCamera( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );

                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: data **/
                                ;
                    U32 inn_x_0 ; /** INPUTS: Camera Rect    **/
                    U32 inn_x_1 ;
                    U32 inn_y_0 ;
                    U32 inn_y_1 ;
                                ;
                    U32 zom_i32 ; /** INPUTS: Camera Zoom **/
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                    /** ************************************ ***
                        @VID_IID[ 0076 ]TIME[ 2H 39M 10S ]

                        weird_names_because: 
                        We kept confusing

                             "Input And Output"
                        With "Expected And Actual"

                        And tangling our mental understanding
                        between the pairs of words.
                    ** ************************************* **/

                    U32 O_A_x_0 ; /** OUT: Camera Rectangle  **/
                    U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL   **/      
                    U32 O_A_y_0 ;
                    U32 O_A_y_1 ;
                                ;
                    U32 exp_x_0 ; /** EXPECTED : Camera Rect **/
                    U32 exp_x_1 ; /**                        **/
                    U32 exp_y_0 ;
                    U32 exp_y_1 ;
                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //: inn_ inn_ inn_ inn_   zom_i32    exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
            0x00,0x00,0x00,0x00 ,   0x00   , 0x00,0x00,0x00,0x00
        ,   0x00,0x00,0x00,0x00 ,0+    1   , 0x00,0x00,   1,   1
        ,   0x00,0x00,0x00,0x00 ,0-    1   , 0x00,0x00,0x00,0x00
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                zom_i32 = tab_utc[ bas + 4 ]; /**Zoom_Amount **/
 
                exp_x_0 = tab_utc[ bas + 5 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 6 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 7 ];
                exp_y_1 = tab_utc[ bas + 8 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 2H 40M 00S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_ZoomCamera(
                        zom_i32  //: Trans:DATAPIXELS: X
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:ZOOM]",0);
                    };;
    
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[PAINT5D_ZOOM_TEST_FAILED]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:ZOOMCAMERA]" );
            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveBrush_XY( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 6 ) /**    SIX(6)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                U32     nouse_1         =( 666070666 );
                U32     nouse_2         =( 666070666 );
                U32     nouse_3         =( 666070666 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 bru_i_x ; /** INPUTS: Brush X/Y **/
                U32 bru_i_y ;

                I32 off_i_x ; /** INPUTS: Brush OFFSET X/Y **/
                I32 off_i_y ;  
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** #_WEIRD_UNIT_TEST_VAR_NAMES_O_A_# **/

                U32 O_A_b_x ; /** OUTPUTS: Brush[x,y]        **/
                U32 O_A_b_y ; /** O_A: OUTPUT & ACTUAL values**/      
                            ;
                U32 exp_b_x ; /** EXPECTED : Brush[x,y] .... **/
                U32 exp_b_y ; /**                       .... **/

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
                //: _i_x _i_y     _i_x _i_y     _b_x _b_y
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
                    0x00,0x00  ,  0x00,0x00  ,  0x00,0x00 
                ,   0x00,0x00  ,     1,0x00  ,     1,0x00 
                ,   0x00,0x00  ,  0x00,   1  ,  0x00,   1 
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                bru_i_x = tab_utc[ bas + 0 ]; /** SEEDING    **/
                bru_i_y = tab_utc[ bas + 1 ]; /** INIT_BRUSH **/
                //:                    #                     ://
                off_i_x = tab_utc[ bas + 2 ]; /**Translate   **/
                off_i_y = tab_utc[ bas + 3 ]; /** X & Y      **/
                //:                    #                     ://
                exp_b_x = tab_utc[ bas + 4 ]; /** EXPECTED   **/
                exp_b_y = tab_utc[ bas + 5 ]; /** OUTPUTS    **/
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                        #_WHAT_DOES_VP1_MEAN_IN_PAINT5D_#
                        #_WHAT_DOES_B_X_B_Y_MEAN_IN_PAINT5D_#

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    , ( bru_i_x ), ( nouse_1 )  //:BRUSH:X 
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    , ( bru_i_y ), ( nouse_1 )  //:BRUSH:X
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveBrush_XY(
                        off_i_x //: o_x : brush_OFFSET_integer_X
                    ,   off_i_y //: o_y : brush_OFFSET_integer_Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    ,&( O_A_b_x ),&( nouse_1 )  //:BRUSH:X 
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    ,&( O_A_b_y ),&( nouse_1 )  //:BRUSH:X
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;


                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_b_x  
                    !=  exp_b_x
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_b_y  
                    !=  exp_b_y
                    ){ failed_unit_test =( 1 ); };

                    /** ************************************ **/
                    /** FAIL BECAUSE OUT OF PAINT5D BOUNDS   **/
                    /** Which are tighter than the bounds    **/
                    /** for generic inclusive rectangle type **/
                    /** ************************************ **/
                    if( 0
                    ||  (((I32)  exp_b_x  )+0) < MIN_X_0 
                    ||  (((I32)  exp_b_y  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  exp_b_x  )+0) > MAX_X_1 
                    ||  (((I32)  exp_b_y  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:BRUSH_TRANS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[b_x:A|E]:(%d):(%d)\n"
                        , O_A_b_x , exp_b_x );;

                        printf("[b_y:A|E]:(%d):(%d)\n"
                        , O_A_b_y , exp_b_y );;

                        ERR("[PAINT5D_BRUSH_TRANS_FAIL]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_MORE_TEST_CASES:MoveBrush_XY]"
            );;

            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileValue( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_val ; /** INPUTS: Tile VAL       **/
                    I32 off_val ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_val ; /** EXPECTED : TILE VALUE  **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_val ; /** ACTUAL   : TILE VALUE  **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_val  |  off_val  |  exp_val
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_val  |  off_val  |  exp_val
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_val = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_val = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_val = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    , ( inn_val ), ( nouse_1 )  //:TILE_VALUE
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileValue(
                        off_val //: del_t_v ( Delta Tile Value )
                    );;  

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    ,&( act_val ),&( nouse_1 )  //:TILE_VALUE
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_VAL (            0            ) //01
                #define MAX_VAL AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act_val  
                    !=  exp_val
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_VAL < MAX_VAL );
                    if( 0
                    ||  (((I32)  exp_val  )+0) < MIN_VAL           
                    ||  (((I32)  exp_val  )+0) > MAX_VAL 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_VALUE_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_val:exp_val]:(%d):(%d)\n"
                        , act_val , exp_val );;

                        ERR("[BRUSH_TILE_VALUE_TEST_FAIL]");
                    };;
                #undef  MIN_VAL                       //: 01 ://
                #undef  MAX_VAL                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileValue]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileExponent( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_E ; /** INPUTS: Tile VAL       **/
                    I32 off_T_E ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_E ; /** EXPECTED :TILE EXPONENT**/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_E ; /** ACTUAL   :TILE EXPONENT**/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_E  |  off_T_E  |  exp_T_E
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_E  |  off_T_E  |  exp_T_E
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_E = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_E = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_E = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    , ( inn_T_E ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileExponent(
                        off_T_E //: del_t_e :............
                    );;         //: ( Delta Tile EXPONENT )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    ,&( act_T_E ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_E (            0            ) //01
                #define MAX_T_E AAC2020_PAINT5D_MAX_til_exp //02
 
                    if( act_T_E  
                    !=  exp_T_E
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_T_E < MAX_T_E );
                    if( 0
                    ||  (((I32)  exp_T_E  )+0) < MIN_T_E           
                    ||  (((I32)  exp_T_E  )+0) > MAX_T_E 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_EXPONENT_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_T_E:exp_T_E]:(%d):(%d)\n"
                        , act_T_E , exp_T_E );;

                        ERR("[BRUSH_TILE_EXPONENT_TEST_FAIL]");
                    };;
                #undef  MIN_T_E                       //: 01 ://
                #undef  MAX_T_E                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileExponent]"
            );;
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileLayer( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_L ; /** INPUTS: Tile LAYER     **/
                    I32 off_T_L ; /** INPUTS: LAY OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_L ; /** EXPECTED :TILE LAYER   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_L ; /** ACTUAL   :TILE LAYER   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_L  |  off_T_L  |  exp_T_L
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_L  |  off_T_L  |  exp_T_L
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_L = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_L = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_L = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    , ( inn_T_L ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileExponent(
                        off_T_L //: del_t_l :............
                    );;         //: ( Delta Tile LAYER )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    ,&( act_T_L ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_L (            0            ) //01
                #define MAX_T_L AAC2020_PAINT5D_MAX_til_lay //02
 
                    if( act_T_L  
                    !=  exp_T_L
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_L < MAX_T_L );
                    if( 0
                    ||  (((I32)  exp_T_L  )+0) < MIN_T_L           
                    ||  (((I32)  exp_T_L  )+0) > MAX_T_L 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_LAYER_IS_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_T_L:exp_T_L]:(%d):(%d)\n"
                        , act_T_L , exp_T_L );;

                        ERR("[BRUSH_TILE_LAYER_TEST_FAIL]");
                    };;
                #undef  MIN_T_L                       //: 01 ://
                #undef  MAX_T_L                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileLayer]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ToggleTile( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:misc_test_runner_vars:--------------------://

                    I32     failed_unit_test=( 0 );
 
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/

                //:--------------------:misc_test_runner_vars://
                //:initial_value(s):-------------------------://

                    U08  t_q ; //: til_qua (TILE QUADRANT     )
                    U08  t_e ; //: til_exp (TILE EXPONENT     )   
                    U08  t_l ; //: til_lay (TILE LAYER        )
                    U08  l_x ; //: loc_t_x (LOCAL TILE X      ) 
                    U08  l_y ; //: loc_t_y (LOCAL TILE Y      ) 
                    U08  a_d ; //: aus_dex (AUSET INDEX       )
                    U08  t_v ; //: til_val (INITIAL tile value)   

                //:-------------------------:initial_value(s)://    
                //:mutator_value(s):-------------------------://

                    U08  b_v ; //:MUST_LOAD_INTO_BRUSH!

                //:-------------------------:mutator_value(s)://
                //:expected_value(s):------------------------://

                    U08  exp ; /** EXPECTED :TILE VALUE   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U08  act ; /** ACTUAL   :TILE VALUE   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={                                
                //: t_v : INITIAL                tile_value
                //: exp : EXPECTED after command tile_value
                //: act : ACTUAL     (output)    tile_value
                //:     ( act should not be in this table )
                //: b_v : BRUSH VALUE 
                //:     ( value loaded into brush )
                                               
        //: t_q | t_e | t_l | l_x | l_y | a_d | t_v | b_v | exp
            0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   1 ,   0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   0 ,   0
            };;   //:THREE_ARE_TILE_VALUES: >>> ___ , ___ , ___
        //: 001   002   003   004   005   006   007   008   009

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                //:unpack_test_row_data:---------------------://

                    /** INITIAL_VALUE(S) **/
                    t_q = (U08) ( tab_utc[ bas + 0 ] );
                    t_e = (U08) ( tab_utc[ bas + 1 ] );              
                    t_l = (U08) ( tab_utc[ bas + 2 ] );
                    l_x = (U08) ( tab_utc[ bas + 3 ] );
                    l_y = (U08) ( tab_utc[ bas + 4 ] );
                    a_d = (U08) ( tab_utc[ bas + 5 ] );
                    t_v = (U08) ( tab_utc[ bas + 6 ] );

                    /** mutator_value(s)  **/
                    b_v = (U08) ( tab_utc[ bas + 7 ] );  

                    /** expected_value(s) **/
                    exp = (U08) ( tab_utc[ bas + 8 ] ); 
              
                //:---------------------:unpack_test_row_data://
                //:OVERWRITE_til_val_WITH_BRUSH:-------------://
        
                    /** Seed Tile Data Location With The **/
                    /** Initial Value .................. **/

                        /** Load brush with all of it's state**/
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent)
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   t_v //: INITAL / OVERWRITE VALUE
                        );;

                        /** Like ToggleTile , but is an      **/
                        /** override rather than a toggle.   **/                 
                        aac2020_paint5d_Put_UsingBrush( );

                //:-------------:OVERWRITE_til_val_WITH_BRUSH://
                //:apply_tile_toggle_action:-----------------://

                    /** Set the brush value you want to      **/
                    /** test the ToggleTile( ) command with  **/
                         
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent) 
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   b_v //: <-- t_v __SWAPPED_TO__ b_v
                        );;

                    /** Uses what is loaded into the tilemap **/
                    /** to determine the results.            **/

                        aac2020_paint5d_ToggleTile( );

                //:-----------------:apply_tile_toggle_action://
                //:get_ACTUAL_value_set_into_bitmap:---------://

                    /** @VID_IID[ 2H 55M 40S ] ************* **/
                    /** More abstractly explained:           **/
                    /** Get the tile value at this location  **/
                    /** within the paint5d tilemap data.     **/
                    /** ************************************ **/

                    AAC2020_PAINT5D_Get(
                            t_q   /** 01 :         til_qua   **/  
                    ,       t_e   /** 02 :         til_exp   **/  
                    ,       t_l   /** 03 :         til_lay   **/  
                    ,       l_x   /** 04 :         loc_t_x   **/  
                    ,       l_y   /** 05 :         loc_t_y   **/  
                    ,       a_d   /** 06 :         aus_dex   **/  
                    ,  &(   act ) /** 07 : GET ACT til_val   **/
                    );;

                //:---------:get_ACTUAL_value_set_into_bitmap://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_V (            0            ) //01
                #define MAX_T_V AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act 
                    !=  exp 
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_V < MAX_T_V );
                    if( 0
                    ||  (((I32)  exp   )+0) < MIN_T_V           
                    ||  (((I32)  exp   )+0) > MAX_T_V 

                    ||  (((I32)  act   )+0) < MIN_T_V           
                    ||  (((I32)  act   )+0) > MAX_T_V 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[T_V:OOB:2021:746PM]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act:exp]:(%d):(%d)\n"
                        , act , exp );;

                        ERR("[TILE_TOGGLE_TEST_FAIL:2021]");
                    };;
                #undef  MIN_T_V                       //: 01 ://
                #undef  MAX_T_V                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
                    
            AAC2020_TODOMAN_Vital(
                "[ADD_MORE_TEST_CASES:ToggleTile]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_UnitTest_ProgControls( void )
    {
        //:helper_functions:generic:- - - - - - - - - - - - -://

        EXT VOD aac2020_paint5d_UTC_Min_I16( VOD );
                aac2020_paint5d_UTC_Min_I16(     );

        EXT VOD aac2020_paint5d_UTC_i32_Cap_u32( VOD );
                aac2020_paint5d_UTC_i32_Cap_u32(     );

        //:- - - - - - - - - - - - -:helper_functions:generic://
        //:helper_functions::conversion:- - - - - - - - - - -://
 
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_bip_sip( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_bip_sip(     );

        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_max_cor( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_max_cor(     );

        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_diagpix(     );

        EXT VOD aac2020_paint5d_UTC_diagpix_CTO_til_exp( VOD );
                aac2020_paint5d_UTC_diagpix_CTO_til_exp(     );

        /**@DNE aac2020_paint5d_UTC_diagpix_CTO_astipix @DNE **/

        EXT VOD aac2020_paint5d_UTC_astipix_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_astipix_CTO_diagpix(     );

        //:- - - - - - - - - - -:helper_functions::conversion://
        //:paired_unit_tests::- - - - - - - - - - - - - - - -://

        EXT VOD aac2020_paint5d_UTC_glocpix_CTO_painpix( VOD );
                aac2020_paint5d_UTC_glocpix_CTO_painpix(     );

        EXT VOD aac2020_paint5d_UTC_painpix_CTO_glocpix( VOD );
                aac2020_paint5d_UTC_painpix_CTO_glocpix(     );

        //:- - - - - - - - - - - - - - - -:paired_unit_tests:://
        //:main_get_put_tests::- - - - - - - - - - - - - - -:://

            EXT VOD aac2020_paint5d_UTC_Put( VOD );
                    aac2020_paint5d_UTC_Put(     );

            EXT VOD aac2020_paint5d_UTC_Get( VOD );
                    aac2020_paint5d_UTC_Get(     );

            /** ******************************************** ***
                @DEP[ aac2020_paint5d_UTC_Get ]               
                @DEP[ aac2020_paint5d_UTC_Put ]               
                @DEP[ aac2020_paint5d_UTC_glocpix_CTO_painpix ]  
            
                @VID_IID[ 0071 ]TIME[ 00H 12M 52S ]  
            *** ******************************************** **/

            EXT VOD aac2020_paint5d_UTC_Put_Get( VOD );
                    aac2020_paint5d_UTC_Put_Get(     );

            /** ******************************************** **/

        //:- - - - - - - - - - - - - - -::main_get_put_tests:://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:MAIN_GET_PUT_TESTS:-----------------------------------://
    #define NUM_TEST_CASES_put (  8  )                  //:01://
    #define NUM_TEST_COLMS_put (  7  ) /**COLUMNS**/    //:02://
    #define NUM_TEST_CASES_get (  8  )                  //:03://
    #define NUM_TEST_COLMS_get (  7  ) /**COLUMNS**/    //:04://

        void aac2020_paint5d_UTC_Put( void )
        {

            /** @VID_IID[ 0070 ]TIME[ 1H 9M 50S ] .......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  p_g ; /** Put( 0 ) or Get( 1 ) Loop. .......**/
            I32  t_i ; /** Test_row_Index             .......**/
            I32  bas ; /** BASe_offset_of_test_data   .......**/
            I32  m_i =( NUM_TEST_CASES_put - 1);

            /* Input VALUES:@VID_IID[ 0071 ]T[ 1H 57M 17S ] */
            U08     til_qua ;   //:--------------------------://
            U08     til_exp ;   //:                          ://
            U08     til_lay ;   //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08     loc_t_x ;   //:                          ://
            U08     loc_t_y ;   //:--------------------------://
                                //:--------------------------://
            U08     aus_dex ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
            U08 put_til_val ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
                                //:--------------------------://

            /** Output Value:@VID_IID[ 0071 ]T[ 1H 57M 17S ] **/

            U08 got_til_val ;

            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 NUM_TEST_CASES_put
                            *
                 NUM_TEST_COLMS_put
            ]={
            /**8 smoke tests. @VID_IID[ 0071 ]T[ 1H 40M 20S ]**/
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   aus_   _val
/*  00  01  */  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
/*  01  02  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    0
/*  02  03  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    0
/*  03  04  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    0
/*  04  05  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    3
/*  05  06  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    3
/*  06  07  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    3  
/*  07  08  */,    1 ,    1 ,    1 ,    1 ,    1 ,    1 ,    1
/// --  --    : _qua   _exp   _lay   loc_   loc_   aus_   _val
/// --  --    : 0001   0002   0003   0004   0005   0006   0007

                /** TODO: More tests **/
            };;
            AAC2020_TODOMAN_Vital("[MORE_TESTS!!!!2021]");

            for( p_g = 0 ; p_g <=( 1 ); p_g ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * NUM_TEST_COLMS_put );

                /** Setting @TRAP_VALUES               * * * **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 53S ] * * * **/

                til_qua=( 101 );  /** @TRAP_VALUES@ **/
                til_exp=( 102 );  /** @TRAP_VALUES@ **/
                til_lay=( 103 );  /** @TRAP_VALUES@ **/
                loc_t_x=( 104 );  /** @TRAP_VALUES@ **/
                loc_t_y=( 105 );  /** @TRAP_VALUES@ **/
                aus_dex=( 106 );  /** @TRAP_VALUES@ **/
            put_til_val=( 107 );  /** @TRAP_VALUES@ **/

                /** Extracted Values For The Current Test    **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 24S ] * * * **/

                til_qua=(         (U08)tab_utc[ bas + 0 ] );
                til_exp=(         (U08)tab_utc[ bas + 1 ] );
                til_lay=(         (U08)tab_utc[ bas + 2 ] );
                loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                aus_dex=(         (U08)tab_utc[ bas + 5 ] );
            put_til_val=(         (U08)tab_utc[ bas + 6 ] );

                /** Integer Overflow Dectection.             **/
                /** @VID_IID[ 0071 ]TIME[ 1H 46M 08S ]       **/
                #define      TIL_VAL put_til_val
                assert(((I16)til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)aus_dex)==tab_utc[ bas + 5 ] );
                assert(((I16)TIL_VAL)==tab_utc[ bas + 6 ] );
                #undef       TIL_VAL

                //:all_puts_before_all_gets:-----------------://
                //:                                          ://
                //: @VID_IID[ 0071 ]TIME[ 02H 03M 44S ]      ://
                //: We do all of the AAC2020_PAINT5D_Put(..) ://
                //: calls BEFORE all of the                  ://
                //: AAC2020_PAINT5D_Get(...) calls in case   ://
                //: we have overlapping [ memory / pixel ]   ://
                //: locations where the data is being stored.://
                //:                                          ://
                //: If we do interlaced                      ://
                //:"get(..) then put(..)" calls, we may      ://
                //: end up with a "FALSE UNIT TEST PASS"     ://
                //:                                          ://
                //:all_puts_before_all_gets:- - - - - - - - -://

                if( 0 == p_g ){
                AAC2020_PAINT5D_Put(
                        til_qua    /* AusetTile SubQuad Index */
                ,       til_exp    /* TileExponent            */
                ,       til_lay    /* TileLayer ..............*/
                ,       loc_t_x    /* LocalTile X Coord / b_x */
                ,       loc_t_y    /* LocalTile Y Coord / b_y */
                ,       aus_dex    /* AUSet_inDEX             */
                ,   put_til_val    /* [ val_cur / til_val ]   */
                );; };;

                if( 1 == p_g ){
                AAC2020_PAINT5D_Get(
                        til_qua    /** Same exact variables  **/
                ,       til_exp    /** as "Put(..)" function **/
                ,       til_lay    /** but last parameter is **/
                ,       loc_t_x    /** an OUTPUT parameter.  **/
                ,       loc_t_y    /** @VID_IID[ 0071 ]      **/
                ,       aus_dex    /** @TIME[ 2H 00M 50S ]   **/
                ,&( got_til_val )  
                );; };;

                assert( ( 1 == p_g ) || ( 0 == p_g ) );
 
                //:-----------------:all_puts_before_all_gets://

            };;};; //:NEXT[ p_g , t_i ]
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( 
                "[MORE_TESTS:aac2020_paint5d_UTC_Put]"
            );;

        }  //:[ END: paint5d_UTC_Put ]://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get( void )
        {

            U08     t_i; //:Test Index
            U08     bas; //:Base Offset To Test Data Points

            U08 til_qua;
            U08 til_exp;
            U08 til_lay;
            U08 loc_t_x;
            U08 loc_t_y;
            U08 aus_dex;

            U08 exp_til_val; //:EXPECTED: til_val
            U08 act_til_val; //:ACTUAL::: til_val

            //:meddling_test:001:----------------------------://
            /** @VID_IID[ 0071 ]TIME[ 2H 31M 03S ]           **/
            //:meddling_test:001::- - - - - - - - - - - - - -://

                AAC2020_PIXNAME_paint5d_cpu_pix[ 0 ]=(
                    0x11 /** RED   BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 1 ]=(
                    0x22 /** GREEN BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 2 ]=(
                    0x33 /** BLUE  BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 3 ]=(
                    0x44 /** ALPHA BITS **/
                );;
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ]
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ]
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ]
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ]

                //: @VID_IID[ 0071 ]TIME[ 2H 42M 21S ]       ://
                //: Overlay the[ aus_dex ] over the correct  ://
                //: 2-bit pattern ( til_val ) it should      ://
                //: be paired with.                          ://
                //:                            15 14 13 12   ://
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ] ://
                //:                                          ://
                //:                            11 10 09 08   ://
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ] ://
                //:                                          ://
                //:                            07 06 05 04   ://
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ] ://
                //:                                          ://
                //:                            03 02 01 00   ://
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ] ://
 
                /** Test Table #001 for meddling test #001   **/
                /** @VID_IID[ 0071 ]TIME[ 2H 59M 10S ]       **/

                U08 tab_001[ 16 * 2 ]={
                //:          aus_dex | til_val
                  /** 00 **/   0x0   ,   0x0
                , /** 01 **/     1   ,     1  /* 1 : BIN[ 01 ]*/
                , /** 02 **/     2   ,     0
                , /** 03 **/     3   ,     1
                , /** 04 **/     4   ,     3  /* 3 : BIN[ 11 ]*/
                , /** 05 **/     5   ,     0
                , /** 06 **/     6   ,     3
                , /** 07 **/     7   ,     0
                , /** 08 **/     8   ,     2 /** 2 : BIN[ 10 ]*/
                , /** 09 **/     9   ,     0
                , /** 10 **/    10   ,     2
                , /** 11 **/    11   ,     0
                , /** 12 **/    12   ,     1
                , /** 13 **/    13   ,     0
                , /** 14 **/    14   ,     1
                , /** 15 **/    15   ,     0 /** 0 : BIN[ 00 ]*/
                };;
       
                /** **************************************** ***
                    @VID_IID[ 0071 ]TIME[ 02H 55M 20S ] 
                    The first meddling test using
                    table[ tab_001 ] only looks at data
                    we set on the very first pixel.
                    
                    This is because we want to confirm
                    our [ bit shifting & bit packing ]
                    logic is correct and don't want the
                    mistake in this test to be looking
                    at the WRONG PIXEL LOCATION.

                *** **************************************** **/

                for( t_i = 0 ; t_i <= 15 ; t_i ++ ){

                        bas =( t_i * 2 );  /*2 colums per test*/
                    aus_dex = tab_001[ bas + 0 ];
                exp_til_val = tab_001[ bas + 1 ];

                    /** Might not be true for other meddling **/
                    /** tests. But true for this one.        **/
                    assert( t_i == aus_dex );

                    AAC2020_PAINT5D_Get(
                        ( til_qua = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_exp = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_lay = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_x = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_y = 0 )  //: <-- FIRST_PIXEL
                    ,   ( aus_dex     )  
                    ,  &( act_til_val )  
                    );;

                    if( exp_til_val != act_til_val ){
                        ERR("[MEDDLING_TEST_NUMBER_001]");
                    };;

                };;

            //:----------------------------:meddling_test:001://
            //:meddling_Test:002:----------------------------://

                /** **************************************** **/
                /** @VID_IID[ 0071 ]TIME[ 03H 06M 49S        **/
                /** Now that we know our bit shifting math   **/
                /** is working, test with a pixel that is    **/
                /** NOT at [ 0,0 ] on our bitmap to verify   **/
                /** physical locations of pixel data are     **/
                /** also correct.                            **/
                /** **************************************** **/

                AAC2020_TODOMAN_Vital("[TestWithAnotherPixel]");
    
            //:----------------------------:meddling_test:002://

            AAC2020_TODOMAN_Vital("[FINISH_THIS_CODE!!!!!!!]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Put_Get( void )
        {
            /** PUT & GET test for the MAIN functionality.   **/
            /** 1: AAC2020_PAINT5D_Put( ... )                **/
            /** 2: AAC2020_PAINT5D_Get( ... )                **/

            /** ******************************************** ***
                About THIS[ paint5d_UTC_Put_Get ]FUNCTION:

                Tests every single possible value there
                is by iterating over the entire 512x512
                bitmap in a double nested [ p_x , p_y ]
                loop. 
            *** ******************************************** **/

            I16 p_x; /** pixel x location **/
            I16 p_y; /** pixel y location **/
            /** ******************************************** ***
                @VID_IID[ 0071 ]TIME[ 00H 07M 54S  ]
                [p_x ,p_y ] == [ glo_t_x , glo_t_y ]
                Located On: AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/
            
            U08 til_qua    ; //:-----------------------------://
            U08 til_exp    ; //:                             ://
            U08 til_lay    ; //:                             ://
            U08 loc_t_x    ; //: FOR: glocpix_CTO_painpix    ://
            U08 loc_t_y    ; //:                             ://
                             //:                             ://
            I16 glo_t_x_001; //: Expected & Actual are       ://
            I16 glo_t_y_001; //: meaningless terms for       ://
                             //: these variables.            ://
            I16 glo_t_x_002; //: @VID_IID[ 0071 ]            ://
            I16 glo_t_y_002; //: TIME[ 01H 18M 07 ]          ://
                             //:_____________________________://

            /** Before Testing "GET" and "PUT" functions     **/
            /** we will test the uderlying conversion        **/
            /** functions first.                             **/

            for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                glo_t_x_001 = p_x; /** Load Function Inputs **/
                glo_t_y_001 = p_y; /** Load Function Inputs **/

                aac2020_paint5d_glocpix_CTO_painpix(
                   &( til_qua     )    /// Auset Sub Quad    ///
                ,  &( til_exp     )    /// Size_Exponent     ///
                ,  &( til_lay     )    /// TileLayer ........///
                ,  &( loc_t_x     )    /// Local  Tile X     ///
                ,  &( loc_t_y     )    /// Local  Tile Y     ///
                ,   ( glo_t_x_001 )    /// Global Tile X     ///
                ,   ( glo_t_y_001 )    /// Global Tile X     ///
                );;

                aac2020_paint5d_painpix_CTO_glocpix(
                    ( til_qua )        /// Auset Sub Quad    ///
                ,   ( til_exp )        /// Size_Exponent     ///
                ,   ( til_lay )        /// TileLayer ........///
                ,   ( loc_t_x )        /// Local  Tile X     ///
                ,   ( loc_t_y )        /// Local  Tile Y     ///
                ,  &( glo_t_x_002 )    /// Global Tile X     ///
                ,  &( glo_t_y_002 )    /// Global Tile X     ///
                );;

                if( 0
                || glo_t_x_001 != glo_t_x_002
                || glo_t_y_001 != glo_t_y_002
                ){
                    ERR("[GET_PUT_TEST_FAILED:YEAR_2021]");
                };;

            };;};;

            //:Put_Everything_Then_Get_Everything:-----------://

                U08 p_g     =( 0 ); //:Put(0) or Get(1)
                U08 aus     =( 0 ); //:Auset_Index_0_to_15
                U32 val_gen =( 0 );
                U08 got_val =( 0 ); //:GOTEN_VALUE
                U08 val     =( 0 ); //:Tile_value_0_1_2_or_3

                for( p_g = 0 ; p_g <= (    1    ) ; p_g ++ ){
                 val_gen =( 0 );
                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    val_gen = ( val_gen + 7 );
                    val     = (U08)( val_gen % 4 );
                    assert( val <= 3 /** Max Tile Val :3 **/ );

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( 0 == p_g ){
                        
                        AAC2020_PAINT5D_Put(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        ,       val  //: til_val / put_val ://
                        );;          
                    }else
                    if( 1 == p_g ){

                        AAC2020_PAINT5D_Get(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        , &(got_val )//: til_val ://
                        );;
                    }else{
                        ERR("[PG_OUT_OF_BOUNDS:2021]");
                    };;

                    if( got_val != val ){
                        ERR("[TEST_DEF_FAIL_2021]");
                    };;

                };;};; //: [ p_x , p_y ] ::::::::::::::::::: ://

                };;};; //: [ p_g , aus ] ::::::::::::::::::: ://

            //:-----------:Put_Everything_Then_Get_Everything://
            //:ALL_ONES_AND_ALL_ZEROS_TEST_VARS:-------------://

                /** **************************************** ***

                    @VID_IID[ 0077 ]TIME[ 05H 21M 12S ]

                    The last two loops are pidgeon hole
                    smoke tests. 

                    [00] #_P5D_BINARY_TEST_00_#

                        IF: We set the binary tile value as
                        "[00]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ZEROS except for last 4 bytes.

                    [11] #_P5D_BINARY_TEST_11_#

                        IF: We set the binary tile value as
                        "[11]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ONES except for last 4 bytes.

                    WHY EVERYTHING BUT LAST 4 BYTES ?

                        The last pixel cannot encode 3 layers
                        and thus is not used in the data
                        structure to encode tile values.

                        The last pixel of the
                        [quarkmap / mipmap ] structure
                        is used as a special settings
                        preset number pixel
                
                *** **************************************** **/

                I32  b_i; //:Byte_Index
                I32  mpi; //:Max_PIXEL_Index
                I32  mbi; //:Max_Byte_Index

                U08  p_c ; /** Pixel_Component_Byte **/

            //:-------------:ALL_ONES_AND_ALL_ZEROS_TEST_VARS://
            //:Loop_Through_Set_All:1s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 1 bit.                              **/

                /** #_P5D_BINARY_TEST_11_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         3  //: BINARY[ 11 ] ://
                    );;   //: 3  ://
                    //: DELTA[ Loop_Through_Set_All ]
                    //: DELTA_3

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0xFF_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0xFF != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ONE]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:1s://
            //:Loop_Through_Set_All:0s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 0 bit.                              **/

                /** #_P5D_BINARY_TEST_00_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         0  //: BINARY[ 00 ] ://
                    );;  //:  0   ://
                    //: DELTA[ Loop_Through_Set_All ]

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0x00_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0x00 != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ZER]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:0s://
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get_Put( void )
        {
            /** ******************************************** **/
            /** @VID_IID[ 0070 ]TIME[ 1H 19M 32S ]           **/  
            /** Make note of what is NOT done so that        **/
            /** no one comes along later and adds this       **/
            /** function.                                    **/
            /** CANNOT GET WHAT WAS NEVER PUT!!!!!!!!!!!!!!  **/
            /** ******************************************** **/

            ERR("[THERE_IS_ONLY:PUT_GET:NEVER:GET_PUT]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

    #undef  NUM_TEST_CASES_put                          //:01://
    #undef  NUM_TEST_COLMS_put                          //:02://
    #undef  NUM_TEST_CASES_get                          //:03://
    #undef  NUM_TEST_COLMS_get                          //:04://
    //:-----------------------------------:MAIN_GET_PUT_TESTS://
    //:paired_unit_tests::- - - ---- - - - - - - - - - - - - ://
    //:1: glocpix_CTO_painpix : ---- - - - - - - - - - - - - ://
    //:2: painpix_CTO_glocpix : ---- - - - - - - - - - - - - ://
    #define glocpix_CTO_painpix_CASES (  4  )         //: 01 ://
    #define glocpix_CTO_painpix_DATUM (  7  )         //: 02 ://
    #define painpix_CTO_glocpix_CASES (  4  )         //: 03 ://
    #define painpix_CTO_glocpix_DATUM (  7  )         //: 04 ://

        void
        aac2020_paint5d_UTC_glocpix_CTO_painpix( void )
        {

            /** @VID_IID[ 0069 ]TIME[ 1H 52M 50S ] ......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( glocpix_CTO_painpix_CASES - 1);

            /* ACTUAL(act_*)VALUES:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  act_til_qua ;  //:--------------------------://
            U08  act_til_exp ;  //:                          ://
            U08  act_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  act_loc_t_x ;  //:                          ://
            U08  act_loc_t_y ;  //:--------------------------://
                 
            /* EXPECTED(exp_*)VALS:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  exp_til_qua ;  //:--------------------------://
            U08  exp_til_exp ;  //:                          ://
            U08  exp_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  exp_loc_t_x ;  //:                          ://
            U08  exp_loc_t_y ;  //:--------------------------://
 
            /* INPUT VALUES(inn_*):@VID_IID[ 0069]T[ 1H 45M ] */
            I16  inn_glo_t_x ;  //:                          ://
            I16  inn_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 glocpix_CTO_painpix_CASES
                            *
                 glocpix_CTO_painpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * glocpix_CTO_painpix_DATUM );

                /** @VID_IID[ 0069 ]TIME[ 1H 36M 33S ]    **/
                /** Most are expected ("exp_*") values    **/
                /** Except the global values which are    **/
                /** actual ("act_*") values.              **/

                exp_til_qua=(   201 );  /** @TRAP_VALUES@ **/
                exp_til_exp=(   202 );  /** @TRAP_VALUES@ **/
                exp_til_lay=(   203 );  /** @TRAP_VALUES@ **/
                exp_loc_t_x=(   204 );  /** @TRAP_VALUES@ **/
                exp_loc_t_y=(   205 );  /** @TRAP_VALUES@ **/
                inn_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                inn_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                /** @VID_IID[ 0070 ]TIME[ 00H 20M 50S ]   **/
                /** Checking for integer overflow .       **/

                exp_til_qua=(         (U08)tab_utc[ bas + 0 ] );
                exp_til_exp=(         (U08)tab_utc[ bas + 1 ] );
                exp_til_lay=(         (U08)tab_utc[ bas + 2 ] );
                exp_loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                exp_loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                inn_glo_t_x=(              tab_utc[ bas + 5 ] );
                inn_glo_t_y=(              tab_utc[ bas + 6 ] );

                assert(((I16)exp_til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)exp_til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)exp_til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)exp_loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)exp_loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)inn_glo_t_x)==tab_utc[ bas + 5 ] );
                assert(((I16)inn_glo_t_y)==tab_utc[ bas + 6 ] );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(act_til_qua)  //:<-- OUTPUTS -------
                , &(act_til_exp)  //:<-- OUTPUTS -------
                , &(act_til_lay)  //:<-- OUTPUTS -------
                , &(act_loc_t_x)  //:<-- OUTPUTS -------
                , &(act_loc_t_y)  //:<-- OUTPUTS -------
                ,   inn_glo_t_x   //:<----------INPUTS--
                ,   inn_glo_t_y   //:<----------INPUTS--
                );;
 
                if( 0
                ||  exp_til_qua != act_til_qua
                ||  exp_til_exp != act_til_exp
                ||  exp_til_lay != act_til_lay
                ||  exp_loc_t_x != act_loc_t_x
                ||  exp_loc_t_y != act_loc_t_y
                ){
                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_qua  , act_til_qua );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_exp  , act_til_exp );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_lay  , act_til_lay );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_x  , act_loc_t_x );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_y  , act_loc_t_y );

                    ERR("[FAIL:glocpix_CTO_painpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_316PM]" );
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void
        aac2020_paint5d_UTC_painpix_CTO_glocpix( void )
        {
            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( painpix_CTO_glocpix_CASES - 1);

            /** ******************************************** **/
            /** @VID_IID[ 0069 ]TIME[ 02H 05M 55S ]     .....**/
            /**  inn_*  : Input    Values                    **/
            /**  exp_*  : EXPECTED outputs                   **/
            /**  act_*  : ACTUAL   outputs                   **/
            /** ******************************************** **/
                                                      
            U08  inn_til_qua ;  //:--------------------------://
            U08  inn_til_exp ;  //:                          ://
            U08  inn_til_lay ;  //:--------------------------://
            U08  inn_loc_t_x ;  //:                          ://
            U08  inn_loc_t_y ;  //:                          ://
                                //:   SEE[ #DIA_GLO_PIX# ]   ://
            I16  exp_glo_t_x ;  //:                          ://
            I16  exp_glo_t_y ;  //:                          ://
                                //:--------------------------://
            I16  act_glo_t_x ;  //:                          ://
            I16  act_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 painpix_CTO_glocpix_CASES
                            *
                 painpix_CTO_glocpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * painpix_CTO_glocpix_DATUM );

                inn_til_qua=(    11 );  /** @TRAP_VALUES@ **/
                inn_til_exp=(    22 );  /** @TRAP_VALUES@ **/
                inn_til_lay=(    33 );  /** @TRAP_VALUES@ **/
                inn_loc_t_x=(    44 );  /** @TRAP_VALUES@ **/
                inn_loc_t_y=(    55 );  /** @TRAP_VALUES@ **/
                exp_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                exp_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                inn_til_qua=( (U08) tab_utc[ bas + 0 ] );
                inn_til_exp=( (U08) tab_utc[ bas + 1 ] );
                inn_til_lay=( (U08) tab_utc[ bas + 2 ] );
                inn_loc_t_x=( (U08) tab_utc[ bas + 3 ] );
                inn_loc_t_y=( (U08) tab_utc[ bas + 4 ] );
                exp_glo_t_x=(       tab_utc[ bas + 5 ] );
                exp_glo_t_y=(       tab_utc[ bas + 6 ] );

                /** @VID_IID[ 0070 ]TIME[ 00H 16M 22S ]      **/
                /** Check for integer overflow.              **/
                assert(((I16)inn_til_qua)==tab_utc[ bas +0 ]);
                assert(((I16)inn_til_exp)==tab_utc[ bas +1 ]);
                assert(((I16)inn_til_lay)==tab_utc[ bas +2 ]);
                assert(((I16)inn_loc_t_x)==tab_utc[ bas +3 ]);
                assert(((I16)inn_loc_t_y)==tab_utc[ bas +4 ]);
                assert(((I16)exp_glo_t_x)==tab_utc[ bas +5 ]);
                assert(((I16)exp_glo_t_y)==tab_utc[ bas +6 ]);

                aac2020_paint5d_painpix_CTO_glocpix(
                    inn_til_qua   //:<-- INPUTS -----------
                ,   inn_til_exp   //:<-- INPUTS -----------
                ,   inn_til_lay   //:<-- INPUTS -----------
                ,   inn_loc_t_x   //:<-- INPUTS -----------
                ,   inn_loc_t_y   //:<-- INPUTS -----------
                , &(act_glo_t_x)  //:<---------- OUTPUTS --
                , &(act_glo_t_y)  //:<---------- OUTPUTS --
                );;
 
                if( 0
                ||  exp_glo_t_x != act_glo_t_x
                ||  exp_glo_t_y != act_glo_t_y
                ){
                    printf("[glo_t_x]:(%d)(%d)\n",
                    exp_glo_t_x  , act_glo_t_x );

                    printf("[glo_t_y]:(%d)(%d)\n",
                    exp_glo_t_y  , act_glo_t_y );

                    ERR("[FAIL:painpix_CTO_glocpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_504PM]" );

        }

    #undef  glocpix_CTO_painpix_CASES                 //: 01 ://
    #undef  glocpix_CTO_painpix_DATUM                 //: 02 ://
    #undef  painpix_CTO_glocpix_CASES                 //: 03 ://
    #undef  painpix_CTO_glocpix_DATUM                 //: 04 ://
    //: - - - - - - - - - - - - ---- - 1: glocpix_CTO_painpix://
    //: - - - - - - - - - - - - ---- - 2: painpix_CTO_glocpix://
    //: - - - - - - - - - - - - ---- - - -::paired_unit_tests://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://



    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://
//:helper_functions:generic:|||||||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_Min_I16( void )
    {
        #define FUN aac2020_paint5d_Min_I16

        assert( FUN(    3  ,    7  ) ==      3 );
        assert( FUN( 0x00FF,0x7FFF ) == 0x00FF );
        assert( FUN( 0x0001,0x7FFF ) == 0x0001 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_i32_Cap_u32( void )
    {

        I32 bru_x_y = 0x0F00 ; /** brush [X|Y] location     **/
        U16 cap_min = 0x000F ; /** Minimum Boundary         **/
        U16 cap_max = 0xF000 ; /** Maximum Boundary         **/
        U32 u32_x_y           ; /** U32 output of function   **/

        #define FUN aac2020_paint5d_i32_Cap_u32

            /** First test to formalize what the parameter   **/
            /** names we are working with are............... **/

            u32_x_y = FUN( bru_x_y , cap_min , cap_max );

            assert( u32_x_y == 0x0F00 );

            /** Tests where input doesn't change **/
            assert( FUN(   0 ,   0 ,   0 ) ==   0 );
            assert( FUN(   2 ,   1 ,   3 ) ==   2 );
            assert( FUN(  50 ,   0 , 100 ) ==  50 );
            assert( FUN( 200 , 100 , 300 ) == 200 );

            /** Tests where capped to max value **/
            assert( FUN( 300 , 100,  200 ) == 200 );
            assert( FUN(   4 ,   1 ,   3 ) ==   3 );
            assert( FUN( 200 ,   0 , 100 ) == 100 );
            assert( FUN( 400 , 100 , 300 ) == 300 );

            /** Tests where capped to min value **/
            assert( FUN(  50 , 100,  200 ) == 100 );
            assert( FUN(   0 ,   1 ,   3 ) ==   1 );
            assert( FUN(   0 ,   0 , 100 ) ==   0 );
            assert( FUN(  50 , 100 , 300 ) == 100 );

            /** capped to min using NEGATIVES **/
            assert( FUN( -12345678 , 100,  200 ) == 100 );
            assert( FUN( -23456789 ,   1 ,   3 ) ==   1 );
            assert( FUN( -34567890 ,   0 , 100 ) ==   0 );
            assert( FUN( -45678901 , 100 , 300 ) == 100 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    

//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||||||:helper_functions:generic://
//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://
//:helper_functions::conversion:|||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_bip_sip( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_bip_sip
        assert( FUN(0) == 128 );
        assert( FUN(1) ==  64 );
        assert( FUN(2) ==  32 );
        assert( FUN(3) ==  16 );
        assert( FUN(4) ==   8 );
        assert( FUN(5) ==   4 );
        assert( FUN(6) ==   2 );
        assert( FUN(7) ==   1 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_max_cor( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_max_cor
        assert( FUN(0) == 127 );
        assert( FUN(1) ==  63 );
        assert( FUN(2) ==  31 );
        assert( FUN(3) ==  15 );
        assert( FUN(4) ==   7 );
        assert( FUN(5) ==   3 );
        assert( FUN(6) ==   1 );
        assert( FUN(7) ==   0 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_diagpix

        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 00H 44M 10M ]    * * * * * **/
        /** What we were thinking when we started  * * * * * **/
        /** creating entries for tab_utc below.    * * * * * **/
        /**                                                  **/
        /** @VID_IID[ 0071 ]TIME[ 00H 54M 37S ]              **/
        /** 7 is the last useful index (til_exp)             **/
        /** because 8 can only store 1 pixel instead         **/
        /** of 3 groups of pixels.                           **/
        /** ************************************************ **/

        /** tab_utc[  row(s)  col(s) **/
        I32 num_tes=( (9*2)  * 2       );;
        I16 tab_utc[  (9*2)  * 2     ]={           //:C_S DEX://
            0 ,   0                                //: 1   0 ://
        ,   1 , 128                                //: 2   1 ://
        ,   2 , 128 + 64                           //: 3   2 ://
        ,   3 , 128 + 64 + 32                      //: 4   3 ://
        ,   4 , 128 + 64 + 32 + 16                 //: 5   4 ://
        ,   5 , 128 + 64 + 32 + 16 + 8             //: 6   5 ://
        ,   6 , 128 + 64 + 32 + 16 + 8 + 4         //: 7   6 ://
        ,   7 , 128 + 64 + 32 + 16 + 8 + 4 + 2     //: 8   7 ://
        ,   8 , 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 //: 9   8 ://
        //:- - - - - - - - - - - - - - - - - - - - - : ----- ://
        ,   0 ,   0                                //: 1   9 ://
        ,   1 , 128                                //: 2  10 ://
        ,   2 , 192                                //: 3  11 ://
        ,   3 , 224                                //: 4  12 ://
        ,   4 , 240                                //: 5  13 ://
        ,   5 , 248                                //: 6  14 ://
        ,   6 , 252                                //: 7  15 ://
        ,   7 , 254                                //: 8  16 ://
        ,   8 , 255                                //: 9  17 ://
        };;                                        

        I32 dex ; //: Current Test Index
        I32 bas ; //: Base Offset Value For Test Data.

        U08 act_til_exp;
        U08 exp_diagpix;
        U08 act_diagpix;

        for( dex = 0; dex <= ( num_tes - 1); dex++ ){

            bas = ( dex * 2 ); //:Multiply Testindex by stride

            /** Extract Data From Table             **/
            /** @VID_IID[ 0071 ]TIME[ 01H 05M 21S ] **/

            act_til_exp = tab_utc[ bas + 0 ]; 
            exp_diagpix = tab_utc[ bas + 1 ];

            act_diagpix = FUN( act_til_exp );

            if( exp_diagpix != act_diagpix ){
                ERR("[FAIL_ACTDIAGNOTEQUALEXPDIAG]");
            };;
        };;

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_diagpix_CTO_til_exp( void )
    {
        U08 til_exp    ;
        U08 til_exp_chk;
        U08 diagpix    ;

        for( til_exp = 0 ; til_exp <= MAX_EXP ; til_exp ++ ){

            diagpix=(
            aac2020_paint5d_til_exp_CTO_diagpix( til_exp ));;

            til_exp_chk=(
            aac2020_paint5d_diagpix_CTO_til_exp( diagpix ));;

            if( til_exp != til_exp_chk ){
                ERR("[diagpix_CTO_til_exp:UNIT_TEST_FAIL]");
            };;
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /**     @DNE aac2020_paint5d_UTC_diagpix_CTO_astipix     **/
    /**     @DNE == @DOES_NOT_EXIST                          **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_astipix_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_astipix_CTO_diagpix

            assert( FUN( 127              ) ==   0            );
            assert( FUN( 128              ) == 128            );
            assert( FUN( 128+64-1         ) == 128            );
            assert( FUN( 128+64+0         ) == 192            );
            assert( FUN( 128+64+0         ) == 128+64         );
            assert( FUN( 128+64+1         ) == 128+64         );
            assert(      128+64+0           == 192            );
            assert( FUN( 128+64+32-1      ) == 192            );
            assert( FUN( 128+64+32+0      ) == 128+64+32      );
            assert( FUN( 128+64+32+1      ) == 128+64+32      );
            assert( FUN( 128+64+32+16-1   ) == 128+64+32      );
            assert( FUN( 128+64+32+16+0   ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+1   ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+8-1 ) == 128+64+32+16   );
            assert( FUN( 128+64+32+16+8+0 ) == 128+64+32+16+8 );

            /** ******************************************** **/
            /** Previous test, but collapsing numbers so we  **/
            /** don't run out of column space in source code.**/
            /** ******************************************** **/

            assert( FUN( 248 ) == 248 ); //:#_DONT_TOUCH_ME_#://

            /** ******************************************** **/

            assert( FUN( 248              ) == 248            );
            assert( FUN( 248+4-1          ) == 248            );
            assert( FUN( 248+4+0          ) == 248+4          );
            assert( FUN( 248+4+1          ) == 248+4          );
            assert( FUN( 248+4+2          ) == 248+4+2        );
            assert( FUN( 248+4+2+1        ) == 248+4+2+1      );

            //:Use some explicit edge case values:           ://
            //:If 255 fails because it is out of bounds, then://
            //:Just comment out that test, as the case has   ://
            //:been properly handled by runtime asserts in   ://
            //:the function being tested.                    ://
            assert( FUN( 0 ) ==   0 );
            assert( FUN(255) == 255 ); //:<--ShouldNeverUse
            assert( FUN(254) == 254 );
            assert( FUN(253) == 252 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||:helper_functions::conversion://
//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://

    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://

#undef  MAX_EXP                                       //: 01 ://
#undef  EXT                                           //: 02 ://
#undef  VOD                                           //: 03 ://
#undef  I08                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  I16                                           //: 06 ://
#undef  U16                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  U32                                           //: 09 ://
#undef  ERR                                           //: 10 ://
#undef  LOG                                           //: 11 ://
//:========================================:UNIT_TEST_SECTION://
//:========================================:SECTION_UNIT_TEST://