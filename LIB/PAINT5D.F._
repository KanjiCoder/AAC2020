//: PAINT5D: ( .F._ : FuncFile )
//: #NAMESPACE_PATTERN_BREAKER_PAINT5D#

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://

    void
    aac2020_paint5d_Halt( const char* msg_err )
    {

        printf("[PAINT5D_HALT____MSG_ERR]:%s\n", msg_err );
        fflush(stdout);
        exit(  11 /** 4*20-69 **/ );         

    }

//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://
    void
    aac2020_paint5d_Info_any( //:FUNC:::Info , OVERLOAD:any
        const char* str_fmt   //:GENERAL:str , SPECIFIC:fmt
    ,   void*       dat_any   //:GENERAL:dat , SPECIFIC:any
    )
    {                                        int say=( 0 );
        if( AAC2020_SILENCE.PAINT5D <=(  0  ) ){ say=( 1 ); };
        if( AAC2020_SILENCE.SILENCE <=( 0-1 ) ){ say=( 1 ); };
        if( AAC2020_SILENCE.SILENCE >=( 0+1 ) ){ say=( 0 ); };
        if( say >= 1 ){
            printf("[paint5d_log]....("    ); fflush( stdout );
            printf( str_fmt , dat_any      ); fflush( stdout );
            printf(                  ")\n" ); fflush( stdout );
        };;
    }
//:===========================================:LOG_AFTER_HALT://
//:ARE_WE_ALLOWED_TO_SPEAK:==================================://
#define U08 uint8_t /** GCC: <stdint.h> **/
    U08
    aac2020_paint5d_AllowedToSpeak( void ){
                                             U08 say=( 0 ); 
        if( AAC2020_SILENCE.PAINT5D <=(  0  ) ){ say=( 1 ); };
        if( AAC2020_SILENCE.SILENCE <=( 0-1 ) ){ say=( 1 ); };
        if( AAC2020_SILENCE.SILENCE >=( 0+1 ) ){ say=( 0 ); };

        return( say );
    }
#undef  U08
//:==================================:ARE_WE_ALLOWED_TO_SPEAK://
//:OKAY_STATUS_INFO_MESSAGE:=================================://
    void
    aac2020_paint5d_Okay( const char* msg_o_k )
    {   
        aac2020_paint5d_Info_any(
        "[aac2020_paint5d_Okay:...]" , (void*)msg_o_k );;
    }
//:=================================:OKAY_STATUS_INFO_MESSAGE://
//:INFO_STATUS_INFO_MESSAGE:=================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info( const char* msg_inf )
    {   
        if( aac2020_paint5d_AllowedToSpeak() ){
            printf("[aac2020_paint5d_Info]:%s\n", msg_inf );
            fflush(stdout);  
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_dec( 
        const char* str_fmt
    ,   I32         val_dec
    )
    {   
        if( aac2020_paint5d_AllowedToSpeak() ){
            printf( "[aac2020_paint5d_Info_dec]...\n");
            fflush( stdout            ); //:@DOUBLE_FLUSH@://
            printf( str_fmt , val_dec );
            fflush( stdout            );    
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_VPC( void ) //:MACRO[LOG_VPC]
    {
        if( aac2020_paint5d_AllowedToSpeak() ){
            U32 x_0 ;
            U32 x_1 ;
            U32 y_0 ;
            U32 y_1 ;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VPC //:DEX_VAR
            ,  &(x_0),&(x_1),&(y_0),&(y_1)
            );;

            printf("\n");
            printf("[aac2020_paint5d_Info_VPC(CANVAS/CLIENT)]\n");
            printf("[AAC2020_TAUDEPO.P5D_VPC.x_0]:%d\n", x_0 );
            printf("[AAC2020_TAUDEPO.P5D_VPC.x_1]:%d\n", x_1 );
            printf("[AAC2020_TAUDEPO.P5D_VPC.y_0]:%d\n", y_0 );
            printf("[AAC2020_TAUDEPO.P5D_VPC.y_1]:%d\n", y_1 );
            printf("\n");
        };;

    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_VP0( void ) //:MACRO[LOG_VP0]
    {
        if( aac2020_paint5d_AllowedToSpeak() ){
            U32 x_0 ;
            U32 x_1 ;
            U32 y_0 ;
            U32 y_1 ;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP0 //:DEX_VAR
            ,  &(x_0),&(x_1),&(y_0),&(y_1)
            );;

            printf("\n");
            printf("[aac2020_paint5d_Info_VP0(SCREEN/VIEWPORT)]\n");
            printf("[AAC2020_TAUDEPO.P5D_VP0.x_0]:%d\n", x_0 );
            printf("[AAC2020_TAUDEPO.P5D_VP0.x_1]:%d\n", x_1 );
            printf("[AAC2020_TAUDEPO.P5D_VP0.y_0]:%d\n", y_0 );
            printf("[AAC2020_TAUDEPO.P5D_VP0.y_1]:%d\n", y_1 );
            printf("\n");
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Info_VP1( void ) //:MACRO[LOG_VP1]
    {
        if( aac2020_paint5d_AllowedToSpeak() ){
            U32 x_0 ;
            U32 x_1 ;
            U32 y_0 ;
            U32 y_1 ;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
            ,  &(x_0),&(x_1),&(y_0),&(y_1)
            );;

            printf("\n");
            printf("[aac2020_paint5d_Info_VP1(CAMERA/DATA)]\n");
            printf("[AAC2020_TAUDEPO.P5D_VP1.x_0]:%d\n", x_0 );
            printf("[AAC2020_TAUDEPO.P5D_VP1.x_1]:%d\n", x_1 );
            printf("[AAC2020_TAUDEPO.P5D_VP1.y_0]:%d\n", y_0 );
            printf("[AAC2020_TAUDEPO.P5D_VP1.y_1]:%d\n", y_1 );
            printf("\n");
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32
#undef  U32
//:=================================:INFO_STATUS_INFO_MESSAGE://
//:HELPER_FUNCTIONS_BINARY_PRINT:============================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define CHR const char

    void
    aac2020_paint5d_BinaryPrintf( 
        CHR* txt
    ,   U32  num    
    )
    {
        printf( "%s    " , txt );

        /** ************************************************ ***
            @VID_IID[ 0091 ]TIME[ 00:16:50 ]
            Copied Of: BINPRIN_BinaryPrintf
            https://github.com/KanjiCoder/BINPRIN
        *** ************************************************ **/

        U32 bit ;
        U32 cou ; //:Counter for dividers
        U32 e_o = 1; //:every other

        printf(   "( "   );
        for( I32 i = ( 32 - 1 ) ; i >= 0 ; i-- ){
            cou++;
            bit = ( ( num >> i ) & 1 );
            printf( "%d" , bit );
            if( 0 == cou % 4 && 0 != i ){ 
                e_o = ( ! e_o );
                if( 0 == e_o ){ printf(" - " ); };
                if( 1 == e_o ){ printf(" | " ); };
            };;
        };;
        printf(   " )"   );
        printf(   "\n"   );
    }

#undef  I32
#undef  U32
#undef  CHR
//:============================:HELPER_FUNCTIONS_BINARY_PRINT://
//:HELPER_FUNCTIONS:ASSERT_AND_INSPECT:======================://
#define U16  uint16_t /** GCC: <stdint.h> **/         //: 01 ://
#define I32   int32_t /** GCC: <stdint.h> **/         //: 02 ://
#define CHR  const char                               //: 03 ://
#define ERR  aac2020_paint5d_Halt                     //: 04 ://
#define BASSU16_COMPARE_WHEN_SAME ( 1 )               //: 05 ://

    U16 aac2020_paint5d_BASSU16_AssertAndInspect(  
        U16  u16_001 //: 1st bit field uint16 to compare.    ://
    ,   U16  u16_002 //: 2nd bit field uint16 to compare.    ://
    ,   CHR* msg_err //: Message to display when assert fails://
    )
    {
        /** ************************************************ ***
        @VID_IID[ 0102 ]TIME[ 00:09:11 ]
        This code was cut and pasted from the project:
        R:/G/KANJICODER/BASSU16/BASSU16.C11
        It was written yesterday/today(2021_01_21 - 2021_01_22)
        to help find mistakes with how I am bit packing
        values into unsigned 16 bit integers for one of
        my unit tests.
        *** ************************************************ **/

        //:declare_variables:--------------------------------://

            U16 u16_min;
            U16 u16_max;
            U16 u16_del; //:delta.
            U16 u16_tem; //:temp variable
            
            I32     dex; //:Index variable for looping.

        //:--------------------------------:declare_variables://
        //:find_delta_of_inputs:-----------------------------://

            if( u16_001 <= u16_002 ){ u16_min = u16_001 ;
                                      u16_max = u16_002 ; };;

            if( u16_002 <= u16_001 ){ u16_min = u16_002 ;
                                      u16_max = u16_001 ; };;

            u16_del=( u16_max - u16_min );

        //:-----------------------------:find_delta_of_inputs://
        //:analysis_of_inputs:-------------------------------://
        if( u16_001 != u16_002 || BASSU16_COMPARE_WHEN_SAME ){  

        //:SWAPPED_BITS_CHECK://

            //:----------------------------------------------://
            //:  Check to see if the bit patterns are   .....://
            //:  mirror images of each other.           .....://
            //:                                         .....://
            //:  0 0 0 0   1 1 1 1  <-- example u16_001 .....://
            //:  1 1 1 1   0 0 0 0  <-- example u16_002 .....://
            //:                                         .....://
            //:  1 1 1 1   1 1 0 0  <-- example u16_001 .....://
            //:  0 0 1 1   1 1 1 1  <-- example u16_002 .....://
            //:----------------------------------------------://

            u16_tem =( (U16)0x0000 );

            for( dex = 0 ; dex <= (16-1) ; dex ++ ){

                u16_tem =(
                u16_tem 
                    |  //:<-- Or to SMASH together.
                    (
                       ( ( u16_002 >> dex )&( 1 ) )
                       <<
                       ((16-1)-dex )
                    )
                );;

            };;

            /** Are inputs mirror images of each other? **/
            if( u16_001 == u16_tem /**swapped_bits:u16_002**/ ){

                printf("[MIRROR_IMAGES_OF_EACH_OTHER]\n");
            };;

        //:PAIRS_OF_TWO_BITS_PACKED_IN_WRONG_ORDER://

            //: 11 10 01 00 <== u16_001  ( using 8 bit values )
            //: 00 01 10 11 <== u16_002  ( for example        )

            u16_tem =( (U16)0x0000 );

            for( dex = 0 ; dex <= ((16/2)-1) ; dex ++ ){

                u16_tem =(
                u16_tem 
                    |  //:<-- Or to SMASH together.
                    (
                       ( ( u16_002 >> (dex*2) )&( 3 ) )
                       <<
                       (   ( ((16/2)-1)-(dex) )*( 2 ) )
                    )
                );;

            };;

            if( u16_001 == u16_tem /**swapped_bits:u16_002**/ ){

                printf("[BIT_PAIRS_IN_INVERTED_ORDER]\n");
            };;

        //:CLUSTER_OF_4_BITS:(NYBLES/NIBBLES):

            u16_tem =( (U16)0x0000 );

            for( dex = 0 ; dex <= ((16/4)-1) ; dex ++ ){

                u16_tem =(
                u16_tem 
                    |  //:<-- Or to SMASH together.
                    (
                       ( ( u16_002 >> (dex*4) )&( 15 ) )
                       <<
                       (   ( ((16/4)-1)-(dex) )*(  4 ) )
                    )
                );;

            };;

            if( u16_001 == u16_tem /**swapped_bits:u16_002**/ ){

                printf("[NIBBLES_IN_INVERTED_ORDER]\n");
            };;

        //:BYTE_ENDIAN_NESS_CHECK://

            if(
                (
                    ( ( u16_001 >> 8 ) & 0xFF )
                 == ( ( u16_002 >> 0 ) & 0xFF )
                )
                &&
                (
                    ( ( u16_001 >> 0 ) & 0xFF )
                 == ( ( u16_002 >> 8 ) & 0xFF )
                )
            ){
                printf("[INVERTED_ENDIAN_NESS]\n");
            };;

        //:IMPROPER_TRANSCRIPTION_OF_2_BIT_VALUES://

            u16_tem =( (U16)0x0000 );

            for( dex = 0 ; dex <= ((16/2)-1) ; dex ++ ){

                if( 
                    (( u16_001 >> ( dex*2) ) & ( 3 ))
                !=  (( u16_002 >> ( dex*2) ) & ( 3 ))
                ){
                    u16_tem++; //:Number Of Non_Matching
                               //:2-bit values.
                };;
            };;
            if( u16_tem >= 1 && u16_tem <= 2 ){
                /** You may have made a mistake when you     **/
                /** created the table of 2-bit valuess to    **/
                /** bit pack together. Possibly 1 or two     **/
                /** of them was written down wrong.          **/
                printf("[NUM_MISMATCHED_PAIRS]:%d\n", u16_tem);
                printf("[HARD_CODED_2_BIT_TABLE_TERROR]");
            };;

        };; ////////////////////////////////////////////////////
        //:-------------------------------:analysis_of_inputs://
        //:crash_or_notify_if_different:---------------------://

            if( u16_001 != u16_002 ){

                printf( "[BASSU16:msg_err]:%s\n", msg_err );
                ERR("[ORIGINS_IS_BASSU16_SEE_MESSAGE_ABOVE]");
                exit( 77 );
            };;

        //:---------------------:crash_or_notify_if_different://
        //:no_news_is_not_always_good_news:------------------://
        if( u16_001+0 == u16_001+0 ){
            
            printf("[THEY_ARE_THE_SAME_BOSS]\n");

        };;
        //:------------------:no_news_is_not_always_good_news://

        return( u16_del );
    }

#undef  U16                        //:..................: 01 ://
#undef  I32                        //:..................: 02 ://
#undef  CHR                        //:..................: 03 ://
#undef  ERR                        //:..................: 04 ://
#undef  BASSU16_COMPARE_WHEN_SAME  //:..................: 05 ://
//:======================:HELPER_FUNCTIONS:ASSERT_AND_INSPECT://
//:HELPER_FUNCTIONS:GENERIC:=================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U16 uint16_t /** GCC: <stdint.h> **/
#define I16  int16_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I16
    aac2020_paint5d_Min_I16(
        I16 i16_001
    ,   I16 i16_002
    )
    {
        I16 i16_min = ( 0 - 4433 /** @TRAP_VALUE@ **/ );
        if( i16_001 <= i16_002 ){ i16_min = i16_001 ; };
        if( i16_002 <= i16_001 ){ i16_min = i16_002 ; };

        assert( 0 - 4433 != i16_min /** @CHECK_TRAP@ **/ );
        return( i16_min );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_i32_Cap_u32(

        I32 bru_x_y /** [ b_x | b_y ](Brush_X -or- Brush_Y) **/
    ,   U16 cap_min
    ,   U16 cap_max

    )
    {
        assert( cap_min <= cap_max ); /** Sorted/Ordered ? **/

        U32 out_u32 = ( (U32)bru_x_y );

        if( bru_x_y < (I32)cap_min ){ out_u32 =(U32)(cap_min);};
        if( bru_x_y > (I32)cap_max ){ out_u32 =(U32)(cap_max);};

        return( out_u32 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32 
#undef  U32 
#undef  U16 
#undef  I16
//:=================================:HELPER_FUNCTIONS:GENERIC://
//[CONVERSION_FUNCTIONS:COORDINATE_TRANSFORMING:=============]//



    #include "./PAINT5D.F.CTO._" //:<--[ CTO == ConvertTO ] 



//[=============:CONVERSION_FUNCTIONS:COORDINATE_TRANSFORMING]//
//:PIXEL_BIT_PACKING:========================================://
//:@VID_IID[ 0080 ]TIME[ 01:02:20 ]==========================://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 01 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 02 ://
#define ERR aac2020_paint5d_Halt                      //: 03 ://

    U08
 //:aac2020_paint5d_Put_BitPack <--- @CTRL_F_HELP@
    aac2020_paint5d_BitPack_Put(
        U08* cpu_pix //: AAC2020_PIXNAME_paint5d_cpu_pix     ://
    ,   I32  glo_com //: Component Index. Divisible By 4.    ://
    ,   U08  aus_dex //: Auset Index: 0-to-15 inclusive.     ://
    ,   U08  til_val //: <-- Value To Put                    ://
    )
    {
        //:input_checks:-------------------------------------://
            if( ((U08*)0) == cpu_pix ){
                ERR("[NULL_CPU_PIX_2021_820PM]");
            };;

            /** Assertion is only valid if we are NOT unit   **/
            /** testing. @VID_IID[ 0081 ]TIME[ 00:27:46 ]    **/
            if( aac2020_paint5d_unit_test_is_running_now <= 0 ){

                if( cpu_pix != AAC2020_PIXNAME_paint5d_cpu_pix){
                    /**  NE: Not Equal **/
                    ERR("[CPU_PIX_NE_PAINT5D____BITPACK_PUT]");
                };;
            };;

            if( ( 0 != glo_com % 4 ) ){
                /** @VID_IID[ 0081 ]TIME[ 00:47:40 ]         **/
                /** Component index should be divisible by 4 **/

                printf("[glo_com]:%d\n" , glo_com );

                ERR("[GLO_COM____NOT_DIV_BY_4____BITPACK_PUT]");
            };;

        //:-------------------------------------:input_checks://
        //:variable_declaration(s):--------------------------://

            U08 old_val ; //: <-- previous bit value stored.
            I32 arr_dex ;
            U08 var_u08 ;
            I32 aus_loc ; //: AUSet_LOCal (Bitpacking_Index)
                          //: LOC != LOCATION
                          //: LOC == LOCAL
            /** set trap values **/
            old_val = ( 0 + 202 );
            arr_dex = ( 0 - 333 );
            var_u08 = ( 0 + 202 );
            aus_loc = ( 0 - 333 );

        //:--------------------------:variable_declaration(s)://
        //:bit_packing_stuff:--------------------------------://
        #define BIN_011 3 /** 2 set bits in a row **/
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
                arr_dex =(         glo_com + 3 );
                var_u08 = cpu_pix[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
                arr_dex =(         glo_com + 2 );
                var_u08 = cpu_pix[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
                arr_dex =(         glo_com + 1 );
                var_u08 = cpu_pix[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

                arr_dex =(         glo_com + 0 );
                var_u08 = cpu_pix[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:PUT]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 3H 38M 10S ]BEG
                @VID_IID[ 0072 ]TIME[ 3H 46M 09S ]END
    
                Bit packing logic to ONLY CHANGE the bits
                where the new value needs to be stored.
                We need to erase the bits in the proper
                position by masking ( & ). Then merge the bits
                together by using a bitwise or. ( | )

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );
    
            cpu_pix[ arr_dex ]=(

                /**  11001111 <-- Conceptually:if:aus_loc==2**/
                ( var_u08 &  (~(  BIN_011 << ( aus_loc*2 ) )) )

                |  //:<-- Bitwise Or to merge together

                /**  00110000 <-- Conceptually:if:aus_loc==2**/
                /** Slide Delta Bits Into Position **/
                ( til_val                 << ( aus_loc*2 )    )

            );;

        #undef  BIN_011 /* <-- NEEDED: binary [ 11 ] 2 bits   */
        #undef  CPU_PIX /* <-@KFR@VID_IID[ 0083 ]T[ 1:55:55 ] */
        //:--------------------------------:bit_packing_stuff://

        /** return the value that was overwritten by         **/
        /** til_val. This is necessary for the toggleTile    **/
        /** functionality. @VID_IID[ 0081 ]TIME[ 01:04:33 ]  **/
        return( old_val );
    }
    
    void
 //:aac2020_paint5d_Get_BitPack <--- @CTRL_F_HELP@
    aac2020_paint5d_BitPack_Get(
        U08* cpu_pix //: AAC2020_PIXNAME_paint5d_cpu_pix     ://
    ,   I32  glo_com //: Component Index. Divisible By 4.    ://
    ,   U08  aus_dex //: Auset Index: 0-to-15 inclusive.     ://
    ,   U08* til_val //: <-- Value To Get                    ://
    )
    {
        //:input_checks:-------------------------------------://
       
            //:input_checks:refs_cannot_be_null:-------------://

                if( ((U08*)0) == til_val ){
                    ERR("[NULL_REF:til_val:2021]");
                };;

            //:-------------:input_checks:refs_cannot_be_null://
            //:input_checks:everything_else:-----------------://
            #define ING aac2020_paint5d_unit_test_is_running_now
            #define P5D_CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        
                /** @VID_IID[ 0083 ]TIME[ 1H 45M 35S ]       **/
                /** Cleaned up this section of input checks. **/

                if( ((U08*)0) == cpu_pix ){
                    ERR("[NULL_CPU_PIX_2021_TEN-FOURTEEN_PM]");
                };;

                /** Assertion only valid if we are NOT unit  **/
                /** testing. @VID_IID[ 0081 ]TIME[ 00:27:46 ]**/
                if( ING /** Running ? **/ <= 0 ){

                    if( cpu_pix != P5D_CPU_PIX){
                        /** NE: Not Equal **/
                        ERR("[CPU_PIX_NE_PAINT5D_BITPACK_GET]");
                    };;
                };;

                if( ( 0 != glo_com % 4 ) ){
                    /** @VID_IID[ 0081 ]TIME[ 00:47:40 ]     **/
                    /** Component index is DIVISIBLE by 4    **/
                    ERR("[glo_com__NOT__div_by_4_bitpack_GET]");
                };;

            #undef ING  
            #undef P5D_CPU_PIX
            //:-----------------:input_checks:everything_else://

        //:-------------------------------------:input_checks://
        //:variable_declaration(s):--------------------------://

            U08 old_val ; //: <-- previous bit value stored.
        /// I32 arr_dex ;
            U08 var_u08 ;
            I32 aus_loc ; //: SEE[ @aus_loc ]IN[ PAINT5D.D._ ]
                          //: [ @aus_loc ]IN[ #DIA_P5D_MAIN# ]
                          //: AUSet_LOCal (Bitpacking_Index)
                          //: LOC != LOCATION
                          //: LOC == LOCAL
            /** set trap values **/
            old_val = ( 0 + 202 );
        /// arr_dex = ( 0 - 333 );
            var_u08 = ( 0 + 202 );
            aus_loc = ( 0 - 333 ); 

        //:--------------------------:variable_declaration(s)://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

            if( 1
            /** aus_dex >=  0 **/ 
            &&  aus_dex <=  3 ){  /** ALPHA **/
                               
        ////    arr_dex =(         glo_com + 3 );
                var_u08 = cpu_pix[ glo_com + 3 ];
                aus_loc =( aus_dex -  0 );
                                                       
            }else                                      
            if( aus_dex >=  4  
            &&  aus_dex <=  7 ){  /** BLUE  **/
                      
        ////    arr_dex =(         glo_com + 2 );
                var_u08 = cpu_pix[ glo_com + 2 ];
                aus_loc =( aus_dex -  4 );
                                
            }else                                      
            if( aus_dex >=  8 
            &&  aus_dex <= 11 ){  /** GREEN **/
                                          
        ////    arr_dex =(         glo_com + 1 );
                var_u08 = cpu_pix[ glo_com + 1 ];  
                aus_loc =( aus_dex -  8 );    
                                                       
            }else                                      
            if( aus_dex >= 12 
            &&  aus_dex <= 15 ){  /** RED   **/

        ////    arr_dex =(         glo_com + 0 );
                var_u08 = cpu_pix[ glo_com + 0 ];
                aus_loc =( aus_dex - 12 );

            }else{
                ERR("[PAINT5D_OOB_PROBLEM_YEAR_2021:GET]");
            };;

            assert( aus_loc <= 3 /** [ 0 | 1 | 2 | 3 ] **/ );

            /** ******************************************** ***

                @VID_IID[ 0072 ]TIME[ 4H 08M 50S ]
                We can nuke most of the bit shifting
                code copied from the "Put(..)" function
                and just keep the fetch of "old_val".
                "old_val" is the value we want to load
                into the output parameter "til_val".

            *** ******************************************** **/

            old_val =( (var_u08 >> ( aus_loc*2)) & BIN_011 );

        #undef  CPU_PIX //: <-- Reference @VID_IID[ 0083  ]  ://
        #undef  BIN_011 //: <-- Reference @TIME[ 01:53:20 ]  ://
        //:--------------------------------:bit_packing_stuff://
        //:return_old_val:-----------------------------------://

            (*til_val)=( old_val );

        //:-----------------------------------:return_old_val://
        return;
    }

#undef  U08                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
//:=========================:@VID_IID[ 0080 ]TIME[ 01:02:20 ]://
//:========================================:PIXEL_BIT_PACKING://
//:PAINT5D_QUARKMAP_GET_PUT:=================================://
//:PAINT5D_QUARKMAP_PUT_GET:=================================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define I16  int16_t /** GCC: <stdint.h> **/          //: 02 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 03 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 04 ://
#define ERR aac2020_paint5d_Halt                      //: 05 ://

    /** #_WHAT_IS_THE_QUARKMAP_# * * * * *  **/
    /** @VID_IID[ 0067 ]TIME[ 00H 52M 23S ] **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    #if( AAC2020_CRASH_ON_VITAL_TODO >= 1 ) //:##############://

        #error TEST THE BIT PACKING LOGIC IN ISOLATION

    #endif //:###############################################://

    U08
    AAC2020_PAINT5D_Put(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08  til_val   /** [ val_cur / til_val ]          ...**/
        //[ SAME_PARAM_ORDER_AS[ PAINT5D_Put_BrushState ]    ]//
        //[ @VID_IID[ 0076 ]TIME[ 6H 00M 00S ]               ]//
    )
    {
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            /** @VID_IID[ 0072 ]TIME[ 03H 07M 30S ]    ......**/
            /** til_val commentary is the decimal and  ......**/
            /** binary representations of it's values. ......**/

            if( til_exp >= 8 ){

                printf("[aac2020_paint5d_CTF]:%s\n"
                        ,aac2020_paint5d_CTF );;

                printf("[aac2020_paint5d_CTS]:%s\n"
                        ,aac2020_paint5d_CTS );;

                printf("[til_exp]:%d\n", til_exp );
                ERR("[TILE_EXPONENT_IS_OUT_OF_BOUNDS_2021]");
            };;

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );
            assert( til_val <=   3 );/**[  0 |  1 |  2 |  3 ]**/
                                     /**[ 00 | 01 | 10 | 11 ]**/

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );

                /** @VID_IID[ 0078 ]TIME[ 1H 34M 50S ]  **** **/
                /** 16 bits:enough for [ glo_t_x , glo_t_y ] **/
                /** NOT ENOUGH FOR GLOBAL INDEXES.           **/
                /** **************************************** **/

            I32 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I32 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I32 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
    ////    U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
    ////    U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

            U08 old_val =(      111  /** Prev til_val **/ );
                                     /** @TRAP_VALUE@ **/

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            //: CANNOT USE 0xFFFF to store glo_com.
            //: Not enought bits. Not even enough
            //: bits for glo_dex.
            assert( 512 * 512 * 4 > 0xFFFF ); //:max: glo_com
            assert( 512 * 512 * 1 > 0xFFFF ); //:max: glo_dex

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );
    
            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                U08 a_1; /** Assert #1 **/
                U08 a_2; /** Assert #2 **/
                a_1 =(       chk_glo_com  == ((U32)glo_com) );
                a_2 =( ((I32)chk_glo_com) == (     glo_com) );
                if( (!a_1) || (!a_2) ){
                    printf("[a_1]:%d\n", a_1 );
                    printf("[a_2]:%d\n", a_2 );

                    printf("[chk_glo_com]:%d\n" , chk_glo_com);
                    printf("[    glo_com]:%d\n" ,     glo_com);

                    U32 i32_chk =  ((I32)chk_glo_com) ;
                    U32 u32_glo =  ((U32)    glo_com) ;

                    printf("[i32_chk]:%d\n" , i32_chk);
                    printf("[u32_glo]:%d\n" , u32_glo);

                    ERR("[EVERYONE_PANIC_AND_HIT_THE_FLOOR]");
                };;
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM___TAG[ #DIA_P5D_MAIN# ]
                SEE_DIAGRAM_LABEL[ @P5D_AUS_BITS@ ]
                FROM_________FILE[ PAINT5D.D._    ]
            *** ******************************************** **/

            old_val=( 
            aac2020_paint5d_BitPack_Put(
                CPU_PIX //: U08* :  PIXNAME_paint5d_cpu_pix  ://
            ,   glo_com //: U08  :  Component Index. @DIV_B4@://
            ,   aus_dex //: U08  :  Auset Index: [0 - 15]    ://
            ,   til_val //: U08  :  <-- Value To Put         ://    
            ));;
      

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://

        /** If the tile value we set down was different than **/
        /** It was previously, maybe we should return        **/
        /** a ONE( 1 ) to signify that.                      **/
        return( til_val != old_val );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Get(
        U08  til_qua   /** Auset Tile Sub Quadrant Index     **/
    ,   U08  til_exp   /** TileExponent (TileSizeEnum)    ...**/
    ,   U08  til_lay   /** TileLayer .................    ...**/
    ,   U08  loc_t_x   /** Local Tile X Coord / b_x       ...**/
    ,   U08  loc_t_y   /** Local Tile Y Coord / b_y       ...**/
    ,   U08  aus_dex   /** AUSet_inDEX (AutoTileSetIndex) ...**/
    ,   U08* til_val   /** [ val_cur / til_val ]          ...**/
    )
    {
        /** ************************************************ **/
        /** NOTE: This code is almost a cut+paste of         **/
        /**       the "Put" code. The "old_val" variable     **/
        /**       from the "Put" code is what we want        **/
        /**       to return from this function via           **/
        /**       an OUTPUT PARAMETER.                       **/
        /** ************************************************ **/
        //:references_are_never_null:------------------------://

            assert( ((void*)0) != til_val );

        //:------------------------:references_are_never_null://
        //:bounds_check_inputs:------------------------------://
        #if( AAC2020_PAINT5D_BOUND_CHECK_INPUTS >= 1 ) //:###://

            if( til_qua >= 4 ){
            #define NOW aac2020_paint5d_unit_test_is_running_now

                //: @VID_IID[ 0083 ]TIME[ 05:07:40S ]
                //:Valid Quadrants:
                //:   0 : TOP LEFT
                //:   1 : TOP RIGHT
                //:   2 : BOT LEFT
                //:   3 : BOT RIGHT

                printf("[aac2020_paint5d_CTF]:%s\n"
                        ,aac2020_paint5d_CTF );;

                printf("[aac2020_paint5d_CTS]:%s\n"
                        ,aac2020_paint5d_CTS );;

                printf("[AAC2020_PAINT5D_Get:HAS_BAD_NEWS]\n");
                ERR("[TIL_QUA_IS_POSITIVE_OUT_OF_BOUNDS_2021]");

            #undef NOW
            };;

            assert(        til_qua     <=   3 );
            assert(        til_exp     <=   7 );
            assert(        til_lay     <=   2 );
            assert( (((I32)loc_t_x)+0) <= 255 );
            assert( (((I32)loc_t_y)+0) <= 255 );

            assert( aus_dex <=  15 );

            if( 0 == til_exp ){
                assert( loc_t_x <= ( 128 - 1) );
                assert( loc_t_y <= ( 128 - 1) );
            }else                    
            if( 1 == til_exp ){      
                assert( loc_t_x <= (  64 - 1) );
                assert( loc_t_y <= (  64 - 1) );
            }else                    
            if( 2 == til_exp ){      
                assert( loc_t_x <= (  32 - 1) );
                assert( loc_t_y <= (  32 - 1) );
            }else                    
            if( 3 == til_exp ){      
                assert( loc_t_x <= (  16 - 1) );
                assert( loc_t_y <= (  16 - 1) );
            }else                    
            if( 4 == til_exp ){      
                assert( loc_t_x <= (   8 - 1) );
                assert( loc_t_y <= (   8 - 1) );
            }else                    
            if( 5 == til_exp ){      
                assert( loc_t_x <= (   4 - 1) );
                assert( loc_t_y <= (   4 - 1) );
            }else                    
            if( 6 == til_exp ){      
                assert( loc_t_x <= (   2 - 1) );
                assert( loc_t_y <= (   2 - 1) );
            }else                       
            if( 7 == til_exp ){         
                assert( loc_t_x <= (   1 - 1) );
                assert( loc_t_y <= (   1 - 1) );
            };;

        #endif  //:########AAC2020_PAINT5D_BOUND_CHECK_INPUTS://
        //:------------------------------:bounds_check_inputs://
        //:declare_variables:--------------------------------://

            I16 glo_t_x =( 0 - 5005 /** @TRAP_VALUE@ **/ );
            I16 glo_t_y =( 0 - 6006 /** @TRAP_VALUE@ **/ );

            /** 16 bits is not enough room !!!!!!!!! **/
            I32 glo_dex =( 0 - 7007 /** @TRAP_VALUE@ **/ );
            I32 glo_com =( 0 - 8008 /** @TRAP_VALUE@ **/ );
    ////    I32 arr_dex =( 0 - 9009 /** @TRAP_VALUE@ **/ );
                               
    ////    U08 var_u08 =(       99 /** @TRAP_VALUE@ **/ );
    ////    U08 aus_loc =(       23 /** @TRAP_VALUE@ **/ );

    ////    U08 old_val =(       00 /** Prev til_val **/ );

        //:--------------------------------:declare_variables://
        //:get_xy_location_of_pixel_storing_data:------------://

            aac2020_paint5d_painpix_CTO_glocpix(
                til_qua        /// Auset Tile Sub Quad Index ///
            ,   til_exp        /// TileSizeExponentEnum      ///
            ,   til_lay        /// TileLayer ................///
            ,   loc_t_x        /// Local  Tile X Coord / b_x ///
            ,   loc_t_y        /// Local  Tile Y Coord / b_y ///
            , &(glo_t_x)       /// Global Tile X Coord       ///
            , &(glo_t_y)       /// Global Tile X Coord       ///
            );;

        //:------------:get_xy_location_of_pixel_storing_data://
        //:convert_pixel_xy_to_index:------------------------://
        #define MAP_SAN ( 512 ) /** WID == HIG == SAN **/

            glo_dex = glo_t_x + ( glo_t_y  *  MAP_SAN );
            glo_com =(glo_dex * 4 /** 4: RGBA **/ );

            //:double_check_component_index:-----------------://
                U32 chk_glo_com=( 
                    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                glo_t_x 
                              ,     glo_t_y ));;

                assert(       chk_glo_com  == ((U32)glo_com) );
                assert( ((I32)chk_glo_com) == (     glo_com) );
            //:-----------------:double_check_component_index://

        #undef  MAP_SAN
        //:------------------------:convert_pixel_xy_to_index://
        //:bit_packing_stuff:--------------------------------://
        #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
        #define BIN_011 3 /** 2 set bits in a row **/

            /** ******************************************** ***
                SEE_DIAGRAM[ #DIA_P5D_MAIN#       ]
                FROM___FILE[ PAINT5D.D._          ]
            *** ******************************************** **/

           aac2020_paint5d_BitPack_Get(
                CPU_PIX //: U08* :  PIXNAME_paint5d_cpu_pix  ://
            ,   glo_com //: U08  :  Component Index. @DIV_B4@://
            ,   aus_dex //: U08  :  Auset Index: [0 - 15]    ://
            ,&(*til_val)//: U08* :  <-- GET OUTPUT PARAMETER ://
            );;

        #undef  CPU_PIX
        #undef  BIN_011
        //:--------------------------------:bit_packing_stuff://
        //:return_via_output_param:--------------------------://

            /** ******************************************** ***
            til_val | old_val : DECIMAL [  0 |  1 |  2 |  3 ]   
            til_val | old_val : BINARY  [ 00 | 01 | 10 | 11 ]   
            *** ******************************************** **/

            //: (*til_val)=( old_val );                      ://
            //: Now set using: aac2020_paint5d_BitPack_Get   ://
 
        //:--------------------------:return_via_output_param://
        
        return; //:<---- Return Via Output Param
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08                                           //: 01 ://
#undef  I16                                           //: 02 ://
#undef  I32                                           //: 03 ://
#undef  U32                                           //: 04 ://
#undef  ERR                                           //: 05 ://
//:=================================:PAINT5D_QUARKMAP_GET_PUT://
//:=================================:PAINT5D_QUARKMAP_PUT_GET://
//:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS:==================://
//:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD:=======================://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 03 ://
#define ERR  aac2020_paint5d_Halt                     //: 04 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Get_BrushState( void )
    {   
        //: @CTRL_F_HELP: aac2020_paint5d_BrushState_Get ://

        //: @VID_IID[ 0077 ]TIME[ 01H 20M 14S ]
        //:IDN_A_HF_FM_HF
        //:I_DONT_NEED_A_HELPER_FUNCTION_FOR_MY_HELPER_FUNCTION
        ERR("[IDN_A_HF_FM_HF:YEAR:2021]");
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void /** @PRIVATE@ NOT TO BE BOUND TO KEYBOARD **/
    aac2020_paint5d_Put_BrushState(

        /** @VID_IID[ 0076 ]TIME[ 5H 45M 00S ] ************* **/
        /** Inputs are I32 instead of their range of         **/
        /** U08 because they will have to be upcasted to     **/
        /** U32 anyways, so why not use I32 so we can        **/
        /** have better range checking debugs?               **/
        /** ************************************************ **/
        I32 t_q //: 01 : til_qua  : Tile Quadrant
    ,   I32 t_e //: 02 : til_exp  : Tile Exponent  
    ,   I32 t_l //: 03 : til_lay  : Tile Layer  
    ,   I32 l_x //: 04 : loc_t_x  : Local Tile Location X  
    ,   I32 l_y //: 05 : loc_t_y  : Local Tile Location Y  
    ,   I32 a_d //: 06 : aus_dex  : AUSet_inDEX  
    ,   I32 t_v //: 07 : til_val  : Tile Value  
                //[      til_val is the LAST parameter       ]//
                //[      because this is the parameter order ]//
                //[      of the function AAC2020_PAINT5D_Put ]//
                //[      @VID_IID[ 0076 ]TIME[ 05H 57M 55S ] ]//
    )
    {
        /** @VID_IID[ 0077 ]TIME[ 5H 42M 00S ] ************* **/
        /** Set Unused Values 1,2,3 to ALL ONE BITS  ....... **/
        /** So that they ensure a memory stomp if    ....... **/
        /** our code makes a mistake as to where     ....... **/
        /** to put the bits.                         ....... **/
        /**        0xRrGgBbAb                        ....... **/
        U32 u_1 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #1 **/
        U32 u_2 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #2 **/
        U32 u_3 =( 0xFFFFFFFF ); /** UNUSED_VARIABLE #3 **/
        /** ************************************************ **/

        //:7_brush_vars_bounds_check:INPUTS:-----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://

            I32 max_l_x =( 0 - 1230123 );
            I32 max_l_y =( 0 - 1230123 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            assert( t_q >= 0 && t_q <= MAX_t_q );     //: 01 ://
            assert( t_e >= 0 && t_e <= MAX_t_e );     //: 02 ://
            assert( t_l >= 0 && t_l <= MAX_t_l );     //: 03 ://
            assert( l_x >= 0 && l_x <= max_l_x );     //: 04 ://
            assert( l_y >= 0 && l_y <= max_l_y );     //: 05 ://
            assert( a_d >= 0 && a_d <= MAX_a_d );     //: 06 ://
            assert( t_v >= 0 && t_v <= MAX_t_v );     //: 07 ://
                                                             
        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        //////  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        #undef  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:-----------------:7_brush_vars_bounds_check:INPUTS://
        //:7_brush_vars_int_overflow_chk:INPUTS:-------------://

            /** Make sure a DOWNCAST and then UPCAST         **/
            /** truncates the U32 to only 8 set bits max.    **/

            assert(    (U32)(U08)0xFFFFFFFF <= 0xFF  );

            assert(  ( (I32)(U08)t_q ) == t_q );      //: 01 ://
            assert(  ( (I32)(U08)t_e ) == t_e );      //: 02 ://
            assert(  ( (I32)(U08)t_l ) == t_l );      //: 03 ://
            assert(  ( (I32)(U08)l_x ) == l_x );      //: 04 ://
            assert(  ( (I32)(U08)l_y ) == l_y );      //: 05 ://
            assert(  ( (I32)(U08)a_d ) == a_d );      //: 06 ://
            assert(  ( (I32)(U08)t_v ) == t_v );      //: 07 ://

        //:-------------:7_brush_vars_int_overflow_chk:INPUTS://
        //:Put:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   (U32)t_q, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   (U32)t_e, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   (U32)t_l, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   (U32)l_x, u_1,u_2,u_3   //:    L_X ====== B_X
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   (U32)l_y, u_1,u_2,u_3   //:    L_Y ====== B_Y
            );;                         //:#PATTERN_BREAKER# ://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   (U32)a_d, u_1,u_2,u_3
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   (U32)t_v, u_1,u_2,u_3
            );;

        //:------------------------------:Put:All_Brush_State://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Put_UsingBrush( void )
    {
        //:Declare_Brush_State_Variables:--------------------://

            /** U32 values used with: "AAC2020_TAUDEPO_Get"  **/

            U32 t_q = ( /** til_qua **/ 1001001 /** @TRAP@ **/);
            U32 t_e = ( /** til_exp **/ 2002002 /** @TRAP@ **/);
            U32 t_l = ( /** til_lay **/ 3003003 /** @TRAP@ **/);
            U32 l_x = ( /** loc_t_x **/ 4004004 /** @TRAP@ **/);
            U32 l_y = ( /** loc_t_y **/ 5005005 /** @TRAP@ **/);
            U32 a_d = ( /** aus_dex **/ 6006006 /** @TRAP@ **/);
            U32 t_v = ( /** til_val **/ 7007007 /** @TRAP@ **/);

            /** U08 values used with: "AAC2020_PAINT5D_Put"  **/

            U08 til_qua = ( /** t_q **/ 101 /** @TRAP@ **/);
            U08 til_exp = ( /** t_e **/ 102 /** @TRAP@ **/);
            U08 til_lay = ( /** t_l **/ 103 /** @TRAP@ **/);
            U08 loc_t_x = ( /** l_x **/ 104 /** @TRAP@ **/);
            U08 loc_t_y = ( /** l_y **/ 105 /** @TRAP@ **/);
            U08 aus_dex = ( /** a_d **/ 106 /** @TRAP@ **/);
            U08 til_val = ( /** t_v **/ 107 /** @TRAP@ **/);

            /** @VID_IID[ 0077 ]TIME[ 2H 19M 50S ] **/
            /** KEEP_U_1_U_2_U_3_INITED_TO_ZERO    **/
            U32 u_1 =( 0 ); //:Unused #1
            U32 u_2 =( 0 ); //:Unused #2
            U32 u_3 =( 0 ); //:Unused #3

        //:--------------------:Declare_Brush_State_Variables://
        //:Get:All_Brush_State:------------------------------://

            AAC2020_TAUDEPO_Get(        //:  001  ://
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR
            ,   &(t_q),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  002  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
            ,   &(t_e),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  003  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
            ,   &(t_l),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  004  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X //:P5D_L_X == P5D_B_X
            ,   &(l_x),&(u_1),&(u_2),&(u_3) //:L_X ====== B_X
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  005  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y //:P5D_L_Y == P5D_B_Y
            ,   &(l_y),&(u_1),&(u_2),&(u_3) //:L_Y ====== B_Y
            );;                             //:#PAT_BREAKER# ://

            AAC2020_TAUDEPO_Get(        //:  006  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR
            ,   &(a_d),&(u_1),&(u_2),&(u_3)
            );;

            AAC2020_TAUDEPO_Get(        //:  007  :// 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
            ,   &(t_v),&(u_1),&(u_2),&(u_3)
            );;

        //:------------------------------:Get:All_Brush_State://
        //:7_brush_vars_bounds_check:OUTPUTS:----------------://
        #define MAX_t_q AAC2020_PAINT5D_MAX_til_qua   //: 01 ://
        #define MAX_t_e AAC2020_PAINT5D_MAX_til_exp   //: 02 ://
        #define MAX_t_l AAC2020_PAINT5D_MAX_til_lay   //: 03 ://
        /////// MAX_l_x AAC2020_PAINT5D_MAX_loc_t_x   //: 04 ://
        /////// MAX_l_y AAC2020_PAINT5D_MAX_loc_t_y   //: 05 ://
        #define MAX_a_d AAC2020_PAINT5D_MAX_aus_dex   //: 06 ://
        #define MAX_t_v AAC2020_PAINT5D_MAX_til_val   //: 07 ://
        
        #define A assert

            U32 max_l_x =( 0 );
            U32 max_l_y =( 0 );
            if( 0 == t_e ){ max_l_x = 127 ; max_l_y = 127 ; };
            if( 1 == t_e ){ max_l_x =  63 ; max_l_y =  63 ; };
            if( 2 == t_e ){ max_l_x =  31 ; max_l_y =  31 ; };
            if( 3 == t_e ){ max_l_x =  15 ; max_l_y =  15 ; };
            if( 4 == t_e ){ max_l_x =   7 ; max_l_y =   7 ; };
            if( 5 == t_e ){ max_l_x =   3 ; max_l_y =   3 ; };
            if( 6 == t_e ){ max_l_x =   1 ; max_l_y =   1 ; };
            if( 7 == t_e ){ max_l_x =   0 ; max_l_y =   0 ; };

            /** Range_Check_Extracted_Variables **/

            A( ((I32)t_q)+0 >= 0 && t_q <= MAX_t_q ); //: 01 ://
            A( ((I32)t_e)+0 >= 0 && t_e <= MAX_t_e ); //: 02 ://
            A( ((I32)t_l)+0 >= 0 && t_l <= MAX_t_l ); //: 03 ://
            A( ((I32)l_x)+0 >= 0 && l_x <= max_l_x ); //: 04 ://
            A( ((I32)l_y)+0 >= 0 && l_y <= max_l_y ); //: 05 ://
            A( ((I32)a_d)+0 >= 0 && a_d <= MAX_a_d ); //: 06 ://
            A( ((I32)t_v)+0 >= 0 && t_v <= MAX_t_v ); //: 07 ://
                        
        #undef  A

        #undef  MAX_t_q                               //: 01 ://
        #undef  MAX_t_e                               //: 02 ://
        #undef  MAX_t_l                               //: 03 ://
        //////  MAX_l_x                               //: 04 ://
        //////  MAX_l_y                               //: 05 ://
        #undef  MAX_a_d                               //: 06 ://
        #undef  MAX_t_v                               //: 07 ://
        //:----------------:7_brush_vars_bounds_check:OUTPUTS://
        //:7_brush_vars_int_overflow_chk:OUTPUTS-------------://

            /** overflow_check___AND___assignment **/

            til_qua = (         (U08)  t_q   );       //: 01 ://
            til_exp = (         (U08)  t_e   );       //: 02 ://
            til_lay = (         (U08)  t_l   );       //: 03 ://
            loc_t_x = (         (U08)  l_x   );       //: 04 ://
            loc_t_y = (         (U08)  l_y   );       //: 05 ://
            aus_dex = (         (U08)  a_d   );       //: 06 ://
            til_val = (         (U08)  t_v   );       //: 07 ://

            assert( til_qua == ( (U32) t_q ) );       //: 01 ://
            assert( til_exp == ( (U32) t_e ) );       //: 02 ://
            assert( til_lay == ( (U32) t_l ) );       //: 03 ://
            assert( loc_t_x == ( (U32) l_x ) );       //: 04 ://
            assert( loc_t_y == ( (U32) l_y ) );       //: 05 ://
            assert( aus_dex == ( (U32) a_d ) );       //: 06 ://
            assert( til_val == ( (U32) t_v ) );       //: 07 ://
     
        //:------------:7_brush_vars_int_overflow_chk:OUTPUTS://
        //:Call_Core_Command:::PUT:--------------------------://
        //:MAIN_DATA_INTERFACE:PUT:--------------------------://

            AAC2020_PAINT5D_Put(
    /*1*/       til_qua    /** Auset Tile Sub Quadrant Index **/
    /*2*/   ,   til_exp    /** TileExponent (TileSizeEnum)   **/
    /*3*/   ,   til_lay    /** TileLayer .................   **/
    /*4*/   ,   loc_t_x    /** Local Tile X Coord / b_x      **/
    /*5*/   ,   loc_t_y    /** Local Tile Y Coord / b_y      **/
    /*6*/   ,   aus_dex    /** AUSet_inDEX (AutoTileSetIndex)**/
    /*7*/   ,   til_val    /** [ val_cur / til_val ]         **/
            );;

        //:--------------------------:MAIN_DATA_INTERFACE:PUT://
        //:--------------------------:Call_Core_Command:::PUT://

        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  ERR                                           //: 04 ://
//:==================:CREATED_TO_HELP_UNIT_TEST_USER_CONTROLS://
//:=======================:ORIGINALLY_NOT_WIRED_INTO_KEYBOARD://
//:functions_wired_into_keyboard:============================://
//:TAU:UNIFORM_CONTROLLER_FUNCTIONS:=========================://
#define CAP aac2020_paint5d_i32_Cap_u32               //: 01 ://
#define V_P    void*                                  //: 02 ://
#define I_P intmax_t /** GCC: <stdint.h> **/          //: 03 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 04 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 05 ://
#define U16 uint16_t /** GCC: <stdint.h> **/          //: 06 ://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 07 ://
#define ERR aac2020_paint5d_Halt                      //: 08 ://
#define LOG aac2020_paint5d_Info_any                  //: 09 ://

    void
    aac2020_paint5d_MoveCamera_XY(
        I32 tra_i_x  //: Amount to translate in pixels: X-axis
    ,   I32 tra_i_y  //: Amount to translate in pixels: Y-axis
    )
    {
        AAC2020_TAUTYPE_rec_inc_Tran_256(
            AAC2020_TAUDEPO.TAU_015  /** TAU Block Index     **/
        ,   AAC2020_TAUDEPO.PAINT5D  /** SubSystem ==PAINT5D **/
        ,   AAC2020_TAUDEPO.P5D_VP1  /** VP1: Viewport #1    **/
        ,   tra_i_x  /** TRAnslation_Integer_amount_X        **/
        ,   tra_i_y  /** TRAnslation_Integer_amount_Y        **/
        );;
        
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:ZoomCamera:-------------------------------------------://

        void
        aac2020_paint5d_ZoomCamera(
            I32 zom_i32 //: Amount To Zoom In And Out In Pixels
        )
        {
            /** ******************************************** **/
            /** @VID_IID[ 0083 ]TIME[ 06:03:59 ]STARTED      **/
            /** @VID_IID[ 0083 ]TIME[ 06:06:10 ]SUMMARY      **/
            /**                                              **/
            /** Camera for the paint5d editor should         **/
            /** be bounded to an area that is                **/
            /** 256x256 smallest tiles in size.              **/
            /** Camera position is going to always be in     **/
            /** units of the smallest tile size so that      **/
            /** the active brush size ( til_exp ) does       **/
            /** not alter the view of the camera.            **/
            /** ******************************************** **/

            AAC2020_TAUTYPE_rec_inc_ZoomPull_256(
                AAC2020_TAUDEPO.TAU_015  
            ,   AAC2020_TAUDEPO.PAINT5D  
            ,   AAC2020_TAUDEPO.P5D_VP1  
            ,   zom_i32  
            );;
            
            return;
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_ZoomCamera_USE_editcam(
            I32 zom_i32
        )
        {
            /** Value is only used to signify if we **/
            /** are zooming in our out.             **/
            assert( ( 0 - 1 ) == zom_i32 //:NEG==OUT
                  ||( 0 + 1 ) == zom_i32 //:POS==INN
            );;

            //: if( zom_i32 ){ /** NOOP **/ };

            /** ******************************************** **/
            /** VP1:Viewport_One(1):                         **/
            /** (Offscreen/Source/TileMapDataBitmap Viewport)**/
            /** ******************************************** **/
        
            //:Declare_Variables:----------------------------://

                U32 x_0; //: EDGE_BOUNDS_OF[ VP1 ]: MIN_X :::://
                U32 x_1; //: EDGE_BOUNDS_OF[ VP1 ]: MAX_X :::://
                U32 y_0; //: EDGE_BOUNDS_OF[ VP1 ]: MIN_Y :::://
                U32 y_1; //: EDGE_BOUNDS_OF[ VP1 ]: MAX_Y :::://

                /** Original Input Camera Size **/

                    I32 san_old =( 0 - 404 );

                /** Snapped Camera Size And Index In Array **/
                /** AAC2020_EDITCAM_tab_zom_san[ san_dex ] **/

                    I32 san_new =( 0 - 747 /**TRAPVALUE**/ );
                    I32 san_dex =( 0 - 474 /**TRAPVALUE**/ );

                /** The final camera size. We can't directly **/
                /** set this, but must do so indirectly by   **/
                /** applying a camera delta.                 **/
                /** @VID_IID[ 0159 ]TIME[ 01:55:00 ]         **/

                    I32 nex_dex=( 0 - 444 );  /** Next Index **/
                    I32 nex_san=( 0 - 222 );  /** Next Span  **/
            
            //:----------------------------:Declare_Variables://
            //:SnapCameraToFriendlySize:---------------------://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                ,  &(x_0),&(x_1),&(y_0),&(y_1)
                );;
        
                if( x_0 > x_1 ){ ERR("[OUTOFORDER:x_0:x_1]"); };
                if( y_0 > y_1 ){ ERR("[OUTOFORDER:y_0:y_1]"); };
                U32 wid=( x_1 - x_0 + 1 );
                U32 hig=( y_1 - y_0 + 1 );
                if( wid != hig ){
                    ERR("[ERR:CAM__NOT__PERFECT_SQUARE:2021]");
                };;

                san_old=( (I32)( wid|hig )     );
                if( 1
                && (   ((U32)san_old) == wid   ) 
                && (   ((U32)san_old) == hig   ) 
                && (         san_old   >   0   ) 
                ){
                    /**OKAY DO NOTHING**/
                }else{
                    ERR("[SOMETHING_WRONG:2021_02_27:802PM]");
                };;
                
                //:Snap camera size to a pre-approved size:
                aac2020_editcam_Snap_cam_san( 
                    zom_i32  //:<---[ ZOOM_DIR_TIE_BREAKER ]
                ,   san_old  //:<--- Old Input Span
                , &(san_new) //:<--- New Input Span
                , &(san_dex) //:USAGE: 
                );;          //:EDITCAM_tab_zom_san[ san_dex ]
                 
                /** @VID_IID[ 0160 ]TIME[ 00:32:13 ]******** **/
                /** Asserts Explained.              ******** **/
                assert( san_new >= 2 && san_new <= 512 );
                assert( san_dex >= 0 && san_dex <=  25 );
                assert( san_new ==
                AAC2020_EDITCAM_tab_zom_san[ san_dex ] );;

            //:---------------------:SnapCameraToFriendlySize://
            //:GetNextCameraSizeAfterSnap:-------------------://
            /** @VID_IID[ 0159 ]TIME[ 02:23:13 ]EXPLAINING   **/
            #define TAB AAC2020_EDITCAM_tab_zom_san

                //:Get the next camera size up or down,    ::://
                //:depending on if a positive or negative  ::://
                //:value was supplied.                     ::://
                //: nex_dex : Next Camera inDEX accessor   ::://
                //: nex_san : Next Camera [ span / size ]  ::://

                if( zom_i32 < 0 ){ //:NEG==OUT (ZOOM_OUT)

                    /** Larger Camera Sizes are Near TOP **/
                    /** of the array. .................. **/

                    nex_dex =(san_dex - 1 );

                    if( (0-1) == nex_dex ){
                        nex_dex=( 0 ); //:Stop At 0
                    }else
                    if( nex_dex < 0 ){
                        ERR("[OVERZOOM:2021_02_27]");
                    };;
                }else
                if( zom_i32 > 0 ){ //:POS==INN (ZOOM_INN)

                    nex_dex =( san_dex + 1);
                    if( 0x0 == TAB[ nex_dex ] ){
                        /** Null terminator hit.       **/
                        /** At bottom of list. Backup. **/
                        nex_dex--; //:<-- BACKUP 1
                    };;

                }else{
                    ERR("[NOT_ZOOM_IN:NOT_ZOOM_OUT:YEAR_2021]");
                };;

                nex_san=(
                AAC2020_EDITCAM_tab_zom_san[ nex_dex ]);;

                //:DEBUG:====================================://
                #if( AAC2020_PAINT5D_MISC_INLINED_TESTS > 0 ) 

                    /** @VID_IID[ 0160 ]TIME[ 01:58:42 ]     **/  
                    /** If the zoom we snapped to is 256 and **/
                    /** we are zooming in, then make sure    **/
                    /** the[ nex_san ](final zoom size) is   **/
                    /** __NOT__ 256x256 ...................  **/

                    if( (256 == san_new) && (zom_i32 > 0) ){

                        if( 256 == nex_san ){
                            printf("[san_dex]:%d\n",san_dex);
                            printf("[nex_dex]:%d\n",nex_dex);

                            printf("[zom_i32]:%d\n",zom_i32);
                            printf("[san_new]:%d\n",san_new);
                            printf("[nex_san]:%d\n",nex_san);
                            ERR("[I_EXPECTED_LESS:YEAR_2021]");
                        };;
                    };;

                #endif
                //:====================================:DEBUG://
        
            #undef  TAB
            //:-------------------:GetNextCameraSizeAfterSnap://
            //:APPLY_CAMERA_SNAP:----------------------------://
            /** @VID_IID[ 0159 ]BEFORE[ 02:22:32 ]EXPLAINED  **/

                I32 snapped_x_0=( 0 - 111 );
                I32 snapped_x_1=( 0 - 222 );
                I32 snapped_y_0=( 0 - 333 );
                I32 snapped_y_1=( 0 - 444 );

                //:Get absolute value between original
                //:camera size and the snapped camera size:
                //: old_ADDTO_new (Vector[ old ]--->[ new ])
                I32 old_ATO_new =( san_new - san_old  );
        ////    if( old_ATO_new <= 0 ){
        ////        old_ATO_new = ( 0 - old_ATO_new );
        ////    };;
        ////    assert( old_ATO_new >=0 );
    
                /** Delta should always be divisible by 2    **/
                /** because must [push|pull] both sides of   **/
                /** the rectangle.                           **/
                assert( old_ATO_new % 2 == 0 );
                I32 d_x =( old_ATO_new / 2 ); //:Delta_X
                I32 d_y =( old_ATO_new / 2 ); //:Delta_Y

                /** @VID_IID[ 0160 ]TIME[ 00:50:42 ]     *** **/
                /** I don't think the snap needs to know *** **/
                /** about the zooming direction.         *** **/
                snapped_x_0 =( ((I32)x_0) - ((I32)d_x) ); 
                snapped_x_1 =( ((I32)x_1) + ((I32)d_x) ); 
                snapped_y_0 =( ((I32)y_0) - ((I32)d_y) );
                snapped_y_1 =( ((I32)y_1) + ((I32)d_y) );

        ////    if( zom_i32 < 0 ){ //:ZOOMING_OUT:(GROW___RECT)
        ////
        ////        //:<<<<<<[ x_0 ]---CEN---[ x_1 ]>>>>>>
        ////        //:<<<<<<[ y_0 ]---CEN---[ y_1 ]>>>>>>
        ////        //:PULLING_RECTANGLE_APART:
        ////        snapped_x_0 =( ((I32)x_0) - ((I32)d_x) );  
        ////        snapped_x_1 =( ((I32)x_1) + ((I32)d_x) );  
        ////        snapped_y_0 =( ((I32)y_0) - ((I32)d_y) );
        ////        snapped_y_1 =( ((I32)y_1) + ((I32)d_y) );
        ////        
        ////    }else
        ////    if( zom_i32 > 0 ){ //:ZOOMING_INN:(SHRINK_RECT)
        ////
        ////        //:[ x_0 ]>>>>>>>>>CEN<<<<<<<<<[ x_1 ] 
        ////        //:[ y_0 ]>>>>>>>>>CEN<<<<<<<<<[ y_1 ] 
        ////        //:PUSH_RECTANGLE_IN_ON_ITSELF:
        ////        snapped_x_0 =( ((I32)x_0) + ((I32)d_x) );
        ////        snapped_x_1 =( ((I32)x_1) - ((I32)d_x) );
        ////        snapped_y_0 =( ((I32)y_0) + ((I32)d_y) );
        ////        snapped_y_1 =( ((I32)y_1) - ((I32)d_y) );
        ////
        ////    }else{
        ////        ERR("[WTFMAN:2020_02_27:5PM]");
        ////    };;

                if( snapped_x_0 < 0
                ||  snapped_x_1 < 0
                ||  snapped_y_0 < 0
                ||  snapped_y_1 < 0
                ){
                    ERR("[YOU_WENT_NEGATIVE:2021:541PM]");
                };;
                x_0 =( snapped_x_0 );
                x_1 =( snapped_x_1 );
                y_0 =( snapped_y_0 );
                y_1 =( snapped_y_1 );

                //:Apply the camera SNAP. This is NOT
                //:the final camera size.
                AAC2020_TAUDEPO_Put( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                ,   (x_0), (x_1), (y_0), (y_1)
                );;

                I32 span_check_x =( x_1 - x_0 + 1 );
                I32 span_check_y =( y_1 - y_0 + 1 );
                if( span_check_x != san_new
                ||  span_check_y != san_new
                ){
        
                    printf("[***************************]\n\n");

                    printf("[x_0]:%d\n", x_0 );
                    printf("[x_1]:%d\n", x_1 );
                    printf("[y_0]:%d\n", y_0 );
                    printf("[y_1]:%d\n", y_1 );

                    printf("[san_new]:%d\n" , san_new );

                    printf("[span_check_x]:%d\n",span_check_x);
                    printf("[span_check_y]:%d\n",span_check_y);

                    printf("[***************************]\n\n");
                    ERR("[I_ONLY_PLAY_DOOM_ETERNAL_2021]");
                };;

            //:----------------------------:APPLY_CAMERA_SNAP://
            //:APPLY_ZOOM_TO_FINAL_SIZE:---------------------://

                //:Error_Check_Next_Span:--------------------://
                /** **************************************** ***
                @VID_IID[ 0160 ]TIME[ 01:06:32 ]
                The FINAL camera rectangle size (san_nex)
                should be different than whatever camera
                rectangle size we snapped to. (san_new)
                *** **************************************** **/

                    if( (san_new+0) == (nex_san+0) ){

                        if( zom_i32 < 0 &&  256 == san_new ){
                            /** OK: Can't Zoom OUT Further.  **/
                            /** 256 == PAINT5D Camera Limit. **/
                        }else
                        if( zom_i32 > 0 &&    2 == san_new ){
                            /** OK: Can't Zoom INN Further.  **/
                        }else{

                            printf("[zom_i32]:%d\n", zom_i32  );
                            printf("[san_new]:%d\n", san_new  );
                            printf("[nex_san]:%d\n", nex_san  );
                            ERR("[WTF_RAWER_2021_02_27_830PM]");

                        };;
                    };;

                //:--------------------:Error_Check_Next_Span://

                /** **************************************** **/
                /** Must use helper function rather than  ** **/
                /** set directly, in case the camera is   ** **/
                /** leaking off the bounds of the dataset ** **/
                /** @VID_IID[ 0159 ]TIME[ 02:11:13 ]      ** **/
                /** **************************************** **/

                //: ATO: Add_TO 
                //: Make vector pointing from[ new ]TO[ nex ]
                I32 new_ATO_nex =( nex_san - san_new );

                
                LOG(          "[nex_san]:%d\n"
                ,   (void*)(I_P)nex_san       );;
                LOG(          "[new_ATO_nex]:%d\n"
                ,   (void*)(I_P)new_ATO_nex       );;
                
               
                /** @VID_IID[ 0160 ]TIME[ 02:22:00 ]******** **/
                /** NEGATIVE: Zooms Out. (ENLARGES_RECTANGLE)**/
                /** POSITIVE: Zooms In . (SHRINKS__RECTANGLE)**/
                aac2020_paint5d_ZoomCamera(
                    ( 0 - (new_ATO_nex/2) )
                );;

            //:---------------------:APPLY_ZOOM_TO_FINAL_SIZE://
        }

    //:-------------------------------------------:ZoomCamera://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_MoveBrush_XY(
        I32 o_x //: offset:X
    ,   I32 o_y //: offset:Y
    )
    {
        U32 b_x =( 0x00 );
        U32 b_y =( 0x00 );
        U32 u_1 ; //:Unused #1
        U32 u_2 ; //:Unused #2
        U32 u_3 ; //:Unused #3

        /** @VID_IID[ 0066 ]TIME[ 03H 59M 25S ]    **/
        /** #_TILE_SIZE_AFFECTS_CAMERA_POSITION_#  **/

        //:brush_coords:READ:--------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

        //:--------------------------------:brush_coords:READ://
        //:brush_coords:TRANSFORM:---------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0066 ]TIME[ 4H 56M 23S ]           **/
            /** The SMALLEST tile value results in a level   **/
            /** map size that is 256x256 tiles.              **/
            /**                                              **/
            /** This is because HALF of 512 is 256.          **/
            /** And we pack our tilemap data in a            **/
            /** mip-map like geometrical packing pattern.    **/
            /**                                              **/
            /** Been referring to that data structure as     **/
            /** a "QUARKMAP" / "QUARK_MAP"                   **/
            /** ******************************************** **/

            /** #_TILE_EXPONENT_AFFECTS_CAMERA_POSITION_#    **/

            U32 til_exp=( 0xFFFFFFFF ); /** TILE_EXPONENT    **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR == til_exp
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

            U16 m_c; /** m_c : Max_Coordinate ( x | y ) **/
            assert(  til_exp <= AAC2020_PAINT5D_MAX_til_exp );
            assert(     7    == AAC2020_PAINT5D_MAX_til_exp );
            m_c = aac2020_paint5d_til_exp_CTO_max_cor(til_exp);

            b_x = CAP( ((I32)b_x) + o_x , (U16)0 , (U16)m_c );
            b_y = CAP( ((I32)b_y) + o_y , (U16)0 , (U16)m_c );

        //:---------------------------:brush_coords:TRANSFORM://
        //:brush_coords:WRITE:-------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X     //:DEX_VAR
            ,   (b_x), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015     //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D     //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y     //:DEX_VAR
            ,   (b_y), (u_1), (u_2), (u_3)  //:<-- INPUT:VALUES
            );;

        //:-------------------------------:brush_coords:WRITE://
        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileValue( 
        I32 del_t_v /** Delta: TileValue( t_v ) **/
    )
    {
        /** @VID_IID[ 0066 ]TIME[ 05H 34M 55S ] **/
        /** #_MORE_NAMES_MORE_PROBLEMS_# ...... **/

        U32 til_val; /** [ TileValue / Tile_Value / til_val ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [ TIL_VAL ]
            ,  &(til_val),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            assert( 3 == AAC2020_PAINT5D_MAX_til_val );

            til_val =CAP( 
                (I32)til_val + del_t_v 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 3 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : [TIL_VAL  ]
            ,   (til_val), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileExponent( 
        I32 del_t_e /** Delta: TileExponent( t_e ) **/
    )
    {
        U32 til_exp; /** [ Tile_Exponent / til_exp ] **/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : [ TIL_EXP ]
            ,  &(til_exp),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://

            //:##############################################://
            #if( AAC2020_PAINT5D_MISC_INLINED_TESTS >= 1 ) 

                U32 original_tile_exponent =( til_exp );

            #endif //:#######################################://
            //:##############################################://

            assert( 15 == AAC2020_PAINT5D_MAX_aus_dex );

            til_exp =CAP( 
                (I32)til_exp + del_t_e 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16)15 //:<---[ @HARD_CODED@ ]
            );;

            //:##############################################://
            #if( AAC2020_PAINT5D_MISC_INLINED_TESTS >= 1 ) 

                if( 0 == original_tile_exponent ){
                if( 1 == del_t_e ){

                    if( 1 != til_exp ){
                        printf("[til_exp]:%d\n",til_exp);
                        ERR("[YOUR_CAP_FUNCTION_SUCKS_2021]");
                    };;

                };;};;

            #endif //:#######################################://
            //:##############################################://

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : [ TIL_EXP ]
            ,   (til_exp), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_DeltaMutate_TileLayer( 
        I32 del_t_l /** DELta_Tile_Layer **/
    )
    {
        U32 til_lay; /** [ TileLayer / Tile_Layer / til_lay ]**/
        U32     u_1; /** Unused # 1 **/
        U32     u_2; /** Unused # 2 **/
        U32     u_3; /** Unused # 3 **/

        //:tile_value:READ:----------------------------------://

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,  &(til_lay),&(u_1),&(u_2),&(u_3)
            );;

        //:----------------------------------:tile_value:READ://
        //:tile_value:TRANSFORM:-----------------------------://
 
            assert( 2 == AAC2020_PAINT5D_MAX_til_lay );

            til_lay =CAP( 
                (I32)til_lay + del_t_l 
            ,   (U16) 0 //:<---[ @HARD_CODED@ ]
            ,   (U16) 2 //:<---[ @HARD_CODED@ ]
            );;

        //:-----------------------------:tile_value:TRANSFORM://
        //:tile_value:WRITE:---------------------------------://

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : [ TIL_LAY ]
            ,   (til_lay), (u_1), (u_2), (u_3)
            );;

        //:---------------------------------:tile_value:WRITE://

        return;
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_ToggleTile( void )
    {
        //:ADDED_DATE[ 2021_02_23 ]//////////////////////////://

            //:dirty flag.
            aac2020_paint5d_needs_to_sync_to_gpu=( 1 );

        //://////////////////////////ADDED_DATE[ 2021_02_23 ]://
        //:variable_declarations:----------------------------://

            /// t_x =  ENDED_UP_USING[ loc_t_x ]INSTEAD ////////
            /// t_y =  ENDED_UP_USING[ loc_t_y ]INSTEAD ////////

            U32 b_x = ( 0 + 123000123 ); /** b_x : brush_x **/
            U32 b_y = ( 0 + 123000123 ); /** b_y : brush_y **/

            /** ******************************************** ***
                @VID_IID[ 0072 ]TIME[ 04H 23M 45S ]

                val_bru :
                    Current[ til_val ]loaded into Josh's
                    tile brush. This is what he is 
                    currently painting with.

                val_cur :
                    Current[ til_val ]found on the canvas
                    that Josh is painting on. More precisely
                    a[ til_val ]encoded into a section
                    of a BYTE of an RGBA pixel stored in
                    a cpu side bitmap known as:

                    AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/

            U32 til_qua =( 1234 ) ;  /**Tile_Quadrant_000_002**/
            U32 til_exp =( 2345 ) ;  /**EXPONENT ( P5D_T_E ) **/
            U32 til_lay =( 3456 ) ;  /**   LAYER ( P5D_T_L ) **/
            U32 loc_t_x =( 4567 ) ;  /**LOCAL__X ( P5D_B_X ) **/
            U32 loc_t_y =( 5678 ) ;  /**LOCAL__Y ( P5D_B_Y ) **/
            U32 aus_dex =( 6789 ) ;  /**Auset_Index_000_015  **/
        //: U32 til_val =( ---- ) ;  /** THIS IS[ val_bru ]  **/

            U32 val_bru =( 4433 ) ;  /** LOADED INTO BRUSH   **/    
            U32 val_cur =( 3344 ) ;  /** ON THE TILEMAP      **/
            U32 val_put =( 1212 ) ;  /** Actual Value To Put **/

            U08 til_val =(  111 ) ;  /** val_cur BUT 8 bits  **/
            assert( 1 == sizeof( til_val ) ); /** 1 BYTE **/

            U32 u_1 ; //: unused_number_001 ://
            U32 u_2 ; //: unused_number_002 ://
            U32 u_3 ; //: unused_number_003 ://
  
        //:----------------------------:variable_declarations://
        //:GET_STATE:OF_BRUSH:-------------------------------://
        /** ************************************************ ***
        Variables we need from this section:
        1:  til_qua <---- P5D_T_Q
        2:  til_exp <---- P5D_T_E
        3:  til_lay <---- P5D_T_L
        4:  loc_t_x <---- P5D_B_X ( brush.xy === local.xy )
        5:  loc_t_y <---- P5D_B_Y ( brush.xy === local.xy )
        6:  aus_dex <---- P5D_A_D
        7:  val_bru <---- P5D_T_V ( til_val  === val_bru  )
        *** ************************************************ **/
            //:GET_STATE:til_qua:----------------------------://

                //: get_tile_value_loaded_into_brush ://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_Q //:DEX_VAR : til_qua
                ,  &(til_qua),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_qua://
            //:GET_STATE:til_exp:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR : til_exp
                ,  &(til_exp),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_exp://
            //:GET_STATE:til_lay:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR : til_lay
                ,  &(til_lay),&(u_1),&(u_2),&(u_3)
                );;
                
            //:----------------------------:GET_STATE:til_lay://
            //:GET_STATE:loc_t_x:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR : brush_x
                ,  &(loc_t_x),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_x://
            //:GET_STATE:loc_t_y:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR : brush_y
                ,  &(loc_t_y),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:loc_t_y://
            //:GET_STATE:aus_dex:----------------------------://

                /** VOID **/
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_A_D //:DEX_VAR : aus_dex
                ,  &(aus_dex),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:aus_dex://
            //:GET_STATE:val_bru:----------------------------://
            //:GET_STATE:til_val:----------------------------://

                //: get_tile_value_loaded_into_brush ://
                //[  til_val ==== val_bru ]//

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR : til_val
                ,  &(val_bru),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:GET_STATE:til_val://
            //:----------------------------:GET_STATE:val_bru://

        //:-------------------------------:GET_STATE:OF_BRUSH://
        //:get_current_value_on_tile_map:--------------------://
    
            /** ******************************************** **/
            /**   @VID_IID[ 0066 ]TIME[ 07H 27M 23S ]        **/
            /**   @_CTRL_F_HELP_@                            **/
            /**   WRONG[ AAC2020_PAINT5D_TileValue_GET ]     **/
            /**   WRONG[ AAC2020_PAINT5D_GetTileValue  ]     **/
            /** CORRECT[ AAC2020_PAINT5D_Get           ]     **/
            /** ******************************************** **/
    
            /** @VID_IID[ 0066 ]TIME[ 08H 14M 15S ] ******* **/
            /** #_WHY_PAINT5D_GET_PARAM_ORDER_# **/
            AAC2020_PAINT5D_Get(
                til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]     **/
            ,   til_exp   /** 02 :  IN[ PAINT5D.D._    ]     **/
            ,   til_lay   /** 03 :                           **/
            ,   loc_t_x   /** 04 : For diagrams explaining   **/
            ,   loc_t_y   /** 05 : these parameters.         **/
            ,   aus_dex   /** 06 : @VID_IID[ 0075 ]          **/
            ,&( til_val ) /** 07 : @TIME[ 2H 46M 20S ]       **/
            );;
                
            /** ******************************************** ***
                @VID_IID[ 0075 ]TIME[ 2H 50M 30S ]       
                Necessary because of the different bit   
                widths required by different functions.  
            *** ******************************************** **/

            val_cur = til_val ;

            /** ******************************************** **/

        //:--------------------:get_current_value_on_tile_map://
        //:brush_coords:READ:--------------------------------://

            /** ******************************************** **/
            /** @VID_IID[ 0075 ]TIME[ 01H 41M 32S ]          **/
            /** This is a bit redundant. Looks like we had   **/
            /** some confusion on our variable names.        **/
            /** Lets just use [ b_x , b_y ] as a redundancy  **/
            /** to check our work I guess.                   **/
            /** ******************************************** **/

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_X    //:DEX_VAR
            ,  &(b_x),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            AAC2020_TAUDEPO_Get( 
                AAC2020_TAUDEPO.TAU_015    //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D    //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_B_Y    //:DEX_VAR
            ,  &(b_y),&(u_1),&(u_2),&(u_3) //:<-- OUTPUT:PARAMS
            );;

            assert( loc_t_x == b_x ); //:@_IDENTICAL_VALUES_@://
            assert( loc_t_y == b_y ); //:@_IDENTICAL_VALUES_@://

        //:--------------------------------:brush_coords:READ://
        //:SET_OR_UNSET_THE_TILE:----------------------------://

            /** ******************************************** ***
                If the value loaded into the brush is the
                same value as the value currently on the
                tilemap, we will [ UNSET / ERASE ]the tile.

                If the tile values DO NOT MATCH, then
                we will [ SET / OVERWRITE ] the tile.
            *** ******************************************** **/

            if( val_bru != val_cur ){  /** [ OVERWRITE ] **/

                val_put = val_bru; 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]

                LOG("[ToggleTile:ADD]",((void*)0));
                LOG("[:::::::val_bru]:%d\n", (V_P)(I_P)val_bru);
            }else
            if( val_bru == val_cur ){  /** [ERASE/UNSET] **/

                /** **************************************** **/
                /**                                          **/
                /** @VID_IID[ 0075 ]TIME[ 1H 54M 00S ]       **/
                /**                                          **/
                /** By convention, the zero tile will        **/
                /** mean empty space. However the code       **/
                /** should NOT be like gamemaker. We should  **/
                /** NOT treat tile zero any differently      **/
                /** when running code on it. Thus if we      **/
                /** really wanted to, we could put a         **/
                /** pattern in tile value zero. For          **/
                /** example, the void of space. Like a       **/
                /** "star space" tile or something.          **/
                /**                                          **/
                /** Example Void Of Space Tile:              **/
                /** youtube.com/watch?v=tl40xidKF-4&t=1m25s  **/
                /** **************************************** **/

                val_put = ( 0 ); 
                assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                        //:[ 00 | 01 | 10 | 11 ]
                LOG("[ToggleTile:REM]",((void*)0));
                LOG("[:::::::val_bru]:%d\n", (V_P)(I_P)val_bru);
            }else{
                ERR("[EDCL:2021_01_02:PAINT5D]");
            };;

            assert( val_put <= 3 ); //:[  0 |  1 |  2 |  3 ]
                                    //:[ 00 | 01 | 10 | 11 ]

            AAC2020_PAINT5D_Put(
                  til_qua   /** 01 : SEE[ #DIA_P5D_MAIN# ]   **/
            ,     til_exp   /** 02 :  IN[ PAINT5D.D._    ]   **/
            ,     til_lay   /** 03 :                         **/
            ,     loc_t_x   /** 04 : For diagrams explaining **/
            ,     loc_t_y   /** 05 : these parameters.       **/
            ,     aus_dex   /** 06 : @VID_IID[ 0075 ]        **/
            ,(U08)val_put   /** 07 : @TIME[ 2H 44M 48S ]     **/
            );;

        //:----------------------------:SET_OR_UNSET_THE_TILE://
        return;
    }

#undef  CAP                                           //: 01 ://
#undef  V_P                                           //: 02 ://
#undef  I_P                                           //: 03 ://
#undef  I32                                           //: 04 ://
#undef  U32                                           //: 05 ://
#undef  U16                                           //: 06 ://
#undef  U08                                           //: 07 ://
#undef  ERR                                           //: 08 ://
#undef  LOG                                           //: 09 ://
//:=========================:TAU:UNIFORM_CONTROLLER_FUNCTIONS://
//:============================:functions_wired_into_keyboard://
//:functions_wired_into_keyboard:============================://
//:DEFAULT_TILE_DESIGN_FILL_PATTERN:=========================://
#define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix       //: 01 ://
#define MAX_COM ((512*512*4)-1) /**Max com_dex **/    //: 02 ://
#define     U08 uint8_t    /** GCC: <stdint.h> **/    //: 03 ://
#define     I32 int32_t    /** GCC: <stdint.h> **/    //: 04 ://
#define     B11 3 /** B11 == BINARY:11 ....... **/    //: 05 ://
#define     ERR aac2020_paint5d_Halt                  //: 06 ://
#define     LOG aac2020_paint5d_Info_any              //: 07 ://

    void
    aac2020_paint5d_DrawDefaultAuset_001(
        void
    )
    {   
        LOG("[aac2020_paint5d_DrawDefaultAuset_001:BEG]",0);

        I32 clr; //: clr for clear
                     
        I32 aus; //: aus for aus_dex
        I32 t_q; //: t_q for til_qua
        I32 t_e; //: t_e for til_exp
        I32 t_l; //: t_l for til_lay
        I32 e_e; //: e_e for "edge index"

        I32 t_v; //: t_v for til_val

        I32 x_0; //: Iterate through X & Y
        I32 x_1; //: coordinates by specifying
        I32 y_0; //: the bounds of our
        I32 y_1; //: double loop.

        I32 m_c; //: max_cor (Maximum [t_x | t_y] coordinate)
        I32 t_x; //: loc_t_x coordinate
        I32 t_y; //: loc_t_y coordinate

        /** Before we draw, clear our canvas. **/   
        /** @VID_IID[ 0094 ]TIME[ 00:25:50 ]  **/
        for( clr = 0 ; clr <= MAX_COM ; clr++ ){
            CPU_PIX[ clr ]=((U08)( 0x00 ));
        };;
    
        assert( (16-1)== AAC2020_PAINT5D_MAX_aus_dex ); //: aus
        assert( ( 4-1)== AAC2020_PAINT5D_MAX_til_qua ); //: t_q
        assert( (   7)== AAC2020_PAINT5D_MAX_til_exp ); //: t_e
        assert( ( 3-1)== AAC2020_PAINT5D_MAX_til_lay ); //: t_l
        assert(    B11== AAC2020_PAINT5D_MAX_til_val ); //: t_v

        /** @VID_IID[ 0094 ]TIME[ 01:19:40 ]       * * * * * **/
        /** Variable shadowing is bad. Rewind the  * * * * * **/
        /** video a minute or so to see what I     * * * * * **/
        /** just deleted.                          * * * * * **/
        for( aus = 0 ; aus <= (16-1) ; aus ++ ){
        for( t_q = 0 ; t_q <= ( 4-1) ; t_q ++ ){
        for( t_e = 0 ; t_e <= (   7) ; t_e ++ ){
        for( t_l = 0 ; t_l <= ( 3-1) ; t_l ++ ){
        for( e_e = 0 ; e_e <= ( 4-1) ; e_e ++ ){

            m_c =((I32)
                aac2020_paint5d_til_exp_CTO_max_cor( t_e )
                );;         /** til_exp ==> max_cor **/
                            /**   t_e ======> m_c   **/

            /** @VID_IID[ 0094 ]TIME[ 00:57:00 ] ******** ** **/
            /** Have the tile value depend on what layer  ** **/
            /** we are on, as this will be helpful for    ** **/
            /** debugging the pattern when we are         ** **/
            /** inspecting it in MS-Paint or rendering    ** **/
            /** it with GLSL code.  ** ****************** ** **/
            t_v =(  t_l + 1  );    /** ****************** ** **/
            assert( t_v <= 3 );    /** ****************** ** **/

            //:configure_edge_to_draw:-----------------------://

                /** @VID_IID[ 0094 ]TIME[ 01:07:05 ] ******* **/
                /** We just one a single line of tiles drawn **/
                /** around the boarders of the currently     **/
                /** active sub-tile of the active auset.     **/
                /** **************************************** **/

                if( 0 == e_e ){ //:TOP: EDGE

                    x_0=(   0      ); //:MOVE_ON:X_AXIS
                    x_1=(  m_c     ); //:MOVE_ON:X_AXIS

                    y_0=(   0      ); //:STATIC:TOP
                    y_1=(   0      ); //:STATIC:TOP
                }else
                if( 1 == e_e ){ //:BOT: EDGE

                    x_0=(   0      ); //:MOVE_ON:X_AXIS
                    x_1=(  m_c     ); //:MOVE_ON:X_AXIS

                    y_0=(  m_c     ); //:STATIC:BOT
                    y_1=(  m_c     ); //:STATIC:BOT
                }else
                if( 2 == e_e ){ //:LEF: EDGE

                    x_0=(   0      ); //:STATIC:LEF
                    x_1=(   0      ); //:STATIC:LEF

                    y_0=(   0      ); //:MOVE_ON:Y_AXIS
                    y_1=(  m_c     ); //:MOVE_ON:Y_AXIS
                }else
                if( 3 == e_e ){ //:RIG: EDGE

                    x_0=(  m_c     ); //:STATIC:RIG
                    x_1=(  m_c     ); //:STATIC:RIG

                    y_0=(   0      ); //:MOVE_ON:Y_AXIS
                    y_1=(  m_c     ); //:MOVE_ON:Y_AXIS
                }else{
                    ERR("[BAD_EDGE_INDEX:YEAR:2021]");
                };;

            //:-----------------------:configure_edge_to_draw://
            //:draw_one_edge:--------------------------------://

                for( t_x = x_0 ; t_x <= x_1 ; t_x ++ ){
                for( t_y = y_0 ; t_y <= y_1 ; t_y ++ ){

                    /** Hard Coded To Use: CPU_PIX **/
                    AAC2020_PAINT5D_Put(
                        (U08)t_q //: U08 [ til_qua / t_q ] 1 ://
                    ,   (U08)t_e //: U08 [ til_exp / t_e ] 2 ://
                    ,   (U08)t_l //: U08 [ til_lay / t_l ] 3 ://
                    ,   (U08)t_x //: U08 [ loc_t_x / t_x ] 4 ://
                    ,   (U08)t_y //: U08 [ loc_t_y / t_y ] 5 ://
                    ,   (U08)aus //: U08 [ aus_dex / aus ] 6 ://
                    ,   (U08)t_v //: U08 [ til_val / t_v ] 7 ://
                    );;                               

                };;};;

            //:--------------------------------:draw_one_edge://

        };;};;};;};;};;

        LOG("[aac2020_paint5d_DrawDefaultAuset_001:END]",0);
    }

#undef  CPU_PIX                                       //: 01 ://
#undef  MAX_COM                                       //: 02 ://
#undef      U08                                       //: 03 ://
#undef      I32                                       //: 04 ://
#undef      B11                                       //: 05 ://
#undef      ERR                                       //: 06 ://
#undef      LOG                                       //: 07 ://
//:=========================:DEFAULT_TILE_DESIGN_FILL_PATTERN://
//:============================:functions_wired_into_keyboard://
//:MOUSE_INPUT_HANDLER:(MouInn):=============================://
#define U08  uint8_t /** GCC: <stdint.h> **/          //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 03 ://
#define MOU struct AAC2020_MOUTEMP                    //: 04 ://
#define REC struct AAC2020_POLYOGL_REC                //: 05 ://
#define IV2 struct AAC2020_POLYOGL_IV2                //: 06 ://
#define ASS assert                                    //: 07 ://
#define LOG aac2020_paint5d_Info_any                  //: 08 :// 
#define ERR aac2020_paint5d_Halt                      //: 09 ://        

    //:OMC: On_Mouse_Click / OnMouseClick

    I32
    aac2020_paint5d_MouInn_OMC_InBoundCheck(
        MOU* mou
    )
    {
    #define CLK_C_X ( mou -> clk_c_x )
    #define CLK_C_Y ( mou -> clk_c_y )

        I32 is_click_within_canvas_user_view_bounds=( 0 );

        U32 x_0 ;
        U32 x_1 ;
        U32 y_0 ;
        U32 y_1 ;

        AAC2020_TAUDEPO_Get( 
            AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
        ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
        ,   AAC2020_TAUDEPO.P5D_VP0 //:DEX_VAR
        ,  &(x_0),&(x_1),&(y_0),&(y_1)
        );;

        if( 1==1
        &&  CLK_C_X >= x_0 && CLK_C_X <= x_1
        &&  CLK_C_Y >= y_0 && CLK_C_Y <= y_1
        ){
            is_click_within_canvas_user_view_bounds =( 1 );
        }else{
            is_click_within_canvas_user_view_bounds =( 0 );

            printf("[mou->clk_c_x]:%d\n",mou->clk_c_x);
            printf("[mou->clk_c_y]:%d\n",mou->clk_c_y);
            LOG("[CLICK_NOT_IN_CANVAS_USER_VIEW_BOUNDS]",0);
        };;
         
        return( 
            is_click_within_canvas_user_view_bounds
        );;
    #undef CLK_C_X
    #undef CLK_C_Y
    }

    I32
    aac2020_paint5d_MouInn_OMC_InBoundActions(
        MOU* mou
    )
    {
        //:toggle_tile_at_mouse_position:--------------------://
         
        LOG("[PAINT5D:IN_BOUND_MOUSE_CLICK]" , ((void*)0) );
                
            //:Declare_Variables:----------------------------://

                U32 u_1 ; //:UNUSED_1                ://
                U32 u_2 ; //:UNUSED_2                ://
                U32 u_3 ; //:UNUSED_3                ://

                U32 x_0 ;
                U32 x_1 ;
                U32 y_0 ;
                U32 y_1 ;

                REC p5d_vp0;
                REC p5d_vp1;

                U32 til_exp; //:AKA[ p5d_exp | t_e ]
                             //:[ til_exp == TileSizeExponent ]

                U08 u08_t_q ;  //: TILE_QUADRANT_1D_LOCATION ://
                U08 u08_b_x ;  //: BRUSH_PIXEL_LOCATION: X   ://
                U08 u08_b_y ;  //: BRUSH_PIXEL_LOCATION: Y   ://

                U32 p5d_t_q ;  //: TILE_QUADRANT_1D_LOCATION ://
                U32 p5d_b_x ;  //: BRUSH_PIXEL_LOCATION: X   ://
                U32 p5d_b_y ;  //: BRUSH_PIXEL_LOCATION: Y   ://

                IV2 fic ; //:Fragment_Integer_Coordinate
                IV2 cuv ; //:cuv: Canvas_User_View://
                        //:SEE_FILE[ PAINT5D.D._           ]
                        //:SEE_DIAGRAM[ #CANVAS_USER_VIEW# ]
                
                U32 cuv_i_x; //:cuvipix.x
                U32 cuv_i_y; //:cuvipix.y

            //:----------------------------:Declare_Variables://
            //:Get_RECTANGLE_Vars_From_CPU_Bitmap:-----------://

                //:- - - - - - - - - - -- - - - - - - - - - -://
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VP0 //:DEX_VAR
                ,  &(x_0),&(x_1),&(y_0),&(y_1)
                );;
                p5d_vp0.x_0 = ( x_0 );
                p5d_vp0.x_1 = ( x_1 );
                p5d_vp0.y_0 = ( y_0 );
                p5d_vp0.y_1 = ( y_1 );
                //:- - - - - - - - - - -- - - - - - - - - - -://
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                ,  &(x_0),&(x_1),&(y_0),&(y_1)
                );;
                p5d_vp1.x_0 = ( x_0 );
                p5d_vp1.x_1 = ( x_1 );
                p5d_vp1.y_0 = ( y_0 );
                p5d_vp1.y_1 = ( y_1 );
                //:- - - - - - - - - - -- - - - - - - - - - -://

            //:-----------:Get_RECTANGLE_Vars_From_CPU_Bitmap://
            //:Get_Brush_til_exp:----------------------------://

                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                ,  &(til_exp),&(u_1),&(u_2),&(u_3)
                );;

            //:----------------------------:Get_Brush_til_exp://
            //:MouseFrag_CTO_CanvasUserView:-----------------://

                fic.x =( mou -> clk_c_x );
                fic.y =( mou -> clk_c_y );

                cuv=(AAC2020_FRAGCOM_fic_MAP_cuv(
                    fic , p5d_vp0 , p5d_vp1
                ));;
                if(  1==1
                &&   cuv.x >=0 && cuv.x <= (256-1)     
                &&   cuv.y >=0 && cuv.y <= (256-1)  
                ){
                    /** Do nothing. Valid Range. **/
                }else{
                    printf("[*******************]\n\n");
                    printf("[fic.x]:%d\n", fic.x );
                    printf("[fic.y]:%d\n", fic.y );
                    printf("[cuv.x]:%d\n", cuv.x );
                    printf("[cuv.y]:%d\n", cuv.y );
                    printf("[*******************]\n\n");
                    ERR("[CANVAS_USER_VIEW_OOB:YEAR_2021]");
                };;
                cuv_i_x=( (U08)( cuv.x ) );
                cuv_i_y=( (U08)( cuv.y ) );
          
            //:-----------------:MouseFrag_CTO_CanvasUserView://
            //:CanvasUserView_CTO_BrushPixelCoord:-----------://

                //:[ loc_t_x ===( b_x | brushpix.x ) ]
                //:[ loc_t_y ===( b_y | brushpix.y ) ]

                AAC2020_PAINT5D_cuvipix_CTO_painqab(
                    cuv_i_x  //:Canvas_User_View:cuvipix: X 
                ,   cuv_i_y  //:Canvas_User_View:cuvipix: Y 
                ,   til_exp  //:TileSizeExponent:til_exp

                , &(u08_t_q) //:TileQuadrant/til_qua/P5D_T_Q
                , &(u08_b_x) //:Brush_X:OUTPUT_PARAM/P5D_B_X
                , &(u08_b_y) //:BRUSH_Y:OUTPUT_PARAM/P5D_B_Y
                );;
                p5d_t_q=( (U32)u08_t_q );
                p5d_b_x=( (U32)u08_b_x );
                p5d_b_y=( (U32)u08_b_y );

                //:Pretty sure this is wrong...
                //:Because it is not local to tile quadrant.
                printf("[p5d_b_x]:%d\n", p5d_b_x);
                printf("[p5d_b_y]:%d\n", p5d_b_y);

            //:-----------:CanvasUserView_CTO_BrushPixelCoord://
            //:Store_Brush_Coord_In_Texture:-----------------://
            /** ******************************************** ***
            @VID_IID[ 0153 ]TIME[ 01:36:32 ]
            The [ p5d_b_x , p5d_b_y ] coordinate is LOCAL
            to the TileQuadrant( t_q / til_qua ) so we
            MUST SET the[ p5d_t_q ]as well here for the
            toggle tile to function properly.
            *** ******************************************** **/

                AAC2020_TAUDEPO_Put( 
                    AAC2020_TAUDEPO.TAU_015        //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D        //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_T_Q        //:DEX_VAR
                ,   (p5d_t_q), (u_1), (u_2), (u_3) //:<-- OUT
                );;

                AAC2020_TAUDEPO_Put( 
                    AAC2020_TAUDEPO.TAU_015        //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D        //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_X        //:DEX_VAR
                ,   (p5d_b_x), (u_1), (u_2), (u_3) //:<-- OUT
                );;
        
                AAC2020_TAUDEPO_Put( 
                    AAC2020_TAUDEPO.TAU_015        //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D        //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_B_Y        //:DEX_VAR
                ,   (p5d_b_y), (u_1), (u_2), (u_3) //:<-- OUT
                );;

            //:-----------------:Store_Brush_Coord_In_Texture://
            //:Statefull_Toggle_Tile_Function:---------------://

                aac2020_paint5d_ToggleTile();

            //:---------------:Statefull_Toggle_Tile_Function://
    
        //:--------------------:toggle_tile_at_mouse_position://

        return( 0 );
    }

    //:
    I32                //: OMS:On_Mouse_Scroll
    aac2020_paint5d_MouInn_OMS_OuterMain( 
        MOU* mou 
    )
    {
        //:@CTRL_F_HELP@: aac2020_paint5d_MouInn_OnMouseScroll

        //:ZoomCamera:---------------------------------------://
        //- MWN AAC2020_IMOUBOX_mwn  /**MouseWheelNotches**/ -//
        /** ************************************************ ***
        @VID_IID[ 0159 ]TIME[ 02:52:42 ] 
        DONT USE[ AAC2020_IMOUBOX_mwn ]here. While[ mou ]
        object is create at the moment by copying from
        the filescope[ AAC2020_IMOUBOX_mwn ]variable. That
        will NOT always be the case. The whole idea of having
        a temporary[ MOU / AAC2020_MOUTEMP ]struct is to
        DE-COUPLE the filescope state from this function.
        *** ************************************************ **/

        //[ ME: TWARD:           ]//
        //[ luuncho: towards lol ]//

            //: mou -> whe_mwn <===> AAC2020_IMOUBOX_mwn
        
            if( 
                //: chr_key == KEY_P5D.p5d_vp1_z_o 
                mou -> whe_mwn < 0 //:NEG/TWARD_USER
            ){
            //: aac2020_paint5d_ZoomCamera( 0 - 1 ); //:NEG==OUT
            //- aac2020_paint5d_ZoomCamera(  MWN  );         -//
                aac2020_paint5d_ZoomCamera_USE_editcam( 0 - 1 );
            }else                                     
            if( 
                //: chr_key == KEY_P5D.p5d_vp1_z_i 
                mou -> whe_mwn > 0 //:POS/AWAY_USER
            ){         
            //: aac2020_paint5d_ZoomCamera( 0 + 1 ); //:POS==INN
            //- aac2020_paint5d_ZoomCamera(  MWN  );         -//
                aac2020_paint5d_ZoomCamera_USE_editcam( 0 + 1 );
            };;
        
        //- #undef MWN -//
        //:---------------------------------------:ZoomCamera://

        return( 0 );
    }

    I32
    aac2020_paint5d_MouInn_OMC_OuterMain(
        MOU* mou
    )
    {
        //:::::::::::::::::::::::::OMC:OnMouseClick::::::::::://
        if( aac2020_paint5d_MouInn_OMC_InBoundCheck(   mou )>0){
            aac2020_paint5d_MouInn_OMC_InBoundActions( mou );
        };;

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32                 //:OD2:On_Down_2 (2 == RIGHT_MOUSE_BTN)
    aac2020_paint5d_MouInn_OD2_OuterMain(
        MOU* mou
    )
    {
        //:printf("[OD2...]\n"); fflush(stdout);

        if( ( (mou -> iss_m2d)+0 ) <= 0 ){
            /**This function should only be called when **/
            /**the non-primary mouse button is down.    **/
            ERR("[OD2==OnDown2==OnMouseLeftButtonDown]");
        };;

        U32 x_0;
        U32 x_1;
        U32 y_0;
        U32 y_1;

        //:STORE_DRAGSTART_STATE:============================://
        if( 1 == mou -> iss_m2d  /** FIRST MOUSE DOWN **/ ){

            LOG("[FIRST_MOUSE_DOWN]",0);

            //:OFFSCREEN_DATA_VIEWPORT:======================://
            //:AKA:CAMERA_____VIEWPORT:======================://
        

                //:[ P5D_VP1 ]>>>>>>>[ P5D_VD1 ]://

                //: VP1:Viewport_One(1): 
                //:(Offscreen/Source/TileMapDataBitmap Viewport)
                AAC2020_TAUDEPO_Get( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                ,  &(x_0),&(x_1),&(y_0),&(y_1)
                );;

                AAC2020_TAUDEPO_Put( 
                    AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                ,   AAC2020_TAUDEPO.P5D_VD1 //:DEX_VAR
                ,   (x_0), (x_1), (y_0), (y_1)
                );;

            //:======================:OFFSCREEN_DATA_VIEWPORT://
            //:======================:AKA:CAMERA_____VIEWPORT://
            //:STORE_MOUSE_DOWN_COORDS:======================://

                //[ GINAMOU: Should have already done this.  ]//
                //[ MOU* mou , should already have this.     ]//
            
                /** *********************************** **/
                /** @VID_IID[ 0163 ]TIME[ 02:03:13 ]    **/
                /** Assert Valid Configuration upon     **/
                /** the mouse-down state being entered. **/
                /** *********************************** **/

                /** TEST ONLY VALID IF IT IS DRAGSTART ***** **/
                /** @VID_IID[ 0163 ]TIME[ 06:41:52 ]   ***** **/
                /** @VID_IID[ 0165 ]TIME[ 00:41:23 ]DS2_BUGGY**/
            /// if(      mou -> iss_ds2 ){ //:DRAG_START_2
                if( 1 == mou -> iss_m2d ){ //:FIRST_MOUSE_DOWN
                #define P_F printf

                    if( mou -> dow_d2x != mou -> pix_m2x
                    ||  mou -> dow_d2y != mou -> pix_m2y
                    ){
                        P_F("\n\n");
                        P_F("[dow_d2x]:%d\n", mou -> dow_d2x);
                        P_F("[pix_m2x]:%d\n", mou -> pix_m2x);
                        
                        P_F("\n\n");
                        P_F("[dow_d2y]:%d\n", mou -> dow_d2y);
                        P_F("[pix_m2y]:%d\n", mou -> pix_m2y);
                        
                        P_F("\n\n");
                        //:"[DOWNSTATE_!_SYNCED_WITH_CURPOS]"://
                        ERR("[pix_NOT_dow_YEAR_2021]");
                    };;

                #undef  P_F
                };; //:FIRST_MOUSE_DOWN
            /// };; //:DRAG_START_2

            //:======================:STORE_MOUSE_DOWN_COORDS://

        };; /** Is_Drag_Start ? **/
        //:============================:STORE_DRAGSTART_STATE://
        //:PERFORM_DRAGGING_PANNING_OF_CAMERA:===============://
        if( mou -> iss_m2d >= 2 ){

            LOG("[DRAGGIN]",0);

            AAC2020_DRAGCOM_Drag(

                //:LOCATE_YOUR_CAMERA_RECTANGLES:
            /**/AAC2020_TAUDEPO.TAU_015
            ,   AAC2020_TAUDEPO.PAINT5D
            ,   AAC2020_TAUDEPO.P5D_VD1 //:DOWNSTATE:CAMERA
            ,   AAC2020_TAUDEPO.P5D_VP1 //:  CURRENT:CAMERA
            ,   AAC2020_TAUDEPO.P5D_VP0 //:   SCREEN:RECT

            ,   mou -> dow_d2x  //:INITIAL_MOUSE_DOWN_COORD
            ,   mou -> dow_d2y  //:INITIAL_MOUSE_DOWN_COORD

            ,   mou -> pix_m2x  //:CURRENT_MOUSE______COORD
            ,   mou -> pix_m2y  //:CURRENT_MOUSE______COORD

            ,   256 //:<-- MAX_WINDOWS_SIZE 
            );;

        };;
        //:===============:PERFORM_DRAGGING_PANNING_OF_CAMERA://

        return( 0 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    I32                //: OU2:On_Upp_2 (2==RIGHT_MOUSE_BUTTON)
    aac2020_paint5d_MouInn_OU2_OuterMain(
        MOU* mou
    )
    {
        if( ((MOU*)0) == mou ){ /** NOOP **/ };

        //:RESOLVE_DRAG_STATE:===============================://

            //[ -------------------------------------------- ]//
            //[ Do nothing because click+drag should have    ]//
            //[ been continually updating the whole time     ]//
            //[ the RIGHT( Non-primary )MOUSE button was     ]//
            //[ down.                                        ]//
            //[ -------------------------------------------- ]//

        //:===============================:RESOLVE_DRAG_STATE://
             

        return( 0 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    I32
    aac2020_paint5d_MouInn(
        MOU* mou
    )
    {
        if( ((mou -> gam_tik)+0) != AAC2020_GAMTICK_gam_tik ){

            /** @VID_IID[ 0155 ]TIME[ 02:27:13 ] ******** **/
            /** Window code might not sync with events... **/
            /**                                           **/
            /** Don't do this way... Object can easily be **/
            /** out of lock step with window code.        **/
            /** Do nothing. Object Is Expired.            **/
            /** ***************************************** **/
        }

        if( 
            mou -> iss_exp >= 1 
        //- mou -> expired >= 1 -//
        ){

            /** Object Flagged As Expired. **/
            /** Do not use it.             **/
        
        }else{
            
            if( mou -> iss_m_c ){ //: ISS_Mouse_Clicking?

                //:                    OMC:OnMouseClick
                aac2020_paint5d_MouInn_OMC_OuterMain( mou );

            };;
            if( mou -> iss_m_s ){ //: ISS_Mouse_Scrolling?

                aac2020_paint5d_MouInn_OMS_OuterMain( mou );

            };;
            if( mou -> iss_m2d ){ //:NON-PRIMARY_MOUSE_DOWN

                //:STORE_DRAG_START_VARIABLES_HERE:

                //:                           Down_2:RIG_MOU_BTN
                //:                    OD2:On_Down_2
                aac2020_paint5d_MouInn_OD2_OuterMain( mou );
            };;
            if( mou -> iss_m2u ){ //:NON-PRIMARY_MOUSE_UPP

                //: Resolve Dragging Code If Needed.

                //:                           Uppp_2:RIG_MOU_BTN
                //:                    OU2:On_Uppp_2
                aac2020_paint5d_MouInn_OU2_OuterMain( mou );
            };;
    
        };;

        return( 0 );
    }

#undef  U08  //:----------------------------------------: 01 ://
#undef  U32  //:----------------------------------------: 02 ://
#undef  I32  //:----------------------------------------: 03 ://
#undef  MOU  //:----------------------------------------: 04 ://
#undef  REC  //:----------------------------------------: 05 ://
#undef  IV2  //:----------------------------------------: 06 ://
#undef  ASS  //:----------------------------------------: 07 ://
#undef  LOG  //:----------------------------------------: 08 ://
#undef  ERR  //:----------------------------------------: 09 ://
//:=============================:MOUSE_INPUT_HANDLER:(MouInn)://
//:KEYBOARD_HANDLER:(KeyInn):================================://
#define             I32  int32_t /**GCC: <stdint.h>**///: 01 ://
#define             U32 uint32_t /**GCC: <stdint.h>**///: 02 ://
#define DEX_EDI_paint5d ( 1 )                         //: 03 ://
#define         KEY_P5D ( AAC2020_KEYBIND.PAINT5D )   //: 04 ://
#define             LOG   aac2020_paint5d_Info_any    //: 05 ://
#define             ERR   aac2020_paint5d_Halt        //: 06 ://
#define         LOG_VPC   aac2020_paint5d_Info_VPC    //: 07 ://
#define         LOG_VP0   aac2020_paint5d_Info_VP0    //: 08 ://
#define         LOG_VP1   aac2020_paint5d_Info_VP1    //: 09 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

                         //+---------------------------------+//
                         //|     P5D_Keyboard_FNS :::::::::::|//
    #include "./P5D.K._" //| <-- PAINT5D.KeyBoard :::::::::::|//
                         //|     PAINT5D.F.KeyInn :::::::::::|//
                         //+---------------------------------+//

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32
    PAINT5D_KeyInn( signed char chr_key )
    {
        I32 res_var=( 0 );

        /** @VID_IID[ 0066 ]TIME[ 0H 19M 48S ] ............. **/
        /** PAINT5D is ALWAYS sub-system #1 which            **/
        /** Is assigned to the number 1, both in code        **/
        /** and in the key on the numpad it corresponds to   **/
        assert( DEX_EDI_paint5d == AAC2020_CEDITOR_paint5d );;
        if(     DEX_EDI_paint5d == AAC2020_CEDITOR_dex_edi ){

            res_var = aac2020_paint5d_KeyInn( chr_key );

        };;
    
        /** @IMPLICIT_INTERFACE[ KeyInn ] ****************** **/
        /** @VID_IID[ 0066 ]TIME[ 0H 30M 30S ] ..............**/
        /** Don't have a use for return code yet.    ........**/
        /** but we should be consistent with all of  ........**/
        /** our different keyboard handlers.         ........**/
        /** ************************************************ **/
        return( res_var );
    }

#undef              I32  //:----------------------------: 01 ://
#undef              U32  //:----------------------------: 02 ://
#undef  DEX_EDI_paint5d  //:----------------------------: 03 ://
#undef          KEY_P5D  //:----------------------------: 04 ://
#undef              LOG  //:----------------------------: 05 ://
#undef              ERR  //:----------------------------: 06 ://
#undef          LOG_VPC  //:----------------------------: 07 ://
#undef          LOG_VP0  //:----------------------------: 08 ://
#undef          LOG_VP1  //:----------------------------: 09 ://
//:================================:KEYBOARD_HANDLER:(KeyInn)://
//:SUB_SYSTEM_BACKUP_CODE:===================================://
#define U08 uint8_t /** GCC: <stdint.h> **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Backup_taudirt(
        U08* *BYREF_taudirt
    )
    {
        AAC2020_TAUDIRT_Backup_taudirt( BYREF_taudirt );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_PAINT5D_Restore_taudirt(
        U08* *BYREF_taudirt
    )
    {
        AAC2020_TAUDIRT_Restore_taudirt( BYREF_taudirt );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U08
//:===================================:SUB_SYSTEM_BACKUP_CODE://
//:VIEWPORT_HELPER_FUNCTION:=================================://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 02 ://
#define ERR aac2020_paint5d_Halt                      //: 03 ://

    void
    AAC2020_PAINT5D_PUT_rec_inc_ALL(
    #define U U32 /** U is for unsigned **/
    #define I I32 /** I is for integer  **/
    #define T I32 /** T is for type     **/

     T vpc_x_0 , T vpc_x_1 , T vpc_y_0 , T vpc_y_1 //:P5D_VPC://
    ,T vp0_x_0 , T vp0_x_1 , T vp0_y_0 , T vp0_y_1 //:P5D_VP0://
    ,T vp1_x_0 , T vp1_x_1 , T vp1_y_0 , T vp1_y_1 //:P5D_VP1://
    ,T ur1_x_0 , T ur1_x_1 , T ur1_y_0 , T ur1_y_1 //:P5D_UR1://

    #undef  U
    #undef  I
    #undef  T
    )
    {
        //:bound_check_inputs:-------------------------------://
        #define U 0x7FFFFFFF /**Upper Bound For Signed 32bit **/

            //:bounds_checks_grouped_by_rectangle_name:------://
            /** ******************************************** ***
            Only add checks for errors that got triggered by 
            "Grouped_By_Lower_And_Upper_Bounds" section.
            Here we dive into the root of the problem.
            @VID_IID[ 0201 ]TIME[ 00:25:00 ]
            *** ******************************************** **/

                if( 0
                ||  ur1_x_0 < 0
                ||  ur1_x_1 > U
                ||  ur1_y_0 < 0
                ||  ur1_y_1 > U
                ){
                    //:UR1==[ UIRectangle1 / SideBarUI ]     ://
                    //:To fix this problem, we will make     ://
                    //:[ UR1 ] snap to fill editor viewport  ://
                    //:when there is no room for [ UR1 ].    ://
                    //:Then we will HIDE the side bar UI.    ://
                    printf("[PAINT5D:ur1:OOB_SOMEHOW]\n");
                    printf("[ur1_x_0]:%d\n" , ur1_x_0 );
                    printf("[ur1_x_1]:%d\n" , ur1_x_1 );
                    printf("[ur1_y_0]:%d\n" , ur1_y_0 );
                    printf("[ur1_y_1]:%d\n" , ur1_y_1 );
                    printf("[ur1:MIN]:%d\n" , (  0  ) );
                    printf("[ur1:MAX]:%d\n" , (  U  ) );

                };;

            //:------:bounds_checks_grouped_by_rectangle_name://
            //:Grouped_By_Lower_And_Upper_Bounds:------------://

                /** PRIA  : Put_Rec_In_All               **/
                /** PRIA_N: Negative Out Of Bounds Error **/
                /** PRIA_P: Positive Out Of Bounds Error **/

                /** lower bounds check **/
                if( vpc_x_0 < 0 ){ ERR("[PRIA_N:vpc_x_0]");};
                if( vpc_y_0 < 0 ){ ERR("[PRIA_N:vpc_y_0]");};
                if( vp0_x_0 < 0 ){ ERR("[PRIA_N:vp0_x_0]");};
                if( vp0_y_0 < 0 ){ ERR("[PRIA_N:vp0_y_0]");};
                if( vp1_x_0 < 0 ){ ERR("[PRIA_N:vp1_x_0]");};
                if( vp1_y_0 < 0 ){ ERR("[PRIA_N:vp1_y_0]");};
                if( ur1_x_0 < 0 ){ ERR("[PRIA_N:ur1_x_0]");};
                if( ur1_y_0 < 0 ){ ERR("[PRIA_N:ur1_y_0]");};

                /** Rough out of bounds check **/
                if( vpc_x_1 > U ){ ERR("[PRIA_P:vpc_x_1]");};
                if( vpc_y_1 > U ){ ERR("[PRIA_P:vpc_y_1]");};
                if( vp0_x_1 > U ){ ERR("[PRIA_P:vp0_x_1]");};
                if( vp0_y_1 > U ){ ERR("[PRIA_P:vp0_y_1]");};
                if( vp1_x_1 > U ){ ERR("[PRIA_P:vp1_x_1]");};
                if( vp1_y_1 > U ){ ERR("[PRIA_P:vp1_y_1]");};
                if( ur1_x_1 > U ){ ERR("[PRIA_P:ur1_x_1]");};
                if( ur1_y_1 > U ){ ERR("[PRIA_P:ur1_y_1]");};

            //:------------:Grouped_By_Lower_And_Upper_Bounds://
            //:Editor_Specific_Bounds_Checks:----------------://

                /** @VID_IID[ 0201 ]T[ 00:23:23 ]  **/
                /** for paint5d system             **/
                /** Specific out of bounds check   **/
                /** VP1: Offscreen/Source/TileMap  **/
                I32 vp1_max=( 256 - 1 ); 
                if( vp1_x_1 > vp1_max ){ ERR("[vp1_x_1:max]");};
                if( vp1_y_1 > vp1_max ){ ERR("[vp1_y_1:max]");};

            //:----------------:Editor_Specific_Bounds_Checks://

        #undef  U
        //:-------------------------------:bound_check_inputs://
        //:call_with_casts_to_u32:---------------------------://
        //:store_viewports:----------------------------------://
        #define T U32 /** T is for type     **/

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VPC //:DEX_VAR
            ,   (T)vpc_x_0 ,(T)vpc_x_1 ,(T)vpc_y_0 ,(T)vpc_y_1
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP0 //:DEX_VAR
            ,   (T)vp0_x_0 ,(T)vp0_x_1 ,(T)vp0_y_0 ,(T)vp0_y_1
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
            ,   (T)vp1_x_0 ,(T)vp1_x_1 ,(T)vp1_y_0 ,(T)vp1_y_1
            );;

            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_UR1 //:DEX_VAR
            ,   (T)ur1_x_0 ,(T)ur1_x_1 ,(T)ur1_y_0 ,(T)ur1_y_1
            );;

        #undef  T
        //:----------------------------------:store_viewports://
        //:---------------------------:call_with_casts_to_u32://
    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  ERR                                           //: 03 ://
//:=================================:VIEWPORT_HELPER_FUNCTION://
//:IOU:INIT_OR_UPDATE:=======================================://
#define I32  int32_t /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define ERR aac2020_paint5d_Halt

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void        /** IOU:Initialize_Or_Update **/
    AAC2020_PAINT5D_IOU_ViewportRectangles( void )
    {           /** IOU:Initialize_Or_Update **/

        //:variable_declarations_with_trap_values:-----------://

            I32 ur1_vis=( 0-666 ); //:Is[ ur1 ]visible?

        //:-----------:variable_declarations_with_trap_values://

        //:  #_GET_SIZE_OF_VIEWPORT_####  ://
        //:  #_DEFAULT_TERMINAL_HEIGHT_#  ://

        I32 cli_wid = AAC2020_GINAWIN_GetClient_WID() ;
        I32 cli_hig = AAC2020_GINAWIN_GetClient_HIG() ;

        I32 ter_hig=( 64 ); //:Default_Terminal_Height

        I32 rec_wid ; /** rectangle width  **/
        I32 rec_hig ; /** rectangle height **/
        I32 rec_min ; /** MIN( rec_wid , rec_hig ) **/

        I32 lover_x ; /** leftovers x **/
        I32 lover_y ; /** leftovers y **/

        rec_wid = cli_wid;
        if( ( cli_hig - ter_hig ) > 0 ){

            rec_hig = cli_hig - ter_hig;

        }else{

            /** Hide terminal if not enough room to display **/
            rec_hig = cli_hig ;

        };;

        /** rec_min =MIN(rec_wid,rec_hig) **/
        if( rec_wid > rec_hig ){
            rec_min = rec_hig;
        }else{
            rec_min = rec_wid;
        };;

        /** get leftovers after accounting for       ........**/
        /** square destination viewport size P5D_VP1 ........**/
        lover_x = ( cli_wid - rec_min );
        lover_y = ( cli_hig - rec_min );
        if( lover_x < 0 ){ lover_x = 0; };
        if( lover_y < 0 ){ lover_y = 0; };
    
        /** calculate canvas viewport that covers context    **/
        I32 vpc_x_0 = 0;
        I32 vpc_x_1 =( cli_wid - 1);
        I32 vpc_y_0 = 0;
        I32 vpc_y_1 =( cli_hig - 1);

        /** calculate destination viewport, square, inside   **/
        /** canvas viewport (P5D_VPC)                        **/
        I32 vp0_x_0 = (    0        ) + (lover_x/2);
        I32 vp0_x_1 = ( cli_wid - 1 ) - (lover_x/2);
        I32 vp0_y_0 = (    0        ) + (lover_y/2);
        I32 vp0_y_1 = ( cli_hig - 1 ) - (lover_y/2);

        //: @POSSIBLE_PROBLEM@ - - - - - - - - - - - - - - - ://
        //: If we are manipulating this with user controls,  ://
        //: does this create a problem for us?               ://
        /** Set the data viewport. Start zoomed all the way  **/
        /** out so that we can see EVERYTHING.               **/
        I32 vp1_x_0 =(     0   );
        I32 vp1_x_1 =( 256 - 1 );
        I32 vp1_y_0 =(     0   );
        I32 vp1_y_1 =( 256 - 1 );

        /** @VID_IID[ 0183 ]TIME[ 00:40:04 ]CALC_UIRECTS.P5D **/
        /** Make[ P5D_UR1 ]User_Interface:                   **/
        /**               1: Same   __HEIGHT__   As Viewport **/
        /**               2: SnapTo __LEFT_SIDE_ Of Viewport **/
        #define LEF_SID ( vp0_x_0 )/**LEFT_SIDE**/      ////////
        #define UR1_WID ( AAC2020_UIRECTS.PAINT5D.P5D_UR1_WID )  
        I32 ur1_x_0 =( LEF_SID -(UR1_WID)+ 1   ); //:P5D_UR1
        I32 ur1_x_1 =( LEF_SID -(   0   )+ 1   ); //:P5D_UR1 
        I32 ur1_y_0 =( vp0_y_0 /**@SAM_HIG@**/ ); //:P5D_UR1 
        I32 ur1_y_1 =( vp0_y_1 /**@SAM_HIG@**/ ); //:P5D_UR1 
        #undef  LEF_SID  ///////////////////////////////////////
        #undef  UR1_WID  ///////////////////////////////////////
        //:user_interface_size_hack:-------------------------://
        if( 0
        //:[ur1]     [vpc]
        ||  ur1_x_0 < vpc_x_0 //:MIN:INCLUSIVE
        ||  ur1_y_0 < vpc_y_0 //:MIN:INCLUSIVE
        ||  ur1_x_1 > vpc_x_1 //:MAX:INCLUSIVE
        ||  ur1_y_1 > vpc_y_1 //:MAX:INCLUSIVE
        //:[ur1]     [vpc]
        ){
            //:Assume just not enough room to put UI on      ://
            //:The side of[ vp0 ](Editor/Screen Within VPC)  ://
            //:And snap[ ur1 ]into[ vp0 ]                    ://

            //:SNAPP:
            ur1_x_0 = vp0_x_0;
            ur1_x_1 = vp0_x_1;
            ur1_y_0 = vp0_y_0;
            ur1_y_1 = vp0_y_1;
        
            ur1_vis =( 0 );
        }else{
            ur1_vis =( 1 );
        };;
        if( ur1_vis ){ /** NOOP FOR NOW **/ };
        //:-------------------------:user_interface_size_hack://
        //:Assert_VP0_Is_Square:-----------------------------://

            //:@VID_IID[ 0151 ]TIME[ 00:25:05 ]
            //:Extra assert because we are paranoid.
            if(   ( vp0_x_1 - vp0_x_0 + 1 )
               != ( vp0_y_1 - vp0_y_0 + 1 )
            ){
                
                I32 vp0_wid =( ( vp0_x_1 - vp0_x_0 + 1 ) );
                I32 vp0_hig =( ( vp0_y_1 - vp0_y_0 + 1 ) );

                //: Allow off by 1. Because weird client     ://
                //: areas could mean width of client is      ://
                //: odd number of pixels and height of       ://
                //: client is even num pixels. Leading to    ://
                //: off by 1 math.                           ://
                //: @VID_IID[ 0151 ]TIME[ 01:56:23 ]         ://
                if( vp0_wid - vp0_hig > 1
                ||  vp0_hig - vp0_wid > 1  
                ){
                    printf("\n\n");
                    printf("[vp0_wid]:%d\n" , rec_wid );
                    printf("[vp0_hig]:%d\n" , rec_hig );

                    printf("\n\n");

                    printf("[vp0_x_0]:%d\n" , vp0_x_0 );
                    printf("[vp0_x_1]:%d\n" , vp0_x_1 );
                    printf("[vp0_y_0]:%d\n" , vp0_y_0 );
                    printf("[vp0_y_1]:%d\n" , vp0_y_1 );

                    printf("\n\n");

                    ERR("[EXPECT_DEST_VP0_TO_BE_SQUARE:2021]");
                };;

            };;
              
        //:-----------------------------:Assert_VP0_Is_Square://
        //:Make_Sure_Nothing_Went_Negative:------------------://
        
            /** @VID_IID[ 0084 ]TIME[ 05:14:30 ] *********** **/
            /** If we end up getting one of these asserts    **/
            /** to fail, we may need to handle things like   **/
            /** resizing viewport to very small to handle    **/
            /** more gracefully if the source is ___NOT___   **/
            /** an error in our logic.                       **/
            /** ******************************************** **/

            assert( vpc_x_0 >= 0 );
            assert( vpc_x_1 >= 0 );
            assert( vpc_y_0 >= 0 );
            assert( vpc_y_1 >= 0 );

            assert( vp0_x_0 >= 0 );
            assert( vp0_x_1 >= 0 );
            assert( vp0_y_0 >= 0 );
            assert( vp0_y_1 >= 0 );

            assert( vp1_x_0 >= 0 );
            assert( vp1_x_1 >= 0 );
            assert( vp1_y_0 >= 0 );
            assert( vp1_y_1 >= 0 );

            /** ******************************************** **/
            /** Don't check upper bounds. Checked in the     **/
            /** helper function that comes next.             **/
            /** ******************************************** **/
 
        //:------------------:Make_Sure_Nothing_Went_Negative://
        //:Set_Visibility_Of_SOME_rectangles:----------------://

            //:[ ur1_vis ]==[ P5D_VU1 ]://
            if( ur1_vis != 0 && ur1_vis != 1 ){
                ERR("[INVALID:ur1_vis]");
            };;
            AAC2020_TAUDEPO_Put( 
                AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
            ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
            ,   AAC2020_TAUDEPO.P5D_VU1 //:DEX_VAR
            ,   (U32)ur1_vis,( 0 ),( 0 ),( 0 )
            );;

        //:----------------:Set_Visibility_Of_SOME_rectangles://
        //:--------------------------------------------------://
        //: @VID_IID[ 0084 ]TIME[ 04:28:10 ] ................://
        //: Explanation on why viewports are named such.     ://
        //:                                                  ://
        //: VP0 because we always have exactly ONE dest      ://
        //: VP1 because we might want other numbers that     ://
        //: sample from other sources. For example,          ://
        //: VP2 might be the name of our [terminal/console]  ://
        //: data viewport.                                   ://
        //:                                                  ://
        //: VP0:Viewport_Zero(0): (Destination/Screen)       ://
        //: VP1:Viewport_One(1) : (Offscreen/Source/Tilemap) ://
        //: VPC:Viewport_Canvas : (Or: Window/OpenGL)        ://
        //:--------------------------------------------------://

        //:TEMP_HACK:
        //: vp0_x_0 = vpc_x_0 ;
        //: vp0_x_1 = vpc_x_1 ;
        //: vp0_y_0 = vpc_y_0 ;
        //: vp0_y_1 = vpc_y_1 ;
         

        AAC2020_PAINT5D_PUT_rec_inc_ALL(
            vpc_x_0 , vpc_x_1 , vpc_y_0 , vpc_y_1  //:P5D_VPC://
        ,   vp0_x_0 , vp0_x_1 , vp0_y_0 , vp0_y_1  //:P5D_VP0://
        ,   vp1_x_0 , vp1_x_1 , vp1_y_0 , vp1_y_1  //:P5D_VP1://
        ,   ur1_x_0 , ur1_x_1 , ur1_y_0 , ur1_y_1  //:P5D_UR1://
        );;

        aac2020_paint5d_cli_wid = cli_wid;
        aac2020_paint5d_cli_hig = cli_hig;

    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void        /** IOU:Initialize_Or_Update **/
    AAC2020_PAINT5D_IOU_DefaultBrushState( void )
    {           /** IOU:Initialize_Or_Update **/

        /** ************************************************ ***

            Initial Values We Have ___STRONG___ opinions about:
            @VID_IID[ 0084 ]TIME[ 02:50:30 ]

            til_qua : NO_STRONG_OPINION
            loc_t_x : NO_STRONG_OPINION
            loc_t_y : NO_STRONG_OPINION

            til_exp = 7 : 
            Start at largest (7) tile exponent to encourage   
            working up the drawing from general vaugness      
            to sharper (smaller tiles) details.               

            til_lay = 0 :                                      
            Start at BACKMOST tile layer (0)                  
            To encourage water color like designing where     
            artist paints in the background first before      
            working up the more detailed foreground.          
            #_WHY_IS_0_THE_BACK_MOST_LAYER_#       

            aus_dex = 0 :
            Start creating the FIRST aus_dex
            (auto tile set) and then work your way forward
            to the other sets. This makes the most sense.

            til_val = 0 :
            Start at the first tile value so that when user
            uses the NEXT_TILE_VALUE button, they get 
            a change in the tile value as expected, and are
            able to immediately cycle through all tile values.

        *** ************************************************ **/

        aac2020_paint5d_Put_BrushState(
            0  //: I32 : [ t_q / til_qua ] : 01 ://
        ,   7  //: I32 : [ t_e / til_exp ] : 02 ://
        ,   0  //: I32 : [ t_l / til_lay ] : 03 ://
        ,   0  //: I32 : [ l_x / loc_t_x ] : 04 ://
        ,   0  //: I32 : [ l_y / loc_t_y ] : 05 ://
        ,   0  //: I32 : [ a_d / aus_dex ] : 06 ://
        ,   0  //: I32 : [ t_v / til_val ] : 07 ://
        );;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32  //:----------------------------------------: 01 ://
#undef  U32  //:----------------------------------------: 02 ://
#undef  ERR  //:----------------------------------------: 03 ://
//:=======================================:IOU:INIT_OR_UPDATE://
//:INITIALIZE_PAINT5D:=======================================://
#define U32  uint32_t /** GCC: <stdint.h> **/         //: 01 ://
#define I32   int32_t /** GCC: <stdint.h> **/         //: 02 ://
#define I16   int16_t /** GCC: <stdint.h> **/         //: 03 ://
#define ERR   aac2020_paint5d_Halt                    //: 04 ://
#define O_K   aac2020_paint5d_Okay                    //: 05 ://
#define I_D   aac2020_paint5d_Info_dec                //: 06 ://
#define INF   aac2020_paint5d_Info                    //: 07 ://
#define LOG   aac2020_paint5d_Info_any                //: 08 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_Init( void ){

        /** We are now initilaizing paint5d **/
        AAC2020_CEDITOR_dex_ing=( 
        AAC2020_CEDITOR_paint5d  );;

        /** Early Exit Will Trigger Recursion Guard Error **/
        O_K( "[OH_FUCK...Code_Below_Was_Never_Ran_Before]" );;

        //:ALL_MEMBERS_OF_PAINT5D:---------------------------://

            //:#_PAINT5D_DATA_IS_A_TEMPORARY_CONTAINER_NOW_#://

        //:---------------------------:ALL_MEMBERS_OF_PAINT5D://
        //:ALLOCATES_OPEN_GL_TEXTURE:------------------------://
    
            //+ #GPUDATA_IS_NOW_A_TEMPORARY_CONTAINER# + + + +//
            //- AAC2020_GPUDATA_InitInstance(  - - - - - - - -//
            //-     ACC2020_PAINT5D_dat      );; - - - - - - -//

        //:------------------------:ALLOCATES_OPEN_GL_TEXTURE://
        //:LOAD_INITIAL_EDITOR_STATE:------------------------://
        LOG("[PAINT5D:LOAD_INITIAL_EDITOR_STATE:BEG]",0);

            //:LIES: Load_Initial_Editor_State
            AAC2020_VITAL_TODO("[P5D_LIES_FROM_SAVE_FILE]");

            /** UPDATES: P5D_VPC , P5D_VP0 , P5D_VP1  **/
            /** IOU: Init_Or_Update  @IOU@            **/
            
            AAC2020_PAINT5D_IOU_DefaultBrushState( );

            /** viewport sizing will depenend on brush **/
            /** state in some cases I think...         **/
            AAC2020_PAINT5D_IOU_ViewportRectangles();

        LOG("[PAINT5D:LOAD_INITIAL_EDITOR_STATE:END]",0);
        //:------------------------:LOAD_INITIAL_EDITOR_STATE://
        //:LOAD_INITIAL_TEXTURE_DATA:------------------------://
        #define DAT gpudata_paint5d
        #define F_S( name ) AAC2020_PIXNAME_##name

            /** #_TODOS_CAN_BREAK_COLUMN_LIMIT_# **/
            /** For now just load a test pattern to confirm we    * * * * * **/
            /** have data. But once that is done, we will want to * * * * * **/
            /** load from a save file on disk on startup.         * * * * * **/
            AAC2020_VITAL_TODO("[Eventually_This_Should_Load_Save_File_Data]");



            struct AAC2020_GPUDATA gpudata_paint5d ={ 0 };



            if( strcmp( &(F_S( paint5d )[0]) ,"paint5d" )!= 0 ){
                aac2020_paint5d_Halt("[BAD_NAME_2020]");
            };;


            
            //: FILE_SCOPE(  F_S  ) --> TEMP_STRUCT(  DAT  );
            DAT.tex_lot =    F_S( paint5d_tex_lot          );
            DAT.tex_han =    F_S( paint5d_tex_han          ); 
            DAT.sam_loc =    F_S( paint5d_tex_sam.sam_loc  );
            DAT.sam_val =    F_S( paint5d_tex_sam.sam_val  );
            DAT.sam_has =    F_S( paint5d_tex_sam_HAS      );
            DAT.pix_wid =  ( 512                           );
            DAT.pix_hig =  ( 512                           );
            DAT.pix_nam = &( F_S( paint5d )[0]             );

            DAT.cpu_pix =&( 
                AAC2020_PIXNAME_paint5d_cpu_pix[0] 
            );;



            AAC2020_PIXPUSH_TestPattern(   &( DAT ) );
            AAC2020_PIXPUSH_UploadTexture( &( DAT ) );
            

            //:get_paint5d_sampler_location:-----------------://
            #define HAS_CHK AAC2020_PIXPUSH_HasSampler
            #define INF_DEC aac2020_paint5d_Info_dec

                //:#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#://
                AAC2020_PIXPUSH_sam_has    ( &( DAT ) );
                AAC2020_PIXPUSH_sam_loc    ( &( DAT ) );
                AAC2020_PIXPUSH_sam_val_PUT( &( DAT ) );

                if( DAT.sam_has >= 1 && DAT.sam_loc <=(0 - 1) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:001]");
                }else 
                if( DAT.sam_has <= 0 && DAT.sam_loc >=(  0  ) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:002]");
                };;

                /** Keep the error prone way of doing this   **/
                /** As a redundancy to check for agreement.  **/

                I32 has = HAS_CHK( "paint5d" );
                if( DAT.sam_has != has ){ ERR("[WTF:0433AM]");};

                INF_DEC( "[DAT.sam_loc]:%d\n" , DAT.sam_loc );
                INF_DEC( "[DAT.sam_val]:%d\n" , DAT.sam_val );

            #undef  HAS_CHK
            #undef  INF_DEC
            //:-----------------:get_paint5d_sampler_location://

            if( has >= 1 ){

                /** Update Texture Sampler Uniform On GPU **/

                aac2020_PIXPUSH_PushSampler(  &( DAT ) );

                /** Persist Changes: **/

                //: TEMP_STRUCT(  DAT  ) --> FILE_SCOPE(  F_S  )
                F_S( paint5d_tex_lot         ) = DAT.tex_lot ;
                F_S( paint5d_tex_han         ) = DAT.tex_han ;
                F_S( paint5d_tex_sam.sam_loc ) = DAT.sam_loc ;
                F_S( paint5d_tex_sam.sam_val ) = DAT.sam_val ;
                F_S( paint5d_tex_sam_HAS     ) = DAT.sam_has ;
                //:                    ( 512 ) = DAT.pix_wid ://
                //:                    ( 512 ) = DAT.pix_hig ://
                //:                 "paint5d" ~=~DAT.pix_nam ://
    
                aac2020_paint5d_Okay("[HAS_TEXTURE_SAMPLER]");
            }else{

                /** Whether this is a good or bad message **/
                /** depends on you looking at code and    **/
                /** deciding.                             **/
                INF("[NO_TEXTURE_SAMPLER:PAINT5D]");
    
            };;
           
        #undef DAT
        #undef F_S
        //:------------------------:LOAD_INITIAL_TEXTURE_DATA://
        //:ERROR_CHECK:--------------------------------------://

            //:#_PAINT5D_DATA_ERROR_CHECK_NOW_POINTLESS_#://
            
        //:--------------------------------------:ERROR_CHECK://
        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

            /** DONE initializing. **/

            AAC2020_CEDITOR_dex_ini=( 
            AAC2020_CEDITOR_paint5d  );;

            /** No editor initializ-ING now. **/
            AAC2020_CEDITOR_dex_ing=( 0xFFFFFFFF );

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://
        //:Run_Unit_Test_If_Never_Ran_Before:----------------://
        #define OVERRIDE AAC2020_KILTEST.KILTEST  //:////////://
        #define      ONN AAC2020_KILTEST.PAINT5D  //:////////://
        #define      E_U extern U32               //:////////://

            if( aac2020_paint5d_unit_test_ran_or_running <= 0 ){
                aac2020_paint5d_unit_test_ran_or_running =( 1 );
                aac2020_paint5d_unit_test_is_running_now =( 1 );

                if( OVERRIDE <= ( 0-1 ) ){/**OVERRIDE:ALL_OFF**/
                    /** DO NOTHING **/
                }else
                if( OVERRIDE >= ( 0+1 ) ){/**OVERRIDE:ALL_ONN**/
                  
                   E_U AAC2020_PAINT5D_UnitTest( U32  );
                       AAC2020_PAINT5D_UnitTest( 0x00 );

                }else
                if( AAC2020_KILTEST.PAINT5D >= 1 /** ONN? **/ ){

                   E_U AAC2020_PAINT5D_UnitTest( U32  );
                       AAC2020_PAINT5D_UnitTest( 0x00 );
                };;

                aac2020_paint5d_unit_test_is_running_now =( 0 );
            };;

        #undef OVERRIDE  //://///////////////////////////////://
        #undef      ONN  //://///////////////////////////////://
        #undef      E_U  //://///////////////////////////////://
        //:----------------:Run_Unit_Test_If_Never_Ran_Before://
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    AAC2020_PAINT5D_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved for future use **/ };

        //:#_INI_SPAM_AND_RECURSION_GAURD_#:-----------------://

        /** Hackishly debug what is going on. **/
        AAC2020_PAINT5D_init_call_count++;
        I_D("[AAC2020_PAINT5D_init_call_count]:%d\n"
                ,AAC2020_PAINT5D_init_call_count       );;

        if( AAC2020_CEDITOR_dex_ing == 
            AAC2020_CEDITOR_paint5d
        ){  
            /** If not recursion, it might be being called   **/
            /** rapidly from another thread. Re-entering     **/
            /** before it is exiting. But that seems         **/
            /** unlikely. I think that would require         **/
            /** more than one thread to call this function.  **/

            ERR("[LIKELY_UNINTENTIONAL_RECURSION]"); 
        };;

            //:actually_implement_init_gaurd:----------------://
            /** ******************************************** ***
            @VID_IID[ 0096 ]TIME[ 00:26:42 ]
            If we are ALREADY in the paint5d system and
            we went a command to SWITCH TO paint5d, we do
            NOT want to re-initialize the system.
            *** ******************************************** **/

                /** #_EDITOR_INIT_SPAM_GAURD_# **/
                if( AAC2020_CEDITOR_nex_edi  //:NEXT____EDITOR
                ==  AAC2020_CEDITOR_dex_edi  //:CURRENT_EDITOR
                ){
                    O_K("[PAINT5D:Init_Already_Up_To_Date]");
                }else{
                    aac2020_paint5d_Init();
                };;

            //:----------------:actually_implement_init_gaurd://

        //:-----------------:#_INI_SPAM_AND_RECURSION_GAURD_#://
        

        return( 0x00 );

    }

#undef  U32                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  I16                                           //: 03 ://
#undef  ERR                                           //: 04 ://
#undef  O_K                                           //: 05 ://
#undef  I_D                                           //: 06 ://
#undef  INF                                           //: 07 ://
#undef  LOG                                           //: 08 ://
//:=======================================:INITIALIZE_PAINT5D://
//:LOOP_TICK:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/  //:-------: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/  //:-------: 02 ://

    /** **************************************************** ***

        @VID_IID[ 0151 ]TIME[ 03:17:32 ]
        @VID_IID[ 0151 ]TIME[ 03:19:42 ]DONE_WRITING_SUMMARY

        We use a "LoopTick" function rather than a callback
        to avoid memory coherency issues when multi threading.
        For example if game logic is supposed to be on
        a different thread than window logic, invoking
        a resize-window callback function from our win32
        code will cause us to unwittingly invoke game
        logic from the window thread.

        @_CALLBACKS_ARE_EVIL_@

    *** **************************************************** **/

    U32
    aac2020_paint5d_LoopTick( U32 u32 )
    {
        if( u32 ){ /**RESERVED_FOR_FUTURE_USE**/ };

        //:ALWAYS_UPDATE_EVERY_FRAME:------------------------://

            /** DONT KNOW WHAT GOES HERE BUT I HAVE A HUNTCH **/
            /** SOMETHING WILL GO HERE EVENTUALLY.           **/
            /** @VID_IID[ 0151 ]TIME[ 03:35:13 ]             **/

        //:------------------------:ALWAYS_UPDATE_EVERY_FRAME://
        //:ONLY_UPDATE_IF_WINDOW_WAS_RESIZED:----------------://

            /** @VID_IID[ 0151 ]TIME[ 03:35:32 ]FIRST_DRAFT  **/

            I32 cli_wid = AAC2020_GINAWIN_GetClient_WID() ;
            I32 cli_hig = AAC2020_GINAWIN_GetClient_HIG() ;

            if( cli_wid != aac2020_paint5d_cli_wid
            ||  cli_hig != aac2020_paint5d_cli_hig
            ){

                AAC2020_PAINT5D_IOU_ViewportRectangles();

            };;

        //:----------------:ONLY_UPDATE_IF_WINDOW_WAS_RESIZED://
        //:Sync_CPU_Bitmap_With_GPU_Texture:-----------------://
        if( aac2020_paint5d_needs_to_sync_to_gpu >= 1 ){
            aac2020_paint5d_needs_to_sync_to_gpu=( 0 );

            AAC2020_PIXPUSH_t2d_PAINT5D();

        };;
        //:-----------------:Sync_CPU_Bitmap_With_GPU_Texture://


        return( 0x00 );
    }

    U32
    AAC2020_PAINT5D_LoopTick( U32 u32 )
    {
        if(    AAC2020_CEDITOR_paint5d
            != AAC2020_CEDITOR_dex_edi
        ){
            /** DO NOTHING. NOT OUR ACTIVE EDITOR. **/
        }else{
            aac2020_paint5d_LoopTick( u32 );
        };;

        return( 0x00 );
    }

#undef  U32  //:----------------------------------------: 01 ://
#undef  I32  //:----------------------------------------: 02 ://
//:================================================:LOOP_TICK://
//:SECTION_UNIT_TEST:========================================://
//:UNIT_TEST_SECTION:========================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_PAINT5D_UnitTest( U32 u32 )
    {
        aac2020_paint5d_unit_test_ran_or_running =( 1 );
        aac2020_paint5d_unit_test_is_running_now =( 1 );

        extern U32 aac2020_paint5d_UnitTest( U32 );
                   aac2020_paint5d_UnitTest( u32 );

        aac2020_paint5d_unit_test_is_running_now =( 0 );
        return( 0x00 );
    }

    //:@VID_IID[ 0170 ]TIME[ 00:24:42 ]::::::::::::::::::::::://
    //:Unit Test Code Is Making it too hard to search through://
    //:this project. Extracted to "P5D.T._" for managability.://
    #include "P5D.T._"
    //:::::::::::::::::::::::::::::::::::::::::::::::::::::::://

#undef  U32
//:========================================:SECTION_UNIT_TEST://
//:========================================:UNIT_TEST_SECTION://
//:VARIABLE_NAMES_AND_CONTROL_F_HELP:========================://
/** ******************************************************** ***

    WRONG[ cuviloc ]===>CORRECT[ cuvipix ]
    WRONG[ cuv_loc ]===>CORRECT[ cuvipix ]

    WRONG[ o_x_qua ]===>CORRECT[ qua_c_x ]
    WRONG[ o_y_qua ]===>CORRECT[ qua_c_y ]
    WRONG[ i_x_qua ]===>CORRECT[ qua_c_x ]
    WRONG[ i_y_qua ]===>CORRECT[ qua_c_y ]
    WRONG[ qua_o_x ]===>CORRECT[ qua_c_x ]
    WRONG[ qua_o_y ]===>CORRECT[ qua_c_y ]
    WRONG[ qua_i_x ]===>CORRECT[ qua_c_x ]
    WRONG[ qua_i_y ]===>CORRECT[ qua_c_y ]

    WRONG[ o_x_lay ]===>CORRECT[ lay_c_x ]
    WRONG[ o_y_lay ]===>CORRECT[ lay_c_y ]
    WRONG[ i_x_lay ]===>CORRECT[ lay_c_x ]
    WRONG[ i_y_lay ]===>CORRECT[ lay_c_y ]
    WRONG[ lay_o_x ]===>CORRECT[ lay_c_x ]
    WRONG[ lay_o_y ]===>CORRECT[ lay_c_y ]
    WRONG[ lay_i_x ]===>CORRECT[ lay_c_x ]
    WRONG[ lay_i_y ]===>CORRECT[ lay_c_y ]

        qua_c_x : QUAdrant Cell X
        qua_c_y : QUAdrant Cell Y

        lay_c_x : Layer    Cell X ( tile layer cell , x )
        lay_c_y : Layer    Cell Y ( tile layer cell , y )

        cuvipix : Canvas_User_VIew:PIXel (pixel coordinate)

        --------------------------------------------------------
        painpix : Conceptually it is all of these values
                  but there is no formal struct.
                  IN THE EXACT ORDER BELOW.

            01: til_qua   <-- Auset Tile Sub Quadrant Index  
            02: til_exp   <-- TileExponent (TileSizeEnum)    
            03: til_lay   <-- TileLayer .................    
            04: loc_t_x   <-- Local  Tile X Coord / b_x      
            05: loc_t_y   <-- Local  Tile Y Coord / b_y      
        --------------------------------------------------------

*** ******************************************************** **/
//:========================:VARIABLE_NAMES_AND_CONTROL_F_HELP://



