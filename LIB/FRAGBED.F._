//:FRAGBED.D._  

//: #_FRAGBED_UNIFORM_FREEABLE_POINTERS_# ://

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_fragbed_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:AAC2020_FRAGBED]:%s\n", msg_err );
        fflush(stdout);
        exit(666);
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://

    const char*
    AAC2020_FRAGBED_CopyHardCodedShaderStrings(
        
        /** One of our FILE_SCOPE hardcoded strings in **/
        /** our source code.                           **/
        const char* AAC2020_FRAGBED_DEFAULT 
    )
    {
        /** FUNCTION_SUMMARY: Copys hard coded FILE_SCOPE    **/
        /** shader strings to dynamic memory so that all     **/
        /** pointers are always freeable regardless of if    **/
        /** we are pointing to HARDCODED shader source or    **/
        /** shader source loaded from disk.                  **/

        //:##################################################://
        #define H aac2020_fragbed_Halt //:###################://
        if( ((void*)0) == AAC2020_FRAGBED_DEFAULT ){
            H( "[NULL_FRAGBED_DEFAULT]" );
        };;
        if( strlen( AAC2020_FRAGBED_DEFAULT ) <= 0 ){
            H("[ZERO_LEN_HARD_CODED_STR]");
        };;
        #undef  H //:########################################://
        //:##################################################://

        //: noc: number_of_characters
        //: nob: number_of_bytes
        int noc = strlen( AAC2020_FRAGBED_DEFAULT );
        int nob = (noc + 1); //:Add null terminator.

        //:Allocate dynamic memory:
        char* aac2020_fragbed_default=calloc(1,nob);

        //:COPY_ALL_CHARACTERS:------------------------------://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** GRADQUAD BUGHUNT_001 led us into the     **/
                /** NEXT file within our library chain.      **/
                printf("[ABOUT_TO_COPY:noc]:%d\n", noc );
                fflush(stdout); 
            #endif

            //:copy_all_characters::- - - - - - - - - - - - -://
            for( int dex = 0 ; dex < noc ; dex ++ ){
                aac2020_fragbed_default[ dex ]=(
                AAC2020_FRAGBED_DEFAULT[ dex ]  );;
            };;//:- - - - - - - - - - - -:copy_all_characters://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** GRADQUAD BUGHUNT_001 led us into the     **/
                /** NEXT file within our library chain.      **/
                printf("[DONE_COPYING:noc]:%d\n", noc );
                fflush(stdout); 
            #endif

        //:------------------------------:COPY_ALL_CHARACTERS://
        //:ADD_NULL_TERM:MEMORY_STOMP_RISK:------------------://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** YES: AAC2020_GRAQUAD_BUGHUNT_001  **/
                /** NOT: AAC2020_FRAGBED_BUGHUNT_001  **/
                //:MSR:MEMORY_STOMP_RISK
                printf("[BEFORE:ADD_NUL_TERM:MSR]");
                fflush(stdout); 
            #endif

            //:add_null_term:MSR!:- - - - - - - - - - - - - -://

                //[AAC2020_GRAQUAD_BUGHUNT_001:FOUND]////[!!!]//
                /** You were off by 1 here and memory        **/
                /** stomping other memory. The reason it     **/
                /** worked originally probably was because   **/
                /** malloc allocates in powers of 2 chunks.  **/
                /** So sometimes going 1 out of bounds       **/
                /** does NOT stomp memory if extra was       **/
                /** allocated. DATE[ 2020_11_06 ]            **/

                int max_dex = (    nob - 1 );
                assert( max_dex == nob - 1 );
                assert( max_dex == noc + 0 );
                assert( nob - 1 == noc + 0 );

                //:Make absolutely god damned sure that we have  
                //:a null terminator at the end of our string.
                aac2020_fragbed_default[ max_dex ] ='\0';

            //:- - - - - - - - - - - - - -:add_null_term:MSR!://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** YES: AAC2020_GRAQUAD_BUGHUNT_001  **/
                /** NOT: AAC2020_FRAGBED_BUGHUNT_001  **/
                //:MSR:MEMORY_STOMP_RISK
                printf("[AFTER::ADD_NUL_TERM:MSR]");
                fflush(stdout); 
            #endif

        //:------------------:ADD_NULL_TERM:MEMORY_STOMP_RISK://

        //:Make sure copy didn't fail.
        if( strlen( aac2020_fragbed_default ) <= 0 ){
            aac2020_fragbed_Halt("[WELL_FUCK_ME_I_GUESS]");
        };;

        return( aac2020_fragbed_default );
    }

    #define U32 uint32_t /** GCC: <stdint.h> **/
    U32 AAC2020_FRAGBED_LoadFileIfExists(
        #define ARG const char
        ARG*         frag_shader_nam //:EX:FRAGBED_001.frag
    ,   ARG*  *BYREF_frag_shader_str //:DESTINATION
        #undef  ARG
    )
    {
        /** SSAE: Shader Should Always Exist * * * * * * * * **/
        /**       A FILE on disk might not exists, but at  * **/
        /**       this point we should have MALCOPY(ed)  the **/
        /**       hardcoded .exe shader string to the        **/
        /**       BYREF_frag_shader_str variable.            **/
        if( ((void*)0) == (*BYREF_frag_shader_str) ){
            aac2020_fragbed_Halt("[FATAL:SSAE]");
        };;

        const char* frag_shader_str =((void*)0);
        int file_nob    = (   0 - 808   ); //: Neg: TrapValue
        int file_exists = (   0         ); //: 0 == undefined.

        //:DOES_THE_FILE_EXIST_ON_DISK:?:--------------------://
        #define F_OK 0 /** unistd.h **/
        #define FNAM frag_shader_nam

        if( access( FNAM , 0x00 /** F_OK **/ ) != -1 ) {
        file_exists=( 1 );

        //:DOES_THE_FILE_EXIST_ON_DISK:YES:
 
            //:FREE_PREVIOUS_MEMORY:-------------------------://

                if( AAC2020_all_default_shaders_malloc_copied ){

                    //:Be paranoid, check your pointers.
                    //:######################################://
                    #define H aac2020_fragbed_Halt //:#######://
                    if( ((void*)0) == BYREF_frag_shader_str ){
                        H("[NULL:BYREF]");
                    };;
                    if( ((void*)0) ==*BYREF_frag_shader_str ){
                        H("[NULL:DEREF]");
                    };;
                    #undef  H //:############################://
                    //:######################################://

                    //:De-reference char** to char* :
                    frag_shader_str=( *BYREF_frag_shader_str );
                    
                    //:Discard const qualifier and free.
                    free( (char*)frag_shader_str );

                }else{
                    //: Fail because we want normalized data.://
                    //: Mixing "freeable" and "non-freeable" ://
                    //: pointers is a HORRIBLE idea.         ://
                    aac2020_fragbed_Halt(
                        "[NULL_OR_NON_DYNAMIC_POINTERS]"
                    );;
                };;

            //:-------------------------:FREE_PREVIOUS_MEMORY://
            //:READ_ALLOCATE_AND_COPY:-----------------------://
            /** SEEK_SET : GCC: unistd.h && mmsystem.h **/
            /** SEEK_END : GCC: unistd.h && mmsystem.h **/
            #define MACRO_SEEK_SET 0  
            #define MACRO_SEEK_END 2  

                //:file_nob:GET_FILE_NUMBER_OF_BYTES:--------://

                    //:Open file for "read as binary" ("rb")
                          file_nob =( 0 - 404 );
                    FILE* file_han = fopen( 
                        frag_shader_nam , "rb" );;
                    
                    //:Seek to end and get number of bytes.
                    //:Then reset file handle to start of file.
                    fseek( file_han , 0 , MACRO_SEEK_END );
                    file_nob = ftell( file_han );
                    fseek( file_han , 0 , MACRO_SEEK_SET );

                //:file_nob:GET_FILE_NUMBER_OF_BYTES:--------://
                //:ALLOCATE_MEMORY:--------------------------://

                    //:1. Allocate_Memory: (plus extra byte)
                    //:2. Be safe. Add extra null byte to end.
                    frag_shader_str = calloc( 1 , file_nob+1 );
            ((char*)frag_shader_str)[ file_nob ]='\0';

                    //:Set output parameter:
                    (*BYREF_frag_shader_str)=frag_shader_str;

                //:--------------------------:ALLOCATE_MEMORY://
                //:READ_FILE_INTO_ALLOCATED_MEMORY:----------://

                    fread( 
                        (char*)         //:<-- MAKE_WRITABLE
                        frag_shader_str //:<-- DESTINTION(WRITE)


                    //[ ------------------------------------ ]//
                    //[ Q: should this be: ( file_nob + 1 ) ?]//
                    //[ A: No. The "file_nob+1" from earlier ]//
                    //[    was a precaution in case string   ]//
                    //[    read into memory here was NOT     ]//
                    //[    null terminated. Text files are   ]//
                    //[    NOT null terminated on disk.      ]//
                    ,   file_nob  //+  file:Number_Of_Bytes  +//
                    //[ ------------------------------------ ]//


                    ,   1               //:Read 1 byte at a time
                    ,   file_han        //:SOURCE(READ)
                    );;

                //:----------:READ_FILE_INTO_ALLOCATED_MEMORY://
                //:DONT_FORGET_TO_CLOSE_FILE:----------------://

                    fclose( file_han );

                //:----------------:DONT_FORGET_TO_CLOSE_FILE://
            #undef MACRO_SEEK_SET
            #undef MACRO_SEEK_END
            //:-----------------------:READ_ALLOCATE_AND_COPY://
           
            
            #if( AAC2020_FRAGBED_BUGHUNT_FileOnDiskNotify >= 1 )
            printf("[file_YES_on_disk]:%s\n",frag_shader_nam);
            fflush(stdout);
            #endif 
         
            file_exists=( 0 + 4 );
        }else{ 
            file_exists=( 0 - 4 );
   
            #if( AAC2020_FRAGBED_BUGHUNT_FileOnDiskNotify >= 1 )
            printf("[file_NOT_on_disk]:%s\n",frag_shader_nam);
            fflush(stdout); 
            #endif
          

        };;
        #undef  F_OK
        #undef  FNAM
        //:--------------------:DOES_THE_FILE_EXIST_ON_DISK:?://
        //:ASSERT_NULL_TERMINATOR:---------------------------://
        #define FATAL_ERROR aac2020_fragbed_Halt
        #define BYREF_BOI BYREF_frag_shader_str

            /** ADDED[ DATE[ 2020_11_16 ] ] **************** **/

            if( file_exists >= 1 ){

                if( '\0' != frag_shader_str[ file_nob ] ){
                    FATAL_ERROR("[DONE_FUCKED_UP:001]");
                };;

                if( '\0' != (*BYREF_BOI)[ file_nob ] ){
                    FATAL_ERROR("[DONE_FUCKED_UP:002]");
                };;

            }else{
                    
                /** nod_noc: NotOnDisk:NumberOfCharacters **/
                int nod_noc = strlen(*BYREF_BOI);

                /** nod_nob: NotOnDisk:NumberOfBytes **/ 
                int nod_nob = ( nod_noc + 1 );

                if( '\0' != (    *BYREF_BOI)[ nod_nob - 1 ]){

                    FATAL_ERROR("[DONE_FUCKED_UP:003]");

                };;

            };;

        #undef BYREF_BOI
        #undef FATAL_ERROR
        //:---------------------------:ASSERT_NULL_TERMINATOR://

        return( 0x00 );
    }
    #undef U32

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    #define U32 uint32_t /** GCC: <stdint.h> **/
    U32 AAC2020_FRAGBED_SaveTextFileToDisk(
        const char* frag_shader_nam //:Name_Of_File
    ,   const char* frag_shader_str //:Contents_Of_File
    )
    {
        #define H aac2020_fragbed_Halt
        if( ((void*)0) == frag_shader_nam ){ H("[NULLNAME]");};;
        if( ((void*)0) == frag_shader_str ){ H("[NULL_STR]");};;
        #undef  H 

        //:##################################################://
        #if( AAC2020_FRAGBED_BUGHUNT_SaveTextFileToDisk >= 1 )
        #define P printf
        
            int frag_shader_len = strlen( frag_shader_str );
            P("[DEBUG:AAC2020_FRAGBED_SaveTextFileToDisk]\n");
            P("[frag_shader_nam]:%s\n"    , frag_shader_nam );
            P("[frag_shader_str]:%s\n"    , frag_shader_str );
            P("[frag_shader_len]:%d\n"    , frag_shader_len );
            fflush( stdout );

        #undef  P
        #endif //:###########################################://
        //:##################################################://

        //: noc:Number_Of_Characters:
        //: nob:Number_Of_Bytes     : (Ascii My Boy!)
        int noc = strlen( frag_shader_str );
        int nob = ( noc + 1 ); 

        /** BUGFIX:                                        * **/
        /**     WRONG: '\0' == frag_shader_str[ nob     ]  * **/
        /**       FIX: '\0' == frag_shader_str[ nob - 1 ]  * **/
        if( '\0' != frag_shader_str[ nob - 1 ] ){

            /** Print this before attempting to print        **/
            /** the string variables in case the string      **/
            /** vars cause a segfault or something.          **/
            printf("[FATAL_ERROR:WE_HAVE_A_PROBLEM_CAPTAIN]\n");
            fflush(stdout);

            printf("[frag_shader_nam]%s\n",
                     frag_shader_nam );;

            printf("[frag_shader_str]%s\n",
                     frag_shader_str );;

            aac2020_fragbed_Halt("[ERR:NNT]");
        };;

        //:CREATE_BLANK_IF_NOT_EXIST:------------------------://

            //:----------------------------------------------://
            //:DOES:                                     : : ://
            //:     1: Creates Directories If Not Exist  : : ://
            //:     2: Creates Empty File  If Not Exist  : : ://
            //:----------------------------------------------://

            /** Will create directory structure AND touch    **/
            /** the file. Touch in the linux sense of        **/
            /** create if not exists and upate access time.  **/
            /** Though I don't care about access time, just  **/
            /** creating if not exist.                       **/
            AAC2020_FILEBOI_TouchFile( frag_shader_nam );

        //:------------------------:CREATE_BLANK_IF_NOT_EXIST://
        //:CORE_ACTION:SaveTextFileToDisk:-------------------://

            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
            //[ AAC2020_FILEBOI_TouchFile( frag_shader_name )]//
            //[ MUST BE CALLED PRIOR TO CORE_ACTION !!!!!!!! ]//
            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

            /** Open file for write.                         **/
            /** This will erase any previous file contents.  **/
            FILE*  file_han = fopen( frag_shader_nam , "wb" );
            
            if( ((void*)0) != file_han ){
            
                fseek( file_han , 0 /**orgin**/ , 0 /**SEEK_SET**/);
                fwrite( 
                    frag_shader_str
                ,   1   //:SizeInBytesOfEachElementToBeWritten
            
                //:Number_of_Elements_To_Write
                ,   noc //:number_of_characters( noc )
                        //:NOT[ nob ]because strings are not
                        //:null terminated inside text files.
            
                ,   file_han //:File We are writing into.
                );;
                fclose( file_han );
            
            }else{
                
                //:TODO: Figure out how to create folders so that
                //:      this file save will work.
                printf("[FILE_SAVE_FAIL]:%s\n"
                        ,frag_shader_nam    );;
                fflush(stdout);
            
                aac2020_fragbed_Halt("[FIX_THIS_YOU_FOOL]");
            };;
        
        //:-------------------:CORE_ACTION:SaveTextFileToDisk://

        return( 0x00 );
    }
    #undef U32

    //:==============================:LOAD_FILE_AND_SAVE_FILE://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:SIMPLE_KEY_HANDLER:=======================================://
#define U32   uint32_t /** GCC: <stdint.h> **/
#define I32    int32_t /** GCC: <stdint.h> **/
#define FN_01 aac2020_graquad_ReLoadShaderUniforms_iMouse
#define FN_02 aac2020_graquad_ReLoadShaderUniforms_iTime
#define FN_03 aac2020_graquad_ReLoadShaderUniforms_iResolution

    I32 
    AAC2020_FRAGBED_SimpleKeyHandler( 
        signed char chr_key 
    )
    {
        //:AKA[ AAC2020_ReadKeySimple ]
        /** ************************************************ ***
        Default ( ONLY ) keyboard callback for FRAGBED    
        USEAGE:                                           
            AAC2020_GINAWIN_SimpleKeyHandler_SetCallback(  
            &( AAC2020_FRAGBED_SimpleKeyHandler ) );;   
        *** ************************************************ **/

        /** 404: Shader Not Found. Don't take seriously.     **/
        /**      Any negative number will do.                **/

        int   shader_index_loaded=( 0 - 404 ); 

        //:FTI:Forgot_To_Init:
        if( AAC2020_FRAGBED_inited <= 0 ){
            printf("[FATAL_ERROR:AAC2020_FRAGBED:FTI]\n");
            fflush(stdout); exit(666);
        };;

        //:TODO: Swap loaded shaders here.
        if( chr_key >= 1 ){

            printf("[AAC2020_FRAGBED_SimpleKeyHandler]...\n");
            printf("[FRAGBED:KEY]:%c\n" , chr_key );
            fflush(stdout);

            #define P_1 AAC2020_FRAGBED_loaded_001_ptr //:###://
            #define P_2 AAC2020_FRAGBED_loaded_002_ptr //:###://
            #define P_3 AAC2020_FRAGBED_loaded_003_ptr //:###://
            #define P_4 AAC2020_FRAGBED_loaded_004_ptr //:###://
            #define P_5 AAC2020_FRAGBED_loaded_005_ptr //:###://
            #define P_6 AAC2020_FRAGBED_loaded_006_ptr //:###://
            #define P_7 AAC2020_FRAGBED_loaded_007_ptr //:###://
            #define P_8 AAC2020_FRAGBED_loaded_008_ptr //:###://
            #define P_9 AAC2020_FRAGBED_loaded_009_ptr //:###://

            int   shader_found =(   0    );
            if(   shader_index_loaded ){ /**@QUELCHNOTUSED@**/};
            const char*    str =((void*)0); //:frag_shader_str

            switch( chr_key ){
            case '1' :{ str = P_1; shader_found = 1; };break;
            case '2' :{ str = P_2; shader_found = 2; };break;
            case '3' :{ str = P_3; shader_found = 3; };break;
            case '4' :{ str = P_4; shader_found = 4; };break;
            case '5' :{ str = P_5; shader_found = 5; };break;
            case '6' :{ str = P_6; shader_found = 6; };break;
            case '7' :{ str = P_7; shader_found = 7; };break;
            case '8' :{ str = P_8; shader_found = 8; };break;
            case '9' :{ str = P_9; shader_found = 9; };break;
            default:{ 
                printf("[PICK_SHADER_USING_NUMBER_KEY]\n");
                fflush(stdout);
            };};;

            #undef  P_1  //:#################################://
            #undef  P_2  //:#################################://
            #undef  P_3  //:#################################://
            #undef  P_4  //:#################################://
            #undef  P_5  //:#################################://
            #undef  P_6  //:#################################://
            #undef  P_7  //:#################################://
            #undef  P_8  //:#################################://
            #undef  P_9  //:#################################://


            int should_re_load_the_shader_uniforms=( 0 );
            
            if( shader_found > 0 ){

                //: These shaders can be user edited and     ://
                //: loaded from disk. So use the more fault  ://
                //: tolerant loading function. If fails,     ://
                //: the screen will display the              ://
                //: letters: "synerr" for "syntax_error"     ://
                AAC2020_GRAQUAD_ReLoadFragShader_SyntaxErrorsOk(
                    str           //: frag_shader_str
                ,   strlen( str ) //: frag_shader_len
                );;

                should_re_load_the_shader_uniforms = ( 1 );
                shader_index_loaded = ( shader_found );
            }else
            if( shader_found <= 0 ){

                if( '0' == chr_key ){

                    /** Any time you call a shader reload    **/
                    /** function, ( AAC2020_GRAQUAD_RFS_*** )**/
                    /** you need to call a                   **/
                    /** uniform reload                       **/
                    /** ( AAC2020_BASUNIF_RFS_*** )          **/
                    /** directly after.                      **/
                    /**                                      **/
                    /** The reason they are two calls that   **/
                    /** always need to be paired is.         **/
                    /**                                      **/
                    /** 1: Flat is better than nested.       **/
                    /** 2: GRAQUAD cannot call BASUNIF       **/
                    /**    functions. But the BASUNIF        **/
                    /**    function needs to be called       **/
                    /**    after the GRAQUAD function.       **/
                    /**                                      **/
                    /**    This is because of our            **/
                    /**    LIBCHAN(s) library ordering.      **/
                    /**                                      **/
                    /** -John Mark DATE[2020_11_08]          **/
                    AAC2020_GRAQUAD_RFS_StatusReady();


                    should_re_load_the_shader_uniforms = ( 2 );
                    shader_index_loaded=( 0 );
                };;

            };;

            if( should_re_load_the_shader_uniforms >= 1 ){

                /** FLAT IS BETTER THAN NESTED **/

                //:ReLoadShaderUniforms:
                FN_01(0x00); /** Reload_Uniform: iMouse      **/
                FN_02(0x00); /** Reload_Uniform: iTime       **/
                FN_03(0x00); /** Reload_Uniform: iResolution **/


                //:Reload_Texture_Sampler_Uniform_For_The
                //:Active_Editor_In_Focus:
                #if( AAC2020_INCLUDE_PIXNAME >= 1 ) //:######://

                    #define EDI AAC2020_CEDITOR_dex_edi

                    if(EDI==AAC2020_PIXNAME_paint5d_tex_lot){
                    /** ************************************ ***
                        We can't do it this way. Would Involve
                        calling functions from the future.
                          
                        Where is this_handler called from?  
                        
                    (((    this_handler==SimpleKeyHandler    )))
                    *** ************************************ **/
                    };;
               
                    #undef  EDI //:##########################://
                #endif
            };;

        }else
        if( chr_key <= 1 ){

            printf("[AAC2020_FRAGBED:IGNORED_KEY]\n");
            fflush(stdout);

        };;

        /**1:1 mapping between editor index and shader index**/
        /** AAC2020_CEDITOR_dex_edi **/
        I32 BEST_NOT_TO_DO_WITH_SIDE_EFFECTS_CEDITOR_dex_edi=(
            shader_index_loaded );;

        if( BEST_NOT_TO_DO_WITH_SIDE_EFFECTS_CEDITOR_dex_edi
        != shader_index_loaded ){

            /** Quelch : set but not used compiler error **/
            aac2020_fragbed_Halt("[WTF_MY_MAN_2020]");

        };;

        /** Caller SHOULD use return value to set: **/
        /** AAC2020_CEDITOR_dex_edi                **/
        return( 
            BEST_NOT_TO_DO_WITH_SIDE_EFFECTS_CEDITOR_dex_edi );;
    }

#undef  U32
#undef  I32
#undef  FN_01  
#undef  FN_02  
#undef  FN_03  
//:=======================================:SIMPLE_KEY_HANDLER://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    int AAC2020_FRAGBED_Init()
    {
        //:LOAD_DEFAULT_SHADER_REFERENCES:-------------------://
        #define COPY AAC2020_FRAGBED_CopyHardCodedShaderStrings

            //:Mini_Unit_Test:COPY:--------------------------://
            //:------------------"1234567"-------------------://
            const char* test_me=("TEST_ME");
            const char* TEST_ME=COPY( test_me );
            int i=( 7 ); //:Inited To Length Of String.
            while(i--){ assert(test_me[i] == TEST_ME[i]); };
            free( (char*)TEST_ME );
            //:------------------"1234567"-------------------://
            //:--------------------------:Mini_Unit_Test:COPY://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                printf("[BEG:MALCOPY:DEFAULT_SHADERS]\n");
                fflush(stdout);
            #endif

            /** SEE[ DOC/WHY_FRAGBED_DEFAULT_COPY.TXT ] **/

            #if( AAC2020_INCLUDE_PAINT5D <= 0 )

                AAC2020_FRAGBED_loaded_001_has=( 1 );
                AAC2020_FRAGBED_loaded_001_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_001 );;

            #endif
            #if( AAC2020_INCLUDE_PAINT5D >= 1 )

                /** #_PULL_GLSL_SHADER_DATA_FROM_FUTURE_# **/
            
                /** #_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#  **/

                AAC2020_FRAGBED_loaded_001_has=( 1 );
                AAC2020_FRAGBED_loaded_001_ptr=COPY( 
                AAC2020_PAINT5D_DEFAULT_001 );;

            #endif

            AAC2020_FRAGBED_loaded_002_has=( 2 );
            AAC2020_FRAGBED_loaded_002_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_002 );;

            AAC2020_FRAGBED_loaded_003_has=( 3 );
            AAC2020_FRAGBED_loaded_003_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_003 );;

            AAC2020_FRAGBED_loaded_004_has=( 4 );
            AAC2020_FRAGBED_loaded_004_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_004 );;

            AAC2020_FRAGBED_loaded_005_has=( 5 );
            AAC2020_FRAGBED_loaded_005_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_005 );;

            AAC2020_FRAGBED_loaded_006_has=( 6 );
            AAC2020_FRAGBED_loaded_006_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_006 );;

            AAC2020_FRAGBED_loaded_007_has=( 7 );
            AAC2020_FRAGBED_loaded_007_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_007 );;

            AAC2020_FRAGBED_loaded_008_has=( 8 );
            AAC2020_FRAGBED_loaded_008_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_008 );;

            AAC2020_FRAGBED_loaded_009_has=( 9 );
            AAC2020_FRAGBED_loaded_009_ptr=COPY( 
            AAC2020_FRAGBED_DEFAULT_009 );;

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                printf("[MID:MALCOPY:DEFAULT_SHADERS]\n");
                fflush(stdout);
            #endif

                //:DEBUG:ASSERT_NON_ZERO_DEFAULTS:-----------://
                #define LEN strlen
                #define  A  assert

                A( LEN( AAC2020_FRAGBED_loaded_001_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_002_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_003_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_004_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_005_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_006_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_007_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_008_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_009_ptr ) > 0 );

                #undef  LEN
                #undef   A
                //:-----------:DEBUG:ASSERT_NON_ZERO_DEFAULTS://

            //: Missing sub namespace, but let's allow it    ://
            //: since the variable name is already a bit     ://
            //: too long for my tastes.                      ://
            AAC2020_all_default_shaders_malloc_copied=( 9 );

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                printf("[END:MALCOPY:DEFAULT_SHADERS]\n");
                fflush(stdout);
            #endif

        #undef COPY
        //:-------------------:LOAD_DEFAULT_SHADER_REFERENCES://
        //:LOAD_OVERRIDES_THEN_SAVE_ALL_TO_DISK:-------------://
        /** This is not the most efficient way to do it,     **/
        /** as it will often read a file from disk and then  **/
        /** immediately write that same file back to disk.   **/
        /** However, it is dead simple. And simple wins over **/
        /** efficiency. Computers will get faster over time. **/
        /** The code however, will stay just as confusing    **/
        /** over time. (Or get more confusing as you forget) **/

            //:HARD_DISK:LOAD_SHADER_OVERRIDES:--------------://

                /** Any FRAGBED_###.frag file on disk        **/
                /** will be de-serialized into RAM-memory.   **/

                #define LOD  AAC2020_FRAGBED_LoadFileIfExists

                    /** YES, 2nd param is DOUBLE_POINTER(**) **/
    
                        LOD( "MOD/SHADER_001_PAINT5D.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_001_ptr ));;

                        LOD( "MOD/SHADER_002_KEYPAD2.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_002_ptr ));;

                        LOD( "MOD/SHADER_003_KEYPAD3.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_003_ptr ));;

                        LOD( "MOD/SHADER_004_KEYPAD4.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_004_ptr ));;

                        LOD( "MOD/SHADER_005_KEYPAD5.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_005_ptr ));;

                        LOD( "MOD/SHADER_006_KEYPAD6.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_006_ptr ));;

                        LOD( "MOD/SHADER_007_KEYPAD7.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_007_ptr ));;

                        LOD( "MOD/SHADER_008_KEYPAD8.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_008_ptr ));;

                        LOD( "MOD/SHADER_009_KEYPAD9.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_009_ptr ));;

                #undef  LOD

            //:--------------:HARD_DISK:LOAD_SHADER_OVERRIDES://
            //:HARD_DISK:SAVE_ALL_SHADERS_IN_MEMORY:---------://

                /** ALL AAC2020_FRAGBED_loaded_### shaders   **/
                /** will be re-serialized to hard disk memory**/

                #define SAV  AAC2020_FRAGBED_SaveTextFileToDisk
    
                        SAV( "MOD/SHADER_001_PAINT5D.FRAG"  ,
                        AAC2020_FRAGBED_loaded_001_ptr  );;

                        SAV( "MOD/SHADER_002_KEYPAD2.FRAG"  ,
                        AAC2020_FRAGBED_loaded_002_ptr  );;

                        SAV( "MOD/SHADER_003_KEYPAD3.FRAG"  ,
                        AAC2020_FRAGBED_loaded_003_ptr  );;

                        SAV( "MOD/SHADER_004_KEYPAD4.FRAG"  ,
                        AAC2020_FRAGBED_loaded_004_ptr  );;

                        SAV( "MOD/SHADER_005_KEYPAD5.FRAG"  ,
                        AAC2020_FRAGBED_loaded_005_ptr  );;

                        SAV( "MOD/SHADER_006_KEYPAD6.FRAG"  ,
                        AAC2020_FRAGBED_loaded_006_ptr  );;

                        SAV( "MOD/SHADER_007_KEYPAD7.FRAG"  ,
                        AAC2020_FRAGBED_loaded_007_ptr  );;

                        SAV( "MOD/SHADER_008_KEYPAD8.FRAG"  ,
                        AAC2020_FRAGBED_loaded_008_ptr  );;

                        SAV( "MOD/SHADER_009_KEYPAD9.FRAG"  ,
                        AAC2020_FRAGBED_loaded_009_ptr  );;

                #undef  SAV


            //:---------:HARD_DISK:SAVE_ALL_SHADERS_IN_MEMORY://

        //:-------------:LOAD_OVERRIDES_THEN_SAVE_ALL_TO_DISK://

        AAC2020_FRAGBED_inited =( 1 );
        return( 0 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://