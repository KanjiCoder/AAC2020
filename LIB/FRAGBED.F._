//:FRAGBED.D._  

//: #_FRAGBED_UNIFORM_FREEABLE_POINTERS_# ://

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_fragbed_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:AAC2020_FRAGBED]:%s\n", msg_err );
        fflush(stdout);
        exit(666);
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:#INFO_MESSAGES_SDC#:======================================://
#define U32  uint32_t  /** <stdint.h> **/
#define P_F  printf
#define F_F  fflush( stdout );
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_fragbed_Info( const char* msg_inf ){
        if( AAC2020_SILENCE.FRAGBED <= 0 ){ //:@LOUD@://
            P_F( "[aac2020_fragbed:Info]:%s\n" ,  msg_inf);
            F_F;
        };;
    }  
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_fragbed_Info_str( 
        const char* str_fmt /** Format String  (with:%s) **/
    ,   const char* str_msg /** String:Message           **/
    ){
        if( AAC2020_SILENCE.FRAGBED <= 0 ){ //:@LOUD@://
            P_F( "[aac2020_fragbed:Info_str:BELOW]" );
            F_F;//:@ECHOFUNC_EXTRAFLUSH@://
            P_F( str_fmt , str_msg );
            F_F;(stdout);
        };;
    }  
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_fragbed_Info_dec( 
        const char* str_fmt /** Format String (with: %d)  **/
    ,   U32         dec_msg /** Message:DECIMAL_VALUE     **/
    ){
        if( AAC2020_SILENCE.FRAGBED <= 0 ){ //:@LOUD@://
            P_F( "[aac2020_fragbed:Info_dec:BELOW]" );
            F_F; //:@ECHOFUNC_EXTRAFLUSH@://
            P_F( str_fmt , dec_msg );
            F_F;
        };;
    }  
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_fragbed_Info_chr( 
        const char* str_fmt /** Format String (with: %c)  **/
    ,   char        chr_msg /** Message:Char_Value        **/
    ){
        if( AAC2020_SILENCE.FRAGBED <= 0 ){ //:@LOUD@://
            P_F( "[aac2020_fragbed:Info_chr:BELOW]" );
            F_F; //:@ECHOFUNC_EXTRAFLUSH@://
            P_F( str_fmt , chr_msg );
            F_F;
        };;
    }  
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  U32
#undef  P_F
#undef  F_F
//:======================================:#INFO_MESSAGES_SDC#://
//:COPY_HARD_CODED_SHADER_STRINGS:===========================://
#define INFO     aac2020_fragbed_Info
#define INFO_DEC aac2020_fragbed_Info_dec
#define FUCK_YOU aac2020_fragbed_Halt

    const char*
    AAC2020_FRAGBED_CopyHardCodedShaderStrings(
        
        /** One of our FILE_SCOPE hardcoded strings in **/
        /** our source code.                           **/
        const char* AAC2020_FRAGBED_DEFAULT 
    )
    {
        /** FUNCTION_SUMMARY: Copys hard coded FILE_SCOPE    **/
        /** shader strings to dynamic memory so that all     **/
        /** pointers are always freeable regardless of if    **/
        /** we are pointing to HARDCODED shader source or    **/
        /** shader source loaded from disk.                  **/

        //:##################################################://
        if( ((void*)0) == AAC2020_FRAGBED_DEFAULT ){
            FUCK_YOU( "[NULL_FRAGBED_DEFAULT]" );
        };;
        if( strlen( AAC2020_FRAGBED_DEFAULT ) <= 0 ){
            FUCK_YOU("[ZERO_LEN_HARD_CODED_STR]");
        };;
        //:##################################################://

        //: noc: number_of_characters
        //: nob: number_of_bytes
        int noc = strlen( AAC2020_FRAGBED_DEFAULT );
        int nob = (noc + 1); //:Add null terminator.

        //:Allocate dynamic memory:
        char* aac2020_fragbed_default=calloc(1,nob);

        //:COPY_ALL_CHARACTERS:------------------------------://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** GRADQUAD BUGHUNT_001 led us into the     **/
                /** NEXT file within our library chain.      **/
                INFO_DEC("[ABOUT_TO_COPY:noc]:%d\n", noc );
            #endif

            //:copy_all_characters::- - - - - - - - - - - - -://
            for( int dex = 0 ; dex < noc ; dex ++ ){
                aac2020_fragbed_default[ dex ]=(
                AAC2020_FRAGBED_DEFAULT[ dex ]  );;
            };;//:- - - - - - - - - - - -:copy_all_characters://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** GRADQUAD BUGHUNT_001 led us into the     **/
                /** NEXT file within our library chain.      **/
                INFO_DEC("[DONE_COPYING:noc]:%d\n", noc );
            #endif

        //:------------------------------:COPY_ALL_CHARACTERS://
        //:ADD_NULL_TERM:MEMORY_STOMP_RISK:------------------://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** YES: AAC2020_GRAQUAD_BUGHUNT_001  **/
                /** NOT: AAC2020_FRAGBED_BUGHUNT_001  **/
                //:MSR:MEMORY_STOMP_RISK
                INFO("[BEFORE:ADD_NUL_TERM:MSR]");
            #endif

            //:add_null_term:MSR!:- - - - - - - - - - - - - -://

                //[AAC2020_GRAQUAD_BUGHUNT_001:FOUND]////[!!!]//
                /** You were off by 1 here and memory        **/
                /** stomping other memory. The reason it     **/
                /** worked originally probably was because   **/
                /** malloc allocates in powers of 2 chunks.  **/
                /** So sometimes going 1 out of bounds       **/
                /** does NOT stomp memory if extra was       **/
                /** allocated. DATE[ 2020_11_06 ]            **/

                int max_dex = (    nob - 1 );
                assert( max_dex == nob - 1 );
                assert( max_dex == noc + 0 );
                assert( nob - 1 == noc + 0 );

                //:Make absolutely god damned sure that we have  
                //:a null terminator at the end of our string.
                aac2020_fragbed_default[ max_dex ] ='\0';

            //:- - - - - - - - - - - - - -:add_null_term:MSR!://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                /** YES: AAC2020_GRAQUAD_BUGHUNT_001  **/
                /** NOT: AAC2020_FRAGBED_BUGHUNT_001  **/
                //:MSR:MEMORY_STOMP_RISK
                INFO("[AFTER::ADD_NUL_TERM:MSR]");
            #endif

        //:------------------:ADD_NULL_TERM:MEMORY_STOMP_RISK://

        //:Make sure copy didn't fail.
        if( strlen( aac2020_fragbed_default ) <= 0 ){
            aac2020_fragbed_Halt("[WELL_FUCK_ME_I_GUESS]");
        };;

        return( aac2020_fragbed_default );
    }

#undef  INFO      
#undef  INFO_DEC  
#undef  FUCK_YOU  
//:===========================:COPY_HARD_CODED_SHADER_STRINGS://
//:LOAD_FILE_IF_EXISTS:======================================://
#define U32       uint32_t /** GCC: <stdint.h> **/
#define INFO_STR  aac2020_fragbed_Info_str

    U32 
    AAC2020_FRAGBED_LoadFileIfExists(
        #define ARG const char
        ARG*         frag_shader_nam //:EX:FRAGBED_001.frag
    ,   ARG*  *BYREF_frag_shader_str //:DESTINATION
        #undef  ARG
    )
    {
        /** SSAE: Shader Should Always Exist * * * * * * * * **/
        /**       A FILE on disk might not exists, but at  * **/
        /**       this point we should have MALCOPY(ed)  the **/
        /**       hardcoded .exe shader string to the        **/
        /**       BYREF_frag_shader_str variable.            **/
        if( ((void*)0) == (*BYREF_frag_shader_str) ){
            aac2020_fragbed_Halt("[FATAL:SSAE]");
        };;

        const char* frag_shader_str =((void*)0);
        int file_nob    = (   0 - 808   ); //: Neg: TrapValue
        int file_exists = (   0         ); //: 0 == undefined.

        //:DOES_THE_FILE_EXIST_ON_DISK:?:--------------------://
        #define F_OK 0 /** unistd.h **/
        #define FNAM frag_shader_nam

        if( access( FNAM , 0x00 /** F_OK **/ ) != -1 ) {
        file_exists=( 1 );

        //:DOES_THE_FILE_EXIST_ON_DISK:YES:
 
            //:FREE_PREVIOUS_MEMORY:-------------------------://

                if( AAC2020_all_default_shaders_malloc_copied ){

                    //:Be paranoid, check your pointers.
                    //:######################################://
                    #define H aac2020_fragbed_Halt //:#######://
                    if( ((void*)0) == BYREF_frag_shader_str ){
                        H("[NULL:BYREF]");
                    };;
                    if( ((void*)0) ==*BYREF_frag_shader_str ){
                        H("[NULL:DEREF]");
                    };;
                    #undef  H //:############################://
                    //:######################################://

                    //:De-reference char** to char* :
                    frag_shader_str=( *BYREF_frag_shader_str );
                    
                    //:Discard const qualifier and free.
                    free( (char*)frag_shader_str );

                }else{
                    //: Fail because we want normalized data.://
                    //: Mixing "freeable" and "non-freeable" ://
                    //: pointers is a HORRIBLE idea.         ://
                    aac2020_fragbed_Halt(
                        "[NULL_OR_NON_DYNAMIC_POINTERS]"
                    );;
                };;

            //:-------------------------:FREE_PREVIOUS_MEMORY://
            //:READ_ALLOCATE_AND_COPY:-----------------------://
            /** SEEK_SET : GCC: unistd.h && mmsystem.h **/
            /** SEEK_END : GCC: unistd.h && mmsystem.h **/
            #define MACRO_SEEK_SET 0  
            #define MACRO_SEEK_END 2  

                //:file_nob:GET_FILE_NUMBER_OF_BYTES:--------://

                    //:Open file for "read as binary" ("rb")
                          file_nob =( 0 - 404 );
                    FILE* file_han = fopen( 
                        frag_shader_nam , "rb" );;
                    
                    //:Seek to end and get number of bytes.
                    //:Then reset file handle to start of file.
                    fseek( file_han , 0 , MACRO_SEEK_END );
                    file_nob = ftell( file_han );
                    fseek( file_han , 0 , MACRO_SEEK_SET );

                //:file_nob:GET_FILE_NUMBER_OF_BYTES:--------://
                //:ALLOCATE_MEMORY:--------------------------://

                    //:1. Allocate_Memory: (plus extra byte)
                    //:2. Be safe. Add extra null byte to end.
                    frag_shader_str = calloc( 1 , file_nob+1 );
            ((char*)frag_shader_str)[ file_nob ]='\0';

                    //:Set output parameter:
                    (*BYREF_frag_shader_str)=frag_shader_str;

                //:--------------------------:ALLOCATE_MEMORY://
                //:READ_FILE_INTO_ALLOCATED_MEMORY:----------://

                    fread( 
                        (char*)         //:<-- MAKE_WRITABLE
                        frag_shader_str //:<-- DESTINTION(WRITE)


                    //[ ------------------------------------ ]//
                    //[ Q: should this be: ( file_nob + 1 ) ?]//
                    //[ A: No. The "file_nob+1" from earlier ]//
                    //[    was a precaution in case string   ]//
                    //[    read into memory here was NOT     ]//
                    //[    null terminated. Text files are   ]//
                    //[    NOT null terminated on disk.      ]//
                    ,   file_nob  //+  file:Number_Of_Bytes  +//
                    //[ ------------------------------------ ]//


                    ,   1               //:Read 1 byte at a time
                    ,   file_han        //:SOURCE(READ)
                    );;

                //:----------:READ_FILE_INTO_ALLOCATED_MEMORY://
                //:DONT_FORGET_TO_CLOSE_FILE:----------------://

                    fclose( file_han );

                //:----------------:DONT_FORGET_TO_CLOSE_FILE://
            #undef MACRO_SEEK_SET
            #undef MACRO_SEEK_END
            //:-----------------------:READ_ALLOCATE_AND_COPY://
           
            
            #if( AAC2020_FRAGBED_BUGHUNT_FileOnDiskNotify >= 1 )
            INFO_STR("[file_YES_on_disk]:%s\n",frag_shader_nam);
            #endif 
         
            file_exists=( 0 + 4 );
        }else{ 
            file_exists=( 0 - 4 );
   
            #if( AAC2020_FRAGBED_BUGHUNT_FileOnDiskNotify >= 1 )
            INFO_STR("[file_NOT_on_disk]:%s\n",frag_shader_nam);
            #endif
          
        };;
        #undef  F_OK
        #undef  FNAM
        //:--------------------:DOES_THE_FILE_EXIST_ON_DISK:?://
        //:ASSERT_NULL_TERMINATOR:---------------------------://
        #define FATAL_ERROR aac2020_fragbed_Halt
        #define BYREF_BOI BYREF_frag_shader_str

            /** ADDED[ DATE[ 2020_11_16 ] ] **************** **/

            if( file_exists >= 1 ){

                if( '\0' != frag_shader_str[ file_nob ] ){
                    FATAL_ERROR("[DONE_FUCKED_UP:001]");
                };;

                if( '\0' != (*BYREF_BOI)[ file_nob ] ){
                    FATAL_ERROR("[DONE_FUCKED_UP:002]");
                };;

            }else{
                    
                /** nod_noc: NotOnDisk:NumberOfCharacters **/
                int nod_noc = strlen(*BYREF_BOI);

                /** nod_nob: NotOnDisk:NumberOfBytes **/ 
                int nod_nob = ( nod_noc + 1 );

                if( '\0' != (    *BYREF_BOI)[ nod_nob - 1 ]){

                    FATAL_ERROR("[DONE_FUCKED_UP:003]");

                };;

            };;

        #undef BYREF_BOI
        #undef FATAL_ERROR
        //:---------------------------:ASSERT_NULL_TERMINATOR://

        return( 0x00 );
    }
   
#undef  U32
#undef  INFO_STR
//:======================================:LOAD_FILE_IF_EXISTS://
//:SAVE_TEXT_FILE_TO_DISK:===================================://
#define P_F       printf
#define U32       uint32_t /** GCC: <stdint.h> **/
#define NIL       ((void*)0)
#define INFO      aac2020_fragbed_Info
#define INFO_STR  aac2020_fragbed_Info_str
#define FATALERR  aac2020_fragbed_Halt
    
    U32 
    AAC2020_FRAGBED_SaveTextFileToDisk(
        const char* frag_shader_nam //:Name_Of_File
    ,   const char* frag_shader_str //:Contents_Of_File
    )
    {
        if( NIL == frag_shader_nam ){ FATALERR("[NULLNAME]");};;
        if( NIL == frag_shader_str ){ FATALERR("[NULL_STR]");};;

        //:##################################################://
        if( AAC2020_SILENCE.FRAGBED <= 0 ){ //:##############://
        #if( AAC2020_FRAGBED_BUGHUNT_SaveTextFileToDisk >= 1 )

            int frag_shader_len = strlen( frag_shader_str );
            P_F("[DEBUG:AAC2020_FRAGBED_SaveTextFileToDisk]\n");
            P_F("[frag_shader_nam]:%s\n"    , frag_shader_nam );
            P_F("[frag_shader_str]:%s\n"    , frag_shader_str );
            P_F("[frag_shader_len]:%d\n"    , frag_shader_len );
            fflush( stdout );

        #endif //:###########################################://
        };; //:##############################################://

        //: noc:Number_Of_Characters:
        //: nob:Number_Of_Bytes     : (Ascii My Boy!)
        int noc = strlen( frag_shader_str );
        int nob = ( noc + 1 ); 

        /** BUGFIX:                                        * **/
        /**     WRONG: '\0' == frag_shader_str[ nob     ]  * **/
        /**       FIX: '\0' == frag_shader_str[ nob - 1 ]  * **/
        if( '\0' != frag_shader_str[ nob - 1 ] ){

            /** Print this before attempting to print        **/
            /** the string variables in case the string      **/
            /** vars cause a segfault or something.          **/
            INFO("[FATAL_ERROR:WE_HAVE_A_PROBLEM_CAPTAIN]\n");
            INFO_STR("[frag_shader_nam]%s\n",
                     frag_shader_nam );;
            INFO_STR("[frag_shader_str]%s\n",
                     frag_shader_str );;
            FATALERR("[ERR:NNT]");
        };;

        //:CREATE_BLANK_IF_NOT_EXIST:------------------------://

            //:----------------------------------------------://
            //:DOES:                                     : : ://
            //:     1: Creates Directories If Not Exist  : : ://
            //:     2: Creates Empty File  If Not Exist  : : ://
            //:----------------------------------------------://

            /** Will create directory structure AND touch    **/
            /** the file. Touch in the linux sense of        **/
            /** create if not exists and upate access time.  **/
            /** Though I don't care about access time, just  **/
            /** creating if not exist.                       **/
            AAC2020_FILEBOI_TouchFile( frag_shader_nam );

        //:------------------------:CREATE_BLANK_IF_NOT_EXIST://
        //:CORE_ACTION:SaveTextFileToDisk:-------------------://

            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
            //[ AAC2020_FILEBOI_TouchFile( frag_shader_name )]//
            //[ MUST BE CALLED PRIOR TO CORE_ACTION !!!!!!!! ]//
            //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

            /** Open file for write.                         **/
            /** This will erase any previous file contents.  **/
            FILE*  file_han = fopen( frag_shader_nam , "wb" );
            
            if( ((void*)0) != file_han ){
            
                fseek( file_han , 0 /**orgin**/ , 0 /**SEEK_SET**/);
                fwrite( 
                    frag_shader_str
                ,   1   //:SizeInBytesOfEachElementToBeWritten
            
                //:Number_of_Elements_To_Write
                ,   noc //:number_of_characters( noc )
                        //:NOT[ nob ]because strings are not
                        //:null terminated inside text files.
            
                ,   file_han //:File We are writing into.
                );;
                fclose( file_han );
            
            }else{
                
                INFO_STR("[FILE_SAVE_FAIL]:%s\n" 
                            ,frag_shader_nam    );;
                FATALERR("[FIX_THIS_YOU_FOOL]");
            };;
        
        //:-------------------:CORE_ACTION:SaveTextFileToDisk://

        return( 0x00 );
    }

#undef  P_F       //: 01 :-----------------------------------://
#undef  U32       //: 02 :-----------------------------------://
#undef  NIL       //: 03 :-----------------------------------://
#undef  INFO      //: 04 :-----------------------------------://
#undef  INFO_STR  //: 05 :-----------------------------------://
#undef  FATALERR  //: 06 :-----------------------------------://
//:===================================:SAVE_TEXT_FILE_TO_DISK://
//:SIMPLE_KEY_HANDLER:=======================================://
#define CHR      const char
#define U32      uint32_t /** GCC: <stdint.h> **/
#define I32       int32_t /** GCC: <stdint.h> **/
#define INFO     aac2020_fragbed_Info
#define INFO_CHR aac2020_fragbed_Info_chr
#define FUCK_YOU aac2020_fragbed_Halt

#define FN_01  aac2020_graquad_ReLoadShaderUniforms_iMouse
#define FN_02  aac2020_graquad_ReLoadShaderUniforms_iTime
#define FN_03  aac2020_graquad_ReLoadShaderUniforms_iResolution

/** These should be number keys 0 -to- 9 unless you've got   **/
/** a working editor already and you absolutely need those   **/
/** keys for something else. ............................... **/
#define BED_000  AAC2020_KEYBIND.FRAGBED.bed_000
#define BED_001  AAC2020_KEYBIND.FRAGBED.bed_001
#define BED_002  AAC2020_KEYBIND.FRAGBED.bed_002
#define BED_003  AAC2020_KEYBIND.FRAGBED.bed_003
#define BED_004  AAC2020_KEYBIND.FRAGBED.bed_004
#define BED_005  AAC2020_KEYBIND.FRAGBED.bed_005
#define BED_006  AAC2020_KEYBIND.FRAGBED.bed_006
#define BED_007  AAC2020_KEYBIND.FRAGBED.bed_007
#define BED_008  AAC2020_KEYBIND.FRAGBED.bed_008
#define BED_009  AAC2020_KEYBIND.FRAGBED.bed_009



//  I32
//  aac2020_fragbed_KeyInn_Simple(
//      signed char chr_key
//  )
//  {
//      CHR* str_fra =((void*)0);
//      I32  dex_fou =( 0 - 660077 );
//      
//      aac2020_fragbed_KIS_chr_key_CTO_str_fra_AND_dex_fou(
//                          chr_key , &(str_fra) ,&(dex_fou) );;
//  
//  }

    void /********* KIS == KeyInn_Simple ******************* **/
    aac2020_fragbed_KIS_chr_key_CTO_dex_fou_AND_str_fra(
        CHR          chr_key
    ,   I32   *BYREF_dex_fou
    ,   CHR*  *BYREF_str_fra
    )
    {
        //:SET_TRAPS_ON_RETURN_VARS:-------------------------://

            /**   dex_fou : inDEX_FOUnd (index of found item)**/
            /**   dex_fou == shader_found (when dex_fou >= 1)**/
            
            int      dex_fou =(  0 - 2 /**MUST_BE_NEGATIVE**/); 
            const char*  str =((void*)0); //:frag_shader_str
            
        //:-------------------------:SET_TRAPS_ON_RETURN_VARS://

        //: #_PRIVATE_FRAGBED_FUNC_REQUIRES_VALID_INPUT_# ://
        assert(       48 == '0' );  assert( 57 == '9' );
        if( 0 ||  chr_key < '0'   ||    chr_key > '9' ){
            /** #_FRAGBED_INVALID_NUMBER_KEY_# **/
            FUCK_YOU("[EXPECTS_VALID_SUB_SYSTEM_KEY_2020]");
        };;

        #define C_K      chr_key
        I32     is_valid_num_key =(( C_K >='0' && C_K <='9'));;
        assert( is_valid_num_key >= 1 );
        #undef  C_K

        //:FTI:Forgot_To_Init:
        if( AAC2020_FRAGBED_inited <= 0 ){
            FUCK_YOU("[FATAL_ERROR:AAC2020_FRAGBED:FTI]\n");
        };;

        //:TODO: Swap loaded shaders here.
        if( is_valid_num_key >= 1 ){

            INFO(    "[AAC2020_FRAGBED_KeyInn_Simple]...\n");
            INFO_CHR("[FRAGBED:KEY]:%c\n" , chr_key );

            #define P_0 ((void*)0)
            #define P_1 AAC2020_FRAGBED_loaded_001_ptr //:###://
            #define P_2 AAC2020_FRAGBED_loaded_002_ptr //:###://
            #define P_3 AAC2020_FRAGBED_loaded_003_ptr //:###://
            #define P_4 AAC2020_FRAGBED_loaded_004_ptr //:###://
            #define P_5 AAC2020_FRAGBED_loaded_005_ptr //:###://
            #define P_6 AAC2020_FRAGBED_loaded_006_ptr //:###://
            #define P_7 AAC2020_FRAGBED_loaded_007_ptr //:###://
            #define P_8 AAC2020_FRAGBED_loaded_008_ptr //:###://
            #define P_9 AAC2020_FRAGBED_loaded_009_ptr //:###://

            //:#DO_SWITCH#:==================================://
            #define KEY chr_key
            #define BIF if( dex_fou >= 0 ){break;};
            do{
                if( KEY == BED_000 ){ dex_fou = 0; str = P_0; };
            BIF    
                if( KEY == BED_001 ){ dex_fou = 1; str = P_1; };
            BIF                                               
                if( KEY == BED_002 ){ dex_fou = 2; str = P_2; };
            BIF                                               
                if( KEY == BED_003 ){ dex_fou = 3; str = P_3; };
            BIF                                               
                if( KEY == BED_004 ){ dex_fou = 4; str = P_4; };
            BIF                                               
                if( KEY == BED_005 ){ dex_fou = 5; str = P_5; };
            BIF                                               
                if( KEY == BED_006 ){ dex_fou = 6; str = P_6; };
            BIF                                               
                if( KEY == BED_007 ){ dex_fou = 7; str = P_7; };
            BIF                                               
                if( KEY == BED_008 ){ dex_fou = 8; str = P_8; };
            BIF                                               
                if( KEY == BED_009 ){ dex_fou = 9; str = P_9; };
            BIF
            }while( 0 );
            #undef  KEY   /** chr_key , key pressed **/
            #undef  BIF   /** BIF:Break_If_Found    **/
            //:==================================:#DO_SWITCH#://

            #undef  P_0  //:#################################://
            #undef  P_1  //:#################################://
            #undef  P_2  //:#################################://
            #undef  P_3  //:#################################://
            #undef  P_4  //:#################################://
            #undef  P_5  //:#################################://
            #undef  P_6  //:#################################://
            #undef  P_7  //:#################################://
            #undef  P_8  //:#################################://
            #undef  P_9  //:#################################://

        }else
        if( is_valid_num_key <= 0 ){

            /** 1FU: ONE(1) FUCK YOU **/
            FUCK_YOU("[AAC2020_FRAGBED:IGNORED_KEY:1FU]\n");

        }else{ //:[ is_valid_num_key ?  ]

            /** DFU: DOUBLE( 2X ) FUCK YOU **/
            FUCK_YOU("[AAC2020_FRAGBED:INVALID_KEY:DFU]\n");

        };;


        //:return_via_output_parameters:---------------------://

            /** @_REFERENCES_ARE_NEVER_NULL_@ **/
            assert( ((void*)0) != BYREF_dex_fou );
            assert( ((void*)0) != BYREF_str_fra );
            
            (*BYREF_dex_fou)=( dex_fou );
            (*BYREF_str_fra)=(     str );
           
        //:---------------------:return_via_output_parameters://
    }

    void /********* KIS == KeyInn_Simple ******************* **/
    aac2020_fragbed_KIS_dex_fou_AND_str_fra_EXE_rfs_GET_sil(
    /**/I32             dex_fou
    ,   CHR*                        str_fra
    ,   I32                                      *BYREF_sil
    )
    {
       //: #_FRAGBED_CODE_SHOULD___NOT___USE_CALLBACKS_#
        /** #_404_SHADER_NOT_FOUND_# ................ **/
        int   shader_index_loaded=( 0 - 404 ); 

            int should_re_load_the_shader_uniforms=( 0 );
            
            if( dex_fou > 0 ){

                //: These shaders can be user edited and     ://
                //: loaded from disk. So use the more fault  ://
                //: tolerant loading function. If fails,     ://
                //: the screen will display the              ://
                //: letters: "synerr" for "syntax_error"     ://
                AAC2020_GRAQUAD_ReLoadFragShader_SyntaxErrorsOk(
                            str_fra   //: frag_shader_str
                ,   strlen( str_fra ) //: frag_shader_len
                );;

                should_re_load_the_shader_uniforms = ( 1 );
                shader_index_loaded = ( dex_fou );
            }else
            if( dex_fou <= 0 ){

                //:------------------------------------------://
                //:@VID_IID[ 0117 ]TIME[ 02:39:00 ] ---------://
                //:------------------------------------------://
                //( '0' == chr_key )
                if(  0  == dex_fou ){

                    /** Any time you call a shader reload    **/
                    /** function, ( AAC2020_GRAQUAD_RFS_*** )**/
                    /** you need to call a                   **/
                    /** uniform reload                       **/
                    /** ( AAC2020_BASUNIF_RFS_*** )          **/
                    /** directly after.                      **/
                    /**                                      **/
                    /** The reason they are two calls that   **/
                    /** always need to be paired is.         **/
                    /**                                      **/
                    /** 1: Flat is better than nested.       **/
                    /** 2: GRAQUAD cannot call BASUNIF       **/
                    /**    functions. But the BASUNIF        **/
                    /**    function needs to be called       **/
                    /**    after the GRAQUAD function.       **/
                    /**                                      **/
                    /**    This is because of our            **/
                    /**    LIBCHAN(s) library ordering.      **/
                    /**                                      **/
                    /** -John Mark DATE[2020_11_08]          **/
                    AAC2020_GRAQUAD_RFS_StatusReady();


                    should_re_load_the_shader_uniforms = ( 2 );
                    shader_index_loaded=( 0 );
                };;

            };;

            if( should_re_load_the_shader_uniforms >= 1 ){

                /** FLAT IS BETTER THAN NESTED **/

                //:ReLoadShaderUniforms:
                FN_01(0x00); /** Reload_Uniform: iMouse      **/
                FN_02(0x00); /** Reload_Uniform: iTime       **/
                FN_03(0x00); /** Reload_Uniform: iResolution **/


                //:Reload_Texture_Sampler_Uniform_For_The
                //:Active_Editor_In_Focus:
                #if( AAC2020_INCLUDE_PIXNAME >= 1 ) //:######://

                    #define EDI AAC2020_CEDITOR_dex_edi

                    if(EDI==AAC2020_PIXNAME_paint5d_tex_lot){
                    /** ************************************ ***
                        We can't do it this way. Would Involve
                        calling functions from the future.
                          
                        Where is this_handler called from?  
                        
                    (((    this_handler==SimpleKeyHandler    )))
                    *** ************************************ **/
                    };;
               
                    #undef  EDI //:##########################://
                #endif
            };;

        //:return_via_output_parameter:----------------------://

            assert(   shader_index_loaded >= 0 );
            assert(   shader_index_loaded <= 9 );

            /** @_BYREF_INPUTS_ARE_NEVER_NULL_@ **/
            assert( ((void*)0) != BYREF_sil );

            (*BYREF_sil)=( shader_index_loaded  );

        //:----------------------:return_via_output_parameter://
    }

    I32
    aac2020_fragbed_KeyInn_Simple(
        signed char chr_key
    )
    {

        ////////////////////////////////////////////////////////

        I32  dex_fou =( 0 - 660077 );
        CHR* str_fra =((void*)0);
        
        /** KIS == KeyInn_Simple **/
        aac2020_fragbed_KIS_chr_key_CTO_dex_fou_AND_str_fra(
                            chr_key  ,&(dex_fou), &(str_fra) );;

        ////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////

        I32 sil =( 0-999 ); /** sil==shader_index_loaded **/

        /** KIS == KeyInn_Simple **/
        aac2020_fragbed_KIS_dex_fou_AND_str_fra_EXE_rfs_GET_sil(
                            dex_fou  ,  str_fra  ,        &(sil)
        );;

        ////////////////////////////////////////////////////////

        return( sil /** shader_index_loaded **/ );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    I32 
    AAC2020_FRAGBED_KeyInn_Simple( 
        signed char chr_key 
    )
    {

        /** editor_index_to_activate **/
        I32 PUTTHIS_dex_edi =( 0 - 6660666 );

        assert( 48 == '0' );
        assert( 57 == '9' );
        I32 is_valid_num_key =( 
            ( chr_key >= '0' && chr_key <= '9' )
        );;
        if( is_valid_num_key >= 1 ){

            I32 shader_index_loaded=(
                aac2020_fragbed_KeyInn_Simple( chr_key )
            );;

            /** ******************************************** **/
            /** @VID_IID[ 0066 ]TIME[ 1H 4M 46 ]             **/
            /** BECAUSE: 1:1 mapping between the shader      **/
            /** indexes and the sub-system indexes.          **/
            /** EXAMPLE: PAINT5D is subsystem #1             **/
            /**          And uses shader slot #1             **/
            /** ******************************************** **/

            PUTTHIS_dex_edi =( shader_index_loaded  );

        }else{

            PUTTHIS_dex_edi =( AAC2020_CEDITOR_dex_edi );
        };;

        /** ************************************************ ***
            @VID_IID[ 0066 ]TIME[ 00H 50M 55S ]

            Shader index loaded should match editor index     
            1:1 mapping between active editor and the
            loaded shader code.            
            
            Caller SHOULD use return value to set:  
            AAC2020_CEDITOR_dex_edi    

            In Calling Code That Calls FragBed Function:

                AAC2020_CEDITOR_dex_edi == shader_index_loaded
          
        *** ************************************************ **/

        return( PUTTHIS_dex_edi /* editor_index_to_activate */);
    }

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://
#undef  CHR                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  I32                                           //: 03 ://
#undef  INFO                                          //: 04 ://
#undef  INFO_CHR                                      //: 05 ://
#undef  FUCK_YOU                                      //: 06 ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://                                               //: -- ://
#undef  FN_01                                         //: 07 ://
#undef  FN_02                                         //: 08 ://
#undef  FN_03                                         //: 09 ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://
#undef  BED_000                                       //: 10 ://
#undef  BED_001                                       //: 11 ://
#undef  BED_002                                       //: 12 ://
#undef  BED_003                                       //: 13 ://
#undef  BED_004                                       //: 14 ://
#undef  BED_005                                       //: 15 ://
#undef  BED_006                                       //: 16 ://
#undef  BED_007                                       //: 17 ://
#undef  BED_008                                       //: 18 ://
#undef  BED_009                                       //: 19 ://
//:=======================================:SIMPLE_KEY_HANDLER://
//:INIT:=====================================================://
#define U32  uint32_t /** GCC: <stdint.h> **/
#define INFO aac2020_fragbed_Info

    U32 
    AAC2020_FRAGBED_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved_For_Future_Use **/ };

        //:LOAD_DEFAULT_SHADER_REFERENCES:-------------------://
        #define COPY AAC2020_FRAGBED_CopyHardCodedShaderStrings

            //:Mini_Unit_Test:COPY:--------------------------://
            //:------------------"1234567"-------------------://
            const char* test_me=("TEST_ME");
            const char* TEST_ME=COPY( test_me );
            int i=( 7 ); //:Inited To Length Of String.
            while(i--){ assert(test_me[i] == TEST_ME[i]); };
            free( (char*)TEST_ME );
            //:------------------"1234567"-------------------://
            //:--------------------------:Mini_Unit_Test:COPY://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                INFO("[BEG:MALCOPY:DEFAULT_SHADERS]\n");
            #endif

            /** SEE[ DOC/WHY_FRAGBED_DEFAULT_COPY.TXT ] **/

            //:PAINT5D:OVERRIDE?:----------------------------://
            #if( AAC2020_INCLUDE_PAINT5D <= 0 )

                AAC2020_FRAGBED_loaded_001_has=( 1 );
                AAC2020_FRAGBED_loaded_001_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_001 );;

            #endif
            #if( AAC2020_INCLUDE_PAINT5D >= 1 )

                /** #_PULL_GLSL_SHADER_DATA_FROM_FUTURE_# **/
            
                /** #_WHY_CANT_I_SEE_PAINT5D_IN_MY_EXE_#  **/

                AAC2020_FRAGBED_loaded_001_has=( 1 );
                AAC2020_FRAGBED_loaded_001_ptr=COPY( 
                AAC2020_PAINT5D_DEFAULT_001 );;

            #endif
            //:----------------------------:PAINT5D:OVERRIDE?://
            //:Remaining_Non_Overridden_Shaders:-------------://

                AAC2020_FRAGBED_loaded_002_has=( 2 );
                AAC2020_FRAGBED_loaded_002_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_002 );;

                AAC2020_FRAGBED_loaded_003_has=( 3 );
                AAC2020_FRAGBED_loaded_003_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_003 );;

                AAC2020_FRAGBED_loaded_004_has=( 4 );
                AAC2020_FRAGBED_loaded_004_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_004 );;

                AAC2020_FRAGBED_loaded_005_has=( 5 );
                AAC2020_FRAGBED_loaded_005_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_005 );;

                AAC2020_FRAGBED_loaded_006_has=( 6 );
                AAC2020_FRAGBED_loaded_006_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_006 );;

                AAC2020_FRAGBED_loaded_007_has=( 7 );
                AAC2020_FRAGBED_loaded_007_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_007 );;

                AAC2020_FRAGBED_loaded_008_has=( 8 );
                AAC2020_FRAGBED_loaded_008_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_008 );;

                AAC2020_FRAGBED_loaded_009_has=( 9 );
                AAC2020_FRAGBED_loaded_009_ptr=COPY( 
                AAC2020_FRAGBED_DEFAULT_009 );;

            //:-------------:Remaining_Non_Overridden_Shaders://

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                INFO("[MID:MALCOPY:DEFAULT_SHADERS]\n");
            #endif

                //:DEBUG:ASSERT_NON_ZERO_DEFAULTS:-----------://
                #define LEN strlen
                #define  A  assert

                A( LEN( AAC2020_FRAGBED_loaded_001_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_002_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_003_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_004_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_005_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_006_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_007_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_008_ptr ) > 0 );
                A( LEN( AAC2020_FRAGBED_loaded_009_ptr ) > 0 );

                #undef  LEN
                #undef   A
                //:-----------:DEBUG:ASSERT_NON_ZERO_DEFAULTS://

            //: Missing sub namespace, but let's allow it    ://
            //: since the variable name is already a bit     ://
            //: too long for my tastes.                      ://
            AAC2020_all_default_shaders_malloc_copied=( 9 );

            #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
                INFO("[END:MALCOPY:DEFAULT_SHADERS]\n");
            #endif

        #undef COPY
        //:-------------------:LOAD_DEFAULT_SHADER_REFERENCES://
        //:LOAD_OVERRIDES_THEN_SAVE_ALL_TO_DISK:-------------://
        /** This is not the most efficient way to do it,     **/
        /** as it will often read a file from disk and then  **/
        /** immediately write that same file back to disk.   **/
        /** However, it is dead simple. And simple wins over **/
        /** efficiency. Computers will get faster over time. **/
        /** The code however, will stay just as confusing    **/
        /** over time. (Or get more confusing as you forget) **/

            //:HARD_DISK:LOAD_SHADER_OVERRIDES:--------------://

                /** Any FRAGBED_###.frag file on disk        **/
                /** will be de-serialized into RAM-memory.   **/

                #define LOD  AAC2020_FRAGBED_LoadFileIfExists

                    /** YES, 2nd param is DOUBLE_POINTER(**) **/
    
                        LOD( "MOD/SHADER_001_PAINT5D.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_001_ptr ));;

                        LOD( "MOD/SHADER_002_KEYPAD2.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_002_ptr ));;

                        LOD( "MOD/SHADER_003_KEYPAD3.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_003_ptr ));;

                        LOD( "MOD/SHADER_004_KEYPAD4.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_004_ptr ));;

                        LOD( "MOD/SHADER_005_KEYPAD5.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_005_ptr ));;

                        LOD( "MOD/SHADER_006_KEYPAD6.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_006_ptr ));;

                        LOD( "MOD/SHADER_007_KEYPAD7.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_007_ptr ));;

                        LOD( "MOD/SHADER_008_KEYPAD8.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_008_ptr ));;

                        LOD( "MOD/SHADER_009_KEYPAD9.FRAG"  ,
                      &(AAC2020_FRAGBED_loaded_009_ptr ));;

                #undef  LOD

            //:--------------:HARD_DISK:LOAD_SHADER_OVERRIDES://
            //:HARD_DISK:SAVE_ALL_SHADERS_IN_MEMORY:---------://

                /** ALL AAC2020_FRAGBED_loaded_### shaders   **/
                /** will be re-serialized to hard disk memory**/

                #define SAV  AAC2020_FRAGBED_SaveTextFileToDisk
    
                        SAV( "MOD/SHADER_001_PAINT5D.FRAG"  ,
                        AAC2020_FRAGBED_loaded_001_ptr  );;

                        SAV( "MOD/SHADER_002_KEYPAD2.FRAG"  ,
                        AAC2020_FRAGBED_loaded_002_ptr  );;

                        SAV( "MOD/SHADER_003_KEYPAD3.FRAG"  ,
                        AAC2020_FRAGBED_loaded_003_ptr  );;

                        SAV( "MOD/SHADER_004_KEYPAD4.FRAG"  ,
                        AAC2020_FRAGBED_loaded_004_ptr  );;

                        SAV( "MOD/SHADER_005_KEYPAD5.FRAG"  ,
                        AAC2020_FRAGBED_loaded_005_ptr  );;

                        SAV( "MOD/SHADER_006_KEYPAD6.FRAG"  ,
                        AAC2020_FRAGBED_loaded_006_ptr  );;

                        SAV( "MOD/SHADER_007_KEYPAD7.FRAG"  ,
                        AAC2020_FRAGBED_loaded_007_ptr  );;

                        SAV( "MOD/SHADER_008_KEYPAD8.FRAG"  ,
                        AAC2020_FRAGBED_loaded_008_ptr  );;

                        SAV( "MOD/SHADER_009_KEYPAD9.FRAG"  ,
                        AAC2020_FRAGBED_loaded_009_ptr  );;

                #undef  SAV


            //:---------:HARD_DISK:SAVE_ALL_SHADERS_IN_MEMORY://

        //:-------------:LOAD_OVERRIDES_THEN_SAVE_ALL_TO_DISK://

        AAC2020_FRAGBED_inited =( 1 );
        return( 0x00 );
    }

#undef  U32
#undef  INFO
//:=====================================================:INIT://