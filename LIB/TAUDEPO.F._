/** ******************************************************** ***

USAGE: PUT:

        AAC2020_TAUDEPO_Put( 
            AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
        ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
        ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
        ,   x0,x1,y0,y1
        );;

USAGE: GET:

        AAC2020_TAUDEPO_Get( 
            AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
        ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
        ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
        ,  &(x0),&(x1),&(y0),&(y1)
        );;

*** ******************************************************** **/
//:COM:======================================================://
#define I32  int32_t      /** GCC: <stdint.h> **/     //: 01 ://
#define U08  uint8_t      /** GCC: <stdint.h> **/     //: 02 ://

    I32
    aac2020_taudepo_pix_dex(
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO_TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO_PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO_P5D_VP0
    )
    {
        /** ************************************************ ***
        Use this as a template to write the GLSL equivalent.    
        This code reads+writes on the CPU side. We need a       
        version of this transcribed to GLSL to __read_only__    
        from the GPU side. ---------------------------------    
        *** ************************************************ **/

        I32 pix_dex=( 0 - 404 ); //:Return:Variable

        //:error_check_range_of_inputs:----------------------://

            assert( DEX_TAU_000_015 <=  15 );
            assert( DEX_SUB_000_015 <=  15 );
            
        /// assert( DEX_VAR_000_255 <= 255 );
            assert( sizeof( DEX_VAR_000_255 ) == 1 );

        //:----------------------:error_check_range_of_inputs://
        //:local_subcell_xy(s):------------------------------://

            //: dex_tau's cell location: SEE[ #DIA_TAU_CEL# ]
            I32 t_x =  DEX_TAU_000_015       %   4 ;
            I32 t_y = (DEX_TAU_000_015 - t_x)/   4 ;

            //: dex_sub's cell location: SEE[ #DIA_SUB_CEL# ]
            I32 s_x =  DEX_SUB_000_015       %   4 ;
            I32 s_y = (DEX_SUB_000_015 - s_x)/   4 ;

            //: dex_var's cell location: SEE[ #DIA_VAR_CEL# ]
            I32 v_x =  DEX_VAR_000_255       %  16 ;
            I32 v_y = (DEX_VAR_000_255 - v_x)/  16 ;

        //:------------------------------:local_subcell_xy(s)://
        //:check_our_math:-----------------------------------://
        #define ASS assert

            ASS( 512 / 4 == 128 ); //: 128x128_tau_cells 
            ASS( 128 / 4 ==  32 ); //: 032x032_sub_cells 
             
            ASS( 16 * 16 == 256 ); //:256 unique variables 
            ASS(  2 * 2  ==   4 ); //:  4 pixels per variable 
            ASS( 32 / 16 ==   2 ); //: 16 cells per sub-division    
            ASS( 32*32/256 == 4 ); //:  4_pixels_per_variable

        #undef  ASS
        //:-----------------------------------:check_our_math://
        //:global_pixel_xy_on_512x512:-----------------------://

            I32 p_x =( 0
            +  (t_x * (512 / 4) ) //: 128x128_tau_cells
            +  (s_x * (128 / 4) ) //: 032x032_sub_cells
            +  (v_x * (    2  ) ) //: 002x002 pixels per var
            );;                   //:(002x002:4_pixels_per_var)

            I32 p_y =( 0
            +  (t_y * (512 / 4) ) //: 128x128_tau_cells
            +  (s_y * (128 / 4) ) //: 032x032_sub_cells
            +  (v_y * (    2  ) ) //: 002x002 pixels per var 
            );;                   //:(002x002:4_pixels_per_var)

        //:-----------------------:global_pixel_xy_on_512x512://

                //:XY_TO_INDEX_FORMULA_FOR_TOP_LEFT_PIXEL
                //:OF_OUR_2X2_CLUSTER_OF_PIXELS_REPRESENTING
                //:A_SINGLE_VARIABLE.
                pix_dex = p_x + ( 512 * p_y);
        return( pix_dex );
    }

#undef  I32                                           //: 01 ://
#undef  U08                                           //: 02 ://
//:======================================================:COM://
//:PUT:======================================================://
#define PUT AAC2020_TAUDEPO_Put /** @TAU_PUT@ **/     //: 01 ://
#define I32  int32_t      /** GCC: <stdint.h> **/     //: 02 ://
#define U32 uint32_t      /** GCC: <stdint.h> **/     //: 03 ://
#define U08  uint8_t      /** GCC: <stdint.h> **/     //: 04 ://
#define PIX AAC2020_PIXNAME_taudepo_cpu_pix           //: 05 ://

    /** #_CONSISTENT_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_#**/

    U08
    AAC2020_TAUDEPO_Put( 
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO_TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO_PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO_P5D_VP0

    ,   U32 val_001 //:<-- Data Slot #1, offset index == 0
    ,   U32 val_002 //:<-- Data Slot #2, offset index == 1
    ,   U32 val_003 //:<-- Data Slot #3, offset index == 2
    ,   U32 val_004 //:<-- Data Slot #4, offset index == 3
    )
    {
        I32 pix_dex = aac2020_taudepo_pix_dex(
            DEX_TAU_000_015
        ,   DEX_SUB_000_015        
        ,   DEX_VAR_000_255    
        );;

        //:      |<-------COMPONENT_INDEX-------->|
        //:      |    |<----- PIXEL_INDEX ------->|
        I32 c_1 = 4 * ( ( pix_dex +   0  +   0 ) );  //:TOP_LEF
        I32 c_2 = 4 * ( ( pix_dex +   1  +   0 ) );  //:TOP_RIG
        I32 c_3 = 4 * ( ( pix_dex + 512  +   0 ) );  //:BOT_LEF
        I32 c_4 = 4 * ( ( pix_dex + 512  +   1 ) );  //:BOT_RIG

        PIX[ c_1 + 0 ]=(U08)( ( val_001 >> 24 ) && 0xFF );
        PIX[ c_1 + 1 ]=(U08)( ( val_001 >> 16 ) && 0xFF );
        PIX[ c_1 + 2 ]=(U08)( ( val_001 >>  8 ) && 0xFF );
        PIX[ c_1 + 3 ]=(U08)( ( val_001 >>  0 ) && 0xFF );

        PIX[ c_2 + 0 ]=(U08)( ( val_002 >> 24 ) && 0xFF );
        PIX[ c_2 + 1 ]=(U08)( ( val_002 >> 16 ) && 0xFF );
        PIX[ c_2 + 2 ]=(U08)( ( val_002 >>  8 ) && 0xFF );
        PIX[ c_2 + 3 ]=(U08)( ( val_002 >>  0 ) && 0xFF );

        PIX[ c_3 + 0 ]=(U08)( ( val_003 >> 24 ) && 0xFF );
        PIX[ c_3 + 1 ]=(U08)( ( val_003 >> 16 ) && 0xFF );
        PIX[ c_3 + 2 ]=(U08)( ( val_003 >>  8 ) && 0xFF );
        PIX[ c_3 + 3 ]=(U08)( ( val_003 >>  0 ) && 0xFF );

        PIX[ c_4 + 0 ]=(U08)( ( val_004 >> 24 ) && 0xFF );
        PIX[ c_4 + 1 ]=(U08)( ( val_004 >> 16 ) && 0xFF );
        PIX[ c_4 + 2 ]=(U08)( ( val_004 >>  8 ) && 0xFF );
        PIX[ c_4 + 3 ]=(U08)( ( val_004 >>  0 ) && 0xFF );

       
        AAC2020_TODOMAN_Maybe("[Return_Bitmask_OfChangedVars]");
        return( 0x00 );
    }

#undef  PUT                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  U08                                           //: 04 ://
#undef  PIX                                           //: 05 ://
//:======================================================:PUT://
//:GET:======================================================://
#define GET AAC2020_TAUDEPO_Get /** @TAU_GET@ **/     //: 01 ://
#define I32  int32_t      /** GCC: <stdint.h> **/     //: 02 ://
#define U32 uint32_t      /** GCC: <stdint.h> **/     //: 03 ://
#define U08  uint8_t      /** GCC: <stdint.h> **/     //: 04 ://
#define PIX AAC2020_PIXNAME_taudepo_cpu_pix           //: 05 ://

    /** #_CONSISTENT_SIGNATURES_TRUMP_PARANOID_ERROR_CHECKS_#**/

    void /** #_KEEP_TAUGET_VOID_TO_AVOID_CONFUSION_# **/
    AAC2020_TAUDEPO_Get( 
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO.TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO.PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO.P5D_VP0

        //:RETURN_VALUE_USING_UP_TO_FOUR_OUTPUT_PARAMETERS:
    ,   U32* val_001 //:<-- Data Slot #1, offset index == 0
    ,   U32* val_002 //:<-- Data Slot #1, offset index == 1
    ,   U32* val_003 //:<-- Data Slot #1, offset index == 2
    ,   U32* val_004 //:<-- Data Slot #1, offset index == 3
    )
    {
        I32 pix_dex = aac2020_taudepo_pix_dex(
            DEX_TAU_000_015
        ,   DEX_SUB_000_015        
        ,   DEX_VAR_000_255    
        );;

        //:      |<-------COMPONENT_INDEX-------->|
        //:      |    |<----- PIXEL_INDEX ------->|
        I32 c_1 = 4 * ( ( pix_dex +   0  +   0 ) );  //:TOP_LEF
        I32 c_2 = 4 * ( ( pix_dex +   1  +   0 ) );  //:TOP_RIG
        I32 c_3 = 4 * ( ( pix_dex +   0  + 512 ) );  //:BOT_LEF
        I32 c_4 = 4 * ( ( pix_dex +   1  + 512 ) );  //:BOT_RIG
        //:.........................| X |+| Y |..............://

        assert( sizeof( PIX ) == 1 /** 1 byte **/ );

        (*val_001)=( 0x00
        |   24 << PIX[ c_1 + 0 ]
        |   16 << PIX[ c_1 + 1 ]
        |    8 << PIX[ c_1 + 2 ]
        |    0 << PIX[ c_1 + 3 ]
        );;

        (*val_002)=( 0x00
        |   24 << PIX[ c_2 + 0 ]
        |   16 << PIX[ c_2 + 1 ]
        |    8 << PIX[ c_2 + 2 ]
        |    0 << PIX[ c_2 + 3 ]
        );;

        (*val_003)=( 0x00
        |   24 << PIX[ c_3 + 0 ]
        |   16 << PIX[ c_3 + 1 ]
        |    8 << PIX[ c_3 + 2 ]
        |    0 << PIX[ c_3 + 3 ]
        );;

        (*val_004)=( 0x00
        |   24 << PIX[ c_4 + 0 ]
        |   16 << PIX[ c_4 + 1 ]
        |    8 << PIX[ c_4 + 2 ]
        |    0 << PIX[ c_4 + 3 ]
        );;
    }

#undef  GET                                           //: 01 ://
#undef  I32                                           //: 02 ://
#undef  U32                                           //: 03 ://
#undef  U08                                           //: 04 ://
#undef  PIX                                           //: 05 ://
//:======================================================:GET://
//:LOGGING_AND_HALTING:======================================://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_taudepo_Info_any(
        const char* str_fmt
    ,   void*       poi_dat
    ){ if( AAC2020_SILENCE.TAUDEPO <= 0 ){
    
        printf("[AAC2020_TAUDEPO_Info_any]...\n");
        fflush(stdout);
        printf( str_fmt , poi_dat );
        printf("\n");
        fflush(stdout);

    };;}

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void 
    aac2020_taudepo_Halt( const char* msg_err ){
        printf("[AAC2020_TAUDEPO_Halt:msg_err]:%s\n",msg_err);
        fflush(stdout);
        exit( 123 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:======================================:LOGGING_AND_HALTING://
//:INIT:=====================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/
#define I32  int32_t /** GCC: <stdint.h> **/
#define DAT gpudata_taudepo
#define F_S( name ) AAC2020_PIXNAME_##name
#define CMP strcmp
#define LOG aac2020_taudepo_Info_any
#define ERR aac2020_taudepo_Halt
#define V_P void*
#define I64  int64_t

    U32
    AAC2020_TAUDEPO_Init( U32 u32 ){
        if( u32 ){ /** Reserved for future use **/ };

        /** When fragment shader changes (dex_edi) the    **/
        /** TAUDEPO must re-wire up it's texture samplers **/
        /** to the new shader program. This is the reason **/
        /** for the INITED_WITH variable below.           **/
        AAC2020_TAUDEPO_dex_edi_INITED_WITH=( 
        AAC2020_CEDITOR_dex_edi              );;



        LOG("\t\t[NOTE:taudepo_texture_init_here...]\n"
            "\t\t[NOTE::::::GPUDATA_InitInstanceAll]\n" , 0 );

        AAC2020_TODOMAN_Vital("[THIS_SHOULD_RE_INIT_EVERY_TIME_WE_SWITCH_EDITORS]");

        //:LOAD_INITIAL_TEXTURE_DATA:------------------------://


            /** #_TODOS_CAN_BREAK_COLUMN_LIMIT_# **/
            /** For now just load a test pattern to confirm we    * * * * * **/
            /** have data. But once that is done, we will want to * * * * * **/
            /** load from a save file on disk on startup.         * * * * * **/
            AAC2020_VITAL_TODO("[Eventually_This_Should_Load_Save_File_Data]");



            struct AAC2020_GPUDATA gpudata_taudepo ={ 0 };


            if( CMP( &(F_S( taudepo )[0]) ,"taudepo" )!= 0 ){
                aac2020_taudepo_Halt("[TAU_BAD_NAME_2020]");
            };;


            //: FILE_SCOPE(  F_S  ) --> TEMP_STRUCT(  DAT  );
            DAT.tex_lot =    F_S( taudepo_tex_lot          );
            DAT.tex_han =    F_S( taudepo_tex_han          ); 
            DAT.sam_loc =    F_S( taudepo_tex_sam.sam_loc  );
            DAT.sam_val =    F_S( taudepo_tex_sam.sam_val  );
            DAT.sam_has =    F_S( taudepo_tex_sam_HAS      );
            DAT.pix_wid =  ( 512                           );
            DAT.pix_hig =  ( 512                           );
            DAT.pix_nam = &( F_S( taudepo )[0]             );

            DAT.cpu_pix =&( 
                AAC2020_PIXNAME_taudepo_cpu_pix[0] 
            );;

            //:Upload Texture As Is. Do not put any test
            //:patterns on it, that will corrupt your 
            //:texture_as_uniform values.
            AAC2020_PIXLOAD_UploadTexture( &( DAT ) );
            
            //:get_taudepo_sampler_location:-----------------://
            #define HAS_CHK AAC2020_PIXLOAD_HasSampler

                //:#_GPUDATA_INPUT_OBJECT_IS_OUTPUT_OBJECT_#://
                AAC2020_PIXLOAD_sam_has    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_loc    ( &( DAT ) );
                AAC2020_PIXLOAD_sam_val_PUT( &( DAT ) );

                if( DAT.sam_has >= 1 && DAT.sam_loc <=(0 - 1) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:001]");
                }else 
                if( DAT.sam_has <= 0 && DAT.sam_loc >=(  0  ) ){
                    ERR("[FULL_OF_LIES:@VDAWEA@:002]");
                };;

                /** Keep the error prone way of doing this   **/
                /** As a redundancy to check for agreement.  **/

                I32 has = HAS_CHK( "taudepo" );
                if( DAT.sam_has != has ){ ERR("[WTF:0433AM]");};

                LOG( "[DAT.sam_loc]:%d\n" , (V_P)(I64)DAT.sam_loc );
                LOG( "[DAT.sam_val]:%d\n" , (V_P)(I64)DAT.sam_val );

            #undef  HAS_CHK
            //:-----------------:get_taudepo_sampler_location://

            if( has >= 1 ){

                /** Update Texture Sampler Uniform On GPU **/

                aac2020_pixload_PushSampler(  &( DAT ) );

                /** Persist Changes: **/

                //: TEMP_STRUCT(  DAT  ) --> FILE_SCOPE(  F_S  )
                F_S( taudepo_tex_lot         ) = DAT.tex_lot ;
                F_S( taudepo_tex_han         ) = DAT.tex_han ;
                F_S( taudepo_tex_sam.sam_loc ) = DAT.sam_loc ;
                F_S( taudepo_tex_sam.sam_val ) = DAT.sam_val ;
                F_S( taudepo_tex_sam_HAS     ) = DAT.sam_has ;
                //:                    ( 512 ) = DAT.pix_wid ://
                //:                    ( 512 ) = DAT.pix_hig ://
                //:                 "taudepo" ~=~DAT.pix_nam ://
    
                LOG("[HAS_TEXTURE_SAMPLER]",((void*)0));
            }else{

                /** Whether this is a good or bad message **/
                /** depends on you looking at code and    **/
                /** deciding.                             **/
                LOG("[NO_TEXTURE_SAMPLER:TAUDEPO]",((void*)0));
    
            };;
           
        
        //:------------------------:LOAD_INITIAL_TEXTURE_DATA://

        return( 0x00 );
    }

#undef  U32
#undef  I32
#undef  DAT
#undef  F_S
#undef  CMP
#undef  LOG 
#undef  ERR 
#undef  V_P
#undef  I64
//:=====================================================:INIT://
//:LOOP_TICK:================================================://
#define LOG aac2020_taudepo_Info_any
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_TAUDEPO_LoopTick( U32 u32 ){
        if( u32 ){ /** reserved for future use **/ };

        /** ************************************************ **/
        /** Part of SPRINT#003. Video: IID:0041              **/
        /**             Recorded Date: 2020_12_13            **/
        /**             @2 hours 55 minutes                  **/
        /**                                                  **/
        /** Every time we switch editors a new fragment      **/
        /** shader is loaded (used as rendering code)        **/
        /** (for active editor). And we need to re-wire      **/
        /** the TAUDEPO texture sampler. Thus RE-INIT.       **/
        /** ************************************************ **/

        if( AAC2020_TAUDEPO_dex_edi_INITED_WITH
        !=  AAC2020_CEDITOR_dex_edi
        ){
            LOG("[RE_INITING_TAUDEPO]",((void*)0));

            AAC2020_TAUDEPO_Init( 0x00 );
        };;

        return( 0x00 );
    }

#undef  LOG 
#undef  U32 
//:================================================:LOOP_TICK://