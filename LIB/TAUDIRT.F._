//: 1234567
//: TAUDIRT.F._ : DATA ONLY LIBRARY

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_taudirt_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:aac2020_taudirt]:%s\n", msg_err );
        fflush(stdout);
        exit( 586 /** Sterling Heights Area Code **/ );
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://

    void
    aac2020_taudirt_Info_any(
        const char* str_fmt
    ,   void*       dat_any  /** Optional Data **/
    )
    { if( AAC2020_SILENCE.TAUDIRT <= 0 ){

        /** Same Line As Next Printf **/
        printf("[taudirt_log]....(   " ); fflush( stdout );
        printf( str_fmt , dat_any      ); fflush( stdout );
        printf(               "   )\n" ); fflush( stdout );

    };; }

//:===========================================:LOG_AFTER_HALT://
//:MIN_MAX_HELPER:===========================================://
#define U08 uint8_t /** GCC: <stdint.h> **/

    U08
    AAC2020_TAUDIRT_Min( U08 bou_old , U08 bou_new ){
        U08     bou_min ;
            if(              bou_old <     bou_new ){ 
                bou_min =    bou_old ;     
            };;                                                        
            if(              bou_new <     bou_old ){ 
                bou_min =    bou_new ;
            };;
        return( bou_min );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U08
    AAC2020_TAUDIRT_Max( U08 bou_old , U08 bou_new ){
        U08     bou_max ;
            if(              bou_old >     bou_new ){ 
                bou_max =    bou_old ;     
            };;                                            
            if(              bou_new >     bou_old ){ 
                bou_max =    bou_new ;
            };;
        return( bou_max );
    }

 #undef  U08
//:===========================================:MIN_MAX_HELPER://
//:INIT_NONE:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_TAUDIRT_InitNone( U32 u32 ){
        if( u32 ){ /** reserved for future use **/ };

        extern U32 AAC2020_TAUDIRT_UnitTest( U32 u32 );
                   AAC2020_TAUDIRT_UnitTest( 0x00 );

        return( 0x00 );
    }

#undef  U32
//:================================================:INIT_NONE://
//:MAIN_LOGIC:DOTADIW:=======================================://
#define     I32 int32_t /** GCC: <stdint.h> **/       //: 01 ://
#define     U08 uint8_t /** GCC: <stdint.h> **/       //: 02 ://
#define     REC struct AAC2020_TAUDIRT_rec_inc        //: 03 ://
                                                      //: -- ://
#define TAU_015 DEX_TAU_000_015                       //: 04 ://
#define SUB_015 DEX_SUB_000_015                       //: 05 ://
#define VAR_255 DEX_VAR_000_255                       //: 06 ://
                                                      //: -- ://
#define     X_x AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512 //: 07 ://
#define     u_U AAC2020_TAUDIRT_l_B_04x04_SUB_Pix_128 //: 08 ://
#define     O_o AAC2020_TAUDIRT_l_C_16x16_VAR_Pix_032 //: 09 ://

    void
    aac2020_taudirt_DirtySectorUpdate(
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO_TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO_PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO_P5D_VP0
    )
    {
        /** hackish debugging **/
        aac2020_taudirt_DirtySectorUpdate_call_times++;

        //:Declare:Cell_XY_Tiles:----------------------------://

            U08 x_A; //: @LEVEL_A( l_A )@ 
            U08 y_A; //: AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512

            U08 x_B; //: @LEVEL_B( l_B )@
            U08 y_B; //: AAC2020_TAUDIRT_l_B_04x04_SUB_Pix_128

            U08 x_C; //: @LEVEL_C( l_C )@
            U08 y_C; //: AAC2020_TAUDIRT_l_C_16x16_VAR_Pix_032

        //:----------------------------:Declare:Cell_XY_Tiles://
        //:Get_Dirty:Cell_XY_Tiles:--------------------------://
        
            /** 512x512 pixels, 004x004 (016) cells **/
        
            x_A  =  TAU_015       %   4 ;   //: @LEVEL_A( l_A )@ 
            y_A  = (TAU_015 - x_A)/   4 ;   //: @LEVEL_A( l_A )@ 
        
            /** 128x128 pixels, 004x004 (016) cells. **/
        
            x_B  =  SUB_015       %   4 ;   //: @LEVEL_B( l_B )@
            y_B  = (SUB_015 - x_B)/   4 ;   //: @LEVEL_B( l_B )@
        
            /** 032x032 pixels, 016x016 (256) cells **/
        
            x_C  =  VAR_255       %  16 ;   //: @LEVEL_C( l_C )@
            y_C  = (VAR_255 - x_C)/  16 ;   //: @LEVEL_C( l_C )@
        
        //:--------------------------:Get_Dirty:Cell_XY_Tiles://
        //:Dirty_Rect_Optimization:--------------------------://
        #define  A          AAC2020_TAUDIRT_DIR_ANY
        #define  T          DEX_TAU_000_015
        #define  S          DEX_SUB_000_015
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define  REC_512  ( A                      .rec_512    )
        #define  REC_128  ( A.cel_512[T]           .rec_128    )
        #define  REC_032  ( A.cel_512[T].cel_128[S].rec_032    )
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define  DIRTY_0  ( A                      .is_dirty_0 )
        #define  DIRTY_1  ( A.cel_512[T]           .is_dirty_1 )
        #define  DIRTY_2  ( A.cel_512[T].cel_128[S].is_dirty_2 )
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

            //:Expand_Dirty_Rect_Selections:-----------------://
            #define MIN AAC2020_TAUDIRT_Min           //: 01 ://
            #define MAX AAC2020_TAUDIRT_Max           //: 02 ://

                /** >= 1 : REC is @VALID, use MIN+MAX   **/
                /** <= 0 : REC is @@JUNK, re-initialize **/

            //: #DIA_TAU_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_0 >= 1  ){ //: @VALID

                    REC_512.x_0 = MIN( REC_512.x_0 , x_A );
                    REC_512.x_1 = MAX( REC_512.x_1 , x_A );

                    REC_512.y_0 = MIN( REC_512.y_0 , y_A );
                    REC_512.y_1 = MAX( REC_512.y_1 , y_A );

                }else if( DIRTY_0 <= 0 ){ //:  @@JUNK

                    REC_512.x_0 =    (               x_A );
                    REC_512.x_1 =    (               x_A );
                                                 
                    REC_512.y_0 =    (               y_A );
                    REC_512.y_1 =    (               y_A );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_512]"); };

            //: #DIA_SUB_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_1 >= 1  ){ //: @VALID

                    REC_128.x_0 = MIN( REC_128.x_0 , x_B );
                    REC_128.x_1 = MAX( REC_128.x_1 , x_B );

                    REC_128.y_0 = MIN( REC_128.y_0 , y_B );
                    REC_128.y_1 = MAX( REC_128.y_1 , y_B );

                }else if( DIRTY_1 <= 0 ){ //:  @@JUNK

                    REC_128.x_0 =    (               x_B );
                    REC_128.x_1 =    (               x_B );
                                                 
                    REC_128.y_0 =    (               y_B );
                    REC_128.y_1 =    (               y_B );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_128]"); };

            //: #DIA_VAR_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_2 >= 1  ){ //: @VALID

                    REC_032.x_0 = MIN( REC_032.x_0 , x_C );
                    REC_032.x_1 = MAX( REC_032.x_1 , x_C );

                    REC_032.y_0 = MIN( REC_032.y_0 , y_C );
                    REC_032.y_1 = MAX( REC_032.y_1 , y_C );

                }else if( DIRTY_2 <= 0 ){ //:  @@JUNK

                    REC_032.x_0 =    (               x_C );
                    REC_032.x_1 =    (               x_C );
                                                 
                    REC_032.y_0 =    (               y_C );
                    REC_032.y_1 =    (               y_C );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_032]"); };

            #undef  MIN                               //: 01 ://
            #undef  MAX                               //: 02 ://
            //:-----------------:Expand_Dirty_Rect_Selections://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef        A                               //: 01 ://
        #undef        S                               //: 02 ://
        #undef        T                               //: 03 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  REC_512                               //: 04 ://
        #undef  REC_128                               //: 05 ://
        #undef  REC_032                               //: 06 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  DIRTY_0                               //: 07 ://
        #undef  DIRTY_1                               //: 08 ://
        #undef  DIRTY_2                               //: 09 ://
        //:--------------------------:Dirty_Rect_Optimization://
        //:Declare_Sub_Cells:--------------------------------://
        #define          TYP( nam ) struct AAC2020_TAUDIRT_##nam
        #define CEL_512  TYP( l_B_04x04_SUB_Pix_128 )
        #define CEL_128  TYP( l_C_16x16_VAR_Pix_032 )
        #define CEL_032  U08   

            CEL_512* cel_512=((void*)0);  /**  @cel_512@   **/
            CEL_128* cel_128=((void*)0);  /**  @cel_128@   **/
            CEL_032* cel_032=((void*)0);  /**  @cel_032@   **/

        #undef TYP                                    //: 01 ://
        #undef CEL_512                                //: 02 ://
        #undef CEL_128                                //: 03 ://
        #undef CEL_032                                //: 04 ://
        //:--------------------------------:Declare_Sub_Cells://
        //:Assign_Sub_Cells:---------------------------------://
        #define ANY AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 01 :*/
        #define l_A AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 02 :*/
        #define l_B cel_512                 /* 1 deep   : 03 :*/
        #define l_C cel_128                 /* 2 deep   : 04 :*/

            cel_512 = &( l_A  . cel_512[ TAU_015 ] );
            cel_128 = &( l_B -> cel_128[ SUB_015 ] );
            cel_032 = &( l_C -> cel_032[ VAR_255 ] );

            #define  T  TAU_015 //: 01 ://
            #define  S  SUB_015 //: 02 ://
            #define  V  VAR_255 //: 03 ://
            #define C0  cel_512 //: 04 ://
            #define C1  cel_128 //: 05 ://
            #define C2  cel_032 //: 06 ://

            assert( cel_512 ==&( ANY.C0[ T ]                 ));
            assert( cel_128 ==&( ANY.C0[ T ].C1[ S ]         ));
            assert( cel_032 ==&( ANY.C0[ T ].C1[ S ].C2[ V ] ));
        
            #undef   T          //: 01 ://
            #undef   S          //: 02 ://
            #undef   V          //: 03 ://
            #undef  C0          //: 04 ://
            #undef  C1          //: 05 ://
            #undef  C2          //: 06 ://
              
        #undef  ANY                                   //: 01 ://
        #undef  l_A                                   //: 02 ://
        #undef  l_B                                   //: 03 ://
        #undef  l_C                                   //: 04 ://
        //:---------------------------------:Assign_Sub_Cells://
        //:General_Dirty_Flags:------------------------------://
        #define ANY AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 01 :*/
        #define l_A AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 02 :*/
        #define l_B  (        cel_512   )   /* 1 deep   : 03 :*/
        #define l_C  (        cel_128   )   /* 2 deep   : 04 :*/
        U08*    l_D  = l_C -> cel_032   ;   /* 3 deep   : 05 :*/
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define   A  assert                           //: 01 ://
        #define   T TAU_015                           //: 02 ://
        #define   S SUB_015                           //: 03 ://
                                                      //: -- ://
        #define C_0 cel_512                           //: 04 ://
        #define C_1 cel_128                           //: 05 ://
        #define C_2 cel_032                           //: 06 ://

            A( &(l_A) == &( ANY                          )   );                   
            A(   l_B  == &( ANY.C_0[ T ]                 )   );          
            A(   l_C  == &( ANY.C_0[ T ].C_1[ S ]        )   );
            A(   l_D  == &( ANY.C_0[ T ].C_1[ S ].C_2[0] )   );

        #undef    A                                   //: 01 ://
        #undef    T                                   //: 02 ://
        #undef    S                                   //: 03 ://
                                                      //: -- ://
        #undef  C_0                                   //: 04 ://
        #undef  C_1                                   //: 05 ://
        #undef  C_2                                   //: 06 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define IS_DIRTY_3   VAR_255 //:*********************://

            l_A  . is_dirty_0  =( 1 ); /** NESTING_LEVEL : 0 **/
            l_B -> is_dirty_1  =( 1 ); /** NESTING_LEVEL : 1 **/
            l_C -> is_dirty_2  =( 1 ); /** NESTING_LEVEL : 2 **/
            l_D[   IS_DIRTY_3 ]=( 1 ); /** NESTING_LEVEL : 3 **/

            //:Check_Your_Pointer_Logic:---------------------://
            #define A assert //:-----------------------------://

                /** Cross Check Memory Addresses.            **/
                /** ( Look up SAME addresses in a DIFFERENT )**/
                /** ( way to check your LOOKUP logic.       )**/

                    A( &(     l_A  . is_dirty_0 )
                    == &(     ANY  . is_dirty_0 ) );

                    A( &(     l_B -> is_dirty_1 )
                    == &( cel_512 -> is_dirty_1 ) );

                    A( &(     l_C -> is_dirty_2   ) 
                    == &( cel_128 -> is_dirty_2 ) );;

                    A( &(     l_D[   IS_DIRTY_3 ] )==cel_032 );

            #undef  A //:------------------------------------://
            //:---------------------:Check_Your_Pointer_Logic://

        #undef  IS_DIRTY_3 //:*******************************://

        #undef  ANY                                   //: 01 ://
        #undef  l_A                                   //: 02 ://
        #undef  l_B                                   //: 03 ://
        #undef  l_C                                   //: 04 ://
    //: @undef  l_D                                   //: 05 ://
        //:------------------------------:General_Dirty_Flags://
    }

    #ifdef  A  
        #error "[FORGOT_TO_UNDEFINE_A:2020]"
    #endif

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://
//: BELOW: Complimentary function for testing.               ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

    I32 /** PRIVATE FUNCTION **/
    aac2020_taudirt_DirtySectorAsk(
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO_TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO_PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO_P5D_VP0

        /** Private Debugging Rectangle Output Parameter **/

    ,   struct aac2020_taudirt_rec_bug* rec  

    )
    {
        /** #_DIRTY_SECTOR_ASK_IS_A_BIT_MUCH_BUT_HELPFUL_# **/

        I32 rof=( 0 /** result_of_function **/ );

        /** ************************************************ ***
        //( @VID_IID@[ 0045 ]TIME[ 6H21M30S     )//  
        //( @VID_URL@[ TODO_YOUTUBE_VIDEO_URL ] )//

        3 Possible States:

            1. VAR == CLEAN , VAR  OUTSIDE_DIRTY_RECT ==>  0
            2. VAR == CLEAN , VAR  INSIDE__DIRTY_RECT ==> -1
            3. VAR == DIRTY , VAR  INSIDE__DIRTY_RECT ==> +1

        1  Invalid/Impossible State:

            4. VAR == DIRTY , VAR OUTSIDE_DIRTY_RECT

        Dirty Rectangle Returns ABSOLUTE coords inside:

            AAC2020_PIXNAME_taudepo_cpu_pix

        *** ************************************************ **/

        /** Is the datapoint itself dirty ? - - - - - - - - -**/

            U08 data_point_dirty=(
            AAC2020_TAUDIRT_DIR_ANY
                .cel_512[ TAU_015 ]
                .cel_128[ SUB_015 ]
                .cel_032[ VAR_255 ] );;

        /** Deepest Dirty Rectangle - - - - - - - - - - - - -**/

            struct AAC2020_TAUDIRT_rec_inc*
            rec_032=&(
               AAC2020_TAUDIRT_DIR_ANY
                .cel_512[ TAU_015 ]
                .cel_128[ SUB_015 ]
                .rec_032            );;

        //:Convert_Indexes_To_XY_Cell_Locations:-------------://

            /**  TAUDEPO.D._ : #DIA_TAU_CEL# is  4x4  cells  **/

            I32 t_x =  DEX_TAU_000_015       % 4 ;
            I32 t_y = (DEX_TAU_000_015 - t_x)/ 4 ;

            /**  TAUDEPO.D._ : #DIA_SUB_CEL# is  4x4  cells  **/

            I32 s_x =  DEX_SUB_000_015       % 4 ;
            I32 s_y = (DEX_SUB_000_015 - s_x)/ 4 ;

            /**  TAUDEPO.D._ : #DIA_VAR_CEL# is 16x16 cells  **/

            I32 v_x =  DEX_VAR_000_255       % 16 ;
            I32 v_y = (DEX_VAR_000_255 - v_x)/ 16 ;

                //:check_our_math:---------------------------://

                    if( 0 == DEX_TAU_000_015
                    &&  0 == DEX_SUB_000_015
                    &&  0 == DEX_VAR_000_255
                    ){
                    
                        assert( 0 == t_x );
                        assert( 0 == t_y );
                        assert( 0 == s_x );
                        assert( 0 == s_y );
                        assert( 0 == v_x );
                        assert( 0 == v_y );

                    };;

                //:---------------------------:check_our_math://

        //:-------------:Convert_Indexes_To_XY_Cell_Locations://
        //:Calculate_ABSOLUTE_dirty_rectangle:---------------://

            I32 x_b =( 0 /** xyb: XY base value **/
            +   ( t_x*128 ) /** Each cell 128x128 pixels **/
            +   ( s_x* 32 ) /** Each cell  32x32  pixels **/
            );;
            I32 y_b =( 0 /** xyb: XY base value **/
            +   ( t_y*128 ) /** Each cell 128x128 pixels **/
            +   ( s_y* 32 ) /** Each cell  32x32  pixels **/
            );;

            /** ******************************************** **/
            /** #_PAIRED_COMMENT_2020_12_16_0439PM_#         **/
            /** IF_YOU_SEE: 400 , 201 , 100 , 51             **/
            /** For rectangle output, you are using the      **/
            /** TRAP values and you shouldn't do that.       **/
            /** ******************************************** **/

            //: @VID_IID@[ 0045 ]TIME[ 7H 19M 49S ] ://
            AAC2020_TODOMAN_Vital( "[return_negative_rect_if_dirty_rect_is_invalid]");

            (*rec).x_0 = ( x_b + (rec_032 -> x_0*2) ) + 0;
            (*rec).x_1 = ( x_b + (rec_032 -> x_1*2) ) + 1;
            (*rec).y_0 = ( y_b + (rec_032 -> y_0*2) ) + 0;
            (*rec).y_1 = ( y_b + (rec_032 -> y_1*2) ) + 1;

        //:---------------:Calculate_ABSOLUTE_dirty_rectangle://
        //:Calculate_ABSOLUTE_var_pixel_XY:------------------://
        #define A (128) /**  @cel_512@ is 128x128 pixels     **/
        #define B ( 32) /**  @cel_128@ is  32x32  pixels     **/
        #define C (  2) /**  @cel_032@ is   2x2   pixels     **/

            I32 x_v =( 0 /** xyv: XY base value : VARIABLE   **/
            +   ( t_x*128 ) /** Each cell 128x128 pixels     **/
            +   ( s_x* 32 ) /** Each cell  32x32  pixels     **/
            +   ( v_x*  2 ) /** Each  VAR   2x2   pixels     **/
            );;
            I32 y_v =( 0 /** xyv: XY base value : VARIABLE   **/
            +   ( t_y*128 ) /** Each cell 128x128 pixels     **/
            +   ( s_y* 32 ) /** Each cell  32x32  pixels     **/
            +   ( v_y*  2 ) /** Each  VAR   2x2   pixels     **/
            );;

            assert( t_x >= 0 && t_x <= (  4-1) );
            assert( s_x >= 0 && s_x <= (  4-1) );
            assert( v_x >= 0 && v_x <= ( 16-1) );

            assert( t_y >= 0 && t_y <= (  4-1) );
            assert( s_y >= 0 && s_y <= (  4-1) );
            assert( v_y >= 0 && v_y <= ( 16-1) );

            /** Check Our Math. +1 because [x_v,y_v] is      **/
            /** absolute orign location of a 2x2 pixel cell  **/
            /** on the 512x512 [bitmap/texture]              **/
            assert( (4-1)*128+(4-1)*32+(16-1)*2+1==(512-1) );
            assert( (4-1)*  A+(4-1)* B+(16-1)*C+1==(512-1) );
        
        #undef A
        #undef B
        #undef C
        //:------------------:Calculate_ABSOLUTE_var_pixel_XY://
        //:Error_Check_Bounds:-------------------------------://

            /** We expect the entire 2x2 pixel region that   **/
            /** stores a variable to either be 100% inside   **/
            /** or 100% outside the dirty rectangle.         **/

            I32 in_bounds_check_TOP = ( 0 );
            I32 in_bounds_check_BOT = ( 0 );

            if( (x_v + 1 ) >= (*rec).x_0    //:  +---+---+   ://
            &&  (x_v + 1 ) <= (*rec).x_1    //:  |   |   |   ://
            &&  (y_v + 1 ) >= (*rec).y_0    //:  +---+---+   ://
            &&  (y_v + 1 ) <= (*rec).y_1    //:  |   |BOT|   ://
            ){                              //:  +---+---+   ://
                in_bounds_check_BOT=( 1 );  //:              ://
            };;                             //:  @cel_032@   ://
                                            //:              ://
            if( (x_v + 0 ) >= (*rec).x_0    //:  +---+---+   ://
            &&  (x_v + 0 ) <= (*rec).x_1    //:  |TOP|   |   ://
            &&  (y_v + 0 ) >= (*rec).y_0    //:  +---+---+   ://
            &&  (y_v + 0 ) <= (*rec).y_1    //:  |   |   |   ://
            ){                              //:  +---+---+   ://
                in_bounds_check_TOP=( 1 );
            };;

            if( in_bounds_check_BOT != in_bounds_check_TOP ){

                aac2020_taudirt_Halt("[BAD_DIRTY_RECT:2020]");

            };;

            /**  My way of saying, the choice is arbitrary **/
            /**  while maintaining symmetry in the code    **/

            I32 in_bounds_check=(
                in_bounds_check_TOP
            +   in_bounds_check_BOT
            );;

        //:-------------------------------:Error_Check_Bounds://
        //:Decide_What_To_Return:----------------------------://

            /** ******************************************** ***
            1. VAR == CLEAN , VAR  OUTSIDE_DIRTY_RECT ==>  0
            2. VAR == CLEAN , VAR  INSIDE__DIRTY_RECT ==> -1
            3. VAR == DIRTY , VAR  INSIDE__DIRTY_RECT ==> +1
            *** ******************************************** **/

            I32 OUTSIDE_DIRTY_RECT = ( in_bounds_check  <= 0 );
            I32 INSIDE__DIRTY_RECT = ( in_bounds_check  >= 1 );
            I32 CLEAN              = ( data_point_dirty == 0 );
            I32 DIRTY              = ( data_point_dirty  > 0 );

            assert( CLEAN != DIRTY );

            rof=( 404 );
            if( CLEAN && OUTSIDE_DIRTY_RECT ){ rof =( 0    ); };
            if( CLEAN && INSIDE__DIRTY_RECT ){ rof =( 0 -1 ); };
            if( DIRTY && INSIDE__DIRTY_RECT ){ rof =( 0 +1 ); };

            if( 404 == rof ){
                aac2020_taudirt_Halt("[INVALID_CASE:ROF:404]");
            };;

        //:----------------------------:Decide_What_To_Return://
        //:Error_Check_Mass_Flags:---------------------------://

            /** ******************************************** **/
            /** If the datapoint itself is dirty, then all   **/
            /** flags that lead up to this dirty datapoint   **/
            /** should also be flagged as dirty.             **/
            /**                                              **/
            /** If this is NOT the case, we don't have       **/
            /** a proper QUAD_LIKE-tree                      **/
            /** ******************************************** **/

            if( data_point_dirty ){

                U08 l_0=(
                AAC2020_TAUDIRT_DIR_ANY    .is_dirty_0     );;
                U08 l_1=(
                AAC2020_TAUDIRT_DIR_ANY
                    .cel_512[ TAU_015 ]    .is_dirty_1     );;
                U08 l_2=(
                AAC2020_TAUDIRT_DIR_ANY
                    .cel_512[ TAU_015 ]
                    .cel_128[ SUB_015 ]    .is_dirty_2     );;
                U08 l_3=(
                AAC2020_TAUDIRT_DIR_ANY
                    .cel_512[ TAU_015 ]
                    .cel_128[ SUB_015 ]
                    .cel_032[ VAR_255 ] /**.is_dirty_3 **/ );;

                if( l_0<= 0 || l_1<= 0 || l_2<= 0 || l_3<= 0 ){

                    aac2020_taudirt_Halt(
                        "[all_flags_to_data_should_be_dirty]"
                    );;

                };;
            };;

        //:---------------------------:Error_Check_Mass_Flags://

        return( rof /** result_of_function **/ );

    }

                 
#undef      I32                                       //: 01 ://                                   
#undef      U08                                       //: 02 ://
#undef      REC                                       //: 03 ://
                                                      //: -- ://
#undef  TAU_015                                       //: 04 ://
#undef  SUB_015                                       //: 05 ://
#undef  VAR_255                                       //: 06 ://
                                                      //: -- ://
#undef      X_x                                       //: 07 ://
#undef      u_U                                       //: 08 ://
#undef      O_o                                       //: 09 ://
//:=======================================:MAIN_LOGIC:DOTADIW://
//:FORCE_CLEAR_FOR_UNIT_TEST:================================://
#define ANY AAC2020_TAUDIRT_DIR_ANY
#define C_R aac2020_taudirt_ClearRect
#define I32 int32_t /** GCC: <stdint.h> **/

    void
    aac2020_taudirt_ClearRect(
        struct AAC2020_TAUDIRT_rec_inc * rec_inc
                                     /** rec_512  <-- Inputs **/
                                     /** rec_128  <-- Inputs **/
                                     /** rec_032  <-- Inputs **/
    )
    {
        /** Since rectangle is signed, we will clear it  **/
        /** by giving it out of bound trap values.       **/

        rec_inc -> x_0 =( 200  /** @TRAP_VALUE@ **/ );
        rec_inc -> x_1 =( 100  /** @TRAP_VALUE@ **/ );
        rec_inc -> y_0 =(  50  /** @TRAP_VALUE@ **/ );
        rec_inc -> y_1 =(  25  /** @TRAP_VALUE@ **/ );

        /** #_PAIRED_COMMENT_2020_12_16_0439PM_#             **/
        /** KEEP_TRAP_VALUES[ 200,100,50,25 ] Otherwise      **/
        /** commentary we are paired with is no longer valid.**/

        /** ************************************************ ***
            Anything greater than 15 is out of range 
            so we should use a more unique value than
            "0xFF" maybe... 0x77 ( decimal: 119 )

            #DIA_TAU_CEL# : xy_range[ 0 -to- ( 4  - 1 ) ]  
            #DIA_SUB_CEL# : xy_range[ 0 -to- ( 4  - 1 ) ]  
            #DIA_VAR_CEL# : xy_range[ 0 -to- ( 16 - 1 ) ]  

        *** ************************************************ **/
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_taudirt_ForceClearForUnitTest( void )
    {
        /** FUNCTION_SUMMARY: FoceClearForUnitTest:  **/
        /** Only to be used BEFORE and after calling **/
        /** Unit test so that we can make sure we    **/
        /** are working with predictable state and   **/
        /** restoring to zeroed-out state after      **/
        /** mucking around with the data with our    **/
        /** tests. --------------------------------- **/

        //:ERASE_THE_ACTUAL_BUFFER_AS_WELL:------------------://

            for( I32 dex = 0; dex <= ((512*512*4)-1) ; dex++ ){
                AAC2020_PIXNAME_taudepo_cpu_pix[ dex ]=(0x00);
            };;

        //:------------------:ERASE_THE_ACTUAL_BUFFER_AS_WELL://
        //:NON_RECURSIVELY_TRAVERSE_TREE:--------------------://
        #define D_0 "MAKE_PATTERN_OBVIOUS"            //: 01 ://
        #define D_1  ANY.cel_512[ d_1 ]               //: 02 ://
        #define D_2      cel_128[ d_2 ]               //: 03 ://
        #define D_3      cel_032[ d_3 ]               //: 04 ://

            I32 d_0; I32 d_1; I32 d_2; I32 d_3;
        
            for( d_0 = 0 ; d_0 <=   0 ; d_0 ++ ){ //:@NES_LEV@:0

                        ANY.is_dirty_0 = ( 0 );
                C_R( &( ANY.rec_512         ));

            for( d_1 = 0 ; d_1 <=  15 ; d_1 ++ ){ //:@NES_LEV@:1

                        D_1.is_dirty_1 =( 0 );
                C_R( &( D_1.rec_128        ));

            for( d_2 = 0 ; d_2 <=  15 ; d_2 ++ ){ //:@NES_LEV@:2

                        D_1.D_2.is_dirty_2 =( 0 );
                C_R( &( D_1.D_2.rec_032        ));

            for( d_3 = 0 ; d_3 <= 255 ; d_3 ++ ){ //:@NES_LEV@:3

                        /** is_dirty_3 , conceptually **/

                        D_1.D_2.D_3 = ( 0x00 );

            };; };; };; };; //:  @NON_INDENTED_LOOP_LEVELS@  ://

        #undef  D_0                                   //: 01 ://
        #undef  D_1                                   //: 02 ://
        #undef  D_2                                   //: 03 ://
        #undef  D_3                                   //: 04 ://
        //:--------------------:NON_RECURSIVELY_TRAVERSE_TREE://

    }

#undef  ANY
#undef  C_R
#undef  I32
//:================================:FORCE_CLEAR_FOR_UNIT_TEST://
//:UNIT_TEST:================================================://
#define I32  int32_t /** GCC: <stdint.h> **/              /*01*/
#define U32 uint32_t /** GCC: <stdint.h> **/              /*02*/
#define U08  uint8_t /** GCC: <stdint.h> **/              /*03*/
#define UTF aac2020_taudirt_unit_test_flag                /*04*/
#define L_A struct AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512  /*05*/
#define ANY AAC2020_TAUDIRT_DIR_ANY                       /*06*/
#define LOG aac2020_taudirt_Info_any                      /*07*/
#define ASK aac2020_taudirt_DirtySectorAsk                /*08*/
#define ERR aac2020_taudirt_UnitTestFail                  /*09*/
#define REC struct aac2020_taudirt_rec_bug                /*10*/
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_taudirt_UnitTestFail(
        const char* msg_err
    )
    {
        /** A seperate unit test fail function so that       **/
        /** the failure messages ( msg_err ) do not have     **/
        /** to identify they are comming from a unit test    **/

        printf("[aac2020_taudirt_UnitTestFail]:%s\n", msg_err);
        fflush(stdout);
        exit( 101 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U08
    aac2020_taudirt_NonNegativeDebugRectangle( 
        struct aac2020_taudirt_rec_bug * rec
    )
    {
        U08 non_neg=( 0 /** @_INIT_TO_ZERO_@ **/ );

        if( rec -> x_0 >= 0 ){ non_neg++; };
        if( rec -> x_1 >= 0 ){ non_neg++; };
        if( rec -> y_0 >= 0 ){ non_neg++; };
        if( rec -> y_1 >= 0 ){ non_neg++; };
 
        return( non_neg );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void  
    aac2020_taudirt_UnitTest( void ){ //:@PRIVATE_NAMESPACE@://

        //: Testing Philosophy: #_BTS_BEATS_TOM_# ://

        I32 ask=( 0 - 666 ); /** Result of ASK( ... )  **/
        U08   T   = 0; /** T: TAU_015  EX: TAUDEPO_TAU_015 **/
        U08   S   = 0; /** S: SUB_015  EX: TAUDEPO_PAINT5D **/
        U08   V   = 0; /** V: VAR_255  EX: TAUDEPO_P5D_VP0 **/
        I32 V32   = 0;
        REC R={ 0 };

        R.x_0=( 111 );
        R.x_1=( 222 );
        R.y_0=( 333 );
        R.y_1=( 444 );

        /** Smoke Test. Nothing Fancy. **/
       
        ask = ASK( T , S , V , &R );
        if( ask != 0 ){ 
            ERR("[WTF_MY_MAN:2020_12_16:143PM]"); 
        }else{
            #define I64 int64_t /** GCC: <stdint.h> **/
            LOG( "\n\n" , 0 );
            LOG( "[R.x_0]:%d" , (void*)(I64)R.x_0 );
            LOG( "[R.x_1]:%d" , (void*)(I64)R.x_1 );
            LOG( "[R.y_0]:%d" , (void*)(I64)R.y_0 );
            LOG( "[R.y_1]:%d" , (void*)(I64)R.y_1 );
            LOG( "\n\n" , 0 );
            #undef  I64
        };;

        for(   T = 0 ;   T <= ( 16 - 1 ) ;   T++ ){
        for(   S = 0 ;   S <= ( 16 - 1 ) ;   S++ ){
        for( V32 = 0 ; V32 <= (256 - 1 ) ; V32++ ){
        V=( (U08)V32 );

            ask = ASK( T , S , V , &R );
            if( ask != 0 ){
        
                /** If this fails, it might be because the   **/
                /** rectangle MUST exist somewhere, even if  **/
                /** the entire rectangle itself is INVALID   **/
                /** @VID_IID@[ 0045 ]TIME[ 6H26M30 ]         **/
                /** @VID_URL@[ TODO............... ]         **/
        
                ERR("[The_Simplist_Of_Tests_Has_Failed]");
        
            };;
        
        };;};;};;
    
         printf("\n\n\n");
         LOG("[ESCAPED_THE_LOOP]",0);
         printf("\n\n\n");

    ///  for( p_x = 0 ; p_x <= ( 512-1) ; p_x ++ ){
    ///  for( p_y = 0 ; p_y <= ( 512-1) ; p_y ++ ){
    /// 
    ///      //:Convert [p_x,p_y]TO[ TAU , SUB , VAR ]Indexes
    /// 
    ///      //:Make sure sector is NOT dirty.
    /// 
    ///  };;};;
    /// 
    ///  for( p_x = 0 ; p_x <= ( 512-1) ; p_x ++ ){
    ///  for( p_y = 0 ; p_y <= ( 512-1) ; p_y ++ ){
    /// 
    ///      //:Convert [p_x,p_y]TO[ TAU , SUB , VAR ]Indexes
    /// 
    ///     
    ///      //:make sure sector NOT dirty.
    /// 
    ///      //:flag sector as dirty.
    /// 
    ///      //:make sure sector IS dirty.
    /// 
    ///  };;};;
    /// 
    ///  for( TAU, SUB, & VAR ).....








        
        AAC2020_TODOMAN_Vital( "[Finish_This_Unit_Test]");
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    AAC2020_TAUDIRT_UnitTest( U32 u32 )
    {
        //: Testing Philosophy: #_BTS_BEATS_TOM_# ://

        if( UTF >= 1 ){ return(0x00); };UTF=(  1 );
        if( u32 ){ /** reserved for future use **/ };

        LOG( "[ENTERING:AAC2020_TAUDIRT_UnitTest]",0);

        //:#TAUDEPO_DATA_BACKUP_OR_RESTORE#------------------://
        #define BAK_001  AAC2020_TAUDIRT_DIR_ANY
    /// #define BAK_002  AAC2020_PIXNAME_taudepo_cpu_pix
        #define SIZ_001  sizeof( AAC2020_TAUDIRT_DIR_ANY )
    /// #define SIZ_002  ( 512 * 512 * 4 )

            //( @VID_IID@[ 0045 ]TIME[ 5H33M0S    ] )//  
            //( @VID_URL@[ TODO_YOUTUBE_VIDEO_URL ] )//
            
            /** BACKUP : #BAK_NUM_WHATEVER# : BACKUP **/

            /** @_DONT_ABUSE_THE_STACK_@ **/

            L_A* bak_001=((void*)0);    /** TAUDIRT's TREE   **/
    ////    U08* bak_002=((void*)0);    /** TAUDEPO's PIXELS **/

            bak_001=(L_A*)( malloc( SIZ_001 ) );/* @DANGER_1@ */
    ////    bak_002=(U08*)( malloc( SIZ_002 ) );/* @DANGER_2@ */
        
            memcpy( bak_001 , &(BAK_001   ) , SIZ_001 );
    ////    memcpy( bak_002 , &(BAK_002[0]) , SIZ_002 );
            
        #undef  BAK_001                               //: 01 ://
    /// #undef  BAK_002                               //: 02 ://
        #undef  SIZ_001                               //: 03 ://
    /// #undef  SIZ_002                               //: 04 ://
        //:-----------------:#TAUDEPO_DATA_BACKUP_OR_RESTORE#://
        //:DO_AFTER_DATA_BACKUP:-----------------------------://

            aac2020_taudirt_ForceClearForUnitTest( );

        //:-----------------------------:DO_AFTER_DATA_BACKUP://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://


            /** Actual Test Logic Without The Boilerplate **/

            aac2020_taudirt_UnitTest( /** VOID **/  );


        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        //:#TAUDEPO_DATA_BACKUP_OR_RESTORE#------------------://
        #define BAK_001  AAC2020_TAUDIRT_DIR_ANY
    /// #define BAK_002  AAC2020_PIXNAME_taudepo_cpu_pix
        #define SIZ_001  sizeof( AAC2020_TAUDIRT_DIR_ANY )
    /// #define SIZ_002  ( 512 * 512 * 4 )

            /** RESTORE **/
        
            memcpy( &(BAK_001   ) ,  bak_001 , SIZ_001 );
    ////    memcpy( &(BAK_002[0]) ,  bak_002 , SIZ_002 );

            free( bak_001 );                    /* @DANGER_1@ */
    ////    free( bak_002 );                    /* @DANGER_2@ */
            
        #undef  BAK_001                               //: 01 ://
    /// #undef  BAK_002                               //: 02 ://
        #undef  SIZ_001                               //: 03 ://
    /// #undef  SIZ_002                               //: 04 ://
        //:-----------------:#TAUDEPO_DATA_BACKUP_OR_RESTORE#://

        LOG( "[EXITING:AAC2020_TAUDIRT_UnitTest]",0);

        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  UTF                                           //: 04 ://
#undef  L_A                                           //: 05 ://
#undef  ANY                                           //: 06 ://
#undef  LOG                                           //: 07 ://
#undef  ASK                                           //: 08 ://
#undef  ERR                                           //: 09 ://
#undef  REC                                           //: 10 ://
//:================================================:UNIT_TEST://