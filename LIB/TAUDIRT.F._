//: 1234567
//: TAUDIRT.F._ : DATA ONLY LIBRARY

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_taudirt_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:aac2020_taudirt]:%s\n", msg_err );
        fflush(stdout);
        exit( 586 /** Sterling Heights Area Code **/ );
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://

    void
    aac2020_taudirt_Info_any(
        const char* str_fmt
    ,   void*       dat_any  /** Optional Data **/
    )
    { if( AAC2020_SILENCE.TAUDIRT <= 0 ){

        /** Same Line As Next Printf **/
        printf("[taudirt_log]....(   " ); fflush( stdout );
        printf( str_fmt , dat_any      ); fflush( stdout );
        printf(               "   )\n" ); fflush( stdout );

    };; }

//:===========================================:LOG_AFTER_HALT://
//:MIN_MAX_HELPER:===========================================://
#define U08 uint8_t /** GCC: <stdint.h> **/

    U08
    AAC2020_TAUDIRT_Min( U08 bou_old , U08 bou_new ){
        U08     bou_min ;
            if(              bou_old <     bou_new ){ 
                bou_min =    bou_old ;     
            };;                                                        
            if(              bou_new <     bou_old ){ 
                bou_min =    bou_new ;
            };;
        return( bou_min );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U08
    AAC2020_TAUDIRT_Max( U08 bou_old , U08 bou_new ){
        U08     bou_max ;
            if(              bou_old >     bou_new ){ 
                bou_max =    bou_old ;     
            };;                                            
            if(              bou_new >     bou_old ){ 
                bou_max =    bou_new ;
            };;
        return( bou_max );
    }

 #undef  U08
//:===========================================:MIN_MAX_HELPER://
//:INIT_NONE:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_TAUDIRT_InitNone( U32 u32 ){
        if( u32 ){ /** reserved for future use **/ };

        extern U32 AAC2020_TAUDIRT_UnitTest( U32 u32 );
                   AAC2020_TAUDIRT_UnitTest( 0x00 );

        return( 0x00 );
    }

#undef  U32
//:================================================:INIT_NONE://
//:MAIN_LOGIC:DOTADIW:=======================================://
#define     U08 uint8_t /** GCC: <stdint.h> **/       //: 01 ://
#define     REC struct AAC2020_TAUDIRT_rec_inc        //: 02 ://
                                                      //: -- ://
#define TAU_015 DEX_TAU_000_015                       //: 03 ://
#define SUB_015 DEX_SUB_000_015                       //: 04 ://
#define VAR_255 DEX_VAR_000_255                       //: 05 ://
                                                      //: -- ://
#define     X_x AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512 //: 06 ://
#define     u_U AAC2020_TAUDIRT_l_B_04x04_SUB_Pix_128 //: 07 ://
#define     O_o AAC2020_TAUDIRT_l_C_16x16_VAR_Pix_032 //: 08 ://

    void
    aac2020_taudirt_DirtySectorUpdate(
        U08 DEX_TAU_000_015 //:EX: AAC2020_TAUDEPO_TAU_015
    ,   U08 DEX_SUB_000_015 //:EX: AAC2020_TAUDEPO_PAINT5D
    ,   U08 DEX_VAR_000_255 //:EX: AAC2020_TAUDEPO_P5D_VP0
    )
    {
        /** hackish debugging **/
        aac2020_taudirt_DirtySectorUpdate_call_times++;

        //:Declare:Cell_XY_Tiles:----------------------------://

            U08 x_A; //: @LEVEL_A( l_A )@ 
            U08 y_A; //: AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512

            U08 x_B; //: @LEVEL_B( l_B )@
            U08 y_B; //: AAC2020_TAUDIRT_l_B_04x04_SUB_Pix_128

            U08 x_C; //: @LEVEL_C( l_C )@
            U08 y_C; //: AAC2020_TAUDIRT_l_C_16x16_VAR_Pix_032

        //:----------------------------:Declare:Cell_XY_Tiles://
        //:Get_Dirty:Cell_XY_Tiles:--------------------------://
        
            /** 512x512 pixels, 004x004 (016) cells **/
        
            x_A  =  TAU_015       %   4 ;   //: @LEVEL_A( l_A )@ 
            y_A  = (TAU_015 - x_A)/   4 ;   //: @LEVEL_A( l_A )@ 
        
            /** 128x128 pixels, 004x004 (016) cells. **/
        
            x_B  =  SUB_015       %   4 ;   //: @LEVEL_B( l_B )@
            y_B  = (SUB_015 - x_B)/   4 ;   //: @LEVEL_B( l_B )@
        
            /** 032x032 pixels, 016x016 (256) cells **/
        
            x_C  =  VAR_255       %  16 ;   //: @LEVEL_C( l_C )@
            y_C  = (VAR_255 - x_C)/  16 ;   //: @LEVEL_C( l_C )@
        
        //:--------------------------:Get_Dirty:Cell_XY_Tiles://
        //:Dirty_Rect_Optimization:--------------------------://
        #define  A          AAC2020_TAUDIRT_DIR_ANY
        #define  T          DEX_TAU_000_015
        #define  S          DEX_SUB_000_015
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define  REC_512  ( A                      .rec_512    )
        #define  REC_128  ( A.cel_512[T]           .rec_128    )
        #define  REC_032  ( A.cel_512[T].cel_128[S].rec_032    )
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define  DIRTY_0  ( A                      .is_dirty_0 )
        #define  DIRTY_1  ( A.cel_512[T]           .is_dirty_1 )
        #define  DIRTY_2  ( A.cel_512[T].cel_128[S].is_dirty_2 )
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

            //:Expand_Dirty_Rect_Selections:-----------------://
            #define MIN AAC2020_TAUDIRT_Min           //: 01 ://
            #define MAX AAC2020_TAUDIRT_Max           //: 02 ://

                /** >= 1 : REC is @VALID, use MIN+MAX   **/
                /** <= 0 : REC is @@JUNK, re-initialize **/

            //: #DIA_TAU_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_0 >= 1  ){ //: @VALID

                    REC_512.x_0 = MIN( REC_512.x_0 , x_A );
                    REC_512.x_1 = MAX( REC_512.x_1 , x_A );

                    REC_512.y_0 = MIN( REC_512.y_0 , y_A );
                    REC_512.y_1 = MAX( REC_512.y_1 , y_A );

                }else if( DIRTY_0 <= 0 ){ //:  @@JUNK

                    REC_512.x_0 =    (               x_A );
                    REC_512.x_1 =    (               x_A );
                                                 
                    REC_512.y_0 =    (               y_A );
                    REC_512.y_1 =    (               y_A );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_512]"); };

            //: #DIA_SUB_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_1 >= 1  ){ //: @VALID

                    REC_128.x_0 = MIN( REC_128.x_0 , x_B );
                    REC_128.x_1 = MAX( REC_128.x_1 , x_B );

                    REC_128.y_0 = MIN( REC_128.y_0 , y_B );
                    REC_128.y_1 = MAX( REC_128.y_1 , y_B );

                }else if( DIRTY_1 <= 0 ){ //:  @@JUNK

                    REC_128.x_0 =    (               x_B );
                    REC_128.x_1 =    (               x_B );
                                                 
                    REC_128.y_0 =    (               y_B );
                    REC_128.y_1 =    (               y_B );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_128]"); };

            //: #DIA_VAR_CEL# (BELOW) ://

                ;;;;;;if( DIRTY_2 >= 1  ){ //: @VALID

                    REC_032.x_0 = MIN( REC_032.x_0 , x_C );
                    REC_032.x_1 = MAX( REC_032.x_1 , x_C );

                    REC_032.y_0 = MIN( REC_032.y_0 , y_C );
                    REC_032.y_1 = MAX( REC_032.y_1 , y_C );

                }else if( DIRTY_2 <= 0 ){ //:  @@JUNK

                    REC_032.x_0 =    (               x_C );
                    REC_032.x_1 =    (               x_C );
                                                 
                    REC_032.y_0 =    (               y_C );
                    REC_032.y_1 =    (               y_C );

                }else{ aac2020_taudirt_Halt("[WTF:CEL_032]"); };

            #undef  MIN                               //: 01 ://
            #undef  MAX                               //: 02 ://
            //:-----------------:Expand_Dirty_Rect_Selections://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef        A                               //: 01 ://
        #undef        S                               //: 02 ://
        #undef        T                               //: 03 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  REC_512                               //: 04 ://
        #undef  REC_128                               //: 05 ://
        #undef  REC_032                               //: 06 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #undef  DIRTY_0                               //: 07 ://
        #undef  DIRTY_1                               //: 08 ://
        #undef  DIRTY_2                               //: 09 ://
        //:--------------------------:Dirty_Rect_Optimization://
        //:Declare_Sub_Cells:--------------------------------://
        #define          TYP( nam ) struct AAC2020_TAUDIRT_##nam
        #define CEL_512  TYP( l_B_04x04_SUB_Pix_128 )
        #define CEL_128  TYP( l_C_16x16_VAR_Pix_032 )
        #define CEL_032  U08   

            CEL_512* cel_512=((void*)0);  /**  @cel_512@   **/
            CEL_128* cel_128=((void*)0);  /**  @cel_128@   **/
            CEL_032* cel_032=((void*)0);  /**  @cel_032@   **/

        #undef TYP                                    //: 01 ://
        #undef CEL_512                                //: 02 ://
        #undef CEL_128                                //: 03 ://
        #undef CEL_032                                //: 04 ://
        //:--------------------------------:Declare_Sub_Cells://
        //:Assign_Sub_Cells:---------------------------------://
        #define ANY AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 01 :*/
        #define l_A AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 02 :*/
        #define l_B cel_512                 /* 1 deep   : 03 :*/
        #define l_C cel_128                 /* 2 deep   : 04 :*/

            cel_512 = &( l_A  . cel_512[ TAU_015 ] );
            cel_128 = &( l_B -> cel_128[ SUB_015 ] );
            cel_032 = &( l_C -> cel_032[ VAR_255 ] );

            #define  T  TAU_015 //: 01 ://
            #define  S  SUB_015 //: 02 ://
            #define  V  VAR_255 //: 03 ://
            #define C0  cel_512 //: 04 ://
            #define C1  cel_128 //: 05 ://
            #define C2  cel_032 //: 06 ://

            assert( cel_512 ==&( ANY.C0[ T ]                 ));
            assert( cel_128 ==&( ANY.C0[ T ].C1[ S ]         ));
            assert( cel_032 ==&( ANY.C0[ T ].C1[ S ].C2[ V ] ));
        
            #undef   T          //: 01 ://
            #undef   S          //: 02 ://
            #undef   V          //: 03 ://
            #undef  C0          //: 04 ://
            #undef  C1          //: 05 ://
            #undef  C2          //: 06 ://
              
        #undef  ANY                                   //: 01 ://
        #undef  l_A                                   //: 02 ://
        #undef  l_B                                   //: 03 ://
        #undef  l_C                                   //: 04 ://
        //:---------------------------------:Assign_Sub_Cells://
        //:General_Dirty_Flags:------------------------------://
        #define ANY AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 01 :*/
        #define l_A AAC2020_TAUDIRT_DIR_ANY /* 0 deep   : 02 :*/
        #define l_B  (        cel_512   )   /* 1 deep   : 03 :*/
        #define l_C  (        cel_128   )   /* 2 deep   : 04 :*/
        U08*    l_D  = l_C -> cel_032   ;   /* 3 deep   : 05 :*/
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define   A  assert                           //: 01 ://
        #define   T TAU_015                           //: 02 ://
        #define   S SUB_015                           //: 03 ://
                                                      //: -- ://
        #define C_0 cel_512                           //: 04 ://
        #define C_1 cel_128                           //: 05 ://
        #define C_2 cel_032                           //: 06 ://

            A( &(l_A) == &( ANY                          )   );                   
            A(   l_B  == &( ANY.C_0[ T ]                 )   );          
            A(   l_C  == &( ANY.C_0[ T ].C_1[ S ]        )   );
            A(   l_D  == &( ANY.C_0[ T ].C_1[ S ].C_2[0] )   );

        #undef    A                                   //: 01 ://
        #undef    T                                   //: 02 ://
        #undef    S                                   //: 03 ://
                                                      //: -- ://
        #undef  C_0                                   //: 04 ://
        #undef  C_1                                   //: 05 ://
        #undef  C_2                                   //: 06 ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        #define IS_DIRTY_3   VAR_255 //:*********************://

            l_A  . is_dirty_0  =( 1 ); /** NESTING_LEVEL : 0 **/
            l_B -> is_dirty_1  =( 1 ); /** NESTING_LEVEL : 1 **/
            l_C -> is_dirty_2  =( 1 ); /** NESTING_LEVEL : 2 **/
            l_D[   IS_DIRTY_3 ]=( 1 ); /** NESTING_LEVEL : 3 **/

            //:Check_Your_Pointer_Logic:---------------------://
            #define A assert //:-----------------------------://

                /** Cross Check Memory Addresses.            **/
                /** ( Look up SAME addresses in a DIFFERENT )**/
                /** ( way to check your LOOKUP logic.       )**/

                    A( &(     l_A  . is_dirty_0 )
                    == &(     ANY  . is_dirty_0 ) );

                    A( &(     l_B -> is_dirty_1 )
                    == &( cel_512 -> is_dirty_1 ) );

                    A( &(     l_C -> is_dirty_2   ) 
                    == &( cel_128 -> is_dirty_2 ) );;

                    A( &(     l_D[   IS_DIRTY_3 ] )==cel_032 );

            #undef  A //:------------------------------------://
            //:---------------------:Check_Your_Pointer_Logic://

        #undef  IS_DIRTY_3 //:*******************************://

        #undef  ANY                                   //: 01 ://
        #undef  l_A                                   //: 02 ://
        #undef  l_B                                   //: 03 ://
        #undef  l_C                                   //: 04 ://
    //: @undef  l_D                                   //: 05 ://
        //:------------------------------:General_Dirty_Flags://
    }

    #ifdef  A  
        #error "[FORGOT_TO_UNDEFINE_A:2020]"
    #endif
                                                    
#undef      U08                                       //: 01 ://
#undef      REC                                       //: 02 ://
                                                      //: -- ://
#undef  TAU_015                                       //: 03 ://
#undef  SUB_015                                       //: 04 ://
#undef  VAR_255                                       //: 05 ://
                                                      //: -- ://
#undef      X_x                                       //: 06 ://
#undef      u_U                                       //: 07 ://
#undef      O_o                                       //: 08 ://
//:=======================================:MAIN_LOGIC:DOTADIW://
//:FORCE_CLEAR_FOR_UNIT_TEST:================================://
#define ANY AAC2020_TAUDIRT_DIR_ANY
#define C_R aac2020_taudirt_ClearRect
#define I32 int32_t /** GCC: <stdint.h> **/

    void
    aac2020_taudirt_ClearRect(
        struct AAC2020_TAUDIRT_rec_inc * rec_inc
                                     /** rec_512  <-- Inputs **/
                                     /** rec_128  <-- Inputs **/
                                     /** rec_032  <-- Inputs **/
    )
    {
        /** Since rectangle is signed, we will clear it  **/
        /** by giving it out of bound trap values.       **/
        rec_inc -> x_0 =( 0x66 /** 0x66 == 102 @TRAP_VALUE@**/);
        rec_inc -> x_1 =( 0x77 /** 0x77 == 119 @TRAP_VALUE@**/);
        rec_inc -> y_0 =( 0x88 /** 0x88 == 136 @TRAP_VALUE@**/);
        rec_inc -> y_1 =( 0x99 /** 0x99 == 153 @TRAP_VALUE@**/);

        /** ************************************************ ***
            Anything greater than 15 is out of range 
            so we should use a more unique value than
            "0xFF" maybe... 0x77 ( decimal: 119 )

            #DIA_TAU_CEL# : xy_range[ 0 -to- ( 4  - 1 ) ]  
            #DIA_SUB_CEL# : xy_range[ 0 -to- ( 4  - 1 ) ]  
            #DIA_VAR_CEL# : xy_range[ 0 -to- ( 16 - 1 ) ]  

        *** ************************************************ **/
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_taudirt_ForceClearForUnitTest( void )
    {
        /** FUNCTION_SUMMARY: FoceClearForUnitTest:  **/
        /** Only to be used BEFORE and after calling **/
        /** Unit test so that we can make sure we    **/
        /** are working with predictable state and   **/
        /** restoring to zeroed-out state after      **/
        /** mucking around with the data with our    **/
        /** tests. --------------------------------- **/

        //:NON_RECURSIVELY_TRAVERSE_TREE:--------------------://
        #define D_0 "MAKE_PATTERN_OBVIOUS"            //: 01 ://
        #define D_1  ANY.cel_512[ d_1 ]               //: 02 ://
        #define D_2      cel_128[ d_2 ]               //: 03 ://
        #define D_3      cel_032[ d_3 ]               //: 04 ://

            I32 d_0; I32 d_1; I32 d_2; I32 d_3;
        
            for( d_0 = 0 ; d_0 <=   0 ; d_0 ++ ){ //:@NES_LEV@:0

                        ANY.is_dirty_0 = ( 0 );
                C_R( &( ANY.rec_512         ));

            for( d_1 = 0 ; d_1 <=  15 ; d_1 ++ ){ //:@NES_LEV@:1

                        D_1.is_dirty_1 =( 0 );
                C_R( &( D_1.rec_128        ));

            for( d_2 = 0 ; d_2 <=  15 ; d_2 ++ ){ //:@NES_LEV@:2

                        D_1.D_2.is_dirty_2 =( 0 );
                C_R( &( D_1.D_2.rec_032        ));

            for( d_3 = 0 ; d_3 <= 255 ; d_3 ++ ){ //:@NES_LEV@:3

                        /** is_dirty_3 , conceptually **/

                        D_1.D_2.D_3 = ( 0x00 );

            };; };; };; };; //:  @NON_INDENTED_LOOP_LEVELS@  ://

        #undef  D_0                                   //: 01 ://
        #undef  D_1                                   //: 02 ://
        #undef  D_2                                   //: 03 ://
        #undef  D_3                                   //: 04 ://
        //:--------------------:NON_RECURSIVELY_TRAVERSE_TREE://

    }

#undef  ANY
#undef  C_R
#undef  I32
//:================================:FORCE_CLEAR_FOR_UNIT_TEST://
//:UNIT_TEST:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U08  uint8_t /** GCC: <stdint.h> **/
#define UTF aac2020_taudirt_unit_test_flag
#define L_A struct AAC2020_TAUDIRT_l_A_04x04_TAU_Pix_512
#define ANY AAC2020_TAUDIRT_DIR_ANY
#define LOG aac2020_taudirt_Info_any
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void  
    aac2020_taudirt_UnitTest( void ){ //:@PRIVATE_NAMESPACE@://


        AAC2020_TODOMAN_Vital( "[Finish test logic]" );

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    AAC2020_TAUDIRT_UnitTest( U32 u32 )
    {
        if( UTF >= 1 ){ return(0x00); };UTF=(  1 );
        if( u32 ){ /** reserved for future use **/ };

        LOG( "[ENTERING:AAC2020_TAUDIRT_UnitTest]",0);

        //:#TAUDEPO_DATA_BACKUP_OR_RESTORE#------------------://
        #define BAK_001  AAC2020_TAUDIRT_DIR_ANY
        #define BAK_002  AAC2020_PIXNAME_taudepo_cpu_pix
        #define SIZ_001  sizeof( AAC2020_TAUDIRT_DIR_ANY )
        #define SIZ_002  ( 512 * 512 * 4 )

            /** BACKUP : #BAK_NUM_WHATEVER# : BACKUP **/

            /** @_DONT_ABUSE_THE_STACK_@ **/

            L_A* bak_001=((void*)0);    /** TAUDIRT's TREE   **/
            U08* bak_002=((void*)0);    /** TAUDEPO's PIXELS **/

            bak_001=(L_A*)( malloc( SIZ_001 ) );
            bak_002=(U08*)( malloc( SIZ_002 ) );
        
            memcpy( bak_001 , &(BAK_001   ) , SIZ_001 );
            memcpy( bak_002 , &(BAK_002[0]) , SIZ_002 );
            
        #undef  BAK_001                               //: 01 ://
        #undef  BAK_002                               //: 02 ://
        #undef  SIZ_001                               //: 03 ://
        #undef  SIZ_002                               //: 04 ://
        //:-----------------:#TAUDEPO_DATA_BACKUP_OR_RESTORE#://
        //:DO_AFTER_DATA_BACKUP:-----------------------------://

            aac2020_taudirt_ForceClearForUnitTest( );

        //:-----------------------------:DO_AFTER_DATA_BACKUP://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://


            /** Actual Test Logic Without The Boilerplate **/

            aac2020_taudirt_UnitTest( /** VOID **/  );


        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        //:#TAUDEPO_DATA_BACKUP_OR_RESTORE#------------------://
        #define BAK_001  AAC2020_TAUDIRT_DIR_ANY
        #define BAK_002  AAC2020_PIXNAME_taudepo_cpu_pix
        #define SIZ_001  sizeof( AAC2020_TAUDIRT_DIR_ANY )
        #define SIZ_002  ( 512 * 512 * 4 )

            /** RESTORE **/
        
            memcpy( &(BAK_001   ) ,  bak_001 , SIZ_001 );
            memcpy( &(BAK_002[0]) ,  bak_002 , SIZ_002 );

            free( bak_001 );
            free( bak_002 );
            
        #undef  BAK_001                               //: 01 ://
        #undef  BAK_002                               //: 02 ://
        #undef  SIZ_001                               //: 03 ://
        #undef  SIZ_002                               //: 04 ://
        //:-----------------:#TAUDEPO_DATA_BACKUP_OR_RESTORE#://

        LOG( "[EXITING:AAC2020_TAUDIRT_UnitTest]",0);

        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  U32
#undef  U08
#undef  UTF
#undef  L_A
#undef  ANY
#undef  LOG
//:================================================:UNIT_TEST://