//:GPUDATA.F._
//[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
//#######: INSTANCES OF AAC2020_GPUDATA DO NOT BELONG :#######//
//#######: IN [ GPUDATA.D._ ]OR[ GPUDATA.H._ ]        :#######//
//#######: SEE[ DOC/WHY_NO_INSTANCES_IN_GPUDATA.TXT ] :#######//
//[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

    #define AAC2020_GPUDATA_DEBUG_MODE ( 1 )

    #if( AAC2020_GPUDATA_DEBUG_MODE >= 1 ) //:###############://

        #define PIX_R_G_B_A   AAC2020_GPUDATA_Check_PIX_R_G_B_A
        #define PIX_P_X_P_Y   AAC2020_GPUDATA_Check_PIX_P_X_P_Y

    #else
        //: if no debug mode, remove call sites.

        #define PIX_R_G_B_A(PIX,R,G,B,A,TRACEBACK_MESSAGE)
        #define PIX_P_X_P_Y(PIX,P_X,P_Y,TRACEBACK_MESSAGE)

    #endif //:###############################################://

//:HALTING_FUNCTIONS_AND_MESSAGES:===========================://

    //:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=================://
        void 
        aac2020_gpudata_Halt( const char* msg_err )
        {
            #define P printf
            P("[FATAL_ERROR:AAC2020_GPUDATA]:%s\n", msg_err );
            #undef  P

            fflush(stdout);
            exit(666);
        }
    //:=================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
    //:HALT:UPLOAD_TEXTURE_ERROR:============================://
        void
        aac2020_gpudata_ERR_UploadTexture( const char* msg_err )
        {
            printf("[aac2020_gpudata_ERR_UploadTexture]:%s\n"
            ,msg_err);;
            fflush(stdout);
            exit(666);
        }
    //:============================:HALT:UPLOAD_TEXTURE_ERROR://
    //:HALT_WITH_TRACEBACK_MESSAGE:==========================://

        void 
        aac2020_gpudata_HaltWithTrace( 
            const char* msg_err /** what went wrong **/
        ,   const char* msg_t_b /** Trace Back To Call Site **/
                                /** #TRACEBACK_MESSAGE# **/
        )
        {
            #define P printf
            #define E msg_err
            #define T msg_t_b

            P("[FATAL_ERROR::::AAC2020_GPUDATA]:%s\n", E );
            P("[FATAL_ERROR:TRACE_BACK_MESSAGE]:%s\n", T );

            #undef  P
            #undef  E
            #undef  T

            fflush(stdout);
            exit( 13 /**DoesntReallyMatter**/ );
        }

    //:==========================:HALT_WITH_TRACEBACK_MESSAGE://
    //:GOALS_ARE_NEVER_ERRORS:===============================://

        void
        aac2020_gpudata_Goal( const char* msg_gol ){
        if( AAC2020_SILENCE.GPUDATA <= 0 ){
            printf("[aac2020_gpudata:goal:ok]:%s\n", msg_gol );
            fflush(stdout);
        };;}

    //:===============================:GOALS_ARE_NEVER_ERRORS://
    //:NEITHER_ARE_OKAY_MESSAGES:============================://

        void
        aac2020_gpudata_Okay( const char* msg_gol ){
        if( AAC2020_SILENCE.GPUDATA <= 0 ){
            printf("[aac2020_gpudata_Okay]:%s\n", msg_gol );
            fflush(stdout);
        };;}

    //:============================:NEITHER_ARE_OKAY_MESSAGES://
//:===========================:HALTING_FUNCTIONS_AND_MESSAGES://
//:FAIL_FAST_INPUT_CHECKS:===================================://
#define HWT aac2020_gpudata_HaltWithTrace
#define PIX struct AAC2020_GPUDATA
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U08 uint8_t  /** GCC: <stdint.h> **/
#define STR const char*

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_GPUDATA_Check_PIX_P_X_P_Y(
        PIX* pix
    ,   U32  p_x
    ,   U32  p_y
    ,   STR  t_b /** #TRACEBACK_MESSAGE# / msg_t_b **/
    )
    {
        if( ((void*)0) == pix   ){  HWT("[N_PTR:PIX]", t_b); };

        if( (int)p_x < 0        ){  HWT("[N.OOB:P_X]", t_b); };
        if(      p_x > (512 - 1)){  HWT("[P.OOB:P_X]", t_b); };
                                  
        if( (int)p_y < 0        ){  HWT("[N.OOB:P_Y]", t_b); };
        if(      p_y > (512 - 1)){  HWT("[P.OOB:P_Y]", t_b); };
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_GPUDATA_Check_PIX_R_G_B_A(
        PIX*  pix       /** AAC2020_GPUDATA   **/
    ,   U08*  r         /** OUTPUT_PARAM      **/
    ,   U08*  g         /** OUTPUT_PARAM      **/
    ,   U08*  b         /** OUTPUT_PARAM      **/
    ,   U08*  a         /** OUTPUT_PARAM      **/
    ,   const char* t_b /** TRACEBACK_MESSAGE **/
    )
    {
        //:MAKE_SURE_ALL_POINTERS_NON_NULL:------------------://

            if( ((void*)0) == r ){ HWT("[RGBAP:R!!]" , t_b); };
            if( ((void*)0) == g ){ HWT("[RGBAP:G!!]" , t_b); };
            if( ((void*)0) == b ){ HWT("[RGBAP:B!!]" , t_b); };
            if( ((void*)0) == a ){ HWT("[RGBAP:A!!]" , t_b); };
            if( ((void*)0) ==pix){ HWT("[RGBAP:P!!]" , t_b); };

        //:------------------:MAKE_SURE_ALL_POINTERS_NON_NULL://
        //:MAKE_SURE_RESTRICT_KEYWORD_NOT_VIOLATED:----------://

            if( 0 == r          ){ HWT("[RGBAP:001]" , t_b); };
            if( g == r          ){ HWT("[RGBAP:002]" , t_b); };
            if( b == r          ){ HWT("[RGBAP:003]" , t_b); };
            if( a == r          ){ HWT("[RGBAP:004]" , t_b); };
                                
            if( r == g          ){ HWT("[RGBAP:005]" , t_b); };
            if( 0 == g          ){ HWT("[RGBAP:006]" , t_b); };
            if( b == g          ){ HWT("[RGBAP:007]" , t_b); };
            if( a == g          ){ HWT("[RGBAP:008]" , t_b); };
                                            
            if( r == b          ){ HWT("[RGBAP:009]" , t_b); };
            if( g == b          ){ HWT("[RGBAP:010]" , t_b); };
            if( 0 == b          ){ HWT("[RGBAP:011]" , t_b); };
            if( a == b          ){ HWT("[RGBAP:012]" , t_b); };
                                            
            if( r == a          ){ HWT("[RGBAP:013]" , t_b); };
            if( g == a          ){ HWT("[RGBAP:014]" , t_b); };
            if( b == a          ){ HWT("[RGBAP:015]" , t_b); };
            if( 0 == a          ){ HWT("[RGBAP:016]" , t_b); };

        //:----------:MAKE_SURE_RESTRICT_KEYWORD_NOT_VIOLATED://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  HWT
#undef  PIX
#undef  U32
#undef  U08
#undef  STR
//:===================================:FAIL_FAST_INPUT_CHECKS://
//:MATH_FUNCTIONS:===========================================://
//:#BASIC_2D_ARRAY_ABSTRACTIONS_ONLY#========================://
#define WID 512
#define HIG 512
#define M_P ( (512 * 512 * 1) - 1 ) /** MAX:Pixel_____Index **/
#define M_C ( (512 * 512 * 4) - 1 ) /** MAX:Component_Index **/
#define M_X ( 512 - 1 )             /** MAX:X **/
#define M_Y ( 512 - 1 )             /** MAX:Y **/
#define ERR aac2020_gpudata_Halt
#define U32 uint32_t /** GCC: <stdint.h> **/
    
    //:#_GROUP_MATH_FUNCTIONS_WITH_THEIR_INVERSES_#://

    //:_#GPUDATA_MATH_FUNCTIONS_ARE_BARE_BASIC_ABSTRACTIONS_:#

    U32
    AAC2020_GPUDATA_p_x_p_y_CTO_com_dex( 
        U32 p_x
    ,   U32 p_y
    )
    {
        if( (int)p_x <  0  ){ ERR("[WTF:2020_11_14:A]"); };
        if( (int)p_y <  0  ){ ERR("[WTF:2020_11_14:B]"); };
        if(      p_x > M_X ){ ERR("[WTF:2020_11_14:C]"); };
        if(      p_y > M_Y ){ ERR("[WTF:2020_11_14:D]"); };

        U32 pix_dex = p_x + ( WID * p_y);
        U32 com_dex =( 4 * pix_dex ); /** 4 == RGBA **/
        return( com_dex );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_GPUDATA_com_dex_CTO_p_x_p_y(

        U32       com_dex        /** Always A RED Component. **/
    ,   U32* restrict p_x        /** Pixel_X ............... **/
    ,   U32* restrict p_y        /** Pixel_Y ............... **/

    )
    {
        //:WTFHM:WHAT_THE_FUCKING_HELL_MAN:------------------://
        if( (int)com_dex < 0       ){ ERR("[WTFHM:001]"); };
        if(      com_dex > M_C     ){ ERR("[WTFHM:002]"); };
        if(      ((void*)0) == p_x ){ ERR("[WTFHM:003]"); };
        if(      ((void*)0) == p_y ){ ERR("[WTFHM:004]"); };
        if(      p_x == p_y        ){ ERR("[WTFHM:005]"); };
        if(      com_dex % 4 != 0  ){ 

                /** NDB4: NOT_DIVISIBLE_BY_4 **/
                printf("[NDB4:com_dex]:%d\n" ,com_dex   );;
                fflush(stdout);
                ERR("[ERROR:NDB4#SIX_FIGURES_IS_ONLY#]"); 
        };;
        //:------------------:WTFHM:WHAT_THE_FUCKING_HELL_MAN://

        U32 pix_dex = ( com_dex / 4 )           ;
                                                ;
        U32 val_p_x =  pix_dex            % WID ;
        U32 val_p_y = (pix_dex - val_p_x )/ WID ;
                                                ;
        /** Load Output Parameters **/          ;
        (*p_x) = val_p_x                        ;
        (*p_y) = val_p_y                        ;
    
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  WID
#undef  HIG
#undef  M_P 
#undef  M_C 
#undef  M_X 
#undef  M_Y
#undef  ERR
#undef  U32
//:=======================:#BASIC_2D_ARRAY_ABSTRACTIONS_ONLY#://
//:===========================================:MATH_FUNCTIONS://
//:APPLY_CHANGES_TO_GPU(DEVICE):=============================://
#define U08 uint8_t  /** GCC: <stdint.h> **/
#define PIX struct AAC2020_GPUDATA
#define WID 512
#define HIG 512

    U08
    AAC2020_GPUDATA_ApplyChangesToGPU(
        PIX* pix /** AAC2020_GPUDATA **/
    )
    {
        AAC2020_VITAL_TODO("[FINISH_ApplyChangesToGPU]");

        if( ((void*)0) == pix ){
            aac2020_gpudata_Halt("[NULL:GPUDATA:001]");
        }else{
            aac2020_gpudata_Halt("[TODO:GPUDATA:001]");
        };;
            
        
        return( 0x00 );
    }

#undef  WID
#undef  HIG
#undef  PIX
#undef  U08
//:=============================:APPLY_CHANGES_TO_GPU(DEVICE)://
//:PUT_PIXEL_ON_CPU(HOST):===================================://
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U08 uint8_t  /** GCC: <stdint.h> **/
#define PIX struct AAC2020_GPUDATA
#define WID 512
#define HIG 512

    #if( AAC2020_CRASH_ON_VITAL_TODO >= 1 ) //:##############://

        #error: Does this belong in PIXLOAD ?

        We could keep the pixel put here because they are
        essentially abstractions of the basic math functions
        in this file, but I think anything that pushes to
        the GPU might belong in PIXLOAD? Not sure.....

    #endif //:###############################################://

    U08
    AAC2020_GPUDATA_PutPixelOnCPU_RGBA( 

        PIX* pix /** AAC2020_GPUDATA **/

    ,   U32  p_x
    ,   U32  p_y

    ,   U08    r
    ,   U08    g
    ,   U08    b
    ,   U08    a
    )
    {
        //:RGBA will always be in range. No Debug For Them.
        PIX_P_X_P_Y( pix,p_x,p_y, "[DEBUG_INPUTS:001]");  
 
        U32 com_dex =( 0 ); //:COMponent_inDEX

        com_dex = AAC2020_GPUDATA_p_x_p_y_CTO_com_dex( 
                                  p_x,p_y             );;

        pix -> cpu_pix[ com_dex + 0 ] = r;
        pix -> cpu_pix[ com_dex + 1 ] = g;
        pix -> cpu_pix[ com_dex + 2 ] = b;
        pix -> cpu_pix[ com_dex + 3 ] = a;

        return( 0x00 );
    }

    
    U08
    AAC2020_GPUDATA_PutPixelOnCPU_U32( 
        PIX* pix /** AAC2020_GPUDATA **/

    ,   U32  p_x
    ,   U32  p_y

    ,   U32  RGBA
    )
    {
        //:RGBA will always be in range. No Debug For Them.
        PIX_P_X_P_Y( pix,p_x,p_y , "[DEBUG_INPUTS:005]");
           
        U32 r = ( RGBA >>24 ) & 0xFF;        assert( r <= 255 );
        U32 g = ( RGBA >>16 ) & 0xFF;        assert( g <= 255 );
        U32 b = ( RGBA >> 8 ) & 0xFF;        assert( b <= 255 );
        U32 a = ( RGBA >> 0 ) & 0xFF;        assert( a <= 255 );

        AAC2020_GPUDATA_PutPixelOnCPU_RGBA(
        pix , p_x , p_y 
        ,                (U08)r  
        ,                (U08)g  
        ,                (U08)b  
        ,                (U08)a    
        );;

        return( 0x00 );
    }

#undef  WID
#undef  HIG
#undef  PIX
#undef  U08
#undef  U32
//:===================================:PUT_PIXEL_ON_CPU(HOST)://
//:GET_PIXEL_ON_CPU(HOST):===================================://
#define U32 uint32_t /** GCC: <stdint.h> **/
#define U08 uint8_t  /** GCC: <stdint.h> **/
#define PIX struct AAC2020_GPUDATA
#define WID 512
#define HIG 512

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void /** KEEP_VOID_TO_AVOID_CONFUSION **/

    AAC2020_GPUDATA_GetPixelOnCPU_RGBA( 
        PIX*   restrict pix  /** AAC2020_GPUDATA **/

    ,   U32             p_x
    ,   U32             p_y

    ,   U08*   restrict r    /** OUTPUT_PARAM **/
    ,   U08*   restrict g    /** OUTPUT_PARAM **/
    ,   U08*   restrict b    /** OUTPUT_PARAM **/
    ,   U08*   restrict a    /** OUTPUT_PARAM **/
    )
    {
        //: Debug RGBA because they could be null.
        PIX_R_G_B_A( pix,r,g,b,a , "[DEBUG_INPUTS:002]");  
        PIX_P_X_P_Y( pix,p_x,p_y , "[DEBUG_INPUTS:004]");

        if( ((void*)0) == pix ){
            aac2020_gpudata_Halt("[NULL:GPUDATA:004]");
        }else{

            U32 pix_dex = p_x + ( WID * p_y);
            U32 com_dex = pix_dex * 4; /** RGBA == 4 **/

            (*r )= pix -> cpu_pix[ com_dex + 0 ];
            (*g )= pix -> cpu_pix[ com_dex + 1 ];
            (*b )= pix -> cpu_pix[ com_dex + 2 ];
            (*a )= pix -> cpu_pix[ com_dex + 3 ];

        };;

        return; /** #KEEP_VOID_TO_AVOID_CONFUSION# **/
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    
    U32
    AAC2020_GPUDATA_GetPixelOnCPU_U32( 
        PIX* pix /** AAC2020_GPUDATA **/

    ,   U32  p_x
    ,   U32  p_y
    )
    {
        PIX_P_X_P_Y( pix,p_x,p_y , "[DEBUG_INPUTS:003]");

        if( ((void*)0) == pix ){
            aac2020_gpudata_Halt("[NULL:GPUDATA:005]");
        };;

        U08 r =( 0x77 ); //:Inited_To_Noticable_Values
        U08 g =( 0x77 ); //:That_Should_Be_OverWritten
        U08 b =( 0x77 );
        U08 a =( 0x77 );

        AAC2020_GPUDATA_GetPixelOnCPU_RGBA(
            pix, p_x, p_y, &(r),&(g),&(b),&(a) );;

       
        //:........0x12345678
        U32 rgba=( 0x00000000 );
        //:........0xRrGgBbAa
        
        #define              M (0xFF) 
        rgba = rgba | ( (r & M) << 24 ) ;
        rgba = rgba | ( (g & M) << 16 ) ;
        rgba = rgba | ( (b & M) <<  8 ) ;
        rgba = rgba | ( (a & M) <<  0 ) ;
        #undef               M

        return( rgba );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  WID
#undef  HIG
#undef  PIX
#undef  U08
#undef  U32
//:===================================:GET_PIXEL_ON_CPU(HOST)://
//:INIT_ALL:Private_Helper_Functions:========================://
#define U32 uint32_t /** GCC: <stdint.h> **/
#define I32 int32_t  /** GCC: <stdint.h> **/
#define CHR const char
#define ERR aac2020_gpudata_Halt
#define OGL AAC2020_GLEBIND /** OGL: Open_GL **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /** Helpers required so we can create more concise       **/
    /** Batch-processed style code. These functions are      **/
    /** a bit fault tolerant (NOT FAIL FAST) to help         **/
    /** that process along.                                  **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /** #_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_# **/
    I32 aac2020_gpudata_glGetUniformLocation( 
        U32   pog_iid //:invalid_input: not_allowed
    ,   CHR*  u32_nam //:invalid_input: not_allowed
    )
    {
        
        //:GULO: Get_Uniform_LOcation:
        I32 u32_loc =( 0 - 1 /** Neg1 for not found       **/ );
        U32 err_num =(  666  /** TRAP: Forgot To Call ERR# **/);
        if( (       0) == pog_iid ){ ERR("[POG:NILHAN:GULO]");};
        if( ((void*)0) == u32_nam ){ ERR("[NAM:NILPTR:GULO]"); };

        //:All texture sampler uniforms are exactly
        //:8 characters. 7 letters and a null terminator.
        if( strlen( u32_nam ) != ( 8 - 1 ) ){
            ERR("[ALL_TEXTURE_SAMPLER_UNIFORMS_ARE_7_LETTERS]");
        };;

        u32_loc =(
            OGL.glGetUniformLocation( 
            pog_iid , u32_nam                 ));;

        //:Some errors might be okay to get this to
        //:fail gracefully so we can call succinctly.
        err_num=( OGL.glGetError( /**NO_ARGS**/ ) );
        if( err_num != 0 ){
            ERR("[DECIDE_WHAT_ERRORS_ARE_OKAY_IF_ANY:001]");
        };;

        if(     u32_loc <= ( 0 - 1 ) ){ u32_loc =( 0 - 1 ); };
        return( u32_loc );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    
    /** #_ALWAYS_WRAP_WITH_IDENTICAL_SIGNATURE_# **/
    void aac2020_gpudata_glGetUniformiv(
        U32  pog_iid //:invalid_input: not_allowed
    ,   I32  u32_loc //:INVALID_INPUT: YES_ALLOWED
    ,   I32* u32_val //:invalid_input: not_allowed
    )
    {
        U32 err_num =( 707 /** TRAP:Forgot To Call ERR# **/ );

        //:GUIV: Get_Uniform_IV
        if( (       0) == pog_iid ){ ERR("[POG:NILHAN:GUIV]");};
        if( ((void*)0) == u32_val ){ ERR("[VAL:NILPTR:GUIV]");};
        if( u32_loc <= ( 0 - 1 ) ){

            //:Fail Gracefully by returning -1 in the u32_val.
            (*u32_val)=( 0 - 1 );
        }else{

            //:Fetch EXISTING uniform in currently loaded shader 
            OGL.glGetUniformiv( pog_iid , u32_loc , u32_val );

        };;

        //:Some errors might be okay to get this to
        //:fail gracefully so we can call succinctly.
        err_num=( OGL.glGetError( /**NO_ARGS**/ ) );
        if( err_num != 0 ){
            ERR("[DECIDE_WHAT_ERRORS_ARE_OKAY_IF_ANY:002]");
        };;

        return; /** #_ONE_EXIT_POINT_ALWAYS_# **/
    }
      
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  U32
#undef  I32
#undef  CHR
#undef  ERR
#undef  OGL
//:========================:INIT_ALL:Private_Helper_Functions://
//:INIT_ALL:=================================================://
#define INI_ALL_ERR  aac2020_gpudata_Halt

#define TEX_LOT_000  AAC2020_PIXNAME_taudepo_tex_lot
#define TEX_LOT_001  AAC2020_PIXNAME_paint5d_tex_lot
#define TEX_LOT_002  AAC2020_PIXNAME_todo_02_tex_lot
#define TEX_LOT_003  AAC2020_PIXNAME_todo_03_tex_lot

#define TEX_HAN_000  AAC2020_PIXNAME_taudepo_tex_han
#define TEX_HAN_001  AAC2020_PIXNAME_paint5d_tex_han
#define TEX_HAN_002  AAC2020_PIXNAME_todo_02_tex_han
#define TEX_HAN_003  AAC2020_PIXNAME_todo_03_tex_han

#define SAM_LOC_000  AAC2020_PIXNAME_taudepo_tex_sam.sam_loc
#define SAM_LOC_001  AAC2020_PIXNAME_paint5d_tex_sam.sam_loc
#define SAM_LOC_002  AAC2020_PIXNAME_todo_02_tex_sam.sam_loc
#define SAM_LOC_003  AAC2020_PIXNAME_todo_03_tex_sam.sam_loc

#define SAM_VAL_000  AAC2020_PIXNAME_taudepo_tex_sam.sam_val
#define SAM_VAL_001  AAC2020_PIXNAME_paint5d_tex_sam.sam_val
#define SAM_VAL_002  AAC2020_PIXNAME_todo_02_tex_sam.sam_val
#define SAM_VAL_003  AAC2020_PIXNAME_todo_03_tex_sam.sam_val

    #define TAUDEPO &( AAC2020_PIXNAME_taudepo[ 0 ] )
    #define PAINT5D &( AAC2020_PIXNAME_paint5d[ 0 ] )
    #define TODO_02 &( AAC2020_PIXNAME_todo_02[ 0 ] )
    #define TODO_03 &( AAC2020_PIXNAME_todo_03[ 0 ] )

        //:WEBGL: glCreateTexture   OPENGL: glGenTextures
           
        #define GET_TEX AAC2020_GLEBIND.glGenTextures        
        #define GET_LOC aac2020_gpudata_glGetUniformLocation  
        #define GET_VAL aac2020_gpudata_glGetUniformiv        

            #define G_G AAC2020_GLEBIND /** GL_Easy_Bindings **/
            #define C_C AAC2020_GLCONST /** GL_Constants     **/
            #define U08 uint8_t         /** GCC: <stdint.h>  **/
            #define U32 uint32_t        /** GCC: <stdint.h>  **/

//:INIT_ALL:-------------------------------------------------://
//:InitAll:--------------------------------------------------://

                         //: IIA ://
        void aac2020_gpudata_IIA_UploadTexture( 
                         //: IIA ://

            struct AAC2020_GPUDATA* gpudata /** @INIT_ALL@ **/


        ){
            /** Refactor_Of[ aa2_GPUVCON_pix_Put_Tex_Pix ]   **/
            /** IIA: InitInstanceAll                         **/
            /** AAC2020_GPUDATA_InitInstanceAll_UploadTexture**/
            
            //: Extract_Variables_From_Container:
            //:-   -   -   -   -   --==--   -   -   -   -   -://
            int  tex_lot = gpudata -> tex_lot;
            int  tex_han = gpudata -> tex_han;
            int  pix_wid = gpudata -> pix_wid;
            int  pix_hig = gpudata -> pix_hig;

            /** @SYN_VAR@[ cpu_pix ============ pix_arr ] **/
            U08*           pix_arr = gpudata -> cpu_pix; 
            //:-   -   -   -   -   --==--   -   -   -   -   -://
            //:SANITY_CHECK_CONSTANT_VALUES:-----------------://

                assert( 0x84C0 == C_C.TEXTURE0           );
                assert( 0x0DE1 == C_C.TEXTURE_2D         );
                assert( 0x2600 == C_C.NEAREST            );
                assert( 0x812F == C_C.CLAMP_TO_EDGE      );
                assert( 0x2801 == C_C.TEXTURE_MIN_FILTER );
                assert( 0x2800 == C_C.TEXTURE_MAG_FILTER );
                assert( 0x2802 == C_C.TEXTURE_WRAP_S     );
                assert( 0x2803 == C_C.TEXTURE_WRAP_T     );
                assert( 0x0CF5 == C_C.UNPACK_ALIGNMENT   );
                assert( 0x8D7C == C_C.RGBA8UI            );
                assert( 0x8D99 == C_C.RGBA_INTEGER       );
                assert( 0x1401 == C_C.UNSIGNED_BYTE      );

            //:-----------------:SANITY_CHECK_CONSTANT_VALUES://
            //:TP:Texture_Push:------------------------------://
            //:tp_tp_tp_tp_tp_tp_tp_tptp_tp_tp_tp_tp_tp_tp_tp://
            
            G_G.glActiveTexture( C_C.TEXTURE0   + tex_lot );
            G_G.glBindTexture(   C_C.TEXTURE_2D , tex_han );
            
            //: NEAREST_MIPMAP_NEAREST:
            //: gamedev.stackexchange.com/questions/158738
            U32 T_2D = C_C.TEXTURE_2D   ;
            U32 NEAR = C_C.NEAREST      ;
            U32 EDGE = C_C.CLAMP_TO_EDGE;
            
            U32 MIN_FIL = C_C.TEXTURE_MIN_FILTER;
            U32 MAG_FIL = C_C.TEXTURE_MAG_FILTER;
            U32 TWRAP_S = C_C.TEXTURE_WRAP_S;
            U32 TWRAP_T = C_C.TEXTURE_WRAP_T;
            
            G_G.glTexParameteri( T_2D, MIN_FIL , NEAR );
            G_G.glTexParameteri( T_2D, MAG_FIL , NEAR );
            G_G.glTexParameteri( T_2D, TWRAP_S , EDGE );
            G_G.glTexParameteri( T_2D, TWRAP_T , EDGE );
            
            //:Before pushing, set alignment:
            const int ALN = 4; //:ALN:"Alignment"
            G_G.glPixelStorei(C_C.UNPACK_ALIGNMENT, ALN);   
            
            //:SEE[ DOC/TEX_IMAGE_2D_NOTES.TXT ]
            G_G.glTexImage2D(  //:---------------------------://
                C_C.TEXTURE_2D         //:TARGET
            ,   0                      //:LEVEL
            ,   C_C.RGBA8UI            //:INTERNAL_FORMAT   
                //:------------------------------------------://
            ,   pix_wid                //:WIDTH  / PIX_WID
            ,   pix_hig                //:HEIGHT / PIX_HIG
            ,   0                      //:BORDER
                //:------------------------------------------://
            ,   C_C.RGBA_INTEGER       //:SOURCE_FORMAT     
            ,   C_C.UNSIGNED_BYTE      //:SOURCE_TYPE       
            ,   pix_arr //:(cpu_pix)   //:ARRAY_BUFFER_VIEW
            );//:--------------------------------------------://
            
            //:tp_tp_tp_tp_tp_tp_tp_tptp_tp_tp_tp_tp_tp_tp_tp://

            U32 err_num = AAC2020_GLEBIND.glGetError( );
            if( err_num != 0 ){
                aac2020_gpudata_Halt("[OHFUCKNOITSALLOVERMAN]");
            };;

        }

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

    void
    AAC2020_GPUDATA_InitInstanceAll( void ){

        /** #_NEW_PROGRAMS_DONT_REMOVE_OLD_TEXTURES_# **/

        if( AAC2020_GPUDATA_init_instance_all_call_count++ >0){
    
            /** glGenTextures will cause memory leak if      **/
            /** called more than once I think... But do you  **/
            /** need to regenerate textures when creating    **/
            /** a new program ?  : ANSWER: (Seems to be NO)  **/
            /**                    Programs SHARE textures.  **/
            aac2020_gpudata_Halt(
                "[ONLY_CALL_ONCE_OR_RISK_MEMORY_LEAK]"
            );;
        };;

        //:001:WIRE_IT_ALL_UP:- - - - - - - - - - - - - - - -://

            //:synonymous_texture_slots:. . . . . . . . . . .://

                assert( 0 == TEX_LOT_000 );
                assert( 1 == TEX_LOT_001 );   
                assert( 2 == TEX_LOT_002 );   
                assert( 3 == TEX_LOT_003 );   

                assert( 0 == AAC2020_PIXNAME_taudepo_tex_lot );
                assert( 1 == AAC2020_PIXNAME_paint5d_tex_lot );
                assert( 2 == AAC2020_PIXNAME_todo_02_tex_lot );
                assert( 3 == AAC2020_PIXNAME_todo_03_tex_lot );

            //:. . . . . . . . . . .:synonymous_texture_slots://
            //:generate_all_textures:. . . . . .... . . . . .://

                //:#_GENTEX_ONCE_ON_EXE_STARTUP_#://
                 
                #define ASS assert
                #define MAK_ONE ( 1 ) /* MAKE_JUST_ONE_TEXTURE*/
                #define GEN_TEX  AAC2020_GLEBIND.glGenTextures 
     
                    GEN_TEX( MAK_ONE , &( TEX_HAN_000 ) );
                    GEN_TEX( MAK_ONE , &( TEX_HAN_001 ) );
                    GEN_TEX( MAK_ONE , &( TEX_HAN_002 ) );
                    GEN_TEX( MAK_ONE , &( TEX_HAN_003 ) );

                    ASS( GEN_TEX == GET_TEX );

                    /** Check Generated Texture Handles .... **/
                    /** ------------------------------------ **/
                    ASS( TEX_HAN_001 != TEX_HAN_002 );
                    ASS( TEX_HAN_002 != TEX_HAN_003 );
                    ASS( TEX_HAN_003 != TEX_HAN_001 );
                    /** ------------------------------------ **/
                    ASS( TEX_HAN_000 != TEX_HAN_001 );
                    ASS( TEX_HAN_000 != TEX_HAN_002 );
                    ASS( TEX_HAN_000 != TEX_HAN_003 );
                    /** ------------------------------------ **/

                #undef   ASS
                #undef   MAK_ONE        
                #undef   GEN_TEX   
     
            //:. . . . . .... . . . . .:generate_all_textures://
            //:get_texture_samplers:. . . . . . . . . . . . .://

            #define PID (aac2020_graquad.data.POG_IID) 
            #define G_L  aac2020_gpudata_glGetUniformLocation
            #define G_V  aac2020_gpudata_glGetUniformiv 

            #define L_0 AAC2020_PIXNAME_taudepo_tex_sam.sam_loc
            #define L_1 AAC2020_PIXNAME_paint5d_tex_sam.sam_loc
            #define L_2 AAC2020_PIXNAME_todo_02_tex_sam.sam_loc
            #define L_3 AAC2020_PIXNAME_todo_03_tex_sam.sam_loc

            #define V_0 AAC2020_PIXNAME_taudepo_tex_sam.sam_val
            #define V_1 AAC2020_PIXNAME_paint5d_tex_sam.sam_val
            #define V_2 AAC2020_PIXNAME_todo_02_tex_sam.sam_val
            #define V_3 AAC2020_PIXNAME_todo_03_tex_sam.sam_val
 
                /* #_BAD_IDEA_001_#  (Removed From This Code) */
    
                        assert( L_0 == SAM_LOC_000 );
                        assert( L_1 == SAM_LOC_001 );
                        assert( L_2 == SAM_LOC_002 );
                        assert( L_3 == SAM_LOC_003 );

                        assert( V_0 == SAM_VAL_000 );
                        assert( V_1 == SAM_VAL_001 );
                        assert( V_2 == SAM_VAL_002 );
                        assert( V_3 == SAM_VAL_003 );

                        assert( G_L == GET_LOC     );
                        assert( G_V == GET_VAL     );

                            L_0 = G_L( PID , TAUDEPO );
                            L_1 = G_L( PID , PAINT5D );
                            L_2 = G_L( PID , TODO_02 );
                            L_3 = G_L( PID , TODO_03 );

                G_V( PID ,  L_0  , &( V_0 ) );
                G_V( PID ,  L_1  , &( V_1 ) );
                G_V( PID ,  L_2  , &( V_2 ) );
                G_V( PID ,  L_3  , &( V_3 ) );

            #undef  PID  //: . . . . . . . . . . . . . .: 01 ://
            #undef  G_L  //: . . . . . . . . . . . . . .: 02 ://
            #undef  G_V  //: . . . . . . . . . . . . . .: 03 ://
                         //: . . . . . . . . . . . . . .: -- ://
            #undef  L_0  //: . . . . . . . . . . . . . .: 04 ://
            #undef  L_1  //: . . . . . . . . . . . . . .: 05 ://
            #undef  L_2  //: . . . . . . . . . . . . . .: 06 ://
            #undef  L_3  //: . . . . . . . . . . . . . .: 07 ://
                         //: . . . . . . . . . . . . . .: -- ://
            #undef  V_0  //: . . . . . . . . . . . . . .: 08 ://
            #undef  V_1  //: . . . . . . . . . . . . . .: 09 ://
            #undef  V_2  //: . . . . . . . . . . . . . .: 10 ://
            #undef  V_3  //: . . . . . . . . . . . . . .: 11 ://

            //:. . . . . . . . . . . . .:get_texture_samplers://
                
            aac2020_gpudata_Goal("[001:WIRE_IT_ALL_UP:DONE]");
        
        //:- - - - - - - - - - - - - - - -:001:WIRE_IT_ALL_UP://
        //:002:LOAD_PIXEL_DATA:- - - - - - - - - - - - - - -:://

            /** Uploading pixels here... They'll all be black... **/
            AAC2020_VITAL_TODO( "[I_THINK_THIS_IS_A_POINTLESS_BLOCK_OF_CODE_2020_12_09]" );

        
            /**#_GPU_DATA_IS_A_TEMPORARY_HELPER_OBJECT_ONLY_#**/

            struct AAC2020_GPUDATA g0; //:TEMP_HELPER
            struct AAC2020_GPUDATA g1; //:TEMP_HELPER
            struct AAC2020_GPUDATA g2; //:TEMP_HELPER
            struct AAC2020_GPUDATA g3; //:TEMP_HELPER
        
            //: CTRL_F_HELP:---------------------------------://
            //: gupdata.tex_lot   
            //: gupdata.tex_han   
            //: gupdata.pix_wid   //#_DO_NOT_EXTRACT_COMMENT_#//
            //: gupdata.pix_hig   
            //: gupdata.pix_arr   
            //:----------------------------------:CTRL_F_HELP://

            g0.tex_lot = AAC2020_PIXNAME_taudepo_tex_lot ;
            g0.tex_han = AAC2020_PIXNAME_taudepo_tex_han ;
            g0.pix_wid = ( 512 );
            g0.pix_hig = ( 512 );
            g0.cpu_pix =&( AAC2020_PIXNAME_taudepo_cpu_pix[0] );  
        
            g1.tex_lot = AAC2020_PIXNAME_paint5d_tex_lot ;
            g1.tex_han = AAC2020_PIXNAME_paint5d_tex_han ;
            g1.pix_wid = ( 512 );
            g1.pix_hig = ( 512 );
            g1.cpu_pix =&( AAC2020_PIXNAME_paint5d_cpu_pix[0] );  
        
            //:#_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_#://
            g2.tex_lot = AAC2020_PIXNAME_todo_02_tex_lot ;
            g2.tex_han = AAC2020_PIXNAME_todo_02_tex_han ;
            g2.pix_wid = ( 512 );
            g2.pix_hig = ( 512 );
            g2.cpu_pix =&( AAC2020_PIXNAME_todo_02_cpu_pix[0] );
            
            //:#_GPUDATA_NOT_USED_YET_BUT_STILL_ALLOCATE_#://
            g3.tex_lot = AAC2020_PIXNAME_todo_03_tex_lot ;
            g3.tex_han = AAC2020_PIXNAME_todo_03_tex_han ;
            g3.pix_wid = ( 512 );
            g3.pix_hig = ( 512 );
            g3.cpu_pix =&( AAC2020_PIXNAME_todo_03_cpu_pix[0] );

            #define O_K aac2020_gpudata_Okay
            #define ERR aac2020_gpudata_Halt

                /** Smoke Test: All texture handles  **/
                /**             should be different. **/
                if( g1.tex_han == g2.tex_han  
                ||  g2.tex_han == g3.tex_han 
                ||  g3.tex_han == g1.tex_han 
                //: Compare g0 against everything:
                ||  g0.tex_han == g1.tex_han
                ||  g0.tex_han == g2.tex_han
                ||  g0.tex_han == g3.tex_han
                ){
                    ERR("[SOME_TEXTURE_HANDLES_IDENTICAL]");
                }else{
                    O_K("[SmokeTest:Texture_Handles_Differ]");
                };;

            #undef O_K
            #undef ERR
        
        /** AAC2020_GPUDATA_InitInstanceAll_UploadTexture **/
        #define UPLOAD_TEXTURE aac2020_gpudata_IIA_UploadTexture
        #define UPLOAD_TEX_ERR aac2020_gpudata_ERR_UploadTexture
        
                if( g0.tex_lot != 0 ){ UPLOAD_TEX_ERR("[G0]");};
                if( g1.tex_lot != 1 ){ UPLOAD_TEX_ERR("[G1]");};
                if( g2.tex_lot != 2 ){ UPLOAD_TEX_ERR("[G2]");};
                if( g3.tex_lot != 3 ){ UPLOAD_TEX_ERR("[G3]");};
        
                UPLOAD_TEXTURE(  &(g0)  ); //: gpu_000 ://
                UPLOAD_TEXTURE(  &(g1)  ); //: gpu_001 ://
                UPLOAD_TEXTURE(  &(g2)  ); //: gpu_002 ://
                UPLOAD_TEXTURE(  &(g3)  ); //: gpu_003 ://
        
        #undef  UPLOAD_TEXTURE
        #undef  UPLOAD_TEX_ERR
        
        aac2020_gpudata_Goal("[002:LOAD_PIXEL_DATA:DONE]");

        //::- - - - - - - - - - - - - - -:002:LOAD_PIXEL_DATA://
    
    }

//:-------------------------------------------------:INIT_ALL://
            #undef  G_G  //:............................: -- ://
            #undef  C_C  //:............................: -- ://
            #undef  U08  //:............................: -- ://
            #undef  U32  //:............................: -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
        #undef  GET_TEX  //:............................: -- ://
        #undef  GET_LOC  //:............................: -- ://
        #undef  GET_VAL  //:............................: -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
    #undef  TAUDEPO      //:............................: -- ://
    #undef  PAINT5D      //:............................: -- ://
    #undef  TODO_02      //:............................: -- ://
    #undef  TODO_03      //:............................: -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
#undef  TEX_LOT_000                         
#undef  TEX_LOT_001      //:                            : -- ://
#undef  TEX_LOT_002      //:                            : -- ://
#undef  TEX_LOT_003      //:                            : -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
#undef  TEX_HAN_000
#undef  TEX_HAN_001      //:                            : -- ://
#undef  TEX_HAN_002      //:                            : -- ://
#undef  TEX_HAN_003      //:                            : -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
#undef  SAM_LOC_000      //: TAUDEPO.sam_loc ...........: -- ://
#undef  SAM_LOC_001      //: PAINT5D.sam_loc ...........: -- ://
#undef  SAM_LOC_002      //: TODO_02.sam_Loc ...........: -- ://
#undef  SAM_LOC_003      //: TODO_03.sam_Loc ...........: -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
#undef  SAM_VAL_000
#undef  SAM_VAL_001      //:                            : -- ://
#undef  SAM_VAL_002      //:                            : -- ://
#undef  SAM_VAL_003      //:                            : -- ://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - -: -- ://
#undef  INI_ALL_ERR      //:                            : -- ://
//:--------------------------------------------------:InitAll://
//:=================================================:INIT_ALL://
//:INSTANCE_INITIALIZER:=====================================://
#define GPUDATA struct AAC2020_GPUDATA
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_GPUDATA_InitInstance( GPUDATA* gpudata )
    {
        /** Named "InitInstance" and NOT "InstanceInit"  * * **/
        /** So what if you CTRL+F for "GPUDATA_Init"     * * **/
        /** You will find "GPUDATA_InitInstance"         * * **/
        /** The real work happens in: InitInstanceAll(...)   **/

        /** We should never init instances of GPUDATA        **/
        /** Because they are just temporary vessels for      **/
        /** file-scope variables in PIXNAME                  **/

        if( gpudata ){ /** NOOP **/ };
        aac2020_gpudata_Halt("[NEVER_CALL_ME_EVER_AGAIN:2020]");


        return( 0x00 );
    }

#undef  U32
#undef  GPUDATA
//:=====================================:INSTANCE_INITIALIZER://
//:TEST_CODE:================================================://
#define U08 uint8_t  /** GCC: <stdint.h> **/
#define U32 uint32_t /** GCC: <stdint.h> **/
#define PIX struct AAC2020_GPUDATA

    //:TEST_CODE:COORDINATE_CONVERSION:======================://
    #define MAX ((512*512*4)-1) /** MAX COMPONENT INDEX **/
    #define M_X ((     512 )-1) /** MAX PIXEL     INDEX **/
    #define M_Y ((     512 )-1) /** MAX PIXEL     INDEX **/

        U32
        AAC2020_GPUDATA_Test_Coordinate_Conversion( void )
        {
            /**  Test component indexes. These are NOT the   **/
            /**  same thing as pixel indexes. The index      **/
            /**  represents the red component of whatever    **/
            /**  pixel you are trying to grab.               **/

            U32 d_1; //:Component Index #1
            U32 d_2; //:Component Index #2

            U32 p1x;
            U32 p1y;

            U32 p2x;
            U32 p2y;

            /** Increments by 4 because each component index **/
            /** Should be the first element of our RGBA      **/
            /** chunk of bytes.                              **/
            for( d_1 = 0; d_1 <= MAX;  (((d_1 += 4)))  ){

                if( d_1 % 4 != 0 ){
                    printf("[d_1]:%d\n", d_1 );
                    fflush(stdout);
                    aac2020_gpudata_Halt("[ALREADY_FUCKED]");
                };;

                AAC2020_GPUDATA_com_dex_CTO_p_x_p_y(
                    d_1, &p1x , &p1y
                );;
      
                d_2 = AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                          p1x , p1y
                );;

                if( d_2 != d_1 ){

                    printf("[d_1<>d_2]...\n");

                    printf("\n");

                    printf("[d_1]:%d\n", d_1 );
                    printf("[d_2]:%d\n", d_2 );

                    printf("\n");

                    printf("[p1x]:%d\n", p1x );
                    printf("[p1y]:%d\n", p1y );

                    printf("\n");

                    fflush(stdout);

                    aac2020_gpudata_Halt("[D1D2:FAIL]");
                };;
            };;

            for( p1x = 0; p1x <= M_X; p1x++ ){
            for( p1y = 0; p1y <= M_Y; p1y++ ){

                d_1 = AAC2020_GPUDATA_p_x_p_y_CTO_com_dex(
                                      p1x,p1y             );;

                
                if( d_1 % 4 != 0 ){
                    printf("[d_1]:%d\n" , d_1 );
                    fflush(stdout);
                    aac2020_gpudata_Halt("[ALREADY_WRONG]");
                };;

                AAC2020_GPUDATA_com_dex_CTO_p_x_p_y(
                                    d_1  , &p2x,&p2y
                );;
      
                if( p1x != p2x ){
                    aac2020_gpudata_Halt("[PT_X:FAIL]");
                };;
                if( p1y != p2y ){
                    aac2020_gpudata_Halt("[PT_Y:FAIL]");
                };;
            };;};;
           
            return( 0x00 );
        }

    #undef  M_X
    #undef  M_Y
    #undef  MAX
    //:======================:TEST_CODE:COORDINATE_CONVERSION://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    AAC2020_GPUDATA_Test_CPU_Only( PIX* pix )
    {

        U32 com    = 0;
        U32 com_max=( ( 512 * 512 * 4 ) - 1 );

        U32 p_x;
        U32 p_y;

        U08 r_1;
        U08 g_1;
        U08 b_1;
        U08 a_1;

        U08 r_2;
        U08 g_2;
        U08 b_2;
        U08 a_2;

        //:ALMOST_IDENTICAL_LOOPS:===========================://

            /** The difference in these two loops is in  * * **/
            /** how "p_x" and "p_y" are derived.         * * **/
            /** Everything else should be the same.      * * **/

            //:HELP_ASSURE_LOOPS_ARE_SAME:===================://
            U32 loop_times_loop_0001 =( 0 );
            U32 loop_times_loop_0002 =( 0 );
            U32 loop_check_sums_0001 =( 0 );
            U32 loop_check_sums_0002 =( 0 );
            //:===================:HELP_ASSURE_LOOPS_ARE_SAME://
            //:LOOP_0001:====================================://
            for( p_x = 0; p_x <= (512 - 1); p_x ++ ){
            for( p_y = 0; p_y <= (512 - 1); p_y ++ ){

                r_1 =   p_x         % 255;
                g_1 =   p_y         % 255;
                b_1 = ( p_x + p_y ) % 255;
                a_1 = ( p_x * p_y ) % 255;

                AAC2020_GPUDATA_PutPixelOnCPU_RGBA(
                    pix, p_x, p_y,  r_1 ,  g_1 ,  b_1 ,  a_1
                );;

                AAC2020_GPUDATA_GetPixelOnCPU_RGBA(
                    pix, p_x, p_y, &r_2 , &g_2 , &b_2 , &a_2
                );;

                #define H aac2020_gpudata_Halt
                if( r_1 != r_2 ){ H("[AYE:R_1!=R_2]"); };
                if( g_1 != g_2 ){ H("[AYE:G_1!=G_2]"); };
                if( b_1 != b_2 ){ H("[AYE:B_1!=B_2]"); };
                if( a_1 != a_2 ){ H("[AYE:A_1!=A_2]"); };
                #undef  H

                loop_times_loop_0001++;
                loop_check_sums_0001=( r_1+g_1+b_1+a_1 );

            };;};; //:=============================:LOOP_0001://
            //:LOOP_0002:====================================://
            for( com = 0; com <= com_max; ((( com += 4 ))) ){

                if( com % 4 != 0 ){
                    printf("[com]:%d\n" , com );
                    fflush(stdout);
                    aac2020_gpudata_Halt("[YOUVE_BEEN_HAD]");
                };;
                    
                AAC2020_GPUDATA_com_dex_CTO_p_x_p_y(
                    com, &p_x, &p_y 
                );;

                r_1 =   p_x         % 255;
                g_1 =   p_y         % 255;
                b_1 = ( p_x + p_y ) % 255;
                a_1 = ( p_x * p_y ) % 255;

                AAC2020_GPUDATA_PutPixelOnCPU_RGBA(
                    pix, p_x, p_y,  r_1 ,  g_1 ,  b_1 ,  a_1
                );;

                AAC2020_GPUDATA_GetPixelOnCPU_RGBA(
                    pix, p_x, p_y, &r_2 , &g_2 , &b_2 , &a_2
                );;

                #define H aac2020_gpudata_Halt
                if( r_1 != r_2 ){ H("[BEE:R_1!=R_2]"); };
                if( g_1 != g_2 ){ H("[BEE:G_1!=G_2]"); };
                if( b_1 != b_2 ){ H("[BEE:B_1!=B_2]"); };
                if( a_1 != a_2 ){ H("[BEE:A_1!=A_2]"); };
                #undef  H

                loop_times_loop_0002++;
                loop_check_sums_0002=( r_1+g_1+b_1+a_1 );

            };; //:================================:LOOP_0002://
            //:HELP_ASSURE_LOOPS_ARE_SAME:===================://
            if( loop_times_loop_0001 != loop_times_loop_0002 ){
                aac2020_gpudata_Halt("[LOOP_TIMES_FAIL]");
            };;
            if( loop_check_sums_0001 != loop_check_sums_0002 ){
                aac2020_gpudata_Halt("[CHECK_SUMS_FAIL]");
            };;
            //:===================:HELP_ASSURE_LOOPS_ARE_SAME://

        //:===========================:ALMOST_IDENTICAL_LOOPS://

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    AAC2020_GPUDATA_Test_CPU_AND_GPU(

        struct AAC2020_GPUDATA * pix

    )
    {
        if( pix ){ /** NOOP **/ };

        //:This would require setting up an openGL
        //:texture using struct AAC2020_GPUDATA
        //:
        //:We would need a routine to wire up to GPU.
        //:Does such routine belong in "GPUDATA"....
        //:
        //:Yes, I think so.

        //:TODO

        //: Calling: "AAC2020_GPUDATA_ApplyChangesToGPU()"
        //: After setting pixels is a necessity to properly
        //: test this.

        AAC2020_MAYBE_TODO( "[VITAL_TODO_2020_11_14]" );

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    AAC2020_GPUDATA_TestAll()
    {

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        /** For lifetime of function only. For testing. **/
        PIX pix = {0};
        U08 cpu_pix[ 512 * 512 * 4 ]={ 0 };
        pix.cpu_pix=&( cpu_pix[0] );

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        AAC2020_GPUDATA_Test_Coordinate_Conversion();

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        /** TEST CPU(Host) Before GPU(Device)  * * * * * * * **/

        AAC2020_GPUDATA_Test_CPU_Only( &pix );

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        /** Testing of GPU will require using texture    * * **/
        /** querying functions on CPU side that we would * * **/
        /** normally NOT use because they violate        * * **/
        /** the entire purpose of keeping a seperate     * * **/
        /** copy on CPU and GPU.                         * * **/

        AAC2020_GPUDATA_Test_CPU_AND_GPU( &pix );

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef U08
#undef U32
#undef PIX
//:================================================:TEST_CODE://
//:LIBRARY_INIT_FUNCTION:====================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_GPUDATA_Init( U32 u32 )
    {
        if( u32 ){ /** Reserved For Future Use **/ };

        AAC2020_VITAL_TODO("[FIND_BUG_IN_InitInstanceAll]");

        //: Initialize all data allocations defined          ://
        //: in[ AAC2020_PIXNAME ]. This does mean that       ://
        //: this( InitInstanceAll )code knows about the      ://
        //: FUTURE, which is a violation of the LIBCHAN      ://
        //: idea of layering on things over time. However,   ://
        //: the benifit of having a centralized location of  ://
        //: data allocations outweighs the rule breaking.    ://
        AAC2020_GPUDATA_InitInstanceAll();

        /** ************************************************ **/
        /** Unit Test should be called in the init function  **/
        /** So that testing code is force on startup.        **/
        /** Removing test code (if ever) should be saved     **/
        /** for long down the road when we have a final      **/
        /** product.                                         **/
        /**                                                  **/
        /** In the mean time, make it a PAIN IN THE ASS      **/
        /** to avoid running tests. Because everything in    **/
        /** this world takes the path of least resistance.   **/
        /**                                                  **/
        /** As above, so below. As below, so above.          **/
        /**                                                  **/
        /**     ABOVE: Laws Of Physics                       **/
        /**     BELOW: Laws Of Mental Effort                 **/
        /**                                                  **/    
        /** ************************************************ **/
        aac2020_gpudata_Okay("[ABOUT_TO_ENTER:TestAll]");
        AAC2020_GPUDATA_TestAll();

        return( 0x00 );
    }

#undef  U32
//:==========================================================://
//:CLEANUP_YOUR_MACRO_MESS:==================================://


    #undef  PIX_R_G_B_A
    #undef  PIX_P_X_P_Y


//:==================================:CLEANUP_YOUR_MACRO_MESS://
//[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
//#######: INSTANCES OF AAC2020_GPUDATA DO NOT BELONG :#######//
//#######: IN [ GPUDATA.D._ ]OR[ GPUDATA.H._ ]        :#######//
//#######: SEE[ DOC/WHY_NO_INSTANCES_IN_GPUDATA.TXT ] :#######//
//[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
