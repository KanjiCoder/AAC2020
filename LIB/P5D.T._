//:SECTION_UNIT_TEST:========================================://
//:UNIT_TEST_SECTION:========================================://
#define MAX_EXP AAC2020_PAINT5D_MAX_til_exp           //: 01 ://
#define EXT      extern                               //: 02 ://
#define VOD        void                               //: 03 ://
#define I08      int8_t /** GCC: <stdint.h> **/       //: 04 ://
#define U08     uint8_t /** GCC: <stdint.h> **/       //: 05 ://
#define I16     int16_t /** GCC: <stdint.h> **/       //: 06 ://
#define U16    uint16_t /** GCC: <stdint.h> **/       //: 07 ://
#define I32     int32_t /** GCC: <stdint.h> **/       //: 08 ://
#define U32    uint32_t /** GCC: <stdint.h> **/       //: 09 ://
#define ERR     aac2020_paint5d_Halt                  //: 10 ://
#define LOG     aac2020_paint5d_Info_any              //: 11 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    aac2020_paint5d_UnitTest( U32 u32 )
    {
        if( u32 ){  /** Reserved For Future Use **/  };
        LOG("[BEG:aac2020_paint5d_UnitTest...]",((void*)0));

        /** ************************************************ ***
            ProgControls: 
                Progmattic functions that the end user does
                not directly interface with.

            TestControls: @VID_IID[ 0076 ]T[ 4H 56M 15S ]
                These are controls that may fit into
                the "ProgControls" or the "UserControls"
                category. But the MAIN THING about them
                is that they have been created in order
                to effectively test our "UserControls"
                section. Thus must be called AFTER
                "ProgControls" and BEFORE "UserControls"
            
            UserControls:
                Functions that are directly or near
                directly called as the result of 
                user input such as key presses.
    
                For example( S ):
                    aac2020_paint5d_ToggleTile
                    aac2020_paint5d_MoveBrush_XY
        *** ************************************************ **/
        //:SYSTEM_DATA:BACKUP:-------------------------------://

            /** taudirt : AAC2020_TAUDIRT_DIR_ANY            **/
            /** taudepo : AAC2020_PIXNAME_taudepo_cpu_pix    **/
            /** paint5d : AAC2020_PIXNAME_paint5d_cpu_pix    **/
                                                             
            U08* taudirt =((void*)0); /** DIRTY   TREE       **/
            U08* taudepo =((void*)0); /** USED    SYSTEM     **/
            U08* paint5d =((void*)0); /** CURRENT SYSTEM     **/
            
            AAC2020_PAINT5D_Backup_taudirt( &(taudirt) );
            AAC2020_PIXBACK_Backup_taudepo( &(taudepo) );
            AAC2020_PIXBACK_Backup_paint5d( &(paint5d) );

            AAC2020_TODOMAN_Vital(
                "[FIX:taudirt_backup_is_invalid_back_reference]"
            );;

        //:-------------------------------:SYSTEM_DATA:BACKUP://
        //:RUN_UNIT_TESTS:-----------------------------------://

            aac2020_paint5d_CTS="[____ProgControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_ProgControls( VOD );
            aac2020_paint5d_UnitTest_ProgControls(     );

            aac2020_paint5d_CTS="[____TestControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_TestControls( VOD );
            aac2020_paint5d_UnitTest_TestControls(     );

            aac2020_paint5d_CTS="[____UserControls____]";
            EXT VOD 
            aac2020_paint5d_UnitTest_UserControls( VOD );
            aac2020_paint5d_UnitTest_UserControls(     );

        //:-----------------------------------:RUN_UNIT_TESTS://
        //:SYSTEM_DATA:RESTORE:------------------------------://
            //:assert_different_pointers:--------------------://

                assert( taudirt != taudepo );
                assert( taudirt != paint5d );

                assert( taudepo != taudirt );
                assert( taudepo != paint5d );

                assert( paint5d != taudirt );
                assert( paint5d != taudepo );

            //:--------------------:assert_different_pointers://
            //:more_asserts_and_data_restore:----------------://

                /** @VID_IID[ 0075 ]TIME[ 00H 58M 55S ] **/
                assert( ((void*)0) != taudirt );
                assert( ((void*)0) != taudepo );
                assert( ((void*)0) != paint5d );

                AAC2020_PAINT5D_Restore_taudirt( &(taudirt) );
                AAC2020_PIXBACK_Restore_taudepo( &(taudepo) );
                AAC2020_PIXBACK_Restore_paint5d( &(paint5d) );

                /** @VID_IID[ 0075 ]TIME[ 00H 57M 05S ] **/
                assert( ((void*)0) == taudirt );
                assert( ((void*)0) == taudepo );
                assert( ((void*)0) == paint5d );

            //:----------------:more_asserts_and_data_restore://
        //:------------------------------:SYSTEM_DATA:RESTORE://

        LOG("[END:aac2020_paint5d_UnitTest...]",((void*)0));
        return( 0x00 );
    }
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void aac2020_paint5d_UnitTest_TestControls( void )
    {
        /** @VID_IID[ 0076 ]TIME[ 5H 00M 00S ]               **/
        /** Even if these eventually get wired into          **/
        /** our user controls, they will FOREVER stay        **/
        /** in the "TestControls" category, because that     **/
        /** is what they were initially created for and      **/
        /** also I am lazy and don't see much utility        **/
        /** to refactoring my unit test code for             **/
        /** a NON CODE BREAKING CHANGES                      **/

        aac2020_paint5d_CTF=(     "[Put_BrushState]"          );
        EXT VOD aac2020_paint5d_UTC_Put_BrushState(    void   );
                aac2020_paint5d_UTC_Put_BrushState(/** void**/);

        aac2020_paint5d_CTF=(     "[Put_UsingBrush]"          );
        EXT VOD aac2020_paint5d_UTC_Put_UsingBrush(    void   );
                aac2020_paint5d_UTC_Put_UsingBrush(/** void**/);

    }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_BrushState( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/ 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i =( ROW_S - 1 ); //:m_i: Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]

                    We are NOT going to create a 
                    aac2020_paint5d_Get_BrushState(...)
                    function to help test this code...

                    Because aac2020_paint5d_Put_BrushState
                    itself was created as a HELPER function
                    to help run UNIT TEST code.
                    
                    This has already spiraled enough
                    out of control. I don't want a 
                    Helper function for my helper function
                    that helps test my unit test code
                    for my actual function.
            
                    --------------------------------------------
                    Is this out of control
                    deductive reasonsing?

                    Or is it... "inductive reasoning?"

                    Or is it just "backwards reasoning"
                    because it is a linear chain?
                    --------------------------------------------
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_358AM]");

                    };;

                //:test_table_members:---------------:__chk__://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_Put_UsingBrush( void )
        {
        #define ROW_S ( 24 + 1 ) //:Number_Of_Tests
        #define COL_S (      7 ) //:Num_Elements_In_One_Test

            //:declare:unused_vars:--------------------------://


                U32 u1 ; /** Unused #1 **/
                U32 u2 ; /** Unused #2 **/
                U32 u3 ; /** Unused #3 **/

            //:--------------------------:declare:unused_vars://
            //:declare:iterator_vars:------------------------://
            //:( iterator_vars as in loop_variables )::::::::://

                I32 t_i ; //:Test_Index
                I32 m_i ; //:Max__Index (Max_Test_Index)
                I32 bas ; //:Base_Offset_To_Current_Test_Vals

            //:::::::::( iterator_vars as in loop_variables )://
            //:------------------------:declare:iterator_vars://
            //:declare:test_table_members:-------------------://

                U08     t_q ; //: 01 : til_qua ://
                U08     t_e ; //: 02 : til_exp ://
                U08     t_l ; //: 03 : til_lay ://
                U08     l_x ; //: 04 : loc_t_x ://
                U08     l_y ; //: 05 : loc_t_y ://
                U08     a_d ; //: 06 : aus_dex ://
                U08     t_v ; //: 07 : til_val ://

            //:-------------------:declare:test_table_members://
            //:declare:actual_gotten_values:-----------------://

                U32 GOT_t_q ; //: 01 : til_qua ://
                U32 GOT_t_e ; //: 02 : til_exp ://
                U32 GOT_t_l ; //: 03 : til_lay ://
                U32 GOT_l_x ; //: 04 : loc_t_x ://
                U32 GOT_l_y ; //: 05 : loc_t_y ://
                U32 GOT_a_d ; //: 06 : aus_dex ://
                U32 GOT_t_v ; //: 07 : til_val ://

            //:-----------------:declare:actual_gotten_values://
            //:declare:vars_for:AAC2020_PAINT5D_Get:---------://

            /** @VID_IID[ 0083 ]TIME[ 05:28:32 ]             **/
            /** Most of these are commented out because      **/
            /** we decided NOT to create a                   **/
            /** aac2020_paint5d_Get_BrushState(...) func.    **/

            /// U08 til_qua =( 204 );  //: 01 : t_q ://
            /// U08 til_exp =( 204 );  //: 02 : t_e ://
            /// U08 til_lay =( 204 );  //: 03 : t_l ://
            /// U08 loc_t_x =( 204 );  //: 04 : l_x ://
            /// U08 loc_t_y =( 204 );  //: 05 : l_y ://
            /// U08 aus_dex =( 204 );  //: 06 : a_d ://
                U08 til_val =( 204 );  //: 07 : t_v ://

            //:---------:declare:vars_for:AAC2020_PAINT5D_Get://

            U08 tab_utc[ ROW_S * COL_S ]={
        //:   001   002   003   004   005   006   007
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        /**/  0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 //: 00 ://
  
            /** Using maximum values for all fields,  ...... **/
            /** Even the Local XY coord (l_x, l_y)    ...... **/
            ,   3 ,   7 ,   2 ,   0 ,   0 ,  15 ,   3 //: 01 ://
            ,   3 ,   6 ,   2 ,   1 ,   1 ,  15 ,   3 //: 02 ://
            ,   3 ,   5 ,   2 ,   3 ,   3 ,  15 ,   3 //: 03 ://
            ,   3 ,   4 ,   2 ,   7 ,   7 ,  15 ,   3 //: 04 ://
            ,   3 ,   3 ,   2 ,  15 ,  15 ,  15 ,   3 //: 05 ://
            ,   3 ,   2 ,   2 ,  31 ,  31 ,  15 ,   3 //: 06 ://
            ,   3 ,   1 ,   2 ,  63 ,  63 ,  15 ,   3 //: 07 ://
            ,   3 ,   0 ,   2 , 127 , 127 ,  15 ,   3 //: 08 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-X(s) (l_x)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 , 0x0 ,   0 ,  15 ,   3 //: 09 ://
            ,   3 ,   6 ,   2 , 0x0 ,   1 ,  15 ,   3 //: 10 ://
            ,   3 ,   5 ,   2 , 0x0 ,   3 ,  15 ,   3 //: 11 ://
            ,   3 ,   4 ,   2 , 0x0 ,   7 ,  15 ,   3 //: 12 ://
            ,   3 ,   3 ,   2 , 0x0 ,  15 ,  15 ,   3 //: 13 ://
            ,   3 ,   2 ,   2 , 0x0 ,  31 ,  15 ,   3 //: 14 ://
            ,   3 ,   1 ,   2 , 0x0 ,  63 ,  15 ,   3 //: 15 ://
            ,   3 ,   0 ,   2 , 0x0 , 127 ,  15 ,   3 //: 16 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            /** Previous Test But all local-Y(s) (l_y)    ...**/
            /** Are zero to detect transposition errors.  ...**/
            ,   3 ,   7 ,   2 ,   0 , 0x0 ,  15 ,   3 //: 17 ://
            ,   3 ,   6 ,   2 ,   1 , 0x0 ,  15 ,   3 //: 18 ://
            ,   3 ,   5 ,   2 ,   3 , 0x0 ,  15 ,   3 //: 19 ://
            ,   3 ,   4 ,   2 ,   7 , 0x0 ,  15 ,   3 //: 20 ://
            ,   3 ,   3 ,   2 ,  15 , 0x0 ,  15 ,   3 //: 21 ://
            ,   3 ,   2 ,   2 ,  31 , 0x0 ,  15 ,   3 //: 22 ://
            ,   3 ,   1 ,   2 ,  63 , 0x0 ,  15 ,   3 //: 23 ://
            ,   3 ,   0 ,   2 , 127 , 0x0 ,  15 ,   3 //: 24 ://
        //:   t_q | t_e | t_l | l_x | l_y | a_d | t_v
        //:   001   002   003   004   005   006   007
            };;

            m_i = ( ROW_S - 1 ); //:Max_test_Index
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                //:get_base_address_of_test_row:-------------://

                    bas = ( t_i * COL_S );

                //:-------------:get_base_address_of_test_row://
                //:extract:test_table_members:---------------://

                    t_q = tab_utc[ bas + 0 ];
                    t_e = tab_utc[ bas + 1 ];
                    t_l = tab_utc[ bas + 2 ];
                    l_x = tab_utc[ bas + 3 ];
                    l_y = tab_utc[ bas + 4 ];
                    a_d = tab_utc[ bas + 5 ];
                    t_v = tab_utc[ bas + 6 ];

                    if( t_q >=   4 ){ ERR("[BAD__t_q__2021]");};
                    if( t_e >=   8 ){ ERR("[BAD__t_e__2021]");};
                    if( t_l >=   3 ){ ERR("[BAD__t_l__2021]");};
                    if( l_x >= 128 ){ ERR("[BAD__l_x__2021]");};
                    if( l_y >= 128 ){ ERR("[BAD__l_y__2021]");};
                    if( a_d >=  16 ){ ERR("[BAD__a_d__2021]");};
                    if( t_v >=   4 ){ ERR("[BAD__t_v__2021]");};

                //:---------------:extract:test_table_members://
                //:__use__:test_table_members:---------------://
                //:__put__:test_table_members:---------------://

                    aac2020_paint5d_Put_BrushState(
                        (I32) t_q     //: I32 : til_qua : 01 ://
                    ,   (I32) t_e     //: I32 : til_exp : 02 ://
                    ,   (I32) t_l     //: I32 : til_lay : 03 ://
                    ,   (I32) l_x     //: I32 : loc_t_x : 04 ://
                    ,   (I32) l_y     //: I32 : loc_t_y : 05 ://
                    ,   (I32) a_d     //: I32 : aus_dex : 06 ://
                    ,   (I32) t_v     //: I32 : til_val : 07 ://
                    );;

                //:---------------:__put__:test_table_members://
                //:---------------:__use__:test_table_members://
                //:__get__:test_table_members:---------------://
                /** **************************************** ***
                    @VID_IID[ 0077 ]TIME[ 1H 12M 25S ]
                    COPIDED_FROM: 
                    aac2020_paint5d_UTC_Put_BrushState
                *** **************************************** **/
                    //:--------------------------------------://
                    //:INLINED:aac2020_paint5d_Get_BrushState://
                    //:--------------------------------------://
                    #define TAU AAC2020_TAUDEPO.TAU_015 // 01 //
                    #define P5D AAC2020_TAUDEPO.PAINT5D // 02 //
                    #define T_D AAC2020_TAUDEPO         // 03 //

                        /** ******************************** ***
                        @VID_IID[ 0077 ]TIME[ 1H 37M 25S ]
                        #_WHY_IS_P5D_GET_BS_INLINED_HERE_#
                        *** ******************************** **/

                        AAC2020_TAUDEPO_Get(     ///        001
                            TAU,P5D,T_D.P5D_T_Q  //:DEX,SUB,VAR
                        ,  &(GOT_t_q),&(u1),&(u2),&(u3) /// T_Q
                        );;

                        AAC2020_TAUDEPO_Get(     ///        002        
                            TAU,P5D,T_D.P5D_T_E  //:DEX,SUB,VAR
                        ,  &(GOT_t_e),&(u1),&(u2),&(u3) /// T_E
                        );;

                        AAC2020_TAUDEPO_Get(     ///        003         
                            TAU,P5D,T_D.P5D_T_L  //:DEX,SUB,VAR
                        ,  &(GOT_t_l),&(u1),&(u2),&(u3) /// T_L
                        );;

                        AAC2020_TAUDEPO_Get(     ///        004         
                            TAU,P5D,T_D.P5D_B_X  //:DEX,SUB,VAR
                        ,  &(GOT_l_x),&(u1),&(u2),&(u3) /// B_X
                        );; //:  l_x == b_x #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        005         
                            TAU,P5D,T_D.P5D_B_Y  //:DEX,SUB,VAR
                        ,  &(GOT_l_y),&(u1),&(u2),&(u3) /// B_Y
                        );; //:  l_y == b_y #PATTERN_BREAKER#://

                        AAC2020_TAUDEPO_Get(     ///        006         
                            TAU,P5D,T_D.P5D_A_D  //:DEX,SUB,VAR
                        ,  &(GOT_a_d),&(u1),&(u2),&(u3) /// A_D
                        );;

                        AAC2020_TAUDEPO_Get(     ///        007        
                            TAU,P5D,T_D.P5D_T_V  //:DEX,SUB,VAR
                        ,  &(GOT_t_v),&(u1),&(u2),&(u3) /// T_V
                        );;

                    #undef  TAU                       //: 01 ://
                    #undef  P5D                       //: 02 ://
                    #undef  T_D                       //: 03 ://
                    //:--------------------------------------://
                    //:aac2020_paint5d_Get_BrushState:INLINED://
                    //:--------------------------------------://

                //:---------------:__get__:test_table_members://
                //:__chk__:test_table_members:---------------://

                    if( 0
                    ||  ( (U08)GOT_t_q ) != t_q
                    ||  ( (U08)GOT_t_e ) != t_e
                    ||  ( (U08)GOT_t_l ) != t_l
                    ||  ( (U08)GOT_l_x ) != l_x
                    ||  ( (U08)GOT_l_y ) != l_y
                    ||  ( (U08)GOT_a_d ) != a_d
                    ||  ( (U08)GOT_t_v ) != t_v
                    ){

                        /**   UTF:Unit_Test_Fail  **/
                        ERR("[UTF_2021_01_06_410AM]");

                    };;

                //:test_table_members:---------------:__chk__://
                //:ACTUALLY_PUT_USING_THE_BRUSH_STATE:-------://

                    aac2020_paint5d_Put_UsingBrush( );

                //:-------:ACTUALLY_PUT_USING_THE_BRUSH_STATE://
                //:FETCH_TILE_VALUE_PUT:---------------------://


                     AAC2020_PAINT5D_Get(
                           t_q      /** t_q | til_qua : 01 : **/
                     ,     t_e      /** t_e | til_exp : 02 : **/
                     ,     t_l      /** t_l | til_lay : 03 : **/
                     ,     l_x      /** l_x | loc_t_x : 04 : **/
                     ,     l_y      /** l_y | loc_t_y : 05 : **/
                     ,     a_d      /** a_d | aus_dex : 06 : **/
                     , &(til_val)   /** t_v | til_val : 07 : **/
                     );;
    
                    if( til_val != t_v ){
                        ERR("[TIL_VAL_NOT_EQUAL_TO_T_V_2021]");
                    };;

                ///// @VID_IID[ 0083 ]TIME[ 05:23:28 ]
                ///// THIS CODE IS WRONG, close to right...
                /////
                /////    /** get a value encoded in the **/
                /////    /** [bitmap/texture] data      **/
                /////
                /////        AAC2020_PAINT5D_Get(
                /////            til_qua   /** t_q : 01 : **/
                /////        ,   til_exp   /** t_e : 02 : **/
                /////        ,   til_lay   /** t_l : 03 : **/
                /////        ,   loc_t_x   /** l_x : 04 : **/
                /////        ,   loc_t_y   /** l_y : 05 : **/
                /////        ,   aus_dex   /** a_d : 06 : **/
                /////        , &(til_val)  /** t_v : 07 : **/
                /////        );;
                /////
                /////    /** check that proper value was    **/
                /////    /** encoded in the [bitmap/texture **/
                /////
                /////        if( 0
                /////        || til_qua != t_q /** : 01 : **/
                /////        || til_exp != t_e /** : 02 : **/
                /////        || til_lay != t_l /** : 03 : **/
                /////        || loc_t_x != l_x /** : 04 : **/
                /////        || loc_t_y != l_y /** : 05 : **/
                /////        || aus_dex != a_d /** : 06 : **/
                /////        || til_val != t_v /** : 07 : **/
                /////        ){
                /////            ERR("[DO_DRAGONS_LIKE_GOLD_2021]");
                /////        };;
      
                //:---------------------:FETCH_TILE_VALUE_PUT://

            };; //:NEXT[ t_i ]

        #undef  ROW_S  
        #undef  COL_S  
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : TESTCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UnitTest_UserControls( void )
        {
        #define CTF aac2020_paint5d_CTF

            CTF=("[aac2020_paint5d_UTC_MoveCamera_XY]");
            EXT VOD 
            aac2020_paint5d_UTC_MoveCamera_XY( VOD );
            aac2020_paint5d_UTC_MoveCamera_XY(     );

            CTF=("[aac2020_paint5d_UTC_ZoomCamera]");
            EXT VOD 
            aac2020_paint5d_UTC_ZoomCamera( VOD );
            aac2020_paint5d_UTC_ZoomCamera(     );

            CTF=("[aac2020_paint5d_UTC_MoveBrush_XY]");
            EXT VOD 
            aac2020_paint5d_UTC_MoveBrush_XY( VOD );
            aac2020_paint5d_UTC_MoveBrush_XY(     );

            CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileValue]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileValue( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileValue(     );

        CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileExponent]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileExponent( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileExponent(     );

            CTF=("[aac2020_paint5d_UTC_DeltaMutate_TileLayer]");
            EXT VOD 
            aac2020_paint5d_UTC_DeltaMutate_TileLayer( VOD );
            aac2020_paint5d_UTC_DeltaMutate_TileLayer(     );

            CTF=("[aac2020_paint5d_UTC_ToggleTile]");
            EXT VOD 
            aac2020_paint5d_UTC_ToggleTile( VOD );
            aac2020_paint5d_UTC_ToggleTile(     );
    
        #undef CTF
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveCamera_XY( void )
        {
        #define NUMBER_OF_TESTS ( 3 )
        #define NUMBER_OF_TEST_ELEMENTS ( 10 )
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 inn_x_0 ; /** INPUTS: Camera Rectangle **/
                U32 inn_x_1 ;
                U32 inn_y_0 ;
                U32 inn_y_1 ;
                            ;
                U32 tra_i_x ; /** INPUTS: Camera Translation **/
                U32 tra_i_y ;
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** **************************************** ***
                    @VID_IID[ 0076 ]TIME[ 1H 58M 30S ]

                    weird_names_because: 
                    We kept confusing

                         "Input And Output"
                    With "Expected And Actual"

                    And tangling our mental understanding
                    between the pairs of words.
                ** ***************************************** **/

                U32 O_A_x_0 ; /** OUTPUTS: Camera Rectangle  **/
                U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL values**/      
                U32 O_A_y_0 ;
                U32 O_A_y_1 ;
                            ;
                U32 exp_x_0 ; /** EXPECTED : Camera Rectangle**/
                U32 exp_x_1 ; /**                            **/
                U32 exp_y_0 ;
                U32 exp_y_1 ;

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://


            /** @VID_IID[ 0076 ]TIME[ 0H 59M 30S ]           **/
            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/

            /** PAB == "position and bounds" **/

            /** @VID_IID[ 0076 ]TIME[ 0H 56M 0S ] . . . . . .**/
            /** First 3 Tests are dead simple.    . . . . . .**/
            U32 tab_utc[ 
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
            0x00,0x00,0x00,0x00 , 0x00,0x00, 0x00,0x00,0x00,0x00
        ,   0x00,0x00,0x00,0x00 ,    1,0x00,    1,   1,0x00,0x00
        ,   0x00,0x00,0x00,0x00 , 0x00,   1, 0x00,0x00,   1,   1
        //: STARTING_CAMERA_PAB   TRANSLATE  ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                tra_i_x = tab_utc[ bas + 4 ]; /**Translation **/
                tra_i_y = tab_utc[ bas + 5 ]; /**Integer:X&Y **/
 
                exp_x_0 = tab_utc[ bas + 6 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 7 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 8 ];
                exp_y_1 = tab_utc[ bas + 9 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 1H 10M 16S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveCamera_XY(
                        tra_i_x  //: Trans:DATAPIXELS: X
                    ,   tra_i_y  //: Trans:DATAPIXELS: Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){

                        failed_unit_test=( 1 );

                        /** ******************************** **/
                        /** @VID_IID[ 02H 13M 20S ]          **/
                        /** We originally decided rectangle  **/
                        /** manipulation was bounded into a  **/
                        /** 512x512 region. However for      **/
                        /** PAINT5D system the camera        **/
                        /** rectangle has a tighter          **/
                        /** 256x256 bounds.                  **/
                        /** SEE[ #_P5D_BOUNDING_#  ]         **/
                        /** ******************************** **/
                        LOG("[VP1_Cam_Bounds_Are_Tighter]",0);

                    };;
    
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[YOU_DONE_FAILED]");

                    };;

                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:MoveCamera_XY]" );
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ZoomCamera( void )
        {
        #define NUMBER_OF_TESTS (        22 ) /**TWENTY_2(22)**/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );

                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: data **/
                                ;
                    U32 inn_x_0 ; /** INPUTS: Camera Rect    **/
                    U32 inn_x_1 ;
                    U32 inn_y_0 ;
                    U32 inn_y_1 ;
                                ;
                    U32 zom_i32 ; /** INPUTS: Camera Zoom **/
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                    /** ************************************ ***
                        @VID_IID[ 0076 ]TIME[ 2H 39M 10S ]

                        weird_names_because: 
                        We kept confusing

                             "Input And Output"
                        With "Expected And Actual"

                        And tangling our mental understanding
                        between the pairs of words.
                    ** ************************************* **/

                    U32 O_A_x_0 ; /** OUT: Camera Rectangle  **/
                    U32 O_A_x_1 ; /** O_A: OUTPUT & ACTUAL   **/      
                    U32 O_A_y_0 ;
                    U32 O_A_y_1 ;
                                ;
                    U32 exp_x_0 ; /** EXPECTED : Camera Rect **/
                    U32 exp_x_1 ; /**                        **/
                    U32 exp_y_0 ;
                    U32 exp_y_1 ;
                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        //: inn_ inn_ inn_ inn_   zom_i32    exp_ exp_ exp_ exp_
        //: STARTING_CAMERA_PAB     ZOOM     ENDING_CAMERA_PAB

        //: @VID_IID[ 0083 ]TIME[ 05:45:40 ]            .....://
        //: 1x1 viewport in the extreme corners of the  .....://
        //: auset dataset that Josh is looking over.    .....://
        //: 12 viewport smoke tests below.              .....://
        
        //: #TOP_LEF__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
           0x00,0x00,0x00,0x00 ,   0x00   ,  0x00,0x00,0x00,0x00
        ,  0x00,0x00,0x00,0x00 ,0+    1   ,  0x00,0x00,0x00,0x00
        ,  0x00,0x00,0x00,0x00 ,0-    1   ,  0x00,   2,0x00,   2
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #TOP_RIG__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,   255, 255,0x00,0x00 ,   0x00   ,   255, 255,0x00,0x00
        ,   255, 255,0x00,0x00 ,0+    1   ,   255, 255,0x00,0x00
        ,   255, 255,0x00,0x00 ,0-    1   ,   253, 255,0x00,   2
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #BOT_LEF__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,  0x00,0x00, 255, 255 ,   0x00   ,  0x00,0x00, 255, 255
        ,  0x00,0x00, 255, 255 ,0+    1   ,  0x00,0x00, 255, 255
        ,  0x00,0x00, 255, 255 ,0-    1   ,  0x00,   2, 253, 255
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: #BOT_RIG__SUB_TILE# ( SEE_FILE[ PAINT5D.D._ )    ://
        ,   255, 255, 255, 255 ,   0x00   ,   255, 255, 255, 255
        ,   255, 255, 255, 255 ,0+    1   ,   255, 255, 255, 255
        ,   255, 255, 255, 255 ,0-    1   ,   253, 255, 253, 255
        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1

        //: 9 extra tests where we DONT hit the boarders:
        //: @VID_IID[ 0084 ]TIME[ 00:06:50 ]

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   100, 200, 100, 200 ,   0x00   ,   100, 200, 100, 200
        ,   100, 200, 100, 200 ,0+    1   ,   101, 199, 101, 199
        ,   100, 200, 100, 200 ,0-    1   ,    99, 201,  99, 201

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   100, 200, 0x0, 100 ,   0x00   ,   100, 200, 0x0, 100
        ,   100, 200, 0x0, 100 ,0+    1   ,   101, 199,   1,  99
        ,   100, 200, 0x0, 100 ,0-    1   ,    99, 201, 0x0, 102

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   0x0, 100, 100, 200 ,   0x00   ,   0x0, 100, 100, 200
        ,   0x0, 100, 100, 200 ,0+    1   ,     1,  99, 101, 199
        ,   0x0, 100, 100, 200 ,0-    1   ,   0x0, 102,  99, 201

        //: @VID_IID[ 0084 ]TIME[ 00:18:48 ]
        //: ONE MORE TEST AND THEN FVCK THIS SHIT.

        //:_x_0 _x_1 _y_0 _y_1               _x_0 _x_1 _y_0 _y_1
        ,   0x0,   3, 0x0,   3 , 0-9001   ,   0x0, 255, 0x0, 255

        //: STARTING_CAMERA_PAB     ZOOM     ENDING_CAMERA_PAB
        //: inn_ inn_ inn_ inn_   tra_ tra_  exp_ exp_ exp_ exp_

            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_x_0 = tab_utc[ bas + 0 ]; /** SEEDING    **/
                inn_x_1 = tab_utc[ bas + 1 ]; /** INITIAL    **/
                inn_y_0 = tab_utc[ bas + 2 ]; /** CAMERA     **/
                inn_y_1 = tab_utc[ bas + 3 ];

                zom_i32 = tab_utc[ bas + 4 ]; /**Zoom_Amount **/
 
                exp_x_0 = tab_utc[ bas + 5 ]; /** EXPECTED   **/
                exp_x_1 = tab_utc[ bas + 6 ]; /** OUTPUTS    **/
                exp_y_0 = tab_utc[ bas + 7 ];
                exp_y_1 = tab_utc[ bas + 8 ];
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                    @VID_IID[ 0076 ]TIME[ 2H 40M 00S ]

                    [ VP1 / P5D_VP1 ]:Viewport_One(1): 
                                      Offscreen/Source 
                                      TileMapDataBitmap Viewport 

                    VP1 basically means: "Camera Viewport"
                    This is the camera variables controlled
                    by JOSH when he is editing tiles in
                    Paint5D editor.

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    , ( inn_x_0 ), ( inn_x_1 )  //:<-- x bounds
                    , ( inn_y_0 ), ( inn_y_1 )  //:<-- y bounds
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_ZoomCamera(
                        zom_i32  //: Trans:DATAPIXELS: X
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_VP1 //:DEX_VAR
                    ,&( O_A_x_0 ),&( O_A_x_1 )  //:<-- x bounds
                    ,&( O_A_y_0 ),&( O_A_y_1 )  //:<-- y bounds
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_x_0  
                    !=  exp_x_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_x_1  
                    !=  exp_x_1
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_0  
                    !=  exp_y_0
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_y_1  
                    !=  exp_y_1
                    ){ failed_unit_test =( 1 ); };

                    assert( O_A_x_0 <= O_A_x_1 );
                    assert( O_A_y_0 <= O_A_y_1 );
                    if( 0
                    ||  (((I32)  O_A_x_0  )+0) < MIN_X_0 
                    ||  (((I32)  O_A_y_0  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  O_A_x_1  )+0) > MAX_X_1 
                    ||  (((I32)  O_A_y_1  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:ZOOM]",0);
                    };;
    
                    if( 0 != failed_unit_test ){

                        printf("\n\n\n"); //:Padding for console

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[x_0:A|E]:(%d):(%d)\n"
                        , O_A_x_0 , exp_x_0 );;

                        printf("[x_1:A|E]:(%d):(%d)\n"
                        , O_A_x_1 , exp_x_1 );;

                        printf("[y_0:A|E]:(%d):(%d)\n"
                        , O_A_y_0 , exp_y_0 );;

                        printf("[y_1:A|E]:(%d):(%d)\n"
                        , O_A_y_1 , exp_y_1 );;

                        ERR("[PAINT5D_ZOOM_TEST_FAILED]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital( "[TODO_FINISH_TEST:ZOOMCAMERA]" );
            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_MoveBrush_XY( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 6 ) /**    SIX(6)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                I32     failed_unit_test=( 0 );

                U32     nouse_1         =( 666070666 );
                U32     nouse_2         =( 666070666 );
                U32     nouse_3         =( 666070666 );

                I32     t_i ; /** t_i: Test Index            **/
                I32     mti ; /** mti: Maximum_Test_Index    **/
                I32     bas ; /** bas: BASe offset: test data**/
                            ;
                U32 bru_i_x ; /** INPUTS: Brush X/Y **/
                U32 bru_i_y ;

                I32 off_i_x ; /** INPUTS: Brush OFFSET X/Y **/
                I32 off_i_y ;  
    
                //:-------------------------:inputs_and_stuff://
                //:weird_names_because:----------------------://
                /** #_WEIRD_UNIT_TEST_VAR_NAMES_O_A_# **/

                U32 O_A_b_x ; /** OUTPUTS: Brush[x,y]        **/
                U32 O_A_b_y ; /** O_A: OUTPUT & ACTUAL values**/      
                            ;
                U32 exp_b_x ; /** EXPECTED : Brush[x,y] .... **/
                U32 exp_b_y ; /**                       .... **/

                //:----------------------:weird_names_because://
                         
            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={
                //: _i_x _i_y     _i_x _i_y     _b_x _b_y
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
                    0x00,0x00  ,  0x00,0x00  ,  0x00,0x00 
                ,   0x00,0x00  ,     1,0x00  ,     1,0x00 
                ,   0x00,0x00  ,  0x00,   1  ,  0x00,   1 
                //: BRUSH_X_Y     TRANS_X_Y     NEW___X_Y
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                bru_i_x = tab_utc[ bas + 0 ]; /** SEEDING    **/
                bru_i_y = tab_utc[ bas + 1 ]; /** INIT_BRUSH **/
                //:                    #                     ://
                off_i_x = tab_utc[ bas + 2 ]; /**Translate   **/
                off_i_y = tab_utc[ bas + 3 ]; /** X & Y      **/
                //:                    #                     ://
                exp_b_x = tab_utc[ bas + 4 ]; /** EXPECTED   **/
                exp_b_y = tab_utc[ bas + 5 ]; /** OUTPUTS    **/
                
                //:set_initial_camera_bounds:----------------://
        
                    /** ************************************ ***

                        #_WHAT_DOES_VP1_MEAN_IN_PAINT5D_#
                        #_WHAT_DOES_B_X_B_Y_MEAN_IN_PAINT5D_#

                    *** ************************************ **/

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    , ( bru_i_x ), ( nouse_1 )  //:BRUSH:X 
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    , ( bru_i_y ), ( nouse_1 )  //:BRUSH:X
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_MoveBrush_XY(
                        off_i_x //: o_x : brush_OFFSET_integer_X
                    ,   off_i_y //: o_y : brush_OFFSET_integer_Y
                    );; 

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_X //:DEX_VAR
                    ,&( O_A_b_x ),&( nouse_1 )  //:BRUSH:X 
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_B_Y //:DEX_VAR
                    ,&( O_A_b_y ),&( nouse_1 )  //:BRUSH:X
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;


                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_X_0 AAC2020_PAINT5D_MIN_cam_x_0 //01
                #define MIN_X_1 AAC2020_PAINT5D_MIN_cam_x_1 //02
                #define MIN_Y_0 AAC2020_PAINT5D_MIN_cam_y_0 //03
                #define MIN_Y_1 AAC2020_PAINT5D_MIN_cam_y_1 //04
                                                            ////
                #define MAX_X_0 AAC2020_PAINT5D_MAX_cam_x_0 //05
                #define MAX_X_1 AAC2020_PAINT5D_MAX_cam_x_1 //06
                #define MAX_Y_0 AAC2020_PAINT5D_MAX_cam_y_0 //07
                #define MAX_Y_1 AAC2020_PAINT5D_MAX_cam_y_1 //08

                    if( O_A_b_x  
                    !=  exp_b_x
                    ){ failed_unit_test =( 1 ); };

                    if( O_A_b_y  
                    !=  exp_b_y
                    ){ failed_unit_test =( 1 ); };

                    /** ************************************ **/
                    /** FAIL BECAUSE OUT OF PAINT5D BOUNDS   **/
                    /** Which are tighter than the bounds    **/
                    /** for generic inclusive rectangle type **/
                    /** ************************************ **/
                    if( 0
                    ||  (((I32)  exp_b_x  )+0) < MIN_X_0 
                    ||  (((I32)  exp_b_y  )+0) < MIN_Y_0 
                                
                    ||  (((I32)  exp_b_x  )+0) > MAX_X_1 
                    ||  (((I32)  exp_b_y  )+0) > MAX_Y_1 
                    ){
                        /** BAT: Bounds_Are_Tighter **/
                        failed_unit_test=( 1 );
                        LOG("[VP1_Cam_:BAT:BRUSH_TRANS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[b_x:A|E]:(%d):(%d)\n"
                        , O_A_b_x , exp_b_x );;

                        printf("[b_y:A|E]:(%d):(%d)\n"
                        , O_A_b_y , exp_b_y );;

                        ERR("[PAINT5D_BRUSH_TRANS_FAIL]");
                    };;
                #undef  MIN_X_0                       //: 01 ://
                #undef  MIN_X_1                       //: 02 ://
                #undef  MIN_Y_0                       //: 03 ://
                #undef  MIN_Y_1                       //: 04 ://
                                                      //: -- ://
                #undef  MAX_X_0                       //: 05 ://
                #undef  MAX_X_1                       //: 06 ://
                #undef  MAX_Y_0                       //: 07 ://
                #undef  MAX_Y_1                       //: 08 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_MORE_TEST_CASES:MoveBrush_XY]"
            );;

            return;
        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileValue( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_val ; /** INPUTS: Tile VAL       **/
                    I32 off_val ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_val ; /** EXPECTED : TILE VALUE  **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_val ; /** ACTUAL   : TILE VALUE  **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_val  |  off_val  |  exp_val
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_val  |  off_val  |  exp_val
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_val = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_val = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_val = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    , ( inn_val ), ( nouse_1 )  //:TILE_VALUE
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileValue(
                        off_val //: del_t_v ( Delta Tile Value )
                    );;  

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_V //:DEX_VAR
                    ,&( act_val ),&( nouse_1 )  //:TILE_VALUE
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_VAL (            0            ) //01
                #define MAX_VAL AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act_val  
                    !=  exp_val
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_VAL < MAX_VAL );
                    if( 0
                    ||  (((I32)  exp_val  )+0) < MIN_VAL           
                    ||  (((I32)  exp_val  )+0) > MAX_VAL 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_VALUE_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_val:exp_val]:(%d):(%d)\n"
                        , act_val , exp_val );;

                        ERR("[BRUSH_TILE_VALUE_TEST_FAIL]");
                    };;
                #undef  MIN_VAL                       //: 01 ://
                #undef  MAX_VAL                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileValue]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileExponent( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_E ; /** INPUTS: Tile VAL       **/
                    I32 off_T_E ; /** INPUTS: VAL OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_E ; /** EXPECTED :TILE EXPONENT**/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_E ; /** ACTUAL   :TILE EXPONENT**/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_E  |  off_T_E  |  exp_T_E
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_E  |  off_T_E  |  exp_T_E
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_E = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_E = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_E = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    , ( inn_T_E ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileExponent(
                        off_T_E //: del_t_e :............
                    );;         //: ( Delta Tile EXPONENT )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_E //:DEX_VAR
                    ,&( act_T_E ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_E (            0            ) //01
                #define MAX_T_E AAC2020_PAINT5D_MAX_til_exp //02
 
                    if( act_T_E  
                    !=  exp_T_E
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE VALUE **/
                    assert( MIN_T_E < MAX_T_E );
                    if( 0
                    ||  (((I32)  exp_T_E  )+0) < MIN_T_E           
                    ||  (((I32)  exp_T_E  )+0) > MAX_T_E 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_EXPONENT_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("\n\n");
                        printf("[t_i]:%d\n", t_i );

                        printf("[inn_T_E]:%d\n", inn_T_E);
                        printf("[off_T_E]:%d\n", off_T_E);
                        printf("[exp_T_E]:%d\n", exp_T_E);
                        printf("\n\n");

                        printf("[act_T_E:::exp_T_E]:(%d):(%d)\n"
                               , act_T_E , exp_T_E );;

                        ERR("[BRUSH_TILE_EXPONENT_TEST_FAIL]");
                    };;
                #undef  MIN_T_E                       //: 01 ://
                #undef  MAX_T_E                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]
            
            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileExponent]"
            );;
            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_DeltaMutate_TileLayer( void )
        {
        #define NUMBER_OF_TESTS (         3 ) /**  THREE(3)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 3 ) /**  THREE(3)  **/
            //:variable_declare:-----------------------------://

                //:inputs_and_stuff:-------------------------://

                    I32     failed_unit_test=( 0 );
                    
                    U32     nouse_1         =( 666070666 );
                    U32     nouse_2         =( 666070666 );
                    U32     nouse_3         =( 666070666 );
                    
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/
                                ;
                    U08 inn_T_L ; /** INPUTS: Tile LAYER     **/
                    I32 off_T_L ; /** INPUTS: LAY OFFSET X/Y **/

                //:-------------------------:inputs_and_stuff://
                //:expected_value(s):------------------------://

                    U32 exp_T_L ; /** EXPECTED :TILE LAYER   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U32 act_T_L ; /** ACTUAL   :TILE LAYER   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={ 
                //: inn_T_L  |  off_T_L  |  exp_T_L
                       0x00  ,     0x00  ,     0x00 
                ,      0x00  ,        1  ,        1 
                ,      0x00  ,       -1  ,     0x00 //:StilZero
                //: inn_T_L  |  off_T_L  |  exp_T_L
            };;

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                inn_T_L = tab_utc[ bas + 0 ]; /** SEEDING    **/
                //:                    #                     ://
                off_T_L = tab_utc[ bas + 1 ]; /**Offset Value**/
                //:                    #                     ://
                exp_T_L = tab_utc[ bas + 2 ]; /** EXPECTED   **/

                //:set_initial_camera_bounds:----------------://
        
                    AAC2020_TAUDEPO_Put( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    , ( inn_T_L ), ( nouse_1 )  //:TILE_EXPONENT
                    , ( nouse_2 ), ( nouse_3 )  //:UNUSED_DATA
                    );;

                //:----------------:set_initial_camera_bounds://
                //:apply_camera_translation:-----------------://

                    aac2020_paint5d_DeltaMutate_TileLayer(
                        off_T_L //: del_t_l :............
                    );;         //: ( Delta Tile LAYER )

                //:-----------------:apply_camera_translation://
                //:get_ACTUAL_camera_rectangle:--------------://

                    AAC2020_TAUDEPO_Get( 
                        AAC2020_TAUDEPO.TAU_015 //:DEX_TAU
                    ,   AAC2020_TAUDEPO.PAINT5D //:DEX_SUB
                    ,   AAC2020_TAUDEPO.P5D_T_L //:DEX_VAR
                    ,&( act_T_L ),&( nouse_1 )  //:TILE_EXPONENT
                    ,&( nouse_2 ),&( nouse_3 )  //:UNUSED_DATA
                    );;

                //:--------------:get_ACTUAL_camera_rectangle://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_L (            0            ) //01
                #define MAX_T_L AAC2020_PAINT5D_MAX_til_lay //02
 
                    if( act_T_L  
                    !=  exp_T_L
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_L < MAX_T_L );
                    if( 0
                    ||  (((I32)  exp_T_L  )+0) < MIN_T_L           
                    ||  (((I32)  exp_T_L  )+0) > MAX_T_L 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[TILE_LAYER_IS_OUT_OF_BOUNDS]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test ){

                        /** Print Off Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act_T_L:exp_T_L]:(%d):(%d)\n"
                        , act_T_L , exp_T_L );;

                        ERR("[BRUSH_TILE_LAYER_TEST_FAIL]");
                    };;
                #undef  MIN_T_L                       //: 01 ://
                #undef  MAX_T_L                       //: 02 ://
                //:-----------:check_against_expected_outputs://
            };; //:NEXT[ t_i (test_index ) ]

            AAC2020_TODOMAN_Vital(
                "[TODO_FINISH_TEST:DeltaMutate_TileLayer]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_ToggleTile( void )
        {
        #define NUMBER_OF_TESTS (         9 ) /**   NINE(9)  **/
        #define NUMBER_OF_TEST_ELEMENTS ( 9 ) /**   NINE(9)  **/
            //:variable_declare:-----------------------------://

                //:misc_test_runner_vars:--------------------://

                    I32     failed_unit_test=( 0 );
 
                    I32     t_i ; /** t_i: Test Index        **/
                    I32     mti ; /** mti: Max_Test_Index    **/
                    I32     bas ; /** bas: BASe offset: Data **/

                //:--------------------:misc_test_runner_vars://
                //:initial_value(s):-------------------------://

                    U08  t_q ; //: til_qua (TILE QUADRANT     )
                    U08  t_e ; //: til_exp (TILE EXPONENT     )   
                    U08  t_l ; //: til_lay (TILE LAYER        )
                    U08  l_x ; //: loc_t_x (LOCAL TILE X      ) 
                    U08  l_y ; //: loc_t_y (LOCAL TILE Y      ) 
                    U08  a_d ; //: aus_dex (AUSET INDEX       )
                    U08  t_v ; //: til_val (INITIAL tile value)   

                //:-------------------------:initial_value(s)://    
                //:mutator_value(s):-------------------------://

                    U08  b_v ; //:MUST_LOAD_INTO_BRUSH!

                //:-------------------------:mutator_value(s)://
                //:expected_value(s):------------------------://

                    U08  exp ; /** EXPECTED :TILE VALUE   **/

                //:------------------------:expected_value(s)://
                //:actual_values(s):-------------------------://

                    U08  act ; /** ACTUAL   :TILE VALUE   **/

                //:----------------------------:actual_values://

            //:-----------------------------:variable_declare://
            //:variable_init:--------------------------------://

                    mti =( NUMBER_OF_TESTS - 1 );

            //:--------------------------------:variable_init://

            /** This camera is not going to be a tilecam     **/
            /** Like in the prototype R:\G\A2_JC             **/
            /** PAB == "position and bounds" **/
            /** First 3 Tests are dead simple.    . . . . . .**/
            I32 tab_utc[  //:<-- MUST BE SIGNED HERE
                NUMBER_OF_TESTS 
                    * 
                NUMBER_OF_TEST_ELEMENTS 
            ]={                                
                //: t_v : INITIAL                tile_value
                //: exp : EXPECTED after command tile_value
                //: act : ACTUAL     (output)    tile_value
                //:     ( act should not be in this table )
                //: b_v : BRUSH VALUE 
                //:     ( value loaded into brush )
    
        //:  0   1   2   3    4     5     6      7       8
        //: 1x1,2x2,4x4,8x8,16x16,32x32,64x64,128x128,256x256
                                               
        //: t_q | t_e | t_l | l_x | l_y | a_d | t_v | b_v | exp
            0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   1 ,   0
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   1 ,   0 ,   0

        //: t_q | t_e | t_l | l_x | l_y | a_d | t_v | b_v | exp
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   0 ,   1 ,   1
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   0 ,   2 ,   2
        ,   0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,   0 ,   3 ,   3

        //:@__DO_SET__@
        //:Maxxed_Out_Values_Resulting_In_A__DoSet__Tile:
        //: t_q | t_e | t_l | l_x | l_y | a_d | t_v | b_v | exp
        ,    3  ,  7  ,  2  , 0x0 , 0x0 , 0x0 ,   3 ,   2 ,   2
        ,    3  ,  7  ,  2  , 0x0 , 0x0 ,   7 ,   2 ,   1 ,   1
        ,    3  ,  7  ,  2  , 0x0 , 0x0 ,  15 ,   1 ,   3 ,   3



            };;   //:THREE_ARE_TILE_VALUES: >>> ___ , ___ , ___
        //: 001   002   003   004   005   006   007   008   009

            for( t_i = 0 ; t_i <= mti ; t_i ++ ){

                bas =( t_i * NUMBER_OF_TEST_ELEMENTS );

                //:unpack_test_row_data:---------------------://

                    /** INITIAL_VALUE(S) **/
                    t_q = (U08) ( tab_utc[ bas + 0 ] );
                    t_e = (U08) ( tab_utc[ bas + 1 ] );              
                    t_l = (U08) ( tab_utc[ bas + 2 ] );
                    l_x = (U08) ( tab_utc[ bas + 3 ] );
                    l_y = (U08) ( tab_utc[ bas + 4 ] );
                    a_d = (U08) ( tab_utc[ bas + 5 ] );
                    t_v = (U08) ( tab_utc[ bas + 6 ] );

                    /** mutator_value(s)  **/
                    b_v = (U08) ( tab_utc[ bas + 7 ] );  

                    /** expected_value(s) **/
                    exp = (U08) ( tab_utc[ bas + 8 ] ); 
              
                //:---------------------:unpack_test_row_data://
                //:Basic_Truths:-----------------------------://

                    /** @VID_IID[ 0170 ]TIME[ 01:16:16 ]     **/
                    /** Failure here means that the test data**/
                    /** itself is wrong.                     **/

                    if( t_v >= 1 && b_v >= 1 && exp >= 1 ){

                        /** B_TRU:Basic_TRUth                **/
                        /** If all 3 values are positive,    **/
                        /** then the following must be true. **/
                        if( t_v == b_v ){ /**SHOULD_DIFFER **/

                            printf("[t_i]:%d\n",t_i);
                            ERR("[B_TRU:001]");

                        };;
                        if( exp != b_v ){ 

                            printf("[t_i]:%d\n",t_i);
                            ERR("[B_TRU:002]"); 

                        };;

                    };;

                //:-----------------------------:Basic_Truths://
                //:OVERWRITE_til_val_WITH_BRUSH:-------------://
        
                    /** Seed Tile Data Location With The **/
                    /** Initial Value .................. **/

                        /** Load brush with all of it's state**/
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent)
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   t_v //: INITAL / OVERWRITE VALUE
                        );;

                        /** Like ToggleTile , but is an      **/
                        /** override rather than a toggle.   **/                 
                        aac2020_paint5d_Put_UsingBrush( );

                //:-------------:OVERWRITE_til_val_WITH_BRUSH://
                //:apply_tile_toggle_action:-----------------://

                    /** Set the brush value you want to      **/
                    /** test the ToggleTile( ) command with  **/
                         
                        aac2020_paint5d_Put_BrushState(
                            t_q //: til_qua  
                        ,   t_e //: til_exp  (exp:exponent) 
                        ,   t_l //: til_lay  
                        ,   l_x //: loc_t_x  
                        ,   l_y //: loc_t_y  
                        ,   a_d //: aus_dex  
                        ,   b_v //: <-- t_v __SWAPPED_TO__ b_v
                        );;

                    /** Uses what is loaded into the tilemap **/
                    /** to determine the results.            **/

                        aac2020_paint5d_ToggleTile( );

                //:-----------------:apply_tile_toggle_action://
                //:get_ACTUAL_value_set_into_bitmap:---------://

                    /** @VID_IID[ 2H 55M 40S ] ************* **/
                    /** More abstractly explained:           **/
                    /** Get the tile value at this location  **/
                    /** within the paint5d tilemap data.     **/
                    /** ************************************ **/

                    AAC2020_PAINT5D_Get(
                            t_q   /** 01 :         til_qua   **/  
                    ,       t_e   /** 02 :         til_exp   **/  
                    ,       t_l   /** 03 :         til_lay   **/  
                    ,       l_x   /** 04 :         loc_t_x   **/  
                    ,       l_y   /** 05 :         loc_t_y   **/  
                    ,       a_d   /** 06 :         aus_dex   **/  
                    ,  &(   act ) /** 07 : GET ACT til_val   **/
                    );;

                //:---------:get_ACTUAL_value_set_into_bitmap://
                //:check_against_expected_outputs:-----------://
                #define MIN_T_V (            0            ) //01
                #define MAX_T_V AAC2020_PAINT5D_MAX_til_val //02
 
                    if( act 
                    !=  exp 
                    ){ failed_unit_test =( 1 ); };

                    /** INVALID RANGE FOR OUTPUT TILE LAYER **/
                    assert( MIN_T_V < MAX_T_V );
                    if( 0
                    ||  (((I32)  exp   )+0) < MIN_T_V           
                    ||  (((I32)  exp   )+0) > MAX_T_V 

                    ||  (((I32)  act   )+0) < MIN_T_V           
                    ||  (((I32)  act   )+0) > MAX_T_V 
                    ){
                        failed_unit_test=( 1 );
                        LOG("[T_V:OOB:2021:746PM]",0);
                    };;
    
                    /** ************************************ **/
                    /** Fail because does not match the .....**/
                    /** Values in our test table.       .....**/
                    /** ************************************ **/
                    if( 0 != failed_unit_test 
                    ||       failed_unit_test > 0
                    ){

                        /** Print Test Index **/
                        printf("[t_i]:%d\n", t_i );

                        printf("[act:exp]:(%d):(%d)\n"
                        , act , exp );;

                        ERR("[TILE_TOGGLE_TEST_FAIL_2021]");
                    };;
                #undef  MIN_T_V                       //: 01 ://
                #undef  MAX_T_V                       //: 02 ://
                //:-----------:check_against_expected_outputs://
                //:ToggleTileAgain:--------------------------://
                if( t_v >= 1 && b_v >= 1 && exp == 0 ){

                    /** ************************************ **/
                    /** @VID_IID[ 0170 ]TIME[ 01:04:32 ] *** **/
                    /** 2nd call to ToggleTile should get    **/
                    /** Opposite of original expected value. **/
                    /** ************************************ **/

                    aac2020_paint5d_ToggleTile(); //:@AGAIN@!

                    U08 exp_pos; //:Expected, POSITIVE
                    
                    AAC2020_PAINT5D_Get(
                            t_q       /** 01 :     til_qua   **/  
                    ,       t_e       /** 02 :     til_exp   **/  
                    ,       t_l       /** 03 :     til_lay   **/  
                    ,       l_x       /** 04 :     loc_t_x   **/  
                    ,       l_y       /** 05 :     loc_t_y   **/  
                    ,       a_d       /** 06 :     aus_dex   **/  
                    ,  &(   exp_pos ) /** 07 :     til_val   **/
                    );;

                    if( exp_pos != b_v ){
                        ERR("[2ND_TOGGLE_TILE_FAIL:exp_pos]");
                    };;

                }else
                if( t_v == 0 && b_v >= 1 && exp >= 1 ){
    
                    /** ************************************ **/
                    /** @VID_IID[ 0170 ]TIME[ 01:04:00 ] *** **/
                    /** 2nd call to ToggleTile should get    **/
                    /** Opposite of original expected value. **/
                    /** ************************************ **/

                    aac2020_paint5d_ToggleTile(); //:@AGAIN@!

                    U08 exp_zer; //:Expected, ZERO
                    
                    AAC2020_PAINT5D_Get(
                            t_q       /** 01 :     til_qua   **/  
                    ,       t_e       /** 02 :     til_exp   **/  
                    ,       t_l       /** 03 :     til_lay   **/  
                    ,       l_x       /** 04 :     loc_t_x   **/  
                    ,       l_y       /** 05 :     loc_t_y   **/  
                    ,       a_d       /** 06 :     aus_dex   **/  
                    ,  &(   exp_zer ) /** 07 :     til_val   **/
                    );;

                    if( exp_zer != (0) ){
                        ERR("[2ND_TOGGLE_TILE_FAIL:exp_zer#1]");
                    };;

                }else
                if( t_v >= 1 && b_v >= 1 && exp >= 1 ){

                    //:@VID_IID[ 0170 ]TIME[ 01:13:42 ]
                    //:MBDIEVIP:MustBeDifferentIfExpected
                    //:MBDIEVIP:....ValueIsPositive
                    if( t_v == b_v ){ 
                        printf("[t_i]:%d\n",t_i);
                        ERR("[MBDIEVIP:2021]"); 
                    };;

                    //:EVNBV:ExpectedValueNotBrushValue
                    if( exp != b_v ){ ERR("[EVNBV:2021]"); };

                    aac2020_paint5d_ToggleTile(); //:AGAIN!

                    U08 exp_zer; //:Expected, ZERO  
                    
                    AAC2020_PAINT5D_Get(
                            t_q       /** 01 :     til_qua   **/  
                    ,       t_e       /** 02 :     til_exp   **/  
                    ,       t_l       /** 03 :     til_lay   **/  
                    ,       l_x       /** 04 :     loc_t_x   **/  
                    ,       l_y       /** 05 :     loc_t_y   **/  
                    ,       a_d       /** 06 :     aus_dex   **/  
                    ,  &(   exp_zer ) /** 07 :     til_val   **/
                    );;

                    if( exp_zer != (0) ){
                        ERR("[2ND_TOGGLE_TILE_FAIL:exp_zer#2]");
                    };;

                }else
                if( 0 == b_v ){

                    /** A brush value with ZERO will always  **/
                    /** yeild a zero when using the toggle.  **/

                    aac2020_paint5d_ToggleTile(); //:AGAIN!

                    U08 exp_zer; //:Expected, ZERO  
                    
                    AAC2020_PAINT5D_Get(
                            t_q       /** 01 :     til_qua   **/  
                    ,       t_e       /** 02 :     til_exp   **/  
                    ,       t_l       /** 03 :     til_lay   **/  
                    ,       l_x       /** 04 :     loc_t_x   **/  
                    ,       l_y       /** 05 :     loc_t_y   **/  
                    ,       a_d       /** 06 :     aus_dex   **/  
                    ,  &(   exp_zer ) /** 07 :     til_val   **/
                    );;

                    if( exp_zer != (0) ){
                        ERR("[2ND_TOGGLE_TILE_FAIL:exp_zer#3]");
                    };;

                }else
                if( ((I32)exp)+0 < 0 ){
                    ERR("[EXPECTED_VALUE_CANT_GO_NEG:2021]");
                }else{
                    ERR("[NOT_ALL_CASES_CONSIDERED:YEAR_2021]");
                };;
                //:--------------------------:ToggleTileAgain://

            };; //:NEXT[ t_i (test_index ) ]
                    
            AAC2020_TODOMAN_Vital(
                "[ADD_MORE_TEST_CASES:ToggleTile]"
            );;

            return;

        #undef NUMBER_OF_TESTS         //: . . . . . . . . . ://
        #undef NUMBER_OF_TEST_ELEMENTS //: . . . . . . . . . ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : USERCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : BELOW        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_paint5d_UnitTest_ProgControls( void )
    {
        //:helper_functions:generic:- - - - - - - - - - - - -://
        aac2020_paint5d_CTF=(     "[Min_I16]"    );
        EXT VOD aac2020_paint5d_UTC_Min_I16( VOD );
                aac2020_paint5d_UTC_Min_I16(     );

        aac2020_paint5d_CTF=(     "[i32_Cap_u32]"    );
        EXT VOD aac2020_paint5d_UTC_i32_Cap_u32( VOD );
                aac2020_paint5d_UTC_i32_Cap_u32(     );

        //:- - - - - - - - - - - - -:helper_functions:generic://
        //:helper_functions::conversion:- - - - - - - - - - -://
 
        aac2020_paint5d_CTF=(     "[til_exp_CTO_bip_sip]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_bip_sip( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_bip_sip(     );

        aac2020_paint5d_CTF=(     "[til_exp_CTO_max_cor]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_max_cor( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_max_cor(     );

        aac2020_paint5d_CTF=(     "[til_exp_CTO_diagpix]"    );
        EXT VOD aac2020_paint5d_UTC_til_exp_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_til_exp_CTO_diagpix(     );

        aac2020_paint5d_CTF=(     "[diagpix_CTO_til_exp]"    );
        EXT VOD aac2020_paint5d_UTC_diagpix_CTO_til_exp( VOD );
                aac2020_paint5d_UTC_diagpix_CTO_til_exp(     );

        /**@DNE aac2020_paint5d_UTC_diagpix_CTO_astipix @DNE **/

        aac2020_paint5d_CTF=(     "[astipix_CTO_diagpix]"    );
        EXT VOD aac2020_paint5d_UTC_astipix_CTO_diagpix( VOD );
                aac2020_paint5d_UTC_astipix_CTO_diagpix(     );

        //:- - - - - - - - - - -:helper_functions::conversion://
        //:paired_unit_tests::- - - - - - - - - - - - - - - -://

        aac2020_paint5d_CTF=(     "[glocpix_CTO_painpix]"    );
        EXT VOD aac2020_paint5d_UTC_glocpix_CTO_painpix( VOD );
                aac2020_paint5d_UTC_glocpix_CTO_painpix(     );

        aac2020_paint5d_CTF=(     "[painpix_CTO_glocpix]"    );
        EXT VOD aac2020_paint5d_UTC_painpix_CTO_glocpix( VOD );
                aac2020_paint5d_UTC_painpix_CTO_glocpix(     );

        /** @VID_IID[ 0080 ]TIME[ 00:33:30 ] *************** **/
        /** Test every single possible conversion value by   **/
        /** doing a [p_x , p_y ] loop over 512x512 pixels.   **/

        aac2020_paint5d_CTF=(     "[pix_CTO_pix_PUT_GET]"    );
        EXT VOD aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET( VOD );
                aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET(     );

        //:- - - - - - - - - - - - - - - -:paired_unit_tests:://
        //:main_get_put_tests::DEPENDS_ON::- - - - - - - - -:://
        /** ************************************************ ***
        @VID_IID[ 0081 ]TIME[ 00:09:58 ]
        Test the bit shifting logic used by 
        AAC2020_PAINT5D_Put & AAC2020_PAINT5D_Get
        because we think the reason tests
        "aac2020_paint5d_UTC_Put" and "aac2020_paint5d_UTC_Get"
        are failing is because the bit shifting logic is wrong.
        We have extracted the bit [ shifting / packing ] logic
        into their own functions to help verify that
        logic is correct.
        *** ************************************************ **/

            aac2020_paint5d_CTF=(     "[BitPack_Put]"    );
            EXT VOD aac2020_paint5d_UTC_BitPack_Put( VOD );
                    aac2020_paint5d_UTC_BitPack_Put(     );

            aac2020_paint5d_CTF=(     "[BitPack_Get]"    );
            EXT VOD aac2020_paint5d_UTC_BitPack_Get( VOD );
                    aac2020_paint5d_UTC_BitPack_Get(     );

        //:- - - - - - - - -::main_get_put_tests::DEPENDS_ON:://
        //:main_get_put_tests::- - - - - - - - - - - - - - -:://

            aac2020_paint5d_CTF=(     "[Put]"    );
            EXT VOD aac2020_paint5d_UTC_Put( VOD );
                    aac2020_paint5d_UTC_Put(     );

            aac2020_paint5d_CTF=(     "[Get]"    );
            EXT VOD aac2020_paint5d_UTC_Get( VOD );
                    aac2020_paint5d_UTC_Get(     );

            /** ******************************************** ***
                @DEP[ aac2020_paint5d_UTC_Get ]               
                @DEP[ aac2020_paint5d_UTC_Put ]               
                @DEP[ aac2020_paint5d_UTC_glocpix_CTO_painpix ]  
            
                @VID_IID[ 0071 ]TIME[ 00H 12M 52S ]  
            *** ******************************************** **/

            aac2020_paint5d_CTF=(     "[Put_Get]"    );
            EXT VOD aac2020_paint5d_UTC_Put_Get( VOD );
                    aac2020_paint5d_UTC_Put_Get(     );

            /** ******************************************** **/

        //:- - - - - - - - - - - - - - -::main_get_put_tests:://
        return;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    //:ADDED_FUNC_PAIR_ON_2021_01_09:------------------------://
    #define VERY_SPECIFIC_DEFINES_HERE_ONLY

        void
        aac2020_paint5d_UTC_BitPack_Put( void )
        {
        #define NUM_ELM_001 ( 3 ) /** 3 elements per test    **/
        #define NUM_TES_001 (32 ) /** Total number of tests  **/
        //:                                                  ://
        #define NUM_ELM_002 (16 )  /** Test Table # 2 .......**/
        #define NUM_TES_002 (12 )  /** Sizes.         .......**/

            LOG("[BEG:aac2020_paint5d_UTC_BitPack_Put:BEG]",0);

            I32     bas; //:base offset for current test
            I32     t_i; //:test index
            I32     m_i; //:max test index
            U08 cpu_pix[ 4 * 4 ]={ 0 };

            U08 glo_com;
            U08 aus_dex;
            U08 til_val;

            U32 u32_var; //:<-- 1 pixels worth of data.
            U08 u08_var;

            //:Do all tests in pairs. Set and then erase.
            //:Thus expecting the final array to always be
            //:nothing but zeros. Actually... Don't hard
            //:Code this. Make it a feature of the test....
            U08 tab_utc[ NUM_ELM_001 * NUM_TES_001 ]={

            //: glo_com | aus_dex | til_val //:SUM        DEX://
                   0    ,    0    ,    0    //: 01        00 ://
            ,      0    ,    0    ,    1    //: 02        01 ://
            ,      0    ,    0    ,    2    //: 03        02 ://
            ,      0    ,    0    ,    3    //: 04        03 ://
                                            //: --        -- ://
            ,      0    ,   15    ,    0    //: 05        04 ://
            ,      0    ,   15    ,    1    //: 06        05 ://
            ,      0    ,   15    ,    2    //: 07        06 ://
            ,      0    ,   15    ,    3    //: 08        07 ://
                                            //: --        -- ://
            ,      4    ,    0    ,    0    //: 09        08 ://
            ,      4    ,    0    ,    1    //: 10        09 ://
            ,      4    ,    0    ,    2    //: 11        10 ://
            ,      4    ,    0    ,    3    //: 12        11 ://
                                            //: --        -- ://
            ,      4    ,   15    ,    0    //: 13        12 ://
            ,      4    ,   15    ,    1    //: 14        13 ://
            ,      4    ,   15    ,    2    //: 15        14 ://
            ,      4    ,   15    ,    3    //: 16        15 ://
                                            //: --        -- ://
            ,      8    ,    0    ,    0    //: 17        16 ://
            ,      8    ,    0    ,    1    //: 18        17 ://
            ,      8    ,    0    ,    2    //: 19        18 ://
            ,      8    ,    0    ,    3    //: 20        19 ://
                                            //: --        -- ://
            ,      8    ,   15    ,    0    //: 21        20 ://
            ,      8    ,   15    ,    1    //: 22        21 ://
            ,      8    ,   15    ,    2    //: 23        22 ://
            ,      8    ,   15    ,    3    //: 24        23 ://
                                            //: --        -- ://
            ,     12    ,    0    ,    0    //: 25        24 ://
            ,     12    ,    0    ,    1    //: 26        25 ://
            ,     12    ,    0    ,    2    //: 27        26 ://
            ,     12    ,    0    ,    3    //: 28        27 ://
                                            //: --        -- ://
            ,     12    ,   15    ,    0    //: 29        28 ://
            ,     12    ,   15    ,    1    //: 30        29 ://
            ,     12    ,   15    ,    2    //: 31        30 ://
            ,     12    ,   15    ,    3    //: 32        31 ://
            //: glo_com | aus_dex | til_val //:SUM        DEX://
            };;

            m_i=( NUM_TES_001 - 1 );
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                bas = ( t_i * NUM_ELM_001  ); //:t_i * STRIDE://
                glo_com = tab_utc[ bas + 0 ];
                aus_dex = tab_utc[ bas + 1 ];
                til_val = tab_utc[ bas + 2 ];

                aac2020_paint5d_BitPack_Put(
                    cpu_pix //: PIXEL_BYTE_ARRAY       ..... ://
                ,   glo_com //: GLOBAL_COMPONENT_INDEX ..... ://
                ,   aus_dex //: AUSET_INDEX_00_TO_15   ..... ://
                ,   til_val //: TILE__VALUE_00_TO_03   ..... ://
                );;

                //:manual_check:-----------------------------://

                    u32_var = ( 0x00 ); //:Clear_The_Pixel
                    
                    /** @VID_IID[ 0082 ]TIME[ 01:21:40 ]     **/
                    /** Use "glo_com" to extract the current **/
                    /** pixel we are looking at.             **/
                    /** This is NOT the way we want to do it **/
                    /** in production, because we are looking**/
                    /** at 4 bytes when we only need ONE of  **/
                    /** them. However, the math is more      **/
                    /** straightforward this way and better  **/
                    /** for unit testing.                    **/
                    u32_var=(
                    0x00
                    |   ( cpu_pix[ glo_com + 0 ] << 24 ) //:R://
                    |   ( cpu_pix[ glo_com + 1 ] << 16 ) //:G://
                    |   ( cpu_pix[ glo_com + 2 ] <<  8 ) //:B://
                    |   ( cpu_pix[ glo_com + 3 ] <<  0 ) //:A://
                    );;     

                    //:@VID_IID[ 0082 ]TIME[ 2H 34M 48S ]
                    //:count bits. Should not be more than 2.
                    U32 b_c=( 0 ); /** Bit Count **/
                    for( I32 i = 0; i <= (32-1) ; i++ ){
                        b_c=( b_c + ((u32_var>>i)&1) );
                    };;
                    if( b_c > 2 ){ /** Only 2 bit values! **/
                        ERR("[TOO_MANY_SET_BITS_BAD_BIT_PACK]");
                    };;

                    u08_var=(
                        (U08)(
                            ( u32_var >> ( aus_dex * 2 ) )
                            & //:<-- only ONE "&" symbol.
                            3 //:<-- Binary[ 11 ]MASK
                        )
                    );;
            
                    /**  actual != expected **/
                    if( u08_var != til_val    ){
                
                        U32 pix;
                        I32 n_z=( 0 ); //:non_zero_found?
                        I32 nzi=(0-1); //:index of last[ n_z ]
                        for( I32 i = 0 ; i <= ((4*4)-1) ; i++ ){

                            if( 0x00 != cpu_pix[ i ] ){
                                pix=(   cpu_pix[ i ] );
                                n_z++;
                                nzi=( i );
                                printf("[cur:nzi]:%d\n"   ,nzi);
                                printf("[hex:pix]:%02x\n" ,pix);
                            };;
                        };;

                        printf("[....t_i]:%d\n",     t_i );
                        printf("[u32_var]:%d\n", u32_var );
                        printf("[u08_var]:%d\n", u08_var );
                        printf("[til_val]:%d\n", til_val );
                        printf("[....n_z]:%d\n",     n_z );
            
                        printf("cpu_pix[ glo_com + 0 ]==>%d\n",
                                cpu_pix[ glo_com + 0 ] );;
                        printf("cpu_pix[ glo_com + 1 ]==>%d\n",
                                cpu_pix[ glo_com + 1 ] );;
                        printf("cpu_pix[ glo_com + 2 ]==>%d\n",
                                cpu_pix[ glo_com + 2 ] );;
                        printf("cpu_pix[ glo_com + 3 ]==>%d\n",
                                cpu_pix[ glo_com + 3 ] );;

                            /** MAKE SURE YOUR SHIFT AMOUNT  **/
                            /** IS ON THE RIGHT IN YOUR      **/
                            /** BITPACKING CODE.             **/
                            /**tmu:test_my_understanding**/
                            U32 tmu=( 
                            0x00
                            |   (24 << 0 ) //:R://
                            |   (16 << 0 ) //:G://
                            |   ( 8 << 0 ) //:B://
                            |   ( 0 << 1 ) //:A://
                            );;   
                            if( 24 != tmu ){
                                printf("[tmu]:%d\n", tmu);
                                ERR("[DONT_KNOW_JACK_2021]");
                            };;

                        ERR(
                            "[PUT_HAS_FAILED_2021_01_09_BLUE]"
                        );;
                    };;

                //:-----------------------------:manual_check://

                /** Putting zero should revert the entire    **/
                /** test array to all zeros.                 **/

                aac2020_paint5d_BitPack_Put(
                    cpu_pix //: PIXEL_BYTE_ARRAY       ..... ://
                ,   glo_com //: GLOBAL_COMPONENT_INDEX ..... ://
                ,   aus_dex //: AUSET_INDEX_00_TO_15   ..... ://
                ,      0    //: TILE__VALUE_00_TO_03   ..... ://
                );;

                /** b_i : byte index **/
                for( I32 b_i = 0 ; b_i <= ((4*4)-1) ; b_i ++ ){

                    if( 0x00 != cpu_pix[ b_i ] ){
                        ERR("[PROBLEM_2021_01_09_PUT_TEST]");
                    };;
                };;

            };;

            /** ******************************************** **/
            /** Another Set Of Tests...                      **/
            /** PUT evertything then manually GET everything.**/
            /** So it is like a "Put_Get" test however we    **/
            /** do NOT use the "Getter" function but rather  **/
            /** use manual logic to GET the values.          **/
            /** This is because we want to test the          **/
            /** "get" and "put" functionality in isolation   **/
            /** before we do a real "Put_Get"                **/
            /** integration test.                            **/
            /** @VID_IID[ 0082 ]TIME[ 1H 48M 46S ]           **/
            /** Explaning test table #2 below.               **/
            /** ******************************************** **/

            assert( 16 == NUM_ELM_002 );
            assert( 12 == NUM_TES_002 );
            U08 tab_002[ NUM_ELM_002 * NUM_TES_002 ]={
            //: 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
    /* 01 */     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    /* 02 */,    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 
    /* 03 */,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  
    /* 04 */,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  

    /* 05 */,    0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
    /* 06 */,    3, 2, 1, 0, 3, 2, 1, 0, 3, 2, 1, 0, 3, 2, 1, 0

    /* 07 */,    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3
    /* 08 */,    3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0

    /* 09 */,    3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0
    /* 10 */,    0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3 

                /** Random number test. Keep this one last   **/
                /** because I really don't want to deal with **/
                /** this test case failing as the lack of    **/
                /** a regular pattern makes the data harder  **/
                /** to mentally reason about.                **/
                /** @VID_IID[ 0082 ]TIME[ 01:35:42 ]         **/
    /* 11 */,    1, 3, 2, 0, 3, 2, 1, 2, 3, 0, 1, 2, 0, 3, 1, 2 
    /* 12 */,    0, 3, 1, 2, 0, 3, 0, 1, 2, 3, 1, 2, 0, 3, 1, 0 
            };;

            assert( 16 == NUM_ELM_002     );
            assert( 12 == NUM_TES_002     );
            m_i=(         NUM_TES_002 - 1 );
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                bas =( t_i * NUM_ELM_002 );
            
                /** PUT ALL VALUES FOR CURRENT TEST **/

                for( aus_dex = 0;aus_dex <=(16-1); aus_dex++ ){

                    glo_com = 0;
                    til_val = tab_002[ bas + aus_dex ];

                    aac2020_paint5d_BitPack_Put(
                          cpu_pix  
                    ,     glo_com 
                    ,     aus_dex  
                    ,     til_val 
                    );;
                };;

                /** GET ALL VALUES FOR CURRENT TEST **/

                for( aus_dex = 0;aus_dex <=(16-1); aus_dex++ ){

                    /** expected tile value */
                    til_val = tab_002[ bas + aus_dex ];

                    u32_var=(
                    0x00
                    |   (cpu_pix[ glo_com + 0 ] << 24 ) //:R://
                    |   (cpu_pix[ glo_com + 1 ] << 16 ) //:G://
                    |   (cpu_pix[ glo_com + 2 ] <<  8 ) //:B://
                    |   (cpu_pix[ glo_com + 3 ] <<  0 ) //:A://
                    );;                                  

                    u08_var=( /** <-- ACTUAL tile value **/
                        (U08)(
                            ( u32_var >> ( aus_dex * 2 ) )
                            & //:<-- only ONE "&" symbol.
                            3 //:<-- Binary[ 11 ]MASK
                        )
                    );;

                    if( til_val != u08_var ){
                        /** E_V_A : Expected_Vs_Actual **/
                        ERR( "[E_V_A:til_val:vs:u08_var]" );;
                    };;

                };;

            };;

            LOG("[END:aac2020_paint5d_UTC_BitPack_Put:END]",0);

        #undef NUM_ELM_001                            //: 01 ://
        #undef NUM_TES_001                            //: 02 ://
        //:                                           //: -- ://
        #undef NUM_ELM_002                            //: 03 ://
        #undef NUM_TES_002                            //: 04 ://
        }
        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        void
        aac2020_paint5d_UTC_BitPack_Get( void )
        {
        #define NUM_ELM (       3      ) /** num    elements **/
        #define NUM_TES (     160      ) /** number of tests **/
        #define BIN_011 (       3      ) /** binary:11       **/

            //:declare_most_variables:-----------------------://

                I32     bas; //:base offset for current test ://
                I32     t_i; //:test index                   ://
                I32     m_i; //:max test index               ://
                U08 cpu_pix[ 4 * 4 ]={ 0 }; //:4 RGBA pixels.://

                U08 glo_com;    /** global component index   **/
                U08 aus_dex;    /** auset number index       **/
                U08 til_val;    /** tile value to set 0-to-3 **/
                U08 got_val;    /** GOTTEN tile value/actual **/

                /** from LSB to MSB                          **/
                /** LSB: Least_Significant_Bit               **/
                /** MSB: Most__Significatn_Bit               **/
                I32     bi0;    /** bit index 0 (1st) LSB    **/
                I32     bi1;    /** bit index 1 (2nd) MSB    **/

                I32     zer;    /** Number of __ZERO__ bytes **/
                I32     non;    /** Number of non-zero bytes **/

                I32     era;    /** Erase Before Next Test?  **/

                U32 u32_var; //:<-- 1 pixels worth of data.  ://
            /// U08 u08_var;

            //:-----------------------:declare_most_variables://
            //:table_of_unit_test_code:----------------------://
            U08 tab_utc[ NUM_ELM * NUM_TES ]={
            //: glo_com | aus_dex | til_val //:SUM        DEX://
                   0    ,    0    ,    0    //: 01        00 ://
            ,      0    ,    0    ,    1    //: 02        01 ://
            ,      0    ,    0    ,    2    //: 03        02 ://
            ,      0    ,    0    ,    3    //: 04        03 ://
                                            //: --        -- ://
            ,      0    ,   15    ,    0    //: 05        04 ://
            ,      0    ,   15    ,    1    //: 06        05 ://
            ,      0    ,   15    ,    2    //: 07        06 ://
            ,      0    ,   15    ,    3    //: 08        07 ://
                                            //: --        -- ://
            ,      4    ,    0    ,    0    //: 09        08 ://
            ,      4    ,    0    ,    1    //: 10        09 ://
            ,      4    ,    0    ,    2    //: 11        10 ://
            ,      4    ,    0    ,    3    //: 12        11 ://
                                            //: --        -- ://
            ,      4    ,   15    ,    0    //: 13        12 ://
            ,      4    ,   15    ,    1    //: 14        13 ://
            ,      4    ,   15    ,    2    //: 15        14 ://
            ,      4    ,   15    ,    3    //: 16        15 ://
                                            //: --        -- ://
            ,      8    ,    0    ,    0    //: 17        16 ://
            ,      8    ,    0    ,    1    //: 18        17 ://
            ,      8    ,    0    ,    2    //: 19        18 ://
            ,      8    ,    0    ,    3    //: 20        19 ://
                                            //: --        -- ://
            ,      8    ,   15    ,    0    //: 21        20 ://
            ,      8    ,   15    ,    1    //: 22        21 ://
            ,      8    ,   15    ,    2    //: 23        22 ://
            ,      8    ,   15    ,    3    //: 24        23 ://
                                            //: --        -- ://
            ,     12    ,    0    ,    0    //: 25        24 ://
            ,     12    ,    0    ,    1    //: 26        25 ://
            ,     12    ,    0    ,    2    //: 27        26 ://
            ,     12    ,    0    ,    3    //: 28        27 ://
                                            //: --        -- ://
            ,     12    ,   15    ,    0    //: 29        28 ://
            ,     12    ,   15    ,    1    //: 30        29 ://
            ,     12    ,   15    ,    2    //: 31        30 ://
            ,     12    ,   15    ,    3    //: 32        31 ://

            /** @VID_IID[ 0083 ]TIME[ 03:52:20 ] *********** **/
            /** Added interlacing tests to further check     **/
            /** our logic is correct.                        **/

            /** @VID_IID[ 0083 ]TIME[ 04:21:28 ]             **/
            /** Anyone who says that TYPING is never the     **/
            /** bottleneck is full of shit!                  **/
            /** For an example, see the checksums            **/
            /** we are writing in the comments below         **/
            /** and to the right. -John Mark 2021_01_11      **/

            /** @VID_IID[ 0083 ]TIME[ 04:30:16 ] FIX #1      **/

            //: 32 + ( 16 * 1 ) TESTS TOTAL AFTER BLOCK BELOW:
            //:                ( T_T_A_B_B )

                                            //:SUM        DEX://
            ,     12    ,    0    ,    3    //: 33        32 ://
            ,     12    ,    1    ,    0    //: 34        33 ://
            ,     12    ,    2    ,    3    //: 35        34 ://
            ,     12    ,    3    ,    0    //: 36        35 ://
            ,     12    ,    4    ,    3    //: 37        36 ://
            ,     12    ,    5    ,    0    //: 38        37 ://
            ,     12    ,    6    ,    3    //: 39        38 ://
            ,     12    ,    7    ,    0    //: 40        39 ://
            ,     12    ,    8    ,    3    //: 41        40 ://
            ,     12    ,    9    ,    0    //: 42        41 ://
            ,     12    ,   10    ,    3    //: 43        42 ://
            ,     12    ,   11    ,    0    //: 44        43 ://
            ,     12    ,   12    ,    3    //: 45        44 ://
            ,     12    ,   13    ,    0    //: 46        45 ://
            ,     12    ,   14    ,    3    //: 47        46 ://
            ,     12    ,   15    ,    0    //: 48        47 ://
            
            //: 32 + ( 16 * 2 ) T_T_A_B_B   //: 33 + 16 == 49
                                            //: 33 + 15 == 48

                                            //:SUM        DEX://
            ,     12    ,    0    ,    0    //: 49        48 ://
            ,     12    ,    1    ,    3    //: 50        49 ://
            ,     12    ,    2    ,    0    //: 51        50 ://
            ,     12    ,    3    ,    3    //: 52        51 ://
            ,     12    ,    4    ,    0    //: 53        52 ://
            ,     12    ,    5    ,    3    //: 54        53 ://
            ,     12    ,    6    ,    0    //: 55        54 ://
            ,     12    ,    7    ,    3    //: 56        55 ://
            ,     12    ,    8    ,    0    //: 57        56 ://
            ,     12    ,    9    ,    3    //: 58        57 ://
            ,     12    ,   10    ,    0    //: 59        58 ://
            ,     12    ,   11    ,    3    //: 60        59 ://
            ,     12    ,   12    ,    0    //: 61        60 ://
            ,     12    ,   13    ,    3    //: 62        61 ://
            ,     12    ,   14    ,    0    //: 63        62 ://
            ,     12    ,   15    ,    3    //: 64        63 ://

            //: 32 + ( 16 * 3 ) T_T_A_B_B   //: 49 + 16 == 65
                                            //: 49 + 15 == 64

            ,     12    ,    0    ,    3    //: 65        64 ://
            ,     12    ,    1    ,    3    //: 66        65 ://
            ,     12    ,    2    ,    3    //: 67        66 ://
            ,     12    ,    3    ,    3    //: 68        67 ://
            ,     12    ,    4    ,    3    //: 69        68 ://
            ,     12    ,    5    ,    3    //: 70        69 ://
            ,     12    ,    6    ,    3    //: 71        70 ://
            ,     12    ,    7    ,    3    //: 72        71 ://
            ,     12    ,    8    ,    3    //: 73        72 ://
            ,     12    ,    9    ,    3    //: 74        73 ://
            ,     12    ,   10    ,    3    //: 75        74 ://
            ,     12    ,   11    ,    3    //: 76        75 ://
            ,     12    ,   12    ,    3    //: 77        76 ://
            ,     12    ,   13    ,    3    //: 78        77 ://
            ,     12    ,   14    ,    3    //: 79        78 ://
            ,     12    ,   15    ,    3    //: 80        79 ://

                                            
            //: 32 + ( 16 * 4 ) T_T_A_B_B   //: 65 + 16 = 81
                                            //: 64 + 16 = 80 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    2    //: 81        80 ://
            ,     12    ,    1    ,    2    //: 82        81 ://
            ,     12    ,    2    ,    2    //: 83        82 ://
            ,     12    ,    3    ,    2    //: 84        83 ://
            ,     12    ,    4    ,    2    //: 85        84 ://
            ,     12    ,    5    ,    2    //: 86        85 ://
            ,     12    ,    6    ,    2    //: 87        86 ://
            ,     12    ,    7    ,    2    //: 88        87 ://
            ,     12    ,    8    ,    2    //: 89        88 ://
            ,     12    ,    9    ,    2    //: 90        89 ://
            ,     12    ,   10    ,    2    //: 91        90 ://
            ,     12    ,   11    ,    2    //: 92        91 ://
            ,     12    ,   12    ,    2    //: 93        92 ://
            ,     12    ,   13    ,    2    //: 94        93 ://
            ,     12    ,   14    ,    2    //: 95        94 ://
            ,     12    ,   15    ,    2    //: 96        95 ://

            //: 32 + ( 16 * 5 ) T_T_A_B_B   //: 81 + 16 = 97
                                            //: 80 + 16 = 96 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    1    //: 97        96 ://
            ,     12    ,    1    ,    1    //: 98        97 ://
            ,     12    ,    2    ,    1    //: 99        98 ://
            ,     12    ,    3    ,    1    //:100        99 ://
            ,     12    ,    4    ,    1    //:101       100 ://
            ,     12    ,    5    ,    1    //:102       101 ://
            ,     12    ,    6    ,    1    //:103       102 ://
            ,     12    ,    7    ,    1    //:104       103 ://
            ,     12    ,    8    ,    1    //:105       104 ://
            ,     12    ,    9    ,    1    //:106       105 ://
            ,     12    ,   10    ,    1    //:107       106 ://
            ,     12    ,   11    ,    1    //:108       107 ://
            ,     12    ,   12    ,    1    //:109       108 ://
            ,     12    ,   13    ,    1    //:110       109 ://
            ,     12    ,   14    ,    1    //:111       110 ://
            ,     12    ,   15    ,    1    //:112       111 ://

            //: 32 + ( 16 * 6 ) T_T_A_B_B   //:97 + 16 = 113
                                            //:96 + 16 = 112 
                                         
                                            //:SUM        DEX://
            ,     12    ,    0    ,    0    //:113        112://
            ,     12    ,    1    ,    0    //:114        112://
            ,     12    ,    2    ,    0    //:115        113://
            ,     12    ,    3    ,    0    //:116        114://
            ,     12    ,    4    ,    0    //:117        115://
            ,     12    ,    5    ,    0    //:118        117://
            ,     12    ,    6    ,    0    //:119        118://
            ,     12    ,    7    ,    0    //:120        119://
            ,     12    ,    8    ,    0    //:121        120://
            ,     12    ,    9    ,    0    //:122        121://
            ,     12    ,   10    ,    0    //:123        122://
            ,     12    ,   11    ,    0    //:124        123://
            ,     12    ,   12    ,    0    //:125        124://
            ,     12    ,   13    ,    0    //:126        125://
            ,     12    ,   14    ,    0    //:127        126://
            ,     12    ,   15    ,    0    //:128        127://

            //: 32 + ( 16 * 7 ) T_T_A_B_B   //:113 + 16 = 129
                                            //:112 + 16 = 128 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    3    //:129        128://
            ,     12    ,    1    ,    2    //:130        129://
            ,     12    ,    2    ,    3    //:131        130://
            ,     12    ,    3    ,    2    //:132        131://
            ,     12    ,    4    ,    3    //:133        132://
            ,     12    ,    5    ,    2    //:134        133://
            ,     12    ,    6    ,    3    //:135        134://
            ,     12    ,    7    ,    2    //:136        135://
            ,     12    ,    8    ,    3    //:137        136://
            ,     12    ,    9    ,    2    //:138        137://
            ,     12    ,   10    ,    3    //:139        138://
            ,     12    ,   11    ,    2    //:140        139://
            ,     12    ,   12    ,    3    //:141        140://
            ,     12    ,   13    ,    2    //:142        141://
            ,     12    ,   14    ,    3    //:143        142://
            ,     12    ,   15    ,    2    //:144        143://

            //: 32 + ( 16 * 8 ) T_T_A_B_B   //:129 + 16 = 145
                                            //:128 + 16 = 144 

                                            //:SUM        DEX://
            ,     12    ,    0    ,    2    //:145        144://
            ,     12    ,    1    ,    3    //:146        145://
            ,     12    ,    2    ,    2    //:147        146://
            ,     12    ,    3    ,    3    //:148        147://
            ,     12    ,    4    ,    2    //:149        148://
            ,     12    ,    5    ,    3    //:150        149://
            ,     12    ,    6    ,    2    //:151        150://
            ,     12    ,    7    ,    3    //:152        151://
            ,     12    ,    8    ,    2    //:153        152://
            ,     12    ,    9    ,    3    //:154        153://
            ,     12    ,   10    ,    2    //:155        154://
            ,     12    ,   11    ,    3    //:156        155://
            ,     12    ,   12    ,    2    //:157        156://
            ,     12    ,   13    ,    3    //:158        157://
            ,     12    ,   14    ,    2    //:159        158://
            ,     12    ,   15    ,    3    //:160        159://
            //: glo_com | aus_dex | til_val //:SUM        DEX://

            //: 32 + ( 16 * 8 )==160             ............://
            //: @VID_IID[ 0083 ]TIME[ 04:28:12 ] ............://
            //: Checksum looks good to me!       ............://

            //: glo_com | aus_dex | til_val //:SUM        DEX://
            };;
            //:----------------------:table_of_unit_test_code://
            //:helper_table:---------------------------------://
            //:convert_aus_dex_to_bit_indexes:---------------://
            U08 tab_hel[ 32 ]={ /** hel:HELper **/
                0 , 1  //: 01  -  aus_dex # 0 ==> [  0 , 1 ] ://
            ,   2 , 3  //: 02  -  aus_dex # 1 ==> [  2 , 3 ] ://
            ,   4 , 5  //: 03  -  aus_dex # 2 ==> [  4 , 5 ] ://
            ,   6 , 7  //: 04  -  aus_dex # 3 ==> [  6 , 7 ] ://
            ,   8 , 9  //: 05  -  aus_dex # 4 ==> [  8 , 9 ] ://
            ,  10 ,11  //: 06  -  aus_dex # 5 ==> [ 10 ,11 ] ://
            ,  12 ,13  //: 07  -  aus_dex # 6 ==> [ 12 ,13 ] ://
            ,  14 ,15  //: 08  -  aus_dex # 7 ==> [ 14 ,15 ] ://
            ,  16 ,17  //: 09  -  aus_dex # 8 ==> [ 16 ,17 ] ://
            ,  18 ,19  //: 10  -  aus_dex # 9 ==> [ 18 ,19 ] ://
            ,  20 ,21  //: 11  -  aus_dex #10 ==> [ 20 ,21 ] ://
            ,  22 ,23  //: 12  -  aus_dex #11 ==> [ 22 ,23 ] ://
            ,  24 ,25  //: 13  -  aus_dex #12 ==> [ 24 ,25 ] ://
            ,  26 ,27  //: 14  -  aus_dex #13 ==> [ 26 ,27 ] ://
            ,  28 ,29  //: 15  -  aus_dex #14 ==> [ 28 ,29 ] ://
            ,  30 ,31  //: 16  -  aus_dex #15 ==> [ 30 ,31 ] ://
            };;
            //:---------------:convert_aus_dex_to_bit_indexes://
            //:---------------------------------:helper_table://
            //:test_loop:------------------------------------://
            m_i=( NUM_TES - 1 ); //:max_test_index
            for( era = 1 ; era <=  2  ; era ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                if( 1 == era ){

                    /** @VID_IID[ 0083 ]TIME[ 02:08:55 ]     **/
                    /** erase cpu_pix before next test       **/

                    for( I32 b = 0 ; b <= ((4*4)-1) ; b++ ){    
                        cpu_pix[ b ] = ( 0x00 );//:erase_byte
                    };;
            
                }else
                if( 2 == era ){

                    /**  OKAY! DO ____NOTHING____ .......... **/
                    
                    /**   @VID_IID[ 0083 ]TIME[ 02:06:55 ]   **/
                    /**   Do NOT erase previous set values.  **/
                    /**   Our getter logic might be reading  **/
                    /**   MORE BITS than it should be .      **/

                }else{
                    ERR("BAD_ERA_VALUE:2021]");
                };;

                //:get_base_data_offset:---------------------://

                bas = ( t_i * NUM_ELM ); //:t_i times stride
                
                //:---------------------:get_base_data_offset://
                //:extract_test_table_values:----------------://

                glo_com = tab_utc[ bas + 0 ];
                aus_dex = tab_utc[ bas + 1 ];
                til_val = tab_utc[ bas + 2 ];
                assert( glo_com % 4 == 0   ); //:Divisible_by_4
                assert( glo_com <= ( 16-1) ); //:4 pixels only.
                assert( aus_dex <= ( 16-1) ); //:Ausets 0-to-15
                assert( til_val <= (    3) ); //: 11 10 01 00

                //:----------------:extract_test_table_values://
                //:manually_pack_data_to_get:----------------://

                /** What bit indexes are we looking at       **/
                /** if data where crammed into 32 bit integer**/
                bi0 = (  tab_hel[ ( aus_dex*2) + 0 ] );
                bi1 = (  tab_hel[ ( aus_dex*2) + 1 ] );
                if( bi0 + 1 != bi1 ){ ERR("[BAD_BIT_ONE]"); };

                /** extract what is already there **/
                u32_var=( 0x00
                | ( cpu_pix[ glo_com + 0 ] << 24 ) //: R ://
                | ( cpu_pix[ glo_com + 1 ] << 16 ) //: G ://
                | ( cpu_pix[ glo_com + 2 ] <<  8 ) //: B ://
                | ( cpu_pix[ glo_com + 3 ] <<  0 ) //: A ://
                );;  /** @PAIR_CODE_2021_01_14@ **/

                /** replace correct 2 bits within u32_var **/
                u32_var=(

                    /** erase 2-bit slot in u32_var **/
                    ( u32_var &  (~(BIN_011 << bi0 )) )

                | //:<-- or to merge together bit patterns

                    /** insert 2-bit value into u32_var **/
                    (            (til_val << bi0 ) )

                );;

                /** @VID_IID[ 0083 ]TIME[ 03:43:32 ] **/
                /** Test specific test case.         **/
                if( 1 == era && 2 == t_i ){
                    if( u32_var != 2 ){
                        ERR("[u32_var_improper_packing]");
                    };;
                };;

                /** Overwrite the original uint32 value that **/
                /** is stored as 4 bytes. .................. **/
                /** @VID_IID[ 0083 ]TIME[ 1H 17M 22S ] ..... **/
                /** @VID_IID[ 0083 ]TIME[ 03:38:50   ]FIXED  **/
                /** @VID_IID[ 0083 ]TIME[ 03:44:55   ]FIX_02 **/
                
                cpu_pix[ glo_com  +  0 ]=( //: R ://
                      (( u32_var >> 24 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  1 ]=( //: G ://
                      (( u32_var >> 16 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  2 ]=( //: B ://
                      (( u32_var >>  8 ) &  0xFF)//: 8 bit mask
                );;
                cpu_pix[ glo_com  +  3 ]=( //: A ://
                      (( u32_var >>  0 ) &  0xFF)//: 8 bit mask
                );;

                //:----------------:manually_pack_data_to_get://
                //:run_getter_being_tested:------------------://
                #define GOT_VAL_TRAP ( 123 )

                got_val=( GOT_VAL_TRAP /** @TRAP_VALUE@ **/ );
                aac2020_paint5d_BitPack_Get(
                    cpu_pix //: U08* :  pixel byte array     ://
                ,   glo_com //: U08  :  red byte component   ://
                ,   aus_dex //: U08  :  auset index #        ://
                , &(got_val)//: U08* :  tile value to GET    ://
                );;

                if( GOT_VAL_TRAP == got_val ){
                    /** @VID_IID[ 0083 ]TIME[ 1H 38M 52S ] **/
                    ERR("[GETTER_IS_NOT_TOUCHING_OUT_PARAM]");
                };;

                #undef GOT_VAL_TRAP
                //:------------------:run_getter_being_tested://
                //:compare_actual_vs_expected:---------------://

                if( got_val != til_val ){

                    printf("\n\n");
                    printf("[TEST_FAILED_CHECK_THE_BINARY...]");
                    printf("\n\n");

                    printf("[....era]:%d\n" ,     era );
                    printf("[....t_i]:%d\n" ,     t_i );
                    printf("[got_val]:%d\n" , got_val );
                    printf("[til_val]:%d\n" , til_val );
                    
                    /** @VID_IID[ 0083 ]TIME[ 1H 30M 40S ]   **/
                    /** loop over cpu_pix and count number   **/
                    /** of NON_ZERO bytes within array.      **/
                    zer=( 0 );
                    non=( 0 );
                    for( I32 B_i = 0 ; B_i <= (16-1) ; B_i++ ){

                        if( 0x00 == cpu_pix[ B_i ] ){ zer++; };
                        if( 0x00 != cpu_pix[ B_i ] ){ non++; };

                    };;

                    /** Print off binary of all 4 pixels     **/
                    /** to visually confirm correct data.    **/
                    printf("\n");
                    printf("[PIXEL_PRINTOFF:BEG]\n");
                    U32 bit        =( 0 ); //:binary bit value
                    I32 make_space =( 0 );
                    I32 make_newline=( 0 );
                    I32 g_i_chk =( 32 ); //:global_bit_index_chk
                    I32 l_i_chk =(  8 ); //:local__bit_index_chk
                    for( I32 pix = 0 ; pix <= (4 -1) ; pix++ ){
                    for( I32 b_i = 0 ; b_i <= (32-1) ; b_i++ ){

                        make_space  =( 0 );
                        make_newline=( 0 );

                        /** @VID_IID[ 02:42:01 ] ........... **/
                        g_i_chk--; /** 31 to 0 counting down.**/
                        if( g_i_chk <= (0-1) ){ g_i_chk = 31; };

                        l_i_chk--; /** 7 to 0 counting down. **/
                        if( l_i_chk <= (0-1) ){ l_i_chk =  7; };
    
                        /** Inverted bit index. MSB first. **/
                        I32 inv_b_i = ( 31 - b_i );
                        I32     l_i ; /** Local Bit Index **/
                        I32     cmp ; /** Component Index **/

                        //:get_local_bit_index:--------------://

                        //:@VID_IID[ 0083 ]TIME[ 02:30:30 ]  ://
                        //:@VID_IID[ 0083 ]TIME[ 02:37:00 ]  ://
                        //:SEE_DIAGRAM[ #DIA_P5D_U32#     ]  ://
                        //:SEE_FILE[    PAINT5D.D._       ]  ://

                        assert( inv_b_i == g_i_chk );

                        if(    inv_b_i <= 31    
                        &&     inv_b_i >= 24 ){ 
                        l_i =( inv_b_i  - 24 );
                        cmp =(    0    ); //:RED    COMPONENT
                        }else

                        if(    inv_b_i <= 23    
                        &&     inv_b_i >= 16 ){ 
                        l_i =( inv_b_i  - 16 );
                        cmp =(    1    ); //:GREEN  COMPONENT
                        }else

                        if(    inv_b_i <= 15   
                        &&     inv_b_i >=  8 ){ 
                        l_i =( inv_b_i  -  8 );
                        cmp =(    2    ); //:BLUE   COMPONENT
                        }else

                        if(    inv_b_i <= 7   
                        &&     inv_b_i >= 0 ){ 
                        l_i =( inv_b_i  - 0 );
                        cmp =(    3    ); //:ALPHA  COMPONENT
                        }else

                        { ERR("[BAD_INVERTED_BIT_INDEX]"); }
                        //:--------------:get_local_bit_index://

                        assert( l_i <= ( 8-1)  );
                        assert( l_i >=    0    );
                        if(     l_i != l_i_chk ){
                            ERR("[l_i_CHECK_FAIL_2021]");
                        };;

                        /** @VID_IID[ 0083 ]TIME[ 02:33:50 ] **/
                        bit =( 
                        ( cpu_pix[ ( pix * 4 ) + cmp ] >> l_i )
                            & 1 //:Masked with binary "1"
                        );;

                        

                        if( 0 == b_i && 0 == pix ){
                            make_newline=( 1 );
                        };;
                        if( 31 == inv_b_i ){
                            make_newline=( 1 );
                        };;
                

                        if( 0
                        ||  ( 24 - 1) == inv_b_i
                        ||  ( 16 - 1) == inv_b_i
                        ||  (  8 - 1) == inv_b_i
                        //  (  0 - 1) == inv_b_i
                        ){
                            make_space=( 1 );
                        };;

                        if( make_space   ){ printf(" | "); };
                        if( make_newline ){ 

                            if( 0 != pix ){ printf(" | " ); };

                            printf("\n" ); 
                            printf("[pix#]:(%d) | " , pix);
                        };;

                        if( 0 == bit ){ printf("0"); }else
                        if( 1 == bit ){ printf("1"); }else
                        {
                            ERR("[BAD_BIT_VALUE_2021]");
                        };;
                        if( 0
                        ||  ( 28  ) == inv_b_i //: R dash
                        ||  ( 20  ) == inv_b_i //: G dash
                        ||  ( 12  ) == inv_b_i //: B dash
                        ||  (  4  ) == inv_b_i //: A dash
                        ){
                            printf(" - ");
                        };;

                    };;};;

                    printf(" | "); //:Get that last bar in.

                    printf("\n\n[PIXEL_PRINTOFF:END]\n");
                    printf("\n");

                    assert( ( zer + non ) == 16 ); //:16 bytes
                    printf("[....zer]:%d\n" ,     zer );
                    printf("[....non]:%d\n" ,     non );

                    ERR("[GET_FAIL_2021_got_val_NOT_til_val]");
                };;

                //:---------------:compare_actual_vs_expected://
            };;};; //:Next[ era , t_i ]
            //:------------------------------------:test_loop://

        #undef  BIN_011 /** Binary: 11 **/            //: 01 ://
        #undef  NUM_ELM                               //: 02 ://
        #undef  NUM_TES                               //: 03 ://
        }                                          

    #undef  VERY_SPECIFIC_DEFINES_HERE_ONLY
    //:------------------------:ADDED_FUNC_PAIR_ON_2021_01_09://
    //:ADDED_FUNCTION_ON_DATE_2021_01_07:--------------------://
    #define VERY_SPECIFIC_DEFINES_HERE_ONLY

        void
        aac2020_paint5d_UTC_pix_CTO_pix_PUT_GET( void )
        {
            /** This function was added on:     **/
            /** DATE[  2021_01_07 ]             **/
            /** VID_IID[ 0080 ]TIME[ 00:36:20 ] **/

            I32 p_x;
            I32 p_y;

            U08 til_qua ;
            U08 til_exp ;
            U08 til_lay ;
            U08 loc_t_x ;
            U08 loc_t_y ;
            I16 glo_t_x ;
            I16 glo_t_y ;
    
            for( p_x = 0 ; p_x <= ( 512 - 1 ); p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ); p_y ++ ){

                /** Skip over the configuration pixels.      **/
                /** @VID_IID[ 00:39:20 ]                     **/
                if((256-1)==p_x && ( 256-1)==p_y ){ continue; };
                if((512-1)==p_x && ( 256-1)==p_y ){ continue; };
                if((256-1)==p_x && ( 512-1)==p_y ){ continue; };
                if((512-1)==p_x && ( 512-1)==p_y ){ continue; };

                glo_t_x =( p_x );
                glo_t_y =( p_y );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(til_qua)  //: Auset Tile Sub Quad Index  ://
                , &(til_exp)  //: TileSizeExponentEnum       ://
                , &(til_lay)  //: TileLayer ...............  ://
                , &(loc_t_x)  //: Local  Tile X Coord / b_x  ://
                , &(loc_t_y)  //: Local  Tile Y Coord / b_y  ://
                ,   glo_t_x   //: Global Tile X Coord        ://
                ,   glo_t_y   //: Global Tile X Coord        ://
                );;

                /** Make absolutely sure that           .....**/
                /** aac2020_paint5d_painpix_CTO_glocpix .....**/
                /** is actually setting these values.   .....**/
                glo_t_x=( 0 - 333 );
                glo_t_y=( 0 - 222 );

                aac2020_paint5d_painpix_CTO_glocpix(
                    til_qua   //: Auset Tile Sub Quad Index  ://
                ,   til_exp   //: TileSizeExponentEnum       ://
                ,   til_lay   //: TileLayer ...............  ://
                ,   loc_t_x   //: Local  Tile X Coord / b_x  ://
                ,   loc_t_y   //: Local  Tile Y Coord / b_y  ://
                , &(glo_t_x)  //: Global Tile X Coord        ://
                , &(glo_t_y)  //: Global Tile X Coord        ://
                );;

                if( 0
                || ( glo_t_x != p_x )
                || ( glo_t_y != p_y )
                ){
                    ERR("[YOU_DONE_FAILED_2021_SUPER]");
                };;

            };;};;

            LOG("[99%_SURE_WORKS:painpix_CTO_glocpix]", 0);
            LOG("[99%_SURE_WORKS:glocpix_CTO_painpix]", 0);
        }

    #undef  VERY_SPECIFIC_DEFINES_HERE_ONLY
    //:--------------------:ADDED_FUNCTION_ON_DATE_2021_01_07://
    //:MAIN_GET_PUT_TESTS:-----------------------------------://
    #define NUM_TEST_CASES_put (  8  )                  //:01://
    #define NUM_TEST_COLMS_put (  7  ) /**COLUMNS**/    //:02://
    #define NUM_TEST_CASES_get (  8  )                  //:03://
    #define NUM_TEST_COLMS_get (  7  ) /**COLUMNS**/    //:04://

        void aac2020_paint5d_UTC_Put( void )
        {

            /** @VID_IID[ 0070 ]TIME[ 1H 9M 50S ] .......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  p_g ; /** Put( 0 ) or Get( 1 ) Loop. .......**/
            I32  t_i ; /** Test_row_Index             .......**/
            I32  bas ; /** BASe_offset_of_test_data   .......**/
            I32  m_i =( NUM_TEST_CASES_put - 1);

            /* Input VALUES:@VID_IID[ 0071 ]T[ 1H 57M 17S ] */
            U08     til_qua ;   //:--------------------------://
            U08     til_exp ;   //:                          ://
            U08     til_lay ;   //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08     loc_t_x ;   //:                          ://
            U08     loc_t_y ;   //:--------------------------://
                                //:--------------------------://
            U08     aus_dex ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
            U08 put_til_val ;   //:   SEE[ #DIA_P5D_MAIN#   ]://
                                //:--------------------------://

            /** Output Value:@VID_IID[ 0071 ]T[ 1H 57M 17S ] **/

            U08 got_til_val ;

            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 NUM_TEST_CASES_put
                            *
                 NUM_TEST_COLMS_put
            ]={
            /**8 smoke tests. @VID_IID[ 0071 ]T[ 1H 40M 20S ]**/
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   aus_   _val
/*  00  01  */  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
/*  01  02  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    0
/*  02  03  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    0
/*  03  04  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    0
/*  04  05  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,    3
/*  05  06  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,    1 ,    3
/*  06  07  */, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,   15 ,    3  
/*  07  08  */,    1 ,    1 ,    1 ,    1 ,    1 ,    1 ,    1
/// --  --    : _qua   _exp   _lay   loc_   loc_   aus_   _val
/// --  --    : 0001   0002   0003   0004   0005   0006   0007

                /** TODO: More tests **/
            };;
            AAC2020_TODOMAN_Vital("[MORE_TESTS!!!!2021]");

            for( p_g = 0 ; p_g <=( 1 ); p_g ++ ){
            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * NUM_TEST_COLMS_put );

                /** Setting @TRAP_VALUES               * * * **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 53S ] * * * **/

                til_qua=( 101 );  /** @TRAP_VALUES@ **/
                til_exp=( 102 );  /** @TRAP_VALUES@ **/
                til_lay=( 103 );  /** @TRAP_VALUES@ **/
                loc_t_x=( 104 );  /** @TRAP_VALUES@ **/
                loc_t_y=( 105 );  /** @TRAP_VALUES@ **/
                aus_dex=( 106 );  /** @TRAP_VALUES@ **/
            put_til_val=( 107 );  /** @TRAP_VALUES@ **/

                /** Extracted Values For The Current Test    **/
                /** @VID_IID[ 0071 ]TIME[ 1H 47M 24S ] * * * **/

                til_qua=(         (U08)tab_utc[ bas + 0 ] );
                til_exp=(         (U08)tab_utc[ bas + 1 ] );
                til_lay=(         (U08)tab_utc[ bas + 2 ] );
                loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                aus_dex=(         (U08)tab_utc[ bas + 5 ] );
            put_til_val=(         (U08)tab_utc[ bas + 6 ] );

                /** Integer Overflow Dectection.             **/
                /** @VID_IID[ 0071 ]TIME[ 1H 46M 08S ]       **/
                #define      TIL_VAL put_til_val
                assert(((I16)til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)aus_dex)==tab_utc[ bas + 5 ] );
                assert(((I16)TIL_VAL)==tab_utc[ bas + 6 ] );
                #undef       TIL_VAL

                //:all_puts_before_all_gets:-----------------://
                //:                                          ://
                //: @VID_IID[ 0071 ]TIME[ 02H 03M 44S ]      ://
                //: We do all of the AAC2020_PAINT5D_Put(..) ://
                //: calls BEFORE all of the                  ://
                //: AAC2020_PAINT5D_Get(...) calls in case   ://
                //: we have overlapping [ memory / pixel ]   ://
                //: locations where the data is being stored.://
                //:                                          ://
                //: If we do interlaced                      ://
                //:"get(..) then put(..)" calls, we may      ://
                //: end up with a "FALSE UNIT TEST PASS"     ://
                //:                                          ://
                //:all_puts_before_all_gets:- - - - - - - - -://

                if( 0 == p_g ){
                AAC2020_PAINT5D_Put(
                        til_qua    /* AusetTile SubQuad Index */
                ,       til_exp    /* TileExponent            */
                ,       til_lay    /* TileLayer ..............*/
                ,       loc_t_x    /* LocalTile X Coord / b_x */
                ,       loc_t_y    /* LocalTile Y Coord / b_y */
                ,       aus_dex    /* AUSet_inDEX             */
                ,   put_til_val    /* [ val_cur / til_val ]   */
                );; };;

                if( 1 == p_g ){
                AAC2020_PAINT5D_Get(
                        til_qua    /** Same exact variables  **/
                ,       til_exp    /** as "Put(..)" function **/
                ,       til_lay    /** but last parameter is **/
                ,       loc_t_x    /** an OUTPUT parameter.  **/
                ,       loc_t_y    /** @VID_IID[ 0071 ]      **/
                ,       aus_dex    /** @TIME[ 2H 00M 50S ]   **/
                ,&( got_til_val )  
                );; };;

                assert( ( 1 == p_g ) || ( 0 == p_g ) );
 
                //:-----------------:all_puts_before_all_gets://

            };;};; //:NEXT[ p_g , t_i ]
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( 
                "[MORE_TESTS:aac2020_paint5d_UTC_Put]"
            );;

        }  //:[ END: paint5d_UTC_Put ]://

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get( void )
        {

            U08     t_i; //:Test Index
            U08     bas; //:Base Offset To Test Data Points

            U08 til_qua;
            U08 til_exp;
            U08 til_lay;
            U08 loc_t_x;
            U08 loc_t_y;
            U08 aus_dex;

            U08 exp_til_val; //:EXPECTED: til_val
            U08 act_til_val; //:ACTUAL::: til_val

            //:meddling_test:001:----------------------------://
            /** @VID_IID[ 0071 ]TIME[ 2H 31M 03S ]           **/
            //:meddling_test:001::- - - - - - - - - - - - - -://

                AAC2020_PIXNAME_paint5d_cpu_pix[ 0 ]=(
                    0x11 /** RED   BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 1 ]=(
                    0x22 /** GREEN BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 2 ]=(
                    0x33 /** BLUE  BITS **/
                );;
                AAC2020_PIXNAME_paint5d_cpu_pix[ 3 ]=(
                    0x44 /** ALPHA BITS **/
                );;
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ]
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ]
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ]
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ]

                //: @VID_IID[ 0071 ]TIME[ 2H 42M 21S ]       ://
                //: Overlay the[ aus_dex ] over the correct  ://
                //: 2-bit pattern ( til_val ) it should      ://
                //: be paired with.                          ://
                //:                            15 14 13 12   ://
                assert( 0x11 == 17 ); //: BIN[ 00 01 00 01 ] ://
                //:                                          ://
                //:                            11 10 09 08   ://
                assert( 0x22 == 34 ); //: BIN[ 00 10 00 10 ] ://
                //:                                          ://
                //:                            07 06 05 04   ://
                assert( 0x33 == 51 ); //: BIN[ 00 11 00 11 ] ://
                //:                                          ://
                //:                            03 02 01 00   ://
                assert( 0x44 == 68 ); //: BIN[ 01 00 01 00 ] ://
 
                /** Test Table #001 for meddling test #001   **/
                /** @VID_IID[ 0071 ]TIME[ 2H 59M 10S ]       **/

                U08 tab_001[ 16 * 2 ]={
                //:          aus_dex | til_val
                  /** 00 **/   0x0   ,   0x0
                , /** 01 **/     1   ,     1  /* 1 : BIN[ 01 ]*/
                , /** 02 **/     2   ,     0
                , /** 03 **/     3   ,     1
                , /** 04 **/     4   ,     3  /* 3 : BIN[ 11 ]*/
                , /** 05 **/     5   ,     0
                , /** 06 **/     6   ,     3
                , /** 07 **/     7   ,     0
                , /** 08 **/     8   ,     2 /** 2 : BIN[ 10 ]*/
                , /** 09 **/     9   ,     0
                , /** 10 **/    10   ,     2
                , /** 11 **/    11   ,     0
                , /** 12 **/    12   ,     1
                , /** 13 **/    13   ,     0
                , /** 14 **/    14   ,     1
                , /** 15 **/    15   ,     0 /** 0 : BIN[ 00 ]*/
                };;
       
                /** **************************************** ***
                    @VID_IID[ 0071 ]TIME[ 02H 55M 20S ] 
                    The first meddling test using
                    table[ tab_001 ] only looks at data
                    we set on the very first pixel.
                    
                    This is because we want to confirm
                    our [ bit shifting & bit packing ]
                    logic is correct and don't want the
                    mistake in this test to be looking
                    at the WRONG PIXEL LOCATION.

                *** **************************************** **/

                for( t_i = 0 ; t_i <= 15 ; t_i ++ ){

                        bas =( t_i * 2 );  /*2 colums per test*/
                    aus_dex = tab_001[ bas + 0 ];
                exp_til_val = tab_001[ bas + 1 ];

                    /** Might not be true for other meddling **/
                    /** tests. But true for this one.        **/
                    assert( t_i == aus_dex );

                    AAC2020_PAINT5D_Get(
                        ( til_qua = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_exp = 0 )  //: <-- FIRST_PIXEL
                    ,   ( til_lay = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_x = 0 )  //: <-- FIRST_PIXEL
                    ,   ( loc_t_y = 0 )  //: <-- FIRST_PIXEL
                    ,   ( aus_dex     )  
                    ,  &( act_til_val )  
                    );;

                    if( exp_til_val != act_til_val ){
                        ERR("[MEDDLING_TEST_NUMBER_001]");
                    };;

                };;

            //:----------------------------:meddling_test:001://
            //:meddling_Test:002:----------------------------://

                /** **************************************** **/
                /** @VID_IID[ 0071 ]TIME[ 03H 06M 49S        **/
                /** Now that we know our bit shifting math   **/
                /** is working, test with a pixel that is    **/
                /** NOT at [ 0,0 ] on our bitmap to verify   **/
                /** physical locations of pixel data are     **/
                /** also correct.                            **/
                /** **************************************** **/

                AAC2020_TODOMAN_Vital("[TestWithAnotherPixel]");
    
            //:----------------------------:meddling_test:002://

            AAC2020_TODOMAN_Vital("[FINISH_THIS_CODE!!!!!!!]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Put_Get( void )
        {
            /** PUT & GET test for the MAIN functionality.   **/
            /** 1: AAC2020_PAINT5D_Put( ... )                **/
            /** 2: AAC2020_PAINT5D_Get( ... )                **/

            /** ******************************************** ***
                About THIS[ paint5d_UTC_Put_Get ]FUNCTION:

                Tests every single possible value there
                is by iterating over the entire 512x512
                bitmap in a double nested [ p_x , p_y ]
                loop. 
            *** ******************************************** **/

            I16 p_x; /** pixel x location **/
            I16 p_y; /** pixel y location **/
            /** ******************************************** ***
                @VID_IID[ 0071 ]TIME[ 00H 07M 54S  ]
                [p_x ,p_y ] == [ glo_t_x , glo_t_y ]
                Located On: AAC2020_PIXNAME_paint5d_cpu_pix
            *** ******************************************** **/

            //:@VID_IID[ 0079 ]TIME[ 00H 36M 05S ] ://
            //:#skipped_configuration_pixels#      ://
            U08 skipped_configuration_pixels = ( 0 );
            
            U08 til_qua    ; //:-----------------------------://
            U08 til_exp    ; //:                             ://
            U08 til_lay    ; //:                             ://
            U08 loc_t_x    ; //: FOR: glocpix_CTO_painpix    ://
            U08 loc_t_y    ; //:                             ://
                             //:                             ://
            I16 glo_t_x_001; //: Expected & Actual are       ://
            I16 glo_t_y_001; //: meaningless terms for       ://
                             //: these variables.            ://
            I16 glo_t_x_002; //: @VID_IID[ 0071 ]            ://
            I16 glo_t_y_002; //: TIME[ 01H 18M 07 ]          ://
                             //:_____________________________://

            til_exp=( 232 /** @TRAP_VALUE@ **/ );

            /** Before Testing "GET" and "PUT" functions     **/
            /** we will test the uderlying conversion        **/
            /** functions first.                             **/

            for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
            for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                glo_t_x_001 = p_x; /** Load Function Inputs **/
                glo_t_y_001 = p_y; /** Load Function Inputs **/

                //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:--------://
                if( 255 == p_x && 255 == p_y ){ //:T_L:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 511 == p_x && 255 == p_y ){ //:T_R:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 255 == p_x && 511 == p_y ){ //:B_L:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                }else
                if( 511 == p_x && 511 == p_y ){ //:B_R:u32_cfg
                    skipped_configuration_pixels++;
                    continue;
                };;
                //:----------:_SKIP_CONFIG_PIXELS_P5D_PUTGET_://

                aac2020_paint5d_glocpix_CTO_painpix(
                   &( til_qua     )    /// Auset Sub Quad    ///
                ,  &( til_exp     )    /// Size_Exponent     ///
                ,  &( til_lay     )    /// TileLayer ........///
                ,  &( loc_t_x     )    /// Local  Tile X     ///
                ,  &( loc_t_y     )    /// Local  Tile Y     ///
                ,   ( glo_t_x_001 )    /// Global Tile X     ///
                ,   ( glo_t_y_001 )    /// Global Tile X     ///
                );;

                if( til_exp >= 8 ){
                    ERR("[BAD_TIL_EXP_2021_547PM:AYE]");
                };;

                aac2020_paint5d_painpix_CTO_glocpix(
                    ( til_qua )        /// Auset Sub Quad    ///
                ,   ( til_exp )        /// Size_Exponent     ///
                ,   ( til_lay )        /// TileLayer ........///
                ,   ( loc_t_x )        /// Local  Tile X     ///
                ,   ( loc_t_y )        /// Local  Tile Y     ///
                ,  &( glo_t_x_002 )    /// Global Tile X     ///
                ,  &( glo_t_y_002 )    /// Global Tile X     ///
                );;

                if( 0
                || glo_t_x_001 != glo_t_x_002
                || glo_t_y_001 != glo_t_y_002
                ){
                    ERR("[GET_PUT_TEST_FAILED:YEAR_2021]");
                };;

            };;};;
            if( 4 != skipped_configuration_pixels ){
                ERR("[BAD_SKIP_AMOUNT_2021:A]");
            };;

            //:Declare_Vars:Put_Get_Tests:-------------------://

                U08 ptg_put_val; //:PutThenGet_PUT_VALue
                U08 ptg_got_val; //:PutThenGet_GOT_VALue

                U32 val_gen; //:Used to generate val_til
                U08 val_til;
                U08     aus; //:Auset_Index_0_to_15
                U08     p_g; //:Put(0) or Get(1)

            //:-------------------:Declare_Vars:Put_Get_Tests://
            //:Put_Then_Get_Test_Interlaced:001:-------------://
            /** ********************************************* **

                @VID_IID[ 0079 ]TIME[ 02H 36M 30S ]

                If this section passes [ Put_Then_Get_Tests ]
                But the next section FAILS
                [ Put_Everything_Then_Get_Everything ]
                That is definitely indicative of some
                type of memory-stomping situation.

                Memory Stomps:
                    1. Storing data in same pixel.
                    2. Storing data in same bits of pixel.

                    If the coordinates are not wrong (#1), it
                    could be the BITPACKING and BITUNPACKING
                    (#2) that is wrong.
            
                Investigate BITPACKING if you need to.

            *** ******************************************** **/
             
                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                    skipped_configuration_pixels=( 0 );
                    val_gen =( 0 );

                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    val_gen = ( val_gen + 7 );
                    val_til = (U08)( val_gen % 4 );
                    assert( val_til <= 3 /* Max val_til :3 */);;

                    //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:----://
                    if( 0
                    ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                    ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                    ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                    ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                    ){
                        skipped_configuration_pixels++;
                        continue;
                    };;
                    //:-----#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:BEE]");
                    };;

                    ptg_put_val =( val_til );

                    AAC2020_PAINT5D_Put(
                            til_qua    
                    ,       til_exp    
                    ,       til_lay    
                    ,       loc_t_x    
                    ,       loc_t_y    
                    ,           aus  //: aus_dex ://  
                    ,   ptg_put_val  //: til_val / put_val ://
                    );;   

                    AAC2020_PAINT5D_Get(
                            til_qua    
                    ,       til_exp    
                    ,       til_lay    
                    ,       loc_t_x    
                    ,       loc_t_y    
                    ,           aus  //: aus_dex ://  
                    , &(ptg_got_val) //: til_val / put_val ://
                    );;    

                    if( ptg_put_val != ptg_got_val ){

                        ERR("[You_Done_Got_Some_Problems]");
            
                    };;

                };;};;

                    if( 4 != skipped_configuration_pixels ){
                        ERR("[WeHaveAproblem:2021_01_07]");
                    };;

                };; //:NEXT[ aus ](AUto_tile_Set)

            //:-------------:Put_Then_Get_Test_Interlaced:001://
            //:Put_Then_Get_Test_Interlaced:002:-------------://
            /** ********************************************* **

                @VID_IID[ 0080 ]TIME[ 00H 04M 53S ]
                
                The previous test passed. I am guessing
                the problem I am currently looking for is
                because of bitpacking. If the inner most
                loop loops through all possible "aus" values
                I bet we will have a problem on the 2nd
                aus interation.

            *** ******************************************** **/   
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                /** @VID_IID[ 0080 ]TIME[ 00:16:57 ]         **/
                /** PUT all values packed into same uint32   **/
                /** THEN try to get all values packed into   **/
                /** the uint32. Thus "p_g" must be outer     **/
                /** loop and "aus" the inner loop.           **/
                for( p_g = 0 ; p_g <= (     1   ) ; p_g ++ ){
                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                    if( 0 == aus ){ val_til = ( 0 ); }else
                    if( 1 == aus ){ val_til = ( 1 ); }else
                    if( 2 == aus ){ val_til = ( 2 ); }else
                    if( 3 == aus ){ val_til = ( 3 ); }else
                    if( 4 == aus ){ val_til = ( 0 ); }else
                    if( 5 == aus ){ val_til = ( 1 ); }else
                    if( 6 == aus ){ val_til = ( 2 ); }else
                    if( 7 == aus ){ val_til = ( 3 ); }else
                    if( 8 == aus ){ val_til = ( 0 ); }else
                    if( 9 == aus ){ val_til = ( 1 ); }else
                    if(10 == aus ){ val_til = ( 2 ); }else
                    if(11 == aus ){ val_til = ( 3 ); }else
                    if(12 == aus ){ val_til = ( 2 ); }else
                    if(13 == aus ){ val_til = ( 1 ); }else
                    if(14 == aus ){ val_til = ( 0 ); }else
                    if(15 == aus ){ val_til = ( 0 ); }else
                    { ERR("[INVALID_AUS_VALUE_FOR_TEST]"); };
                    assert( val_til <= 3 );

                    //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:----://
                    if( 0
                    ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                    ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                    ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                    ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                    ){
                        skipped_configuration_pixels++;
                        continue;
                    };;
                    //:-----#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:CEE]");
                    };;

                    ptg_put_val =( val_til );

                    if( 0 == p_g ){

                        AAC2020_PAINT5D_Put(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus  
                        ,   ptg_put_val  
                        );;   

                        AAC2020_PAINT5D_Get(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus   
                        , &(ptg_got_val)  
                        );;    

                        if( ptg_put_val != ptg_got_val ){

                            ERR("[OH_MY_FUCKING_GOD_123]");
            
                        };;

                    }else
                    if( 1 == p_g ){

                        AAC2020_PAINT5D_Get(
                                til_qua    
                        ,       til_exp    
                        ,       til_lay    
                        ,       loc_t_x    
                        ,       loc_t_y    
                        ,           aus   
                        , &(ptg_got_val)  
                        );;    

                        if( ptg_put_val != ptg_got_val ){

                            /** If this error gets triggered **/
                            /** Then I am 90% certain the    **/
                            /** problem is in how bits are   **/
                            /** being packed.                **/

                            ERR("[OH_MY_FUCKING_GOD_123]");
            
                        };;
                    }else{
                        ERR("[Neither_Put_Nore_Get]");
                    };;

                };;};; //:NEXT[ aus , p_g ]
                };;};; //:NEXT[ p_x , p_y ]

            //:-------------:Put_Then_Get_Test_Interlaced:002://
            //:Put_Everything_Then_Get_Everything:-----------://

            //: U08 p_g     =( 0 ); //:Put(0) or Get(1)
            //: U08 aus     =( 0 ); //:Auset_Index_0_to_15
            //: U32 val_gen =( 0 );
            //: U08 org_val =( 0 ); //:OriginalValue
                U08 got_val =( 0 ); //:GOTEN_VALUE
                U08 val     =( 0 ); //:Tile_value_0_1_2_or_3

                skipped_configuration_pixels=( 0 );

                for( p_g = 0 ; p_g <= (    1    ) ; p_g ++ ){
                
                    if( 
                        (  0 != skipped_configuration_pixels)
                    &&
                        ( 64 != skipped_configuration_pixels)
                    &&
                        (128 != skipped_configuration_pixels)
                    ){
                        printf("[scp]:%d\n"
                        ,skipped_configuration_pixels);;
                        ERR("[BAD_SKIP:P_G:...]");
                    };;

                    val_gen =( 0 );

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){

                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                //: val_gen = ( val_gen + 7 );
                //: val     = (U08)( val_gen % 4 );
                //: assert( val <= 3 /** Max Tile Val :3 **/ );

                    if(  0 == aus ){ val = 0; };  
                    if(  1 == aus ){ val = 1; };  
                    if(  2 == aus ){ val = 2; };  
                    if(  3 == aus ){ val = 3; };  
                    if(  4 == aus ){ val = 0; };  
                    if(  5 == aus ){ val = 0; };  
                    if(  6 == aus ){ val = 1; };  
                    if(  7 == aus ){ val = 2; };  
                    if(  8 == aus ){ val = 3; };  
                    if(  9 == aus ){ val = 0; };  
                    if( 10 == aus ){ val = 1; };  
                    if( 11 == aus ){ val = 2; };  
                    if( 12 == aus ){ val = 3; };  
                    if( 13 == aus ){ val = 3; };  
                    if( 14 == aus ){ val = 3; };  
                    if( 15 == aus ){ val = 3; };  

                //:#_SKIP_CONFIG_PIXELS_P5D_PUTGET_#:--------://
                if( 0
                ||  ( 255 == p_x && 255 == p_y ) //:TOP_LEF
                ||  ( 511 == p_x && 255 == p_y ) //:TOP_RIG
                ||  ( 255 == p_x && 511 == p_y ) //:BOT_LEF
                ||  ( 511 == p_x && 511 == p_y ) //:BOT_RIG
                ){
                    skipped_configuration_pixels++;
                    continue;
                };;
                //:----------:_SKIP_CONFIG_PIXELS_P5D_PUTGET_://

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:DEE]");
                    };;

                    if( 0 == p_g ){
 
                        AAC2020_PAINT5D_Put(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        ,       val  //: til_val / put_val ://
                        );;    

                        /** nic_val:                         **/
                        /**     NON_Interlaced_Check____VALUE**/
                        /** @VID_IID[ 0083 ]TIME[ 04:34:58 ] **/

                        U08 nic_val=( 222 /**@TRAP_VALUE@**/ );
                        AAC2020_PAINT5D_Get(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        , &(nic_val) //:Tile value to get.
                        );;    

                        if( nic_val != val ){
                            ERR("[NIC_VAL_TEST_FAIL_2021]");
                        };;
      
                    }else
                    if( 1 == p_g ){

                        AAC2020_PAINT5D_Get(
                            til_qua    
                        ,   til_exp    
                        ,   til_lay    
                        ,   loc_t_x    
                        ,   loc_t_y    
                        ,       aus  //: aus_dex ://  
                        , &(got_val )//: til_val ://
                        );;
                    }else{
                        ERR("[PG_OUT_OF_BOUNDS:2021]");
                    };;

                    if(    1    == p_g ){
                    if( got_val != val ){

                        printf("\n\n\n");
                        printf("[one:p_g]%d:\n"  ,     p_g );
                        printf("[....p_x]%d:\n"  ,     p_x );
                        printf("[....p_y]%d:\n"  ,     p_y );
                        printf("[....aus]%d:\n"  ,     aus );
                        printf("[got_val]%d:\n"  , got_val );
                        printf("[....val]%d:\n"  ,     val );

                        ERR("[TEST_DEF_FAIL_2021_HELLO_KITTY]");
                    };;};;

                };;};; //: [ p_x , p_y ] ::::::::::::::::::: ://

                };;};; //: [ p_g , aus ] ::::::::::::::::::: ://

            //:-----------:Put_Everything_Then_Get_Everything://
            //:ALL_ONES_AND_ALL_ZEROS_TEST_VARS:-------------://

                /** **************************************** ***

                    @VID_IID[ 0077 ]TIME[ 05H 21M 12S ]

                    The last two loops are pidgeon hole
                    smoke tests. 

                    [00] #_P5D_BINARY_TEST_00_#

                        IF: We set the binary tile value as
                        "[00]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ZEROS except for last 4 bytes.

                    [11] #_P5D_BINARY_TEST_11_#

                        IF: We set the binary tile value as
                        "[11]" on every tile...

                        THEN: We expect the underlying memory 
                        to be ALL ONES except for last 4 bytes.

                    WHY EVERYTHING BUT LAST 4 BYTES ?

                        The last pixel cannot encode 3 layers
                        and thus is not used in the data
                        structure to encode tile values.

                        The last pixel of the
                        [quarkmap / mipmap ] structure
                        is used as a special settings
                        preset number pixel
                
                *** **************************************** **/

                I32  b_i; //:Byte_Index
                I32  mpi; //:Max_PIXEL_Index
                I32  mbi; //:Max_Byte_Index

                U08  p_c ; /** Pixel_Component_Byte **/

            //:-------------:ALL_ONES_AND_ALL_ZEROS_TEST_VARS://
            //:Loop_Through_Set_All:1s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 1 bit.                              **/

                /** #_P5D_BINARY_TEST_11_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    /** Skip configuration pixels.           **/
                    /** @VID_IID[ 0083 ]TIME[ 05:04:10 ]     **/
                    if( 255 == p_x && 255 == p_y ){ continue; };
                    if( 511 == p_x && 255 == p_y ){ continue; };
                    if( 255 == p_x && 511 == p_y ){ continue; };
                    if( 511 == p_x && 511 == p_y ){ continue; };

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        printf("[p_x,p_y]:( %d , %d )\n",
                                 p_x,p_y );;
                        ERR("[BAD_TIL_EXP_2021_547PM:EEE]");
                    };;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         3  //: BINARY[ 11 ] ://
                    );;   //: 3  ://
                    //: DELTA[ Loop_Through_Set_All ]
                    //: DELTA_3

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0xFF_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0xFF != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ONE]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:1s://
            //:Loop_Through_Set_All:0s:----------------------://
            /** Everything but bottom right pixel should     **/
            /** end up a 0 bit.                              **/

                /** #_P5D_BINARY_TEST_00_# **/

                for( aus = 0 ; aus <= (  16 - 1 ) ; aus ++ ){
                for( p_x = 0 ; p_x <= ( 512 - 1 ) ; p_x ++ ){
                for( p_y = 0 ; p_y <= ( 512 - 1 ) ; p_y ++ ){

                    /** Skip configuration pixels.           **/
                    if( 255 == p_x && 255 == p_y ){ continue; };
                    if( 511 == p_x && 255 == p_y ){ continue; };
                    if( 255 == p_x && 511 == p_y ){ continue; };
                    if( 511 == p_x && 511 == p_y ){ continue; };

                    aac2020_paint5d_glocpix_CTO_painpix(
                       &( til_qua )    /// Auset Sub Quad    ///
                    ,  &( til_exp )    /// Size_Exponent     ///
                    ,  &( til_lay )    /// TileLayer ........///
                    ,  &( loc_t_x )    /// Local  Tile X     ///
                    ,  &( loc_t_y )    /// Local  Tile Y     ///
                    ,   (     p_x )    /// Global Tile X     ///
                    ,   (     p_y )    /// Global Tile X     ///
                    );;

                    if( til_exp >= 8 ){
                        ERR("[BAD_TIL_EXP_2021_547PM:EFF]");
                    };;

                    AAC2020_PAINT5D_Put(
                        til_qua    
                    ,   til_exp    
                    ,   til_lay    
                    ,   loc_t_x    
                    ,   loc_t_y    
                    ,       aus  //: aus_dex      ://  
                    ,         0  //: BINARY[ 00 ] ://
                    );;  //:  0   ://
                    //: DELTA[ Loop_Through_Set_All ]

                };;};;};;

                mpi=( 512 - 1 - 1 ); //:SKIP_BOTTOM_RIGHT
                //:YES: Minus_One_TWICE

                mbi=( ( mpi * 4 /**4==RGBA**/ )
                    + 0 //:RED   BYTE( NO_OFFSET )
                    + 1 //:GREEN BYTE_OF_mpi_pixel
                    + 1 //:BLUE  BYTE_OF_mpi_pixel
                    + 1 //:ALPHA BYTE_OF_mpi_pixel
                );;
                        
                for( b_i = 0 ; b_i <= mbi ; mbi ++ ){
            
                    /** Make sure byte index does NOT cause  **/
                    /** a SEGFAULT by going out of bounds.   **/
                    assert( ( b_i / 4 ) <= (( 512*512 ) - 1 ) );

                    p_c =AAC2020_PIXNAME_paint5d_cpu_pix[ b_i ];
                     
                    //:DELTA[ Loop_Through_Set_All ]
                    //: 0x00_IS_DELTA_OF[ Loop_Through_Set_All ]
                    if( 0x00 != p_c ){
                        ERR("[PIDGEON_HAS_A_PROBLEM:ZER]");
                    };;
                };;

            //:----------------------:Loop_Through_Set_All:0s://
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void aac2020_paint5d_UTC_Get_Put( void )
        {
            /** ******************************************** **/
            /** @VID_IID[ 0070 ]TIME[ 1H 19M 32S ]           **/  
            /** Make note of what is NOT done so that        **/
            /** no one comes along later and adds this       **/
            /** function.                                    **/
            /** CANNOT GET WHAT WAS NEVER PUT!!!!!!!!!!!!!!  **/
            /** ******************************************** **/

            ERR("[THERE_IS_ONLY:PUT_GET:NEVER:GET_PUT]");
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

    #undef  NUM_TEST_CASES_put                          //:01://
    #undef  NUM_TEST_COLMS_put                          //:02://
    #undef  NUM_TEST_CASES_get                          //:03://
    #undef  NUM_TEST_COLMS_get                          //:04://
    //:-----------------------------------:MAIN_GET_PUT_TESTS://
    //:paired_unit_tests::- - - ---- - - - - - - - - - - - - ://
    //:1: glocpix_CTO_painpix : ---- - - - - - - - - - - - - ://
    //:2: painpix_CTO_glocpix : ---- - - - - - - - - - - - - ://
    #define glocpix_CTO_painpix_CASES (  4  )         //: 01 ://
    #define glocpix_CTO_painpix_DATUM (  7  )         //: 02 ://
    #define painpix_CTO_glocpix_CASES (  4  )         //: 03 ://
    #define painpix_CTO_glocpix_DATUM (  7  )         //: 04 ://

        void
        aac2020_paint5d_UTC_glocpix_CTO_painpix( void )
        {

            /** @VID_IID[ 0069 ]TIME[ 1H 52M 50S ] ......... **/
            /** Variables for iterating through test cases . **/
            /** m_i means "max index" (inclusive range)      **/

            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( glocpix_CTO_painpix_CASES - 1);

            /* ACTUAL(act_*)VALUES:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  act_til_qua ;  //:--------------------------://
            U08  act_til_exp ;  //:                          ://
            U08  act_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  act_loc_t_x ;  //:                          ://
            U08  act_loc_t_y ;  //:--------------------------://
                 
            /* EXPECTED(exp_*)VALS:@VID_IID[ 0069 ]T[ 1H 40M ]*/
            U08  exp_til_qua ;  //:--------------------------://
            U08  exp_til_exp ;  //:                          ://
            U08  exp_til_lay ;  //:   SEE[ #DIA_GLO_PIX# ]   ://
            U08  exp_loc_t_x ;  //:                          ://
            U08  exp_loc_t_y ;  //:--------------------------://
 
            /* INPUT VALUES(inn_*):@VID_IID[ 0069]T[ 1H 45M ] */
            I16  inn_glo_t_x ;  //:                          ://
            I16  inn_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 glocpix_CTO_painpix_CASES
                            *
                 glocpix_CTO_painpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * glocpix_CTO_painpix_DATUM );

                /** @VID_IID[ 0069 ]TIME[ 1H 36M 33S ]    **/
                /** Most are expected ("exp_*") values    **/
                /** Except the global values which are    **/
                /** actual ("act_*") values.              **/

                exp_til_qua=(   201 );  /** @TRAP_VALUES@ **/
                exp_til_exp=(   202 );  /** @TRAP_VALUES@ **/
                exp_til_lay=(   203 );  /** @TRAP_VALUES@ **/
                exp_loc_t_x=(   204 );  /** @TRAP_VALUES@ **/
                exp_loc_t_y=(   205 );  /** @TRAP_VALUES@ **/
                inn_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                inn_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                /** @VID_IID[ 0070 ]TIME[ 00H 20M 50S ]   **/
                /** Checking for integer overflow .       **/

                exp_til_qua=(         (U08)tab_utc[ bas + 0 ] );
                exp_til_exp=(         (U08)tab_utc[ bas + 1 ] );
                exp_til_lay=(         (U08)tab_utc[ bas + 2 ] );
                exp_loc_t_x=(         (U08)tab_utc[ bas + 3 ] );
                exp_loc_t_y=(         (U08)tab_utc[ bas + 4 ] );
                inn_glo_t_x=(              tab_utc[ bas + 5 ] );
                inn_glo_t_y=(              tab_utc[ bas + 6 ] );

                assert(((I16)exp_til_qua)==tab_utc[ bas + 0 ] );
                assert(((I16)exp_til_exp)==tab_utc[ bas + 1 ] );
                assert(((I16)exp_til_lay)==tab_utc[ bas + 2 ] );
                assert(((I16)exp_loc_t_x)==tab_utc[ bas + 3 ] );
                assert(((I16)exp_loc_t_y)==tab_utc[ bas + 4 ] );
                assert(((I16)inn_glo_t_x)==tab_utc[ bas + 5 ] );
                assert(((I16)inn_glo_t_y)==tab_utc[ bas + 6 ] );

                aac2020_paint5d_glocpix_CTO_painpix(
                  &(act_til_qua)  //:<-- OUTPUTS -------
                , &(act_til_exp)  //:<-- OUTPUTS -------
                , &(act_til_lay)  //:<-- OUTPUTS -------
                , &(act_loc_t_x)  //:<-- OUTPUTS -------
                , &(act_loc_t_y)  //:<-- OUTPUTS -------
                ,   inn_glo_t_x   //:<----------INPUTS--
                ,   inn_glo_t_y   //:<----------INPUTS--
                );;
 
                if( 0
                ||  exp_til_qua != act_til_qua
                ||  exp_til_exp != act_til_exp
                ||  exp_til_lay != act_til_lay
                ||  exp_loc_t_x != act_loc_t_x
                ||  exp_loc_t_y != act_loc_t_y
                ){
                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_qua  , act_til_qua );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_exp  , act_til_exp );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_til_lay  , act_til_lay );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_x  , act_loc_t_x );

                    printf("[_qua]:(%d)(%d)\n",
                    exp_loc_t_y  , act_loc_t_y );

                    ERR("[FAIL:glocpix_CTO_painpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_316PM]" );
        }

        //: - - - - - - - - - - - -- - - - - - - - - - - - - ://

        void
        aac2020_paint5d_UTC_painpix_CTO_glocpix( void )
        {
            I32  t_i ; /** Test_row_Index           **/
            I32  bas ; /** BASe_offset_of_test_data **/
            I32  m_i =( painpix_CTO_glocpix_CASES - 1);

            /** ******************************************** **/
            /** @VID_IID[ 0069 ]TIME[ 02H 05M 55S ]     .....**/
            /**  inn_*  : Input    Values                    **/
            /**  exp_*  : EXPECTED outputs                   **/
            /**  act_*  : ACTUAL   outputs                   **/
            /** ******************************************** **/
                                                      
            U08  inn_til_qua ;  //:--------------------------://
            U08  inn_til_exp ;  //:                          ://
            U08  inn_til_lay ;  //:--------------------------://
            U08  inn_loc_t_x ;  //:                          ://
            U08  inn_loc_t_y ;  //:                          ://
                                //:   SEE[ #DIA_GLO_PIX# ]   ://
            I16  exp_glo_t_x ;  //:                          ://
            I16  exp_glo_t_y ;  //:                          ://
                                //:--------------------------://
            I16  act_glo_t_x ;  //:                          ://
            I16  act_glo_t_y ;  //:--------------------------://


            /**  tab_utc: TABle_Unit_Test_Code **/
            I16  tab_utc[ 
                 painpix_CTO_glocpix_CASES
                            *
                 painpix_CTO_glocpix_DATUM
            ]={
            //: 0001   0002   0003   0004   0005   0006   0007
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
                0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
            ,      1 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,    0
            ,      2 , 0x00 , 0x00 , 0x00 , 0x00 ,    0 ,  256
            ,      3 , 0x00 , 0x00 , 0x00 , 0x00 ,  256 ,  256  
            //: _qua   _exp   _lay   loc_   loc_   glo_   glo_
            //: 0001   0002   0003   0004   0005   0006   0007
            };;

            for( t_i = 0 ; t_i <= m_i ; t_i ++ ){

                /** Base(bas) is test index times stride **/
                bas = ( t_i * painpix_CTO_glocpix_DATUM );

                inn_til_qua=(    11 );  /** @TRAP_VALUES@ **/
                inn_til_exp=(    22 );  /** @TRAP_VALUES@ **/
                inn_til_lay=(    33 );  /** @TRAP_VALUES@ **/
                inn_loc_t_x=(    44 );  /** @TRAP_VALUES@ **/
                inn_loc_t_y=(    55 );  /** @TRAP_VALUES@ **/
                exp_glo_t_x=( 10222 );  /** @TRAP_VALUES@ **/
                exp_glo_t_y=( 10111 );  /** @TRAP_VALUES@ **/

                inn_til_qua=( (U08) tab_utc[ bas + 0 ] );
                inn_til_exp=( (U08) tab_utc[ bas + 1 ] );
                inn_til_lay=( (U08) tab_utc[ bas + 2 ] );
                inn_loc_t_x=( (U08) tab_utc[ bas + 3 ] );
                inn_loc_t_y=( (U08) tab_utc[ bas + 4 ] );
                exp_glo_t_x=(       tab_utc[ bas + 5 ] );
                exp_glo_t_y=(       tab_utc[ bas + 6 ] );

                /** @VID_IID[ 0070 ]TIME[ 00H 16M 22S ]      **/
                /** Check for integer overflow.              **/
                assert(((I16)inn_til_qua)==tab_utc[ bas +0 ]);
                assert(((I16)inn_til_exp)==tab_utc[ bas +1 ]);
                assert(((I16)inn_til_lay)==tab_utc[ bas +2 ]);
                assert(((I16)inn_loc_t_x)==tab_utc[ bas +3 ]);
                assert(((I16)inn_loc_t_y)==tab_utc[ bas +4 ]);
                assert(((I16)exp_glo_t_x)==tab_utc[ bas +5 ]);
                assert(((I16)exp_glo_t_y)==tab_utc[ bas +6 ]);

                aac2020_paint5d_painpix_CTO_glocpix(
                    inn_til_qua   //:<-- INPUTS -----------
                ,   inn_til_exp   //:<-- INPUTS -----------
                ,   inn_til_lay   //:<-- INPUTS -----------
                ,   inn_loc_t_x   //:<-- INPUTS -----------
                ,   inn_loc_t_y   //:<-- INPUTS -----------
                , &(act_glo_t_x)  //:<---------- OUTPUTS --
                , &(act_glo_t_y)  //:<---------- OUTPUTS --
                );;
 
                if( 0
                ||  exp_glo_t_x != act_glo_t_x
                ||  exp_glo_t_y != act_glo_t_y
                ){
                    printf("[glo_t_x]:(%d)(%d)\n",
                    exp_glo_t_x  , act_glo_t_x );

                    printf("[glo_t_y]:(%d)(%d)\n",
                    exp_glo_t_y  , act_glo_t_y );

                    ERR("[FAIL:painpix_CTO_glocpix]");
                };;
            };;
    
            /** Add more tests cases to this function. **/
            AAC2020_TODOMAN_Vital( "[TESTS_2020_12_31_504PM]" );

        }

    #undef  glocpix_CTO_painpix_CASES                 //: 01 ://
    #undef  glocpix_CTO_painpix_DATUM                 //: 02 ://
    #undef  painpix_CTO_glocpix_CASES                 //: 03 ://
    #undef  painpix_CTO_glocpix_DATUM                 //: 04 ://
    //: - - - - - - - - - - - - ---- - 1: glocpix_CTO_painpix://
    //: - - - - - - - - - - - - ---- - 2: painpix_CTO_glocpix://
    //: - - - - - - - - - - - - ---- - - -::paired_unit_tests://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://



    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://
//:helper_functions:generic:|||||||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||:|||||||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_Min_I16( void )
    {
        #define FUN aac2020_paint5d_Min_I16

        assert( FUN(    3  ,    7  ) ==      3 );
        assert( FUN( 0x00FF,0x7FFF ) == 0x00FF );
        assert( FUN( 0x0001,0x7FFF ) == 0x0001 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_i32_Cap_u32( void )
    {

        I32 bru_x_y = 0x0F00 ; /** brush [X|Y] location     **/
        U16 cap_min = 0x000F ; /** Minimum Boundary         **/
        U16 cap_max = 0xF000 ; /** Maximum Boundary         **/
        U32 u32_x_y           ; /** U32 output of function   **/

        #define FUN aac2020_paint5d_i32_Cap_u32

            /** First test to formalize what the parameter   **/
            /** names we are working with are............... **/

            u32_x_y = FUN( bru_x_y , cap_min , cap_max );

            assert( u32_x_y == 0x0F00 );

            /** Tests where input doesn't change **/
            assert( FUN(   0 ,   0 ,   0 ) ==   0 );
            assert( FUN(   2 ,   1 ,   3 ) ==   2 );
            assert( FUN(  50 ,   0 , 100 ) ==  50 );
            assert( FUN( 200 , 100 , 300 ) == 200 );

            /** Tests where capped to max value **/
            assert( FUN( 300 , 100,  200 ) == 200 );
            assert( FUN(   4 ,   1 ,   3 ) ==   3 );
            assert( FUN( 200 ,   0 , 100 ) == 100 );
            assert( FUN( 400 , 100 , 300 ) == 300 );

            /** Tests where capped to min value **/
            assert( FUN(  50 , 100,  200 ) == 100 );
            assert( FUN(   0 ,   1 ,   3 ) ==   1 );
            assert( FUN(   0 ,   0 , 100 ) ==   0 );
            assert( FUN(  50 , 100 , 300 ) == 100 );

            /** capped to min using NEGATIVES **/
            assert( FUN( -12345678 , 100,  200 ) == 100 );
            assert( FUN( -23456789 ,   1 ,   3 ) ==   1 );
            assert( FUN( -34567890 ,   0 , 100 ) ==   0 );
            assert( FUN( -45678901 , 100 , 300 ) == 100 );

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    

//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||||||:helper_functions:generic://
//:|||||||||||||||||||||||||||||||||:||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://
//:helper_functions::conversion:|||||||||||||||||||||||||||||://
//:||||||||||||||||||||||||||||:|||||||||||||||||||||||||||||://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_bip_sip( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_bip_sip
        assert( FUN(0) == 128 );
        assert( FUN(1) ==  64 );
        assert( FUN(2) ==  32 );
        assert( FUN(3) ==  16 );
        assert( FUN(4) ==   8 );
        assert( FUN(5) ==   4 );
        assert( FUN(6) ==   2 );
        assert( FUN(7) ==   1 );
        assert( FUN(8) ==   1 ); //:EDGE_CASE_SINGLE_PIXEL://
        #undef  FUN              //:BOTTOM_RIGHT_CORNER:::://
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_max_cor( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_max_cor
        assert( FUN(0) == 127 );
        assert( FUN(1) ==  63 );
        assert( FUN(2) ==  31 );
        assert( FUN(3) ==  15 );
        assert( FUN(4) ==   7 );
        assert( FUN(5) ==   3 );
        assert( FUN(6) ==   1 );
        assert( FUN(7) ==   0 );
        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_til_exp_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_til_exp_CTO_diagpix

        /** ************************************************ **/
        /** @VID_IID[ 0071 ]TIME[ 00H 44M 10M ]    * * * * * **/
        /** What we were thinking when we started  * * * * * **/
        /** creating entries for tab_utc below.    * * * * * **/
        /**                                                  **/
        /** @VID_IID[ 0071 ]TIME[ 00H 54M 37S ]              **/
        /** 7 is the last useful index (til_exp)             **/
        /** because 8 can only store 1 pixel instead         **/
        /** of 3 groups of pixels.                           **/
        /** ************************************************ **/

        /** tab_utc[  row(s)  col(s) **/
        I32 num_tes=( (9*2)          );;
        I16 tab_utc[  (9*2)  * 2     ]={           //:C_S DEX://
            0 ,   0                                //: 1   0 ://
        ,   1 , 128                                //: 2   1 ://
        ,   2 , 128 + 64                           //: 3   2 ://
        ,   3 , 128 + 64 + 32                      //: 4   3 ://
        ,   4 , 128 + 64 + 32 + 16                 //: 5   4 ://
        ,   5 , 128 + 64 + 32 + 16 + 8             //: 6   5 ://
        ,   6 , 128 + 64 + 32 + 16 + 8 + 4         //: 7   6 ://
        ,   7 , 128 + 64 + 32 + 16 + 8 + 4 + 2     //: 8   7 ://
        ,   8 , 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 //: 9   8 ://
        //:- - - - - - - - - - - - - - - - - - - - - : ----- ://
        ,   0 ,   0                                //: 1   9 ://
        ,   1 , 128                                //: 2  10 ://
        ,   2 , 192                                //: 3  11 ://
        ,   3 , 224                                //: 4  12 ://
        ,   4 , 240                                //: 5  13 ://
        ,   5 , 248                                //: 6  14 ://
        ,   6 , 252                                //: 7  15 ://
        ,   7 , 254                                //: 8  16 ://
        ,   8 , 255                                //: 9  17 ://
        };;                                        

        I32 dex ; //: Current Test Index
        I32 bas ; //: Base Offset Value For Test Data.

        U08 act_til_exp;
        U08 exp_diagpix;
        U08 act_diagpix;

        for( dex = 0; dex <= ( num_tes - 1); dex++ ){

            bas = ( dex * 2 ); //:Multiply Testindex by stride

            /** Extract Data From Table             **/
            /** @VID_IID[ 0071 ]TIME[ 01H 05M 21S ] **/

            act_til_exp = tab_utc[ bas + 0 ]; 
            exp_diagpix = tab_utc[ bas + 1 ];

            act_diagpix = FUN( act_til_exp );

            if( exp_diagpix != act_diagpix ){

                printf("[u_test::dex]:%d\n" , dex         );
                printf("[exp_diagpix]:%d\n" , exp_diagpix );
                printf("[act_diagpix]:%d\n" , act_diagpix );

                ERR("[FAIL_ACTDIAGNOTEQUALEXPDIAG]");
            };;
        };;

        #undef  FUN
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_paint5d_UTC_diagpix_CTO_til_exp( void )
    {
        U08 til_exp    ;
        U08 til_exp_chk;
        U08 diagpix    ;

        for( til_exp = 0 ; til_exp <= MAX_EXP ; til_exp ++ ){

            diagpix=(
            aac2020_paint5d_til_exp_CTO_diagpix( til_exp ));;

            til_exp_chk=(
            aac2020_paint5d_diagpix_CTO_til_exp( diagpix ));;

            if( til_exp != til_exp_chk ){

                printf("[::::til_exp]:%d\n" ,     til_exp );
                printf("[::::diagpix]:%d\n" ,     diagpix );
                printf("[til_exp_chk]:%d\n" , til_exp_chk );

                ERR("[diagpix_CTO_til_exp:UNIT_TEST_FAIL]");
            };;
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    /**     @DNE aac2020_paint5d_UTC_diagpix_CTO_astipix     **/
    /**     @DNE == @DOES_NOT_EXIST                          **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void 
    aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK(
        U08 dia_act //:diagpix_actual
    ,   U08 dia_exp //:diagpix_expected
    )
    {
        /** THIS_FUNCTION: ......................... **/
        /** Helper function check test table results **/
        /** @VID_IID[ 0078 ]TIME[ 00H 41M 24S ] .... **/

        if( dia_act != dia_exp ){
            printf("[dia_act]:%d\n" , dia_act );
            printf("[dia_exp]:%d\n" , dia_exp );
            ERR("[OH_NO_MY_FRIEND_UTTER_FAILURE]");
        };;
        
    }
    void 
    aac2020_paint5d_UTC_astipix_CTO_diagpix_C_2(
        U08         dia_act //:diagpix_actual
    ,   U08         dia_exp //:diagpix_expected
    ,   const char* tracebk //:traceback message
    )
    {
       /** Same as:                                     **/
       /** aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK  **/
       /** But pass 3rd param traceback string.         **/

        if( dia_act != dia_exp ){
            printf("[dia_act]:%d\n" , dia_act );
            printf("[dia_exp]:%d\n" , dia_exp );
            printf("[tracebk]:%s\n" , tracebk );
            ERR("[OH_NO_MY_FRIEND_UTTER_FAILURE]");
        };;
        
    }
    void
    aac2020_paint5d_UTC_astipix_CTO_diagpix( void )
    {
        #define FUN aac2020_paint5d_astipix_CTO_diagpix
        #define CHK aac2020_paint5d_UTC_astipix_CTO_diagpix_CHK
        #define C_2 aac2020_paint5d_UTC_astipix_CTO_diagpix_C_2

               CHK( FUN( 127              ) ,    0            );
               CHK( FUN( 128              ) ,  128            );
               CHK( FUN( 128+64-1         ) ,  128            );
               CHK( FUN( 128+64+0         ) ,  192            );
               CHK( FUN( 128+64+0         ) ,  128+64         );
               CHK( FUN( 128+64+1         ) ,  128+64         );
            assert(      128+64+0           == 192            );
               CHK( FUN( 128+64+32-1      ) ,  192            );
               CHK( FUN( 128+64+32+0      ) ,  128+64+32      );
               CHK( FUN( 128+64+32+1      ) ,  128+64+32      );
               CHK( FUN( 128+64+32+16-1   ) ,  128+64+32      );
               CHK( FUN( 128+64+32+16+0   ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+1   ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+8-1 ) ,  128+64+32+16   );
               CHK( FUN( 128+64+32+16+8+0 ) ,  128+64+32+16+8 );

            /** ******************************************** **/
            /** Previous test, but collapsing numbers so we  **/
            /** don't run out of column space in source code.**/
            /** ******************************************** **/

            assert( FUN( 248 ) == 248 ); //:#_DONT_TOUCH_ME_#://

            /** ******************************************** **/

            C_2( FUN( 248       ) , 248       , "[X_X]"   );
            C_2( FUN( 248+4-1   ) , 248       , "[0_0]"   );
            C_2( FUN( 248+4+0   ) , 248+4     , "[._.]"   );
            C_2( FUN( 248+4+1   ) , 248+4     , "[T_T]"   );
            C_2( FUN( 248+4+2   ) , 248+4+2   , "[0_X]"   );
            C_2( FUN( 248+4+2+1 ) , 248+4+2+1 , "[*_*]"   );

            //:Use some explicit edge case values:           ://
            //:If 255 fails because it is out of bounds, then://
            //:Just comment out that test, as the case has   ://
            //:been properly handled by runtime asserts in   ://
            //:the function being tested.                    ://
            assert( FUN( 0 ) ==   0 );
            assert( FUN(255) == 255 ); //:<--ShouldNeverUse
            assert( FUN(254) == 254 );
            assert( FUN(253) == 252 );

        #undef  FUN
        #undef  CHK
        #undef  C_2
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://
//:|||||||||||||||||||||||||||||:helper_functions::conversion://
//:|||||||||||||||||||||||||||||:||||||||||||||||||||||||||||://

    //:******************************************************://
    //:                                                      ://
    //:                                                      ://
    //:    UNIT_TEST_BIG_BLOCK : PROGCONTROLS : ABOVE        ://
    //:                                                      ://
    //:                                                      ://
    //:******************************************************://

#undef  MAX_EXP                                       //: 01 ://
#undef  EXT                                           //: 02 ://
#undef  VOD                                           //: 03 ://
#undef  I08                                           //: 04 ://
#undef  U08                                           //: 05 ://
#undef  I16                                           //: 06 ://
#undef  U16                                           //: 07 ://
#undef  I32                                           //: 08 ://
#undef  U32                                           //: 09 ://
#undef  ERR                                           //: 10 ://
#undef  LOG                                           //: 11 ://
//:========================================:UNIT_TEST_SECTION://
//:========================================:SECTION_UNIT_TEST://