//: 1234567
//: TAUTYPE.F._ : FUNCTIONS for operating on TAUTYPE.D._ types.

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_tautype_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:aac2020_tautype]:%s\n", msg_err );
        fflush(stdout);
        exit( 202 );
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://

    void
    aac2020_tautype_Info_any(
        const char* str_fmt
    ,   void*       dat_any   
    )
    { if( AAC2020_SILENCE.TAUTYPE <= 0 ){

        /** Same Line As Next Printf **/
        printf("[tautype_log]....(   " ); fflush( stdout );
        printf( str_fmt , dat_any      ); fflush( stdout );
        printf(               "   )\n" ); fflush( stdout );

    };; }

//:===========================================:LOG_AFTER_HALT://

//:INIT_NONE:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_TAUTYPE_InitNone( U32 u32 ){
        if( u32 ){ /** reserved for future use **/ };

        /** @VID_IID[ 0060 ]TIME[ 02H 02M 48S ](WRITTEN)     **/
        /** @VID_IID[ 0060 ]TIME[ 02H 14M 48S ](FIXED)       **/
        /** Tests At Bottom Of File Via Forward Declaration  **/

        extern  U32 AAC2020_TAUTYPE_UnitTest( U32  );
                    AAC2020_TAUTYPE_UnitTest( 0x00 );

        return( 0x00 );
    }

#undef  U32
//:================================================:INIT_NONE://
//:INCLUSIVE_RECTANGLE:aac2020_tautype_rec_inc:==============://
//:inclusive_rectangle:AAC2020_TAUTYPE_REC_INC:==============://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define U08 uint8_t  /** GCC: <stdint.h> **/          //: 03 ://
#define ERR aac2020_tautype_Halt                      //: 04 ://

    /** **************************************************** ***
    @VID_IID[ 0060 ]TIME[ 1H 57M 30S ]
    Finished First Draft Of: 
        1: aac2020_tautype_rec_inc_EnforceBounds
        2: AAC2020_TAUTYPE_rec_inc_ZoomPull
        3: AAC2020_TAUTYPE_rec_inc_Tran
    *** **************************************************** **/

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_tautype_rec_inc_EnforceBounds(
        I32* INPUT_OUTPUT_PARAM_x_0_i32 //: @BYREF@
    ,   I32* INPUT_OUTPUT_PARAM_x_1_i32 //: @BYREF@
    ,   I32* INPUT_OUTPUT_PARAM_y_0_i32 //: @BYREF@
    ,   I32* INPUT_OUTPUT_PARAM_y_1_i32 //: @BYREF@
    )
    {
        //:extract_or_restore_values:------------------------://

            I32 x_0_i32 = (*INPUT_OUTPUT_PARAM_x_0_i32);
            I32 x_1_i32 = (*INPUT_OUTPUT_PARAM_x_1_i32);
            I32 y_0_i32 = (*INPUT_OUTPUT_PARAM_y_0_i32);
            I32 y_1_i32 = (*INPUT_OUTPUT_PARAM_y_1_i32);

        //:------------------------:extract_or_restore_values://

                //:back_off_the_boarders:--------------------://

                    //:back_off:lower_bound:-----------------://

                        if( x_0_i32 < 0 ){ 

                            I32 delta_x = ( 0 - x_0_i32 );
                            
                            x_0_i32 += ( delta_x );
                            x_1_i32 += ( delta_x );
                        };;
                        if( y_0_i32 < 0 ){ 

                            I32 delta_y = ( 0 - y_0_i32 );

                            y_0_i32 += ( delta_y );
                            y_1_i32 += ( delta_y );
                        };;

                    //:-----------------:back_off:lower_bound://
                    //:back_off:upper_bound:-----------------://

                        if( x_1_i32 > ( 512 - 1 ) ){

                            //: @_MINUS_FIVE_ELEVEN_@
                            I32 delta_x = ( x_1_i32 - 511 );
                            
                            x_0_i32 -= ( delta_x );
                            x_1_i32 -= ( delta_x );
                        };;
                        if( y_1_i32 > ( 512 - 1 ) ){

                            //: @_MINUS_FIVE_ELEVEN_@
                            I32 delta_y = ( y_1_i32 - 511 );
                            
                            y_0_i32 -= ( delta_y );
                            y_1_i32 -= ( delta_y );
                        };;

                    //:-----------------:back_off:upper_bound://

                //:--------------------:back_off_the_boarders://

        //:extract_or_restore_values:------------------------://

            (*INPUT_OUTPUT_PARAM_x_0_i32) = x_0_i32 ;
            (*INPUT_OUTPUT_PARAM_x_1_i32) = x_1_i32 ;
            (*INPUT_OUTPUT_PARAM_y_0_i32) = y_0_i32 ;
            (*INPUT_OUTPUT_PARAM_y_1_i32) = y_1_i32 ;

        //:------------------------:extract_or_restore_values://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
 
    void
    AAC2020_TAUTYPE_rec_inc_ZoomPull(
        U08 tau_015  //: INDEX:tau: EX: AAC2020_TAUDEPO.TAU_015  
    ,   U08 sub_015  //: INDEX:sub: EX: AAC2020_TAUDEPO.PAINT5D  
    ,   U08 var_255  //: INDEX:var: EX: AAC2020_TAUDEPO.P5D_VP1  
    ,   I32 zom_i32  //: Amount To Zoom In And Out In Pixels
    )
    {
        AAC2020_TODOMAN_Vital( "[TODO:Camera_Initial_Size]");

        U32 x_0 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 x_1 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 y_0 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 y_1 =( 0xFFFFFFFF /** TRAP_VALUE **/ );

        //:Get_Or_Put_Bitmap_Variables:----------------------://

            /** @GETS_HERE@: AAC2020_PIXNAME_taudepo_cpu_pix **/
            AAC2020_TAUDEPO_Get( 
                tau_015
            ,   sub_015
            ,   var_255
            ,   &(x_0),&(x_1),&(y_0),&(y_1)
            );;

            I32 x_0_i32 =( (I32) x_0 );
            I32 x_1_i32 =( (I32) x_1 );
            I32 y_0_i32 =( (I32) y_0 );
            I32 y_1_i32 =( (I32) y_1 );

        //:----------------------:Get_Or_Put_Bitmap_Variables://
        //:check_size_before_transform:----------------------://

            I32 wid =( x_1_i32 - x_0_i32 + 1 );
            I32 hig =( y_1_i32 - y_0_i32 + 1 );
            if( wid != hig ){ ERR("[CAM_NOT_SQUA:ZOOMPULL]"); };
            if( wid  > 512 ){ ERR("[WID_OVER_512:ZOOMPULL]"); };
            if( hig  > 512 ){ ERR("[HIG_OVER_512:ZOOMPULL]"); };

        //:----------------------:check_size_before_transform://
        //:gaurd_from_zooming_in_or_out_too_much:------------://

            /**  @VID_IID[ 0060 ]TIME[ 1H 33M 26S ]          **/
            /**  I thought some comparisons needed to use    **/
            /**  a "+" sign. But turns out all comparisons   **/
            /**  should be "-" for correct bounds checks.    **/

            if( 1 == 1
                /** @VID_IID[ 0063 ]TIME[ 04H 25M 30S ] **/
                /** #_REMOVED_GAURD_CODE_2020_12_26_#   **/
            ){
                x_0_i32 = ( x_0_i32 + zom_i32 );
                x_1_i32 = ( x_1_i32 - zom_i32 );
                y_0_i32 = ( y_0_i32 + zom_i32 );
                y_1_i32 = ( y_1_i32 - zom_i32 );

                aac2020_tautype_rec_inc_EnforceBounds(
                    &( x_0_i32 )
                ,   &( x_1_i32 )
                ,   &( y_0_i32 )
                ,   &( y_1_i32 )
                );;
            };;

            //:did_we_wreck_our_rect:------------------------://
            //:did_we_wreck_our_rect:INVERTED:---------------://
            #define F float
            #define I I32

                if( x_0_i32 > x_1_i32 ){ //:#_INV_ZOOMFIX_#_://

                    /** c: check value. ...................  **/
                    /** @VID_IID[ 0063 ]TIME[ 04H 36M 57S ]  **/
                    F c = ( ((F)x_0_i32) - ((F)x_1_i32) ) / 2.0;
                    I u = (     x_0_i32  -     x_1_i32  ) / 2  ;
        
                    /** Make sure math is discrete(integers) **/
                    assert( ((F)c) == ((F)u) );

                    /** Un-invert the rectangle **/
                    x_0_i32 =( x_0_i32 - u );
                    x_1_i32 =( x_1_i32 + u );
    
                    /** Assert actually un-inverted.  **/
                    /** Also should be co-incidential **/
                    assert( x_0_i32 == x_1_i32 );
                };;
                if( y_0_i32 > y_1_i32 ){ //:#_INV_ZOOMFIX_#_://

                    //: @DITTO_Y_AXIS@ ://

                    F c = ( ((F)y_0_i32) - ((F)y_1_i32) ) / 2.0;
                    I u = (     y_0_i32  -     y_1_i32  ) / 2  ;
        
                    assert( ((F)c) == ((F)u) );

                    y_0_i32 =( y_0_i32 - u );
                    y_1_i32 =( y_1_i32 + u );

                    assert( y_0_i32 == y_1_i32 );
                };;

            #undef  F
            #undef  I
            //:---------------:did_we_wreck_our_rect:INVERTED://
            //:did_we_wreck_our_rect:TOO_BIG:----------------://
            assert( x_0_i32 <= x_1_i32 );
            assert( y_0_i32 <= y_1_i32 );

                //:------------------------------------------://
                //: FIX IN THIS ORDER:                       ://
                //: 1. Shrink back to at least 512 x 512     ://
                //: 2. Translate back into boundaries of     ://
                //:    the [ worldspace / dataspace ]        ://
                //: @VID_IID[ 0063 ]TIME[ 04H 44M 21S ]      ://
                //:------------------------------------------://

                //:fix_number:001:- - - - - - - - - - - - - -://
                #define F float
                #define I I32

                    wid =( x_1_i32 - x_0_i32 + 1 );
                    hig =( y_1_i32 - y_0_i32 + 1 );
                I32 wid_odd=( wid % 2 ); 
                I32 hig_odd=( hig % 2 ); 
                U08 wid_fix=( 0 ); //: @IID[ 0065 ]T[ 00:33:10 ]
                U08 hig_fix=( 0 ); //: @IID[ 0065 ]T[ 00:33:10 ]

                    if( wid > 512 ){ //:#_OVERGROW_PULL_FIX_#://
                        wid_fix=( 1 );
                        /**@VID_IID[ 0065 ]TIME[ 0H 13M 44S ]**/
    
                        I u =( (x_1_i32 - x_0_i32 - 511)/2 );
                        F c =( 
                         ((F)(x_1_i32 - x_0_i32 - 511)) / 2.0 );
                        assert( ((I)u) == ((I)c) ); //:@DELTA_1@
                        if(     ((F)u) != ((F)c) ){
                            //:#_PULL_MORE_IF_U_IS_FRACTION_#://
                            u =( u + 1 ); //:<-- Ceil( f )
                            assert( wid_odd >= 1 );
                        };;
                        x_0_i32 = x_0_i32 + u ; //: 0 --> <-- 1
                        x_1_i32 = x_1_i32 - u ; //: 0 --> <-- 1
                    };;
                    if( hig > 512 ){ //:#_OVERGROW_PULL_FIX_#://
                        hig_fix=( 1 );
                        /**@VID_IID[ 0065 ]TIME[ 0H 34M 31S ]**/

                        I u =( (y_1_i32 - y_0_i32 - 511)/2 );
                        F c =( 
                         ((F)(y_1_i32 - y_0_i32 - 511)) / 2.0 );
                        assert( ((I)u) == ((I)c) ); //:@DELTA_1@
                        if(     ((F)u) != ((F)c) ){
                            //:#_PULL_MORE_IF_U_IS_FRACTION_#://
                            u =( u + 1 ); //:<-- Ceil( f )
                            assert( hig_odd >= 1 );
                        };;

                        y_0_i32 = y_0_i32 + u ; //: 0 --> <-- 1
                        y_1_i32 = y_1_i32 - u ; //: 0 --> <-- 1
        
                    };;

                    //:assert_valid_size_correction:---------://

                        wid = ( x_1_i32  - x_0_i32 + 1 );
                        hig = ( y_1_i32  - y_0_i32 + 1 );

                        assert( x_0_i32 <= x_1_i32 );
                        assert( y_0_i32 <= y_1_i32 );

                        //: wid_fix  :- - - - - - - - - - - -://
                        if( wid_fix >= 1 ){

                        if( (512 + 0) == wid && 0 == wid_odd ){
                            /** Okay: Even Rectangle Shrunk **/
                        }else
                        if( (512 - 1) == wid && 1 == wid_odd ){
                            /** Okay: Odd  Rectangle Shrunk **/
                        }else{
                            ERR("[BADSHRINK_2020:X_AXIS]");
                        };;

                            if( wid < ( 512 - 1 ) ){
                                ERR("[TOO_MUCH_SHRINK:X_AXIS]");
                            };;

                        };;
                        //:- - - - - - - - - - - -:  wid_fix ://
                        //: hig_fix  :- - - - - - - - - - - -://
                        if( hig_fix >= 1 ){

                        if( (512 + 0) == hig && 0 == hig_odd ){
                            /** Okay: Even Rectangle Shrunk **/
                        }else
                        if( (512 - 1) == hig && 1 == hig_odd ){
                            /** Okay: Odd  Rectangle Shrunk **/
                        }else{
                            ERR("[BADSHRINK_2020:Y_AXIS]");
                        };;

                            if( wid < ( 512 - 1 ) ){
                                ERR("[TOO_MUCH_SHRINK:Y_AXIS]");
                            };;

                        };;
                        //:- - - - - - - - - - - -:  hig_fix ://
                        
                    //:---------:assert_valid_size_correction://

                #undef  F
                #undef  I
                //:- - - - - - - - - - - - - -:fix_number:001://
                //:fix_number:002:- - - - - - - - - - - - - -://

                    assert( x_0_i32 <= x_1_i32 );
                    assert( y_0_i32 <= y_1_i32 );

                    aac2020_tautype_rec_inc_EnforceBounds(
                        &( x_0_i32 ) //: @BYREF@
                    ,   &( x_1_i32 ) //: @BYREF@
                    ,   &( y_0_i32 ) //: @BYREF@
                    ,   &( y_1_i32 ) //: @BYREF@
                    );;   

                    assert( x_0_i32 <= x_1_i32     );
                    assert( y_0_i32 <= y_1_i32     );
                    assert( x_0_i32 >=         0   );
                    assert( y_0_i32 >=         0   );
                    assert( x_1_i32 <= ( 512 - 1 ) );
                    assert( y_1_i32 <= ( 512 - 1 ) );

                //:- - - - - - - - - - - - - -:fix_number:002://

            //:----------------:did_we_wreck_our_rect:TOO_BIG://
            //:------------------------:did_we_wreck_our_rect://

        //:------------:gaurd_from_zooming_in_or_out_too_much://
        //:Get_Or_Put_Bitmap_Variables:----------------------://

            assert( x_0_i32 >= 0 && x_0_i32 <= ( 512 - 1 ) );
            assert( x_1_i32 >= 0 && x_1_i32 <= ( 512 - 1 ) );
            assert( y_0_i32 >= 0 && y_0_i32 <= ( 512 - 1 ) );
            assert( y_1_i32 >= 0 && y_1_i32 <= ( 512 - 1 ) );

            x_0 = (U32) x_0_i32 ;
            x_1 = (U32) x_1_i32 ;
            y_0 = (U32) y_0_i32 ;
            y_1 = (U32) y_1_i32 ;

            /** @PUTS_HERE@: AAC2020_PIXNAME_taudepo_cpu_pix **/
            AAC2020_TAUDEPO_Put( 
                tau_015
            ,   sub_015
            ,   var_255
            ,   x_0 , x_1 , y_0 , y_1 
            );;

        //:----------------------:Get_Or_Put_Bitmap_Variables://

        #if( aac2020_tautype_DEBUG_ZOOM >= 1 ) //:###########://
        /** [ Unit Test ] [ Test Case ] Aware Tests **/
        #define T_I aac2020_tautype_UTC_rec_inc_zoom_test_index

            if( 3 == T_I ){
              
                /** **************************************** **/
                /** @VID_IID[ 0065 ][ 02H 16M 48S ] ........ **/
                /** This is an interesting and hackish idea  **/
                /** But we never ended up needing it.        **/
                /** We COULD remove, or we could keep it here**/
                /** for future reference to see one of our   **/
                /** hackish solutions for when unit testing  **/
                /** gets a bit difficult and we are          **/
                /** beginning to get frusterated and lost.   **/
                /** **************************************** **/
            };;

        #undef T_I //:---------------------------------------://
        #endif //:###########################################://
    }
    
    void  AAC2020_TAUTYPE_rec_in_ZoomPush( ){

        /** @VID_IID[ 0065 ]TIME[ 2H 0M 5S ]        **/
        /** To push use pull with a negative number **/
        ERR("[DO_NOT_USE_THIS_USE:ZoomPull]");

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_TAUTYPE_rec_inc_Tran(
        U08 tau_015  //: INDEX:tau: EX: AAC2020_TAUDEPO.TAU_015  
    ,   U08 sub_015  //: INDEX:sub: EX: AAC2020_TAUDEPO.PAINT5D  
    ,   U08 var_255  //: INDEX:var: EX: AAC2020_TAUDEPO.P5D_VP1     
    ,   I32 tra_i_x  //: Amount to translate in pixels: X-axis
    ,   I32 tra_i_y  //: Amount to translate in pixels: Y-axis
    )
    {
        U32 x_0 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 x_1 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 y_0 =( 0xFFFFFFFF /** TRAP_VALUE **/ );
        U32 y_1 =( 0xFFFFFFFF /** TRAP_VALUE **/ );

        //:Get_Or_Put_Bitmap_Variables:----------------------://

            /** @GETS_HERE@: AAC2020_PIXNAME_taudepo_cpu_pix **/
            AAC2020_TAUDEPO_Get( 
                tau_015
            ,   sub_015
            ,   var_255
            ,   &(x_0),&(x_1),&(y_0),&(y_1)
            );;

            I32 x_0_i32 =( (I32) x_0 );
            I32 x_1_i32 =( (I32) x_1 );
            I32 y_0_i32 =( (I32) y_0 );
            I32 y_1_i32 =( (I32) y_1 );

        //:----------------------:Get_Or_Put_Bitmap_Variables://

        AAC2020_TODOMAN_Vital( "[TODO:Camera_Initial_Size]");

        I32 wid =( x_1_i32 - x_0_i32 + 1 );
        I32 hig =( y_1_i32 - y_0_i32 + 1 );
        if( wid != hig ){ ERR("[CAM_NOT_SQUARE:TRAN]"); };
        if( wid  > 512 ){ ERR("[WID_OVER_512:::TRAN]"); };
        if( hig  > 512 ){ ERR("[HIG_OVER_512:::TRAN]"); };

        x_0_i32 = ( x_0_i32 + tra_i_x );
        x_1_i32 = ( x_1_i32 + tra_i_x );
        y_0_i32 = ( y_0_i32 + tra_i_y );
        y_1_i32 = ( y_1_i32 + tra_i_y );

        aac2020_tautype_rec_inc_EnforceBounds(
            &( x_0_i32 )
        ,   &( x_1_i32 )
        ,   &( y_0_i32 )
        ,   &( y_1_i32 )
        );;

        //:Get_Or_Put_Bitmap_Variables:----------------------://

            assert( x_0_i32 >= 0 && x_0_i32 <= ( 512 - 1 ) );
            assert( x_1_i32 >= 0 && x_1_i32 <= ( 512 - 1 ) );
            assert( y_0_i32 >= 0 && y_0_i32 <= ( 512 - 1 ) );
            assert( y_1_i32 >= 0 && y_1_i32 <= ( 512 - 1 ) );

            x_0 = (U32) x_0_i32 ;
            x_1 = (U32) x_1_i32 ;
            y_0 = (U32) y_0_i32 ;
            y_1 = (U32) y_1_i32 ;

            /** @PUTS_HERE@: AAC2020_PIXNAME_taudepo_cpu_pix **/
            AAC2020_TAUDEPO_Put( 
                tau_015
            ,   sub_015
            ,   var_255
            ,   x_0 , x_1 , y_0 , y_1 
            );;

        //:----------------------:Get_Or_Put_Bitmap_Variables://

    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  ERR                                           //: 04 ://
//:==============:AAC2020_TAUTYPE_REC_INC:inclusive_rectangle://
//:==============:aac2020_tautype_rec_inc:INCLUSIVE_RECTANGLE://
//:UNIT_TEST:================================================://
#define I32  int32_t  /** GCC: <stdint.h> **/         //: 01 ://
#define U32 uint32_t  /** GCC: <stdint.h> **/         //: 02 ://
#define U08  uint8_t  /** GCC: <stdint.h> **/         //: 03 ://
#define ERR aac2020_tautype_Halt                      //: 04 ://
#define LOG aac2020_tautype_Info_any                  //: 05 ://
#define NUM_TEST__CASES_001 ( 19 )                    //: 06 ://
#define NUM_TEST_INPUTS_001 ( 10 )                    //: 07 ://
#define NUM_TEST__CASES_002 ( 24 )                    //: 08 ://
#define NUM_TEST_INPUTS_002 (  9 )                    //: 09 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_tautype_UnitTest( void )
    {
        LOG("[aac2020_tautype_UnitTest:BEG]",((void*)0) );

        /** UTC: Unit_Test_Code  ..........................  **/
        /** @VID_IID[ 0063]TIME [ 3H 13M 21S ] ............  **/
        extern void aac2020_tautype_UTC_rec_inc_Tran(  void  );
                    aac2020_tautype_UTC_rec_inc_Tran(/*VOID*/);

        extern void aac2020_tautype_UTC_rec_inc_Zoom(  void  );
                    aac2020_tautype_UTC_rec_inc_Zoom(/*VOID*/);

        LOG("[aac2020_tautype_UnitTest:END]",((void*)0) );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_tautype_UTC_rec_inc_Zoom( void )
    {
        LOG("[aac2020_tautype_UTC_rec_inc_Zoom:BEG]",0);

        /** THIS_FUNCTION: ZOOM of viewport tests **/

        I32 arr[ NUM_TEST_INPUTS_002 
               * NUM_TEST__CASES_002 ]={
    //001 002 003 004 |       005       | 006 007 008 009 
    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
    //x_0 x_1 y_0 y_1       zom_i32       x_0 x_1 y_0 y_1
    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
        0,  0,  0,  0 ,    0+      0    ,   0,  0,  0,  0 //:00
    ,   0,100,  0,100 ,    0+      1    ,   1, 99,  1, 99 //:01
    , 100,200,100,200 ,    0-      1    ,  99,201, 99,201 //:02
    ,   0,  0,  0,  0 ,    0-   9001    ,   0,510,  0,510 //:03
        
        //:TESTS: T_L: OVERGROW:
    ,   0,  9,  0,  9 ,    0-   9090    ,   0,511,  0,511 //:04
    ,   0,  9,  0,  9 ,    0-      1    ,   0, 11,  0, 11 //:05
    ,   0,  9,  0,  9 ,    0-    250    ,   0,509,  0,509 //:06
        
        //:TESTS: T_R: OVERGROW:
    , 502,511,  0,  9 ,    0-   9090    ,   0,511,  0,511 //:07
    , 502,511,  0,  9 ,    0-      1    , 500,511,  0, 11 //:08
    , 502,511,  0,  9 ,    0-    250    ,   2,511,  0,509 //:09
        
        //:TESTS: B_L: OVERGROW:
    ,   0,  9,502,511 ,    0-   9090    ,   0,511,  0,511 //:10
    ,   0,  9,502,511 ,    0-      1    ,   0, 11,500,511 //:11
    ,   0,  9,502,511 ,    0-    250    ,   0,509,  2,511 //:12
        
        //:TESTS: B_R: OVERGROW:
    , 502,511,502,511 ,    0-   9090    ,   0,511,  0,511 //:13
    , 502,511,502,511 ,    0-      1    , 500,511,500,511 //:14
    , 502,511,502,511 ,    0-    250    ,   2,511,  2,511 //:15

        //:TESTS: INVERSION FIX: (CORNERS: T_L,T_R,B_L,B_R)
    ,   0,  0,  0,  0 ,    0+   1234    ,   0,  0,   0,  0 //:16
    , 511,511,  0,  0 ,    0+   1234    , 511,511,   0,  0 //:17
    ,   0,  0, 511,511,    0+   1234    ,  0,  0 , 511,511 //:18
    , 511,511, 511,511,    0+   1234    , 511,511, 511,511 //:19

        //:TESTS: INVERSION FIX: (CORNERS: T_L,T_R,B_L,B_R)
    ,  10, 10,  10, 10,    0+   1234    ,  10, 10,  10, 10 //:20
    , 501,501,  10, 10,    0+   1234    , 501,501,  10, 10 //:21
    ,  10, 10, 501,501,    0+   1234    ,  10, 10, 501,501 //:22
    , 501,501, 501,501,    0+   1234    , 501,501, 501,501 //:23

    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
    // INITIAL_VALUES |    ZOOM AMOUNT  | EXPECTED VALUES
    //___ ___ ___ ___ , ___ ___ ___ ___ , ___ ___ ___ ___
    //001 002 003 004 |       005       | 006 007 008 009
    };; //<-- tes_tra //

        //:Set initial values for tests:
        U32 put_x_0;
        U32 put_x_1;
        U32 put_y_0;
        U32 put_y_1;

        //:Bounds_Of_Inclusive_Rectangle: ACTUAL(ACT)
        U32 act_x_0;
        U32 act_x_1;
        U32 act_y_0;
        U32 act_y_1;

        //:Bounds_Of_Inclusive_Rectangle: EXPECTED(EXP)
        U32 exp_x_0;
        U32 exp_x_1;
        U32 exp_y_0;
        U32 exp_y_1;

        //:Zoom Amounts. @VID_IID[ 0063 ]TIME[ 03H 30M 51S ] ://
        //:POSITIVE: Zooms  IN by shrinking the rectangle.   ://
        //:NEGATIVE: Zooms OUT by growing   the rectangle.   ://
        I32 zom_i32 =( 0 );

        I32 number_of_tests_ran=( 0 );


        I32 m_i =( NUM_TEST__CASES_002 - 1 ); //: max_index
        for( I32 t_i ; t_i <= m_i ; t_i ++ ){

            aac2020_tautype_UTC_rec_inc_zoom_test_index=( t_i );

            //:load_current_test_values:---------------------://

                /** @VID_IID[ 0063 ]TIME[ 3H 48M 40S ] **/
                /** Why the magic number nine( 9 )     **/
                assert( 9 == NUM_TEST_INPUTS_002 );

                put_x_0 = arr[ ( t_i * 9 ) + 0 ];
                put_x_1 = arr[ ( t_i * 9 ) + 1 ];
                put_y_0 = arr[ ( t_i * 9 ) + 2 ];
                put_y_1 = arr[ ( t_i * 9 ) + 3 ];

                zom_i32 = arr[ ( t_i * 9 ) + 4 ];

                exp_x_0 = arr[ ( t_i * 9 ) + 5 ];
                exp_x_1 = arr[ ( t_i * 9 ) + 6 ];
                exp_y_0 = arr[ ( t_i * 9 ) + 7 ];
                exp_y_1 = arr[ ( t_i * 9 ) + 8 ];

            //:---------------------:load_current_test_values://
            //:set_init_rectangle_and_verify:----------------://

                AAC2020_TAUDEPO_Put( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  put_x_0     //: <-- X_AXIS [ _0 x_ ]
                ,  put_x_1     //: <-- X_AXIS [ _1 x_ ]
                ,  put_y_0     //: <-- Y_AXIS [ _0 y_ ]
                ,  put_y_1     //: <-- Y_AXIS [ _1 y_ ]
                );;

                AAC2020_TAUDEPO_Get( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  &(act_x_0)  //: <-- X_AXIS [ _0 x_ ]
                ,  &(act_x_1)  //: <-- X_AXIS [ _1 x_ ]
                ,  &(act_y_0)  //: <-- Y_AXIS [ _0 y_ ]
                ,  &(act_y_1)  //: <-- Y_AXIS [ _1 y_ ]
                );;

                if( 0
                || put_x_0 != act_x_0 
                || put_x_1 != act_x_1 
                || put_y_0 != act_y_0 
                || put_y_1 != act_y_1 
                ){
                    ERR("[MISSION_FAILED:2020_12_26:0737PM]");
                };;

            //:----------------:set_init_rectangle_and_verify://
            //:translate_and_check:--------------------------://

                AAC2020_TAUTYPE_rec_inc_ZoomPull(
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  zom_i32  
                );;
                
                AAC2020_TAUDEPO_Get( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  &(act_x_0)  //: <-- X_AXIS [ _0 x_ ]
                ,  &(act_x_1)  //: <-- X_AXIS [ _1 x_ ]
                ,  &(act_y_0)  //: <-- Y_AXIS [ _0 y_ ]
                ,  &(act_y_1)  //: <-- Y_AXIS [ _1 y_ ]
                );;

                if( 0
                ||  exp_x_0 != act_x_0
                ||  exp_x_1 != act_x_1
                ||  exp_y_0 != act_y_0
                ||  exp_y_1 != act_y_1
                ){

                    printf( "[test_index(t_i)]:%d\n" , t_i );

                    printf( "[exp_x_0:V:act_x_0]:(%d)(%d)\n"
                            , exp_x_0 , act_x_0 );;
                    printf( "[exp_x_1:V:act_x_1]:(%d)(%d)\n"
                            , exp_x_1 , act_x_1 );;

                    printf( "[exp_y_0:V:act_y_0]:(%d)(%d)\n"
                            , exp_y_0 , act_y_0 );;
                    printf( "[exp_y_1:V:act_y_1]:(%d)(%d)\n"
                            , exp_y_1 , act_y_1 );;

                    ERR("[2020_12_26:ZOOM_TEST_FAILED]");
                };;

            //:--------------------------:translate_and_check://

        number_of_tests_ran++;
        };; //:NEXT[ t_i ](Test Index)

        if( number_of_tests_ran != NUM_TEST__CASES_002 ){
            ERR("[TESTS_NOT_ACTUALLY_RAN_2020_12_26]");
        };;

        LOG("[aac2020_tautype_UTC_rec_inc_Zoom:END]",0);
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_tautype_UTC_rec_inc_Tran( void )
    {
        /** THIS_FUNCTION: Translation of viewport tests **/

        /** arr: array of test cases.          **/
        /** @VID_IID[ 0063 ]TIME[ 1H 35M 40S ] **/

        I32 arr[ NUM_TEST_INPUTS_001 
               * NUM_TEST__CASES_001 ]={
    //001 002 003 004 |   005  |  006   | 007 008 009 010 
    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
    //x_0 x_1 y_0 y_1     o_x     o_y     x_0 x_1 y_0 y_1
    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
        0,  0,  0,  0 , 0+    1,0+    1 ,   1,  1,  1,  1 //:00
    ,   3,  3,  7,  7 , 0+    7,0+    3 ,  10, 10, 10, 10 //:01
    ,  10, 10, 10, 10 , 0-    7,0-    3 ,   3,  3,  7,  7 //:02
        
        //:TESTS: x_0 UNDERFLOW:
    ,   0,  0,  0,  0 , 0-    1,0-    0 ,   0,  0,  0,  0 //:03
    ,   0, 49, 33, 82 , 0-  100,0-    0 ,   0, 49, 33, 82 //:04
    , 100,149,133,182 , 0-  200,0-    0 ,   0, 49,133,182 //:05
        
        //:TESTS: x_1 OVERFLOW:
    , 511,511,511,511 , 0+    1,0+    0 , 511,511,511,511 //:06
    , 462,511,333,382 , 0+    1,0+    0 , 462,511,333,382 //:07
    , 262,311,133,182 , 0+  500,0+    0 , 462,511,133,182 //:08
        
        //:TESTS: y_0 UNDERFLOW:
    ,   0,  0,  0,  0 , 0-    0,0-    1 ,   0,  0,  0,  0 //:09
    ,  33, 82,  0, 49 , 0-    0,0-  100 ,  33, 82,  0, 49 //:10
    , 133,182,100,149 , 0-    0,0-  200 , 133,182,  0, 49 //:11
        
        //:TESTS: y_1 OVERFLOW:
    , 511,511,511,511 , 0+    0,0+    1 , 511,511,511,511 //:12
    , 333,382,462,511 , 0+    0,0+    1 , 333,382,462,511 //:13
    , 133,182,262,311 , 0+    0,0+  500 , 133,182,462,511 //:14

    ,   0,511,  0,511 , 0+ 8500,0+ 8500 ,   0,511,  0,511 //:15
    ,   0,511,  0,511 , 0- 8500,0- 8500 ,   0,511,  0,511 //:16
    ,   0,100,200,300 , 0- 8500,0-    0 ,   0,100,200,300 //:17
    , 200,300,  0,100 , 0-    0,0- 8500 , 200,300,  0,100 //:18
    //___ ___ ___ ___ , _______ _______ , ___ ___ ___ ___
    // INITIAL_VALUES |    XY OFFSET    | EXPECTED VALUES
    //___ ___ ___ ___ , ___ ___ ___ ___ , ___ ___ ___ ___
    //001 002 003 004 |   005  |  006   | 007 008 009 010
    };; //<-- tes_tra //

        //:Set initial values for tests:
        U32 put_x_0;
        U32 put_x_1;
        U32 put_y_0;
        U32 put_y_1;

        //:Bounds_Of_Inclusive_Rectangle: ACTUAL(ACT)
        U32 act_x_0;
        U32 act_x_1;
        U32 act_y_0;
        U32 act_y_1;

        //:Bounds_Of_Inclusive_Rectangle: EXPECTED(EXP)
        U32 exp_x_0;
        U32 exp_x_1;
        U32 exp_y_0;
        U32 exp_y_1;

        //: @VID_IID[ 0063 ]TIME[ 02H 24M 01S ] .............://
        //:#_CAL_VALUES_WERE_BAD_IDEA_IN_TAUTYPE_TESTS_#.....://

        //:Translation_Amounts_Used_In_Tests:
        I32 tra_i_x =( 0 );
        I32 tra_i_y =( 0 );

        I32 m_i =( NUM_TEST__CASES_001 - 1 ); //: max_index
        for( I32 t_i ; t_i <= m_i ; t_i ++ ){

            assert( 10 == NUM_TEST_INPUTS_001 );

            //:load_current_test_values:---------------------://

                put_x_0 = arr[ ( t_i * 10 ) + 0 ];
                put_x_1 = arr[ ( t_i * 10 ) + 1 ];
                put_y_0 = arr[ ( t_i * 10 ) + 2 ];
                put_y_1 = arr[ ( t_i * 10 ) + 3 ];

                tra_i_x = arr[ ( t_i * 10 ) + 4 ];
                tra_i_y = arr[ ( t_i * 10 ) + 5 ];

                exp_x_0 = arr[ ( t_i * 10 ) + 6 ];
                exp_x_1 = arr[ ( t_i * 10 ) + 7 ];
                exp_y_0 = arr[ ( t_i * 10 ) + 8 ];
                exp_y_1 = arr[ ( t_i * 10 ) + 9 ];

            //:---------------------:load_current_test_values://
            //:set_init_rectangle_and_verify:----------------://

                AAC2020_TAUDEPO_Put( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  put_x_0     //: <-- X_AXIS [ _0 x_ ]
                ,  put_x_1     //: <-- X_AXIS [ _1 x_ ]
                ,  put_y_0     //: <-- Y_AXIS [ _0 y_ ]
                ,  put_y_1     //: <-- Y_AXIS [ _1 y_ ]
                );;

                AAC2020_TAUDEPO_Get( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  &(act_x_0)  //: <-- X_AXIS [ _0 x_ ]
                ,  &(act_x_1)  //: <-- X_AXIS [ _1 x_ ]
                ,  &(act_y_0)  //: <-- Y_AXIS [ _0 y_ ]
                ,  &(act_y_1)  //: <-- Y_AXIS [ _1 y_ ]
                );;

                if( 0
                || put_x_0 != act_x_0 
                || put_x_1 != act_x_1 
                || put_y_0 != act_y_0 
                || put_y_1 != act_y_1 
                ){
                    ERR("[TAUTYPE_rec_inc:T_TEST:GETPUT_FAIL]");
                };;

            //:----------------:set_init_rectangle_and_verify://
            //:calculate_expected_outputs:-------------------://

                /** @VID_IID[ 0063 ]TIME[ 2H 22M 20S ] **/
                /** This was a bad idea.               **/
                /** Stashed calculations in _H_ file   **/
            
            //:-------------------:calculate_expected_outputs://
            //:translate_and_check:--------------------------://

                AAC2020_TAUTYPE_rec_inc_Tran(
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,     tra_i_x  
                ,     tra_i_y  
                );;
                
                AAC2020_TAUDEPO_Get( 
                   AAC2020_TAUDEPO.TAU_015   //:DEX_TAU
                ,  AAC2020_TAUDEPO.PAINT5D   //:DEX_SUB
                ,  AAC2020_TAUDEPO.P5D_VP1   //:DEX_VAR
                ,  &(act_x_0)  //: <-- X_AXIS [ _0 x_ ]
                ,  &(act_x_1)  //: <-- X_AXIS [ _1 x_ ]
                ,  &(act_y_0)  //: <-- Y_AXIS [ _0 y_ ]
                ,  &(act_y_1)  //: <-- Y_AXIS [ _1 y_ ]
                );;

                if( 0
                ||  exp_x_0 != act_x_0
                ||  exp_x_1 != act_x_1
                ||  exp_y_0 != act_y_0
                ||  exp_y_1 != act_y_1
                ){

                    printf( "[test_index(t_i)]:%d\n" , t_i );

                    printf( "[exp_x_0:V:act_x_0]:(%d)(%d)\n"
                            , exp_x_0 , act_x_0 );;
                    printf( "[exp_x_1:V:act_x_1]:(%d)(%d)\n"
                            , exp_x_1 , act_x_1 );;

                    printf( "[exp_y_0:V:act_y_0]:(%d)(%d)\n"
                            , exp_y_0 , act_y_0 );;
                    printf( "[exp_y_1:V:act_y_1]:(%d)(%d)\n"
                            , exp_y_1 , act_y_1 );;

                    ERR("[TAUTYPE_rec_inc_FAIL_001]");
                };;

                //: #_HORRIBLE_IDEA_REMOVED_2020_12_26_# ://
                //: @VID_IID[ 0063 ]TIME[ 02H 27M 43S ]  ://

            //:--------------------------:translate_and_check://

        };; //:NEXT[ t_i ](Test Index)
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    U32
    AAC2020_TAUTYPE_UnitTest( U32 u32 )
    {
        if( u32 ){ /** reserved for future use **/ };

        U08* backup_taudepo=( (void*) 0 );

        AAC2020_PIXBACK_Backup_taudepo( &( backup_taudepo ) );

        aac2020_tautype_UnitTest( /** void **/ );

        AAC2020_PIXBACK_Restore_taudepo( &( backup_taudepo ) );


        return( 0x00 );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32                                           //: 01 ://
#undef  U32                                           //: 02 ://
#undef  U08                                           //: 03 ://
#undef  ERR                                           //: 04 ://
#undef  LOG                                           //: 05 ://
#undef  NUM_TEST__CASES_001                           //: 06 ://
#undef  NUM_TEST_INPUTS_001                           //: 07 ://
#undef  NUM_TEST__CASES_002                           //: 08 ://
#undef  NUM_TEST_INPUTS_002                           //: 09 ://
//:================================================:UNIT_TEST://