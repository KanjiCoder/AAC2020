//:ABOUT:TAUFRAG:============================================://
/** ******************************************************** ***

    Similiar to[ FRAGCOM ]except manages access to 
    TAUDEPO memory from the shader code.

    Unlike FRAGCOM you must include TWO shader files:

    1. [ TAUFRAG.FRA.TOP.STRING._ ]  ADD    TAU   DEFINES
                                     ADD    TAU FUNCTIONS

    2. [ TAUFRAG.FRA.BOT.STRING._ ]  REMOVE TAU   DEFINES

*** ******************************************************** **/
//:============================================:ABOUT:TAUFRAG://

    U32
    AAC2020_TAUFRAG_UnitTest( U32 u32 )
    {
        LOG("[AAC2020_TAUFRAG_UnitTest:BEG]",((void*)0));

        if( u32 ){ /**Reserved_For_Future_Use**/ };
    
        //:TAUDEPO_SHADER_CONSTANTS:-------------------------://

            E_V aac2020_taufrag_UTC_taudepo_CopiesMatch( V );
                aac2020_taufrag_UTC_taudepo_CopiesMatch(   );

        //:-------------------------:TAUDEPO_SHADER_CONSTANTS://

        LOG("[AAC2020_TAUFRAG_UnitTest:BEG]",((void*)0));
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    E_V
    aac2020_taufrag_UTC_taudepo_CopiesMatch( void )
    {
    /** **************************************************** ***
    ABOUT THIS FUNCTION:
    Makes sure TAUFRAG values are idential to TAUDEPO values.
    This is an UGLY HACK that adds extra indirection in our
    code. Ideally I don't want a[ TAUFRAG ]sub-system, but it
    is the simplist way I can think of to avoid hard coding
    [ TAUDEPO ]values into our shader code while still 
    maintaining a flexible build system for our 
    shader code pipeline. Our pipeline writes GLSL code as
    C99 code that can compile as GLSL due to macro magic.
    AT_MAKERWORKS_DATE[ 2021_03_11 ]
    *** **************************************************** **/
    #define NUM_TAU (  1 )
    #define NUM_SUB (  2 )
    #define NUM_VAR ( 12 )

        //:SUB_SECTION_NAMES_MATCH_TAUDEPO_D:================://
        /** ************************************************ ***
        @VID_IID[ 0173 ]TIME[ 02:54:00 ]
        The code comment section labels below are identical to
        the comment sections in [ TAUDEPO.D._ ]. Hopefully this
        helps you "connect the dots".
        *** ************************************************ **/
        U32 tab_DEX_TAU_000_015[ NUM_TAU * 2 ]={
            //::DEX_TAU_000_015:----------------------------:://

            /**/        AAC2020_TAUDEPO_TAU_015
            ,   AAC2020_TAUFRAG_taudepo_tau_015

            //::----------------------------:DEX_TAU_000_015:://
        };;
        U32 tab_DEX_SUB_000_015[ NUM_SUB * 2 ]={
            //::DEX_SUB_000_015:----------------------------:://

            /**/        AAC2020_TAUDEPO_SUB_TAUDEPO
            ,   AAC2020_TAUFRAG_taudepo_sub_taudepo

            ,           AAC2020_TAUDEPO_SUB_PAINT5D
            ,   AAC2020_TAUFRAG_taudepo_sub_paint5d
            
            //::----------------------------:DEX_SUB_000_015:://
        };;
        U32 tab_DEX_VAR_000_255[ NUM_VAR * 2 ]={
            //::DEX_VAR_000_255:----------------------------:://

            /**/AAC2020_TAUDEPO_SUB_PAINT5D_VAR_D_1 //:[  0  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_D_1 //:[  0  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_vp0 //:[  1  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_vp0 //:[  1  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_vp1 //:[  2  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_vp1 //:[  2  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_vpc //:[  3  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_vpc //:[  3  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_Q //:[  4  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_T_Q //:[  4  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_E //:[  5  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_T_E //:[  5  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_L //:[  6  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_T_L //:[  6  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_B_X //:[  7  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_B_X //:[  7  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_B_Y //:[  8  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_B_Y //:[  8  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_A_D //:[  9  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_A_D //:[  9  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_T_V //:[ 10  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_T_V //:[ 10  ]//
            
            ,   AAC2020_TAUDEPO_SUB_PAINT5D_VAR_vd1 //:[ 11  ]//
            ,   AAC2020_TAUFRAG_tau_sub_p5d_VAR_vd1 //:[ 11  ]//
        
            //::----------------------------:DEX_VAR_000_255:://

        };;
        //:================:SUB_SECTION_NAMES_MATCH_TAUDEPO_D://
        
        I32 dex_met; //:META_TEST_INDEX
        I32 dex_tau; //:index of TAU variable being looked at.
        I32 dex_sub; //:index of SUB variable being looked at.
        I32 dex_var; //:index of VAR variable being looked at.
        
        U32 dex_taudepo; //:INDEX_OF_DATA_IN_ARRAY:TAUDEPO:VAL
        U32 dex_taufrag; //:INDEX_OF_DATA_IN_ARRAY:TAUFRAG:VAL
        
        U32 loc_taudepo; //:u32_taudepo_location : ON TEXTURE
        U32 loc_taufrag; //:u32_taufrag_location : ON TEXTURE
        
            
        //:tab_DEX_TAU_000_015:==============================://
        #define M_I (     NUM_TAU-1       )
        #define TAU ( tab_DEX_TAU_000_015 )
        
            for  dex_met = 1 ; dex_met <= ( 2 ) ; dex_met++ ){
            for( dex_tau = 0 ; dex_tau <= (M_I) ; dex_tau++ ){

                dex_taudepo =(( dex_tau * 2 )+0 );
                dex_taufrag =(( dex_tau * 2 )+1 );
                
                loc_taudepo=( TAU[ dex_taudepo ] );
                loc_taufrag=( TAU[ dex_taufrag ] );
                
                if( 1 == dex_met ){
                    if( loc_taudepo //: MUST_ALWAYS_MATCH :::://
                    !=  loc_taufrag //: MUST_ALWAYS_MATCH :::://
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_VAL_:TAU]");
                    };;
                }else
                if( 2 == dex_met ){
                    if( (              0         )
                    ||  ( loc_taudepo != dex_tau )
                    ||  ( loc_taufrag != dex_tau )
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_DEX_:TAU]");
                    };;
                }else{
                    ERR("[UNKNOWN_META_INDEX:__________:TAU]");
                };;
                
            };;};;
            
        #undef  M_I 
        #undef  TAU 
        //:==============================:tab_DEX_TAU_000_015://
        //:tab_DEX_SUB_000_015:==============================://
        #define M_I (     NUM_SUB-1       )
        #define SUB ( tab_DEX_SUB_000_015 )
        
            for  dex_met = 1 ; dex_met <= ( 2 ) ; dex_met++ ){
            for( dex_sub = 0 ; dex_sub <= (M_I) ; dex_sub++ ){

                dex_taudepo =(( dex_sub * 2 )+0 );
                dex_taufrag =(( dex_sub * 2 )+1 );
                
                loc_taudepo=( SUB[ dex_taudepo ] );
                loc_taufrag=( SUB[ dex_taufrag ] );
                
                if( 1 == dex_met ){
                    if( loc_taudepo //: MUST_ALWAYS_MATCH :::://
                    !=  loc_taufrag //: MUST_ALWAYS_MATCH :::://
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_VAL_:SUB]");
                    };;
                }else
                if( 2 == dex_met ){
                    if( (              0         )
                    ||  ( loc_taudepo != dex_sub )
                    ||  ( loc_taufrag != dex_sub )
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_DEX_:SUB]");
                    };;
                }else{
                    ERR("[UNKNOWN_META_INDEX:__________:SUB]");
                };;
            };;};;
            
        #undef  M_I 
        #undef  SUB 
        //:==============================:tab_DEX_SUB_000_015://
        //:tab_DEX_VAR_000_255:==============================://
        #define M_I (     NUM_VAR-1       )
        #define VAR ( tab_DEX_VAR_000_255 )
        
            for  dex_met = 1 ; dex_met <= ( 2 ) ; dex_met++ ){
            for( dex_var = 0 ; dex_var <= (M_I) ; dex_var++ ){

                dex_taudepo =(( dex_var * 2 )+0 );
                dex_taufrag =(( dex_var * 2 )+1 );
                
                loc_taudepo=( VAR[ dex_taudepo ] );
                loc_taufrag=( VAR[ dex_taufrag ] );
                
                if( 1 == dex_met ){
                    if( loc_taudepo //: MUST_ALWAYS_MATCH :::://
                    !=  loc_taufrag //: MUST_ALWAYS_MATCH :::://
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_VAL_:VAR]");
                    };;
                }else
                if( 2 == dex_met ){
                    if( (              0         )
                    ||  ( loc_taudepo != dex_var )
                    ||  ( loc_taufrag != dex_var )
                    ){
                        ERR("[TAUFRAG_UTC_TAUDEPO:_DEX_:VAR]");
                    };;
                }else{
                    ERR("[UNKNOWN_META_INDEX:__________:VAR]");
                };;
            };;};;
            
        #undef  M_I 
        #undef  VAR 
        //:==============================:tab_DEX_VAR_000_255://

    #undef  NUM_TAU  //:Number_Of_Unique:TAU:locations:::::::://
    #undef  NUM_SUB  //:Number_Of_Unique:SUB:locations:::::::://
    #undef  NUM_VAR  //:Number_Of_Unique:VAR:locations::::::::// 
    }
    
    
    
    
    
    
    
    
    
    
    
    
    