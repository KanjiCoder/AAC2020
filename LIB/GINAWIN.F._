//:SEE: #_OLD_GINAWIN_DOCUMENTATION_#
//:SEE: #_WHY_CANT_I_SEE_MY_WINDOW_#
/** ******************************************************** ***

    TODO: This needs to be re-written so the only difference
          between the threaded an non-threaded version is
          where our infinite loop function is called.
          
          The middle of the window loop will be done using
          function pointers.

          (This might already be done. Check and then remove)
          (this comment. )

*** ******************************************************** **/
//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://

    void
    aac2020_ginawin_Halt( 
        const char* error_message_string
    ){
        printf(
            "[AAC2020_GINAWIN :Fatal_Error_Encountered]\n"
        );;
        printf( "[AAC2020_GINAWIN:error_message_string]:%s\n"
                                , error_message_string );;
        fflush(stdout);
        exit( 666 );
    } 

//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:ABOUT_TO_ERROR_MESSAGE:===================================://

    void
    aac2020_ginawin_AboutToErrorMessage(

        const char* atem /** about_to_error_message **/

    )
    {
        /** Do NOT make silencable. Since these messages **/
        /** Are always shown before crashing system.     **/

        printf("[AAC2020_GINAWIN:ATEM]:%s\n" , atem );;
        fflush( stdout );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_ginawin_AboutToErrorMessage_dec(

        const char* fmts /** format_string ........ **/
    ,   int          dec /** decimal value to print **/

    )
    {
        /** Do NOT make silencable. Since these messages **/
        /** Are always shown before crashing system.     **/

        printf("[AAC2020_GINAWIN:ATEM_DEC]:MESSAGE_BELOW]:\n");
        printf( fmts , dec );
        fflush( stdout );
    }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    aac2020_ginawin_AboutToErrorMessage_str(

        const char* fmts /** format_string ........ **/
    ,   const char*  str /** string value to print  **/

    )
    {
        /** Do NOT make silencable. Since these messages **/
        /** Are always shown before crashing system.     **/

        printf("[AAC2020_GINAWIN:ATEM_STR]:MESSAGE_BELOW]:\n");
        fflush( stdout ); //:#_EXTRAFLUSH_INCASE_BADFMTSTR_#://
        printf( fmts , str );
        fflush( stdout );
    }

//:===================================:ABOUT_TO_ERROR_MESSAGE://
//:ALERT_MESSAGE:============================================://
#define ATEM_STR aac2020_ginawin_AboutToErrorMessage_str
#define HALT     aac2020_ginawin_Halt

    int 
    aac2020_ginawin_Alert( 
        const char* msg 
    ){

        ATEM_STR( "[WhatWentWrong]:%s\n", msg );

        aac2020_ginawin_FUNCTION_POINTERS_struct*
        FP=&(aac2020_ginawin_function_pointers);

        if(NULL==FP->USER32.MessageBoxW){
            const char* msg = "[ForgotToInitMsgBoxW]";
            HALT( msg  );
        };;

        struct aac2020_ginawin_data_USER32*         
        U32D = &(  FP->USER32.DATA );

        int msgboxID =(
        FP->USER32.MessageBoxW(
            NULL
        ,
            L"You forgot to do something in code.\n"
            L"strcat is a lot of work to make a  \n"
            L"custom message. So check the       \n"
            L"console for what went wrong.       \n"
        ,
            L"[!!CHECK_THE_CONSOLE!!]"
        ,
            (
                U32D -> mb_iconexclamation | 
                U32D -> mb_ok              |
            0)
        ));;

        return msgboxID;    
    } 

#undef ATEM_STR
#undef     HALT
//:============================================:ALERT_MESSAGE://
//:OKAY_MESSAGE:=============================================://

    void
    aac2020_ginawin_Okay( const char* ok_message ){

        if( AAC2020_SILENCE.GINAWIN >= 1 ){

            /** DO NOTHING. Non errors Silenced. **/

        }else{

            printf( "[AAC2020_GINAWIN:OK]:%s\n" ,  ok_message);
            fflush(stdout);

        };;
    }  

//:=============================================:OKAY_MESSAGE://
//:INFO_MESSAGE_IS_SILENCABLE:===============================://
#define I32 int32_t /** GCC: <stdint.h> **/

    void
    aac2020_ginawin_Info( const char* msg_inf ){

        if( AAC2020_SILENCE.GINAWIN >= 1 ){

            /** DO NOTHING. Non errors Silenced. **/

        }else{

            printf( "[AAC2020_GINAWIN:INFO]:%s\n" ,  msg_inf);
            fflush(stdout);
        };;
    }  

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

    void
    AAC2020_GINAWIN_Info_dec( 
        const char* fmt_str
    ,   I32         dec_val
    )
    {
        if( AAC2020_SILENCE.GINAWIN >= 1 ){

            /** DO NOTHING. Non errors Silenced. **/

        }else{

            printf( "[AAC2020_GINAWIN_Info_dec:BELOW]:\n");
            fflush(stdout);//:#_EXTRAFLUSH_INCASE_BADFMTSTR_#://
            printf( fmt_str , dec_val );
            fflush(stdout);

        };;
    }

#undef  I32
//:===============================:INFO_MESSAGE_IS_SILENCABLE://
//:ASSERT_CORRECT_SIZES_OF_TYPES:============================://
#define ATEM     aac2020_ginawin_AboutToErrorMessage
#define ATEM_DEC aac2020_ginawin_AboutToErrorMessage_dec
#define HALT     aac2020_ginawin_Halt

    void
    aac2020_ginawin_AssertCorrectSizesOfTypes(){

        int size_errors = 0; //:Number_Of_Size_Errors
        int wrong_sign  = 0; //:Number_Of_Wrong_Sign_Errors

        //:size_errors?:-------------------------------------://
        
            if(sizeof(   BOOL_i32_4B) != 4 ){
                ATEM("[BOOL_i32_4B]");
                size_errors++;
            };;
            if(sizeof(  DWORD_u32_4B) != 4 ){
                ATEM("[DWORD_u32_4B]");
                size_errors++;
            };;
            if(sizeof(   UINT_u32_4B) != 4 ){
                ATEM("[UINT_u32_4B]");
                size_errors++;
            };;
            if(sizeof(   WORD_u16_2B) != 2 ){
                ATEM("[WORD_u16_2B]");
                size_errors++;
            };;
            //:I recall windows returning negative
            //:characters to flag status codes or
            //:something. So pretty sure CHAR
            //:is a signed type.
            if(sizeof(   CHAR_b08_1B) != 1 ){
                ATEM("[CHAR_b08_1B]");
                size_errors++;
            };;
            {
                //:assume if this works, c_LPCSTR_b08_1B
                //:is correctly defined.
                //:"i08_1B" refers to size of 
                //:POINTED TO type, not the size of
                //:the pointer.
                const char pointed_to_value = 'e';
                c_LPCSTR_b08_1B pointer = &(
                    pointed_to_value
                );;
                if( *pointer == 'e' ){
                    //:okay
                }else{
                    ATEM("[WTF:2020_12_09:0614PM]");
                };;
            }
        
        //:--------------------------------------:size_errors://
        //:wrong_sign?:--------------------------------------://

            ;{
                 BOOL_i32_4B v =(
                (BOOL_i32_4B)(-1) );;
                if( v >= 0 ){ 
                    wrong_sign++;
                    ATEM("[WS:BOOL_i32_4B]");
                }
            }{
                 DWORD_u32_4B v =(
                (DWORD_u32_4B)(-1) );;
                if( v <= 0 ){ 
                    wrong_sign++; 
                    ATEM("[WS:DWORD_u32_4B]");
                }
            }{
                 UINT_u32_4B v =(
                (UINT_u32_4B)(-1) );;
                if( v <= 0 ){ 
                    wrong_sign++; 
                    ATEM("[WS:UINT_u32_4B]");
                }
            }{
                 WORD_u16_2B v =(
                (WORD_u16_2B)(-1) );;
                if( v <= 0 ){ 
                    wrong_sign++; 
                    ATEM("[WS:WORD_u16_2B]");
                }
            }{
                 CHAR_b08_1B v =(
                (CHAR_b08_1B)(-1) );;
                if( v > 0 ){ 
                    //:Turns out that character type
                    //:signedness is compiler dependent,
                    //:so... Dont test this.
                    wrong_sign++; 
                    ATEM("[WS:CHAR_b08_1B]");
                }
            };;

        //:--------------------------------------:wrong_sign?://
        //:should_we_crash?:---------------------------------://

            if(wrong_sign  > 0){
                ATEM_DEC(
                    "[TypesOfWrongSign]:%d\n"
                ,   wrong_sign
                );;
            };;
            if(size_errors > 0){
                ATEM_DEC(
                    "[TypesNotCorrectBitWidth]:%d\n"
                ,   size_errors
                );;
            };;
            if( size_errors > 0 || wrong_sign > 0 ){
                HALT("[AAC2020_GINAWIN:AssertFailed]\n");
            };;

        //:---------------------------------:should_we_crash?://
    }  
 
#undef ATEM
#undef ATEM_DEC
#undef HALT
//:============================:ASSERT_CORRECT_SIZES_OF_TYPES://
//:ASSERT_RESTRICTED_NON_NULL:===============================://
#define ATEM     aac2020_ginawin_AboutToErrorMessage
#define HALT     aac2020_ginawin_Halt

    void
    aac2020_ginawin_AssertDifferentAndNonZero(
    /**/void* ptr_01
    ,   void* ptr_02
    ){
        int has_error = 0;

        //:collect_errors:-----------------------------------://

            if(NULL==ptr_01){
                has_error++;
                ATEM("[ptr_01:NULL]");
            };;
            if(NULL==ptr_02){
                has_error++;
                ATEM("[ptr_02:NULL]");
            };;
            if( ptr_01 == ptr_02 ){
                has_error++;
                ATEM("[FAIL:ptr_01==ptr_02]");
            };;
        //:-----------------------------------:collect_errors://
        //:THROW_ERROR:--------------------------------------://

            if( 0 != has_error ){
                HALT( "[FAIL:AssertDifferentAndNonZero]\n" );
            };;

        //:--------------------------------------:THROW_ERROR://

    }  

#undef ATEM
#undef HALT
//:===============================:ASSERT_RESTRICTED_NON_NULL://
//:LOAD_LIBRARY:=============================================://
#define ATEM      aac2020_ginawin_AboutToErrorMessage
#define HALT      aac2020_ginawin_Halt
#define ATEM_STR  aac2020_ginawin_AboutToErrorMessage_str

    v_HINSTANCE
    aac2020_ginawin_LoadLibrary( 
        const char* dll_name //:Example: "user32.dll"
    ){
        v_HINSTANCE dll_handle =(
            PEB2020_LoadLibraryA( dll_name )
        );;
        if(NULL==dll_handle){
            ATEM(    "[aac2020_ginawin:Failed_To_Load_DLL]");
            ATEM_STR("[dll_name]:%s", dll_name );
            HALT("[FUCK_IAM_OUT_OF_HERE:2020_12_09:0628PM]");
        };;
        
        return( dll_handle );
    } 

#undef  ATEM
#undef  HALT
#undef  ATEM_STR
//:=============================================:LOAD_LIBRARY://
//:GET_PROC_ADDRESS:=========================================://
#define HALT aac2020_ginawin_Halt

    //:GPA=="GetProcAddress"
    AAC2020_GINAWIN_FUNC
    aac2020_ginawin_GPA(
    /**/c_LPCSTR_b08_1B                 function_name
    ,   v_HMODULE   dll_containing_function
    ){
        if( ((void*)0) == dll_containing_function ){
            HALT("[null:dll_containing_function]");
        };;

        f_FARPROC function_pointer =(f_FARPROC)(
            PEB2020_GetProcAddress(
            /**/dll_containing_function
            ,   function_name
            )
        );;

        if( ((void*)0) ==function_pointer){
            HALT("[aac2020_ginawin:null:fn_ptr]");
        };;

        return( (AAC2020_GINAWIN_FUNC)function_pointer );
    }  

#undef  HALT
//:=========================================:GET_PROC_ADDRESS://
//:NULFUN:===================================================://
#define ATEM      aac2020_ginawin_AboutToErrorMessage
#define ATEM_STR  aac2020_ginawin_AboutToErrorMessage_str
#define HALT      aac2020_ginawin_Halt

    void
    aac2020_ginawin_NULFUN( 
        const char* name_of_null_function
    ){
        /** aac2020_ginawin_NULFUN MEANS:   **/
        /** NULFUN:NullFunctionPointerError **/

        ATEM    (  "[AAC2020_GINAWIN :Null_Func_Ptr_Found]\n" );
        ATEM_STR( "Null:%s\n", name_of_null_function );
        HALT    ( "[FUNCTION_POINTER_SEEMS_TO_BE_NULL]");

    } 

#undef ATEM    
#undef ATEM_STR
#undef HALT    
//:===================================================:NULFUN://



//:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
//:                                                          ://
//:                  W:WINDOW_CODE:(BELOW)                   ://
//:                                                          ://
//:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
//:WINDOW_CODE:##############################################://

//:window_code.WIN_MSG_HAN_WND_POC:==========================://
//:window_code.WindowMessageHander,WindowProc:===============://
#define HALT aac2020_ginawin_Halt
#define INFO aac2020_ginawin_Info
#define FPTR aac2020_ginawin_function_pointers

    //:WINDOW_MESSAGE_HANDLER_WNDPROC
    //:WIN:WINDOW
    //:MSG:MESSAGE
    //:HAN:HANDLER
    //:WND:WIND
    //:POC:PROC
    //:WND_POC:WNDPROC
    __stdcall
    LRESULT_i64_8B   
    aac2020_ginawin_WIN_MSG_HAN_WND_POC(
    /**/       v_HWND   Hw  
    ,     UINT_u32_4B   Msg
    ,   WPARAM_u64_8B   wParam  
    ,   LPARAM_i64_8B   lParam
    ){
        //:An LRESULT tells us what we did
        //:with the message. If handled it
        //:should return zero.
        LRESULT_i64_8B return_this_result = 0;
        BOOL_i32_4B ok = 0;

        //:ASSERT_SATED_FUNCTION_POINTERS:===================://
        #define N ((void*)0)
        #define F aac2020_ginawin_function_pointers
        #define H aac2020_ginawin_Halt
                                                                                                     
            if(N==F.USER32.DestroyWindow  ){ H("[U32.DW!!]");};                                                
            if(N==F.USER32.PostQuitMessage){ H("[U32.PQM!]");};                                                 
            if(N==F.USER32.DefWindowProcW ){ H("[U32.DWPW]");};          
                                                               
        #undef  N
        #undef  F
        #undef  H
        //:===================:ASSERT_SATED_FUNCTION_POINTERS://
        //:SWITCH:===========================================://
        switch(Msg){ //:=====================================://

        case 0x0200 /** WM_MOUSEMOVE **/:
        {

            //:MOUSE_COORDS:CALCULATE:-----------------------://
            #define U32 uint32_t /** GCC: <stdint.h> **/

                //:LOW_AND_HIGH_WORDS:.......................://

                    U32 low_word_is_x_axis=( 0 );
                    U32 hig_word_is_y_axis=( 0 );

                    /** Get X and Y Coordinates in **/
                    /** WM_MOUSEMOVE case          **/

                    low_word_is_x_axis=
                    ((unsigned short)(((unsigned __int64)(

                        lParam /** INPUT_VALUE **/

                    )) & 0xffff));;

                    hig_word_is_y_axis=
                    ((unsigned short)((((unsigned __int64)( 

                        lParam /** INPUT_VALUE **/

                    )) >> 16) & 0xffff));;

                //:.......................:LOW_AND_HIGH_WORDS://
                //:TODO:IMPLEMENT_DRAG_COORDS:...............://

                    AAC2020_VITAL_TODO("[ShaderToyDragCoords]");

                //:...............:TODO:IMPLEMENT_DRAG_COORDS://

            //:-----------------------:MOUSE_COORDS:CALCULATE://
            //:MOUSE_COORDS:STORE:---------------------------://

                int decide_if_we_have_made_a_click = ( 0 );

                /** [m_x,m_y]: always the current mouse pos. **/
                AAC2020_IMOUBOX_m_x = low_word_is_x_axis ;
                AAC2020_IMOUBOX_m_y = hig_word_is_y_axis ;
        
                /** Is left or right mouse button down? **/
                int dow_lef = wParam & 0x0001 ; //:MK_LBUTTON://
                int dow_rig = wParam & 0x0002 ; //:MK_RBUTTON://

                if( dow_rig ){ /** NOT USED AT THIS TIME **/ };

                int is_mouse_currently_down = ( dow_lef >= 1 );
                int is_mouse_currently_up   = ( dow_lef <= 0 );
                assert( 1 == is_mouse_currently_down
                            +is_mouse_currently_up );;


                //:SET_MOUSE_DOWN:...........................://
                if( is_mouse_currently_down ){

                    //:IF::: Mouse was previously up 
                    //:THEN: set DOWN position.
                    if( AAC2020_IMOUBOX_m_u >= 1 ){

                        AAC2020_IMOUBOX_d_x =   //:  X-AXIS  ://
                        AAC2020_IMOUBOX_m_x ;   //:  X-AXIS  ://
                                                             
                        AAC2020_IMOUBOX_d_y =   //:  Y-AXIS  ://
                        AAC2020_IMOUBOX_m_y ;   //:  Y-AXIS  ://

                    };;
                }else
                //:...........................:SET_MOUSE_DOWN://
                //:SET_MOUSE_UP:.............................://
                if( is_mouse_currently_up ){

                    //:IF::: Mouse was previously DOWN 
                    //:THEN: set UP position.
                    if( AAC2020_IMOUBOX_m_d >= 1 ){

                        AAC2020_IMOUBOX_u_x =   //:  X-AXIS  ://
                        AAC2020_IMOUBOX_m_x ;   //:  X-AXIS  ://
                                                             
                        AAC2020_IMOUBOX_u_y =   //:  Y-AXIS  ://
                        AAC2020_IMOUBOX_m_y ;   //:  Y-AXIS  ://

                        decide_if_we_have_made_a_click =( 1 );

                    };;
                }else{
                    aac2020_ginawin_Halt("[EDCL:2020_11_17]");
                };;
                //:.............................:SET_MOUSE_UP://
                //:HAVE_WE_CLICKED?..........................://
                if( decide_if_we_have_made_a_click >= 1 ){

                    //:If delta between [u_x,u_y] & [d_x,d_y]
                    //:is small enough, record as a click
                    //:position.
                    
                    #define X1 AAC2020_IMOUBOX_u_x  //:######://
                    #define X2 AAC2020_IMOUBOX_u_y  //:######://
                    #define Y1 AAC2020_IMOUBOX_d_x  //:######://
                    #define Y2 AAC2020_IMOUBOX_d_y  //:######://
                    
                    int min_click_distance =( 7 );
                    
                    //:Distance Squared:::: ( dist *  dist )
                    int d_2 = (X1-X2)*(X1-X2) 
                            + (Y1-Y2)*(Y1-Y2);
                    
                    //:Thresh-hold Squared: (tdist * tdist )
                    int t_2 = ( min_click_distance
                              * min_click_distance );;
                    
                    if( d_2 <= t_2 ){
                    
                        AAC2020_IMOUBOX_c_x =   //:  X-AXIS  ://
                        AAC2020_IMOUBOX_m_x ;   //:  X-AXIS  ://
                                                             
                        AAC2020_IMOUBOX_c_y =   //:  Y-AXIS  ://
                        AAC2020_IMOUBOX_m_y ;   //:  Y-AXIS  ://
                    
                    };;
                    
                    #undef  X1  //:##########################://
                    #undef  X2  //:##########################://
                    #undef  Y1  //:##########################://
                    #undef  Y2  //:##########################://

                };;
                //:.........................:HAVE_WE_CLICKED?://
                //:UPDATE_LAST:..............................://

                    /** Update LAST so we can use  values  **/
                    /**  as PREVIOUS values in code above. **/

                    if( is_mouse_currently_down  ){
                        AAC2020_IMOUBOX_m_d = ( 1 );
                        AAC2020_IMOUBOX_m_u = ( 0 );
                    }else
                    if( is_mouse_currently_up    ){
                        AAC2020_IMOUBOX_m_d = ( 0 );
                        AAC2020_IMOUBOX_m_u = ( 1 );
                    };;

                //:..............................:UPDATE_LAST://

            #undef U32
            //:---------------------------:MOUSE_COORDS:STORE://

            /** ********************************************* **

                @REFERENCE@

                // Check to see if the left button is held down:
                int lef_dow = wParam & 0x0001 ; //:MK_LBUTTON://

                // Check if right button down:
                int rig_dow = wParam & 0x0002 ; //:MK_RBUTTON://

            *** ******************************************** **/

        }break;


        case 0x0005 /** WM_SIZE **/:{ 

            INFO("[AAC2020_GINAWIN:WM_SIZE]\n");

            //:#_GAME_WITHOUT_MUTEXES_#://

        }break;
        case 0x0100 /** WM_KEYDOWN **/:{
            if(wParam==0x1B /** VK_ESCAPE **/){

                ok = FPTR.USER32.DestroyWindow(Hw);
                if(0==ok){aac2020_ginawin_Halt("[0OK_1]");}

            }else{


                //:PO_BOX_INSTEAD_OF_CALLBACKS:--------------://
                char key =(
                    AAC2020_NATIKEY_wParam_CTO_AZ09(wParam) );;
                       
                AAC2020_IKEYBOX_k_p   = key ;
                AAC2020_IKEYBOX_dirty =( 0 );
                //:--------------:PO_BOX_INSTEAD_OF_CALLBACKS://

            };;

        }break;

        case 0x0101 /** WM_KEYUP **/:{
            
                //: KEBO_UPPP_HandleVirtualKey( wParam );
                INFO("[WM_KEYUP]");
        }break;

        //:WM_CLOSE: The "[X]" button was clicked.
        case 0x0010 /** WM_CLOSE **/:{

            //:Question: Should "WM_CLOSE" fallthrough
            //:              to "WM_DESTROY"?

            //:#_WM_CLOSE_VS_WM_DESTROY_#://

            #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 ) //:######://
            #define OK aac2020_ginawin_Okay
            OK("[OK:WM_CLOSE:About_To_DestroyWindow]");
            #undef  OK 
            #endif //:#######################################://

            ok = FPTR.USER32.DestroyWindow(Hw); 
            if(0==ok){aac2020_ginawin_Halt("[0OK_2]");}

            
        }break;
        //:WM_DESTROY: ( DESTROYED|DESTROYING )
        case 0x0002 /** WM_DESTROY **/:{

            //:#_WM_CLOSE_VS_WM_DESTROY_#://

            #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 ) //:######://
            #define OK aac2020_ginawin_Okay
            OK("[WM_DESTROY:Handling_Destroy_Window_Message]");
            #undef  OK 
            #endif //:#######################################://

            //: Send "WM_QUIT" to exit msg loop.
            FPTR.USER32.PostQuitMessage(0);

        }break;
        case 0x000F /** WM_PAINT **/:{
            
            //:#_WM_PAINT_RECYCLED_2020_12_09_#://

        }break;

        //:Keep window responsive:
        default:{ 

            if( return_this_result ){ /** NOOP **/ };

            //+ Removed: Think you must ALWAYS call this.    +//
            //+          not just in DEFAULT case.           +//
            //-   return_this_result=(                       -//
            //-       FP->USER32.DefWindowProcW(             -//
            //-           Hw,Msg,wParam,lParam               -//
            //-       )                                      -//
            //-   );;                                        -//
        }
        };; //:---------------------------------------:SWITCH://
        
        //:#_I_THINK_MUST_ALWAYS_CALL_DEFWINPROC_#://
        return_this_result=(                                 
            FPTR.USER32.DefWindowProcW(                       
                Hw,Msg,wParam,lParam                         
            )                                                
        );;                                                                                      

        return( return_this_result );
    } 

#undef HALT
#undef INFO
#undef FPTR
//:==========================:window_code.WIN_MSG_HAN_WND_POC://
//:===============:window_code.WindowMessageHander,WindowProc://

BOOL_i32_4B 
aac2020_ginawin_RegisterWindow(
//+-------------------------+[ ]+//
/**/v_HINSTANCE           //+[1]+//
    hin                   //+[1]+//
                          //+[ ]+//
//+ (UNICODE_STRING)         [ ]+//
,   c_LPCWSTR_b16_2B      //+[2]+//
    unique_window_name    //+[2]+//
//+-------------------------+[ ]+//
){
    #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
     if( AAC2020_SILENCE.GINAWIN     <= 0 ){

        //:RWIN:RegisterWindow
        wprintf( L"[RWIN:unique_window_name]%s\n" 
                  , unique_window_name );;
        
     };;
    #endif

    aac2020_ginawin_FUNCTION_POINTERS_struct*
    FP = &(aac2020_ginawin_function_pointers);

    if(NULL==FP->GDI32.GetStockObject){
        aac2020_ginawin_Halt("[G32.GSO]");
    };;




    //:Before using re-creation of
    //:WNDCLASSEXW, make sure correct size
    //:as a basic smoke test.
    size_t struct_size =(
        sizeof( aac2020_ginawin_WNDCLASSEXW )
    );;
    if( struct_size != 80 ){
        aac2020_ginawin_Halt("[BadStructSize]");
    };;
    


    
    //: WNDCLASSEXW W;
    aac2020_ginawin_WNDCLASSEXW W = {0};

    

    W.cbSize=sizeof( aac2020_ginawin_WNDCLASSEXW);
    W.style=(0
        //: THIS_BITMASK: - - - ://
        //: Copied from glfw's: ://
        //: win32_window.c      ://
        //: _gflwRegisterWindow ://
        //: ...ClassWin32       ://
        //: - - - - - - - - - - ://
    |   0x0002 /** CS_HREDRAW : TODO:DOUBLE_CHECK_THIS **/ 
    |   0x0001 /** CS_VREDRAW : TODO:DOUBLE_CHECK_THIS **/
    |   0x0020 /** CS_OWNDC   : TODO:DOUBLE_CHECK_THIS **/
    |                
    0);;
    W.lpfnWndProc=aac2020_ginawin_WIN_MSG_HAN_WND_POC;
    W.cbClsExtra=0;
    W.cbWndExtra=0;
    W.hInstance=hin;

    W.hIcon  =FP->USER32.LoadIconA(
        NULL
    ,   FP->USER32.DATA.A.idi_application
    );;
    W.hCursor=FP->USER32.LoadCursorA(
        NULL
    ,   FP->USER32.DATA.A.idc_arrow
    );;

    //| Looking at:                            |//
    //| https://github.com/glfw/glfw/blob/     |//
    //| master/src/win32_window.c              |//
    //| does not look like background          |//
    //| brush color eneds to be set.           |//
    //|                                        |//
    //| Code here specifically says:           |//
    //| "No Background Required For GL"        |//
    //| http://nehe.gamedev.net/tutorial       |//
    //| /creating_an_opengl_window_(win32)     |//
    //| /13001/                                |//
    //- W.hbrBackground=(                      -//
    //-     /**/(HBRUSH)                       -// 
    //-     /**/ FP->GDI32.GetStockObject(     -// 
    //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-// 
    //-     /**/)                              -// 
    //- );;                                    -//
    W.hbrBackground=NULL;

    W.lpszMenuName=NULL;
    W.lpszClassName=unique_window_name;
    W.hIconSm=(
        FP->USER32.LoadIconA(
            NULL
        ,   FP->USER32.DATA.A.idi_application
        )
    );;

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //! If you forget to register your         !//
    //! window class, the observable effect    !//
    //! is the window never opening, and the   !//
    //! wait loop exiting immediately.         !//
    //|________________________________________|//
    return(
        FP->USER32.RegisterClassExW(
            &( W )
        )
    );;
} //[Register]//

void
aac2020_ginawin_AssertPeekFunctionExists(){

    aac2020_ginawin_FUNCTION_POINTERS_struct*
    FP = &(aac2020_ginawin_function_pointers);

    if(NULL==FP){ 
        aac2020_ginawin_Halt("[FP]");
    };;
    if(NULL==FP->USER32.PeekMessageW){ 
        aac2020_ginawin_Halt("[PM]");
    };;

} //[aac2020_ginawin_AssertPeekFunctionExists]//

BOOL_i32_4B
aac2020_ginawin_TakeOrLookMessage( 
/**/
    AAC2020_GINAWIN_LPMSG /** Pointer To Message Struct **/
    dont_prefix_message_with_and_symbol

,   

    int take_the_message
){

    aac2020_ginawin_AssertPeekFunctionExists();

    aac2020_ginawin_FUNCTION_POINTERS_struct*
    FP = &(aac2020_ginawin_function_pointers);

    UINT_u32_4B look;
    UINT_u32_4B take;
    UINT_u32_4B look_or_take;

    look = FP->USER32.DATA.pm_noremove;
    take = FP->USER32.DATA.pm_remove;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        aac2020_ginawin_Halt("[Exp:Pos|Or|Zero]");
    };;

    BOOL_i32_4B ret =(
    FP->USER32.PeekMessageW(
    /**/dont_prefix_message_with_and_symbol
    ,   NULL
    ,   0
    ,   0
    ,   look_or_take
    ));;

    return( ret );

} //[aac2020_ginawin_TakeOrLookMessage]//
BOOL_i32_4B
aac2020_ginawin_LookMessage(
    AAC2020_GINAWIN_LPMSG msg /** PointerToMessageStruct **/
){
    BOOL_i32_4B ret;
    const int look = 0;
    ret=aac2020_ginawin_TakeOrLookMessage(msg,look);
    return( ret );
} //[aac2020_ginawin_LookMessage]//
BOOL_i32_4B
aac2020_ginawin_TakeMessage(
    AAC2020_GINAWIN_LPMSG msg /** PointerToMessageStruct **/
){
    BOOL_i32_4B ret;
    const int take = 1;
    ret=aac2020_ginawin_TakeOrLookMessage(msg,take);
    return( ret );
} //[aac2020_ginawin_TakeMessage]//

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

//:window_code.TICK_PRIVATE:=================================://
#define INFO aac2020_ginawin_Info
#define I32  int32_t /** GCC: <stdint.h> **/

    int 
    aac2020_ginawin_WindowTick_private(
        
        /** Get this using a member variable  **/
        /** v_HWND       Hw  : HandleToWindow **/

        MSG_48B*  ptr_M  /** MessageStructPassedByPointer **/
    ){
        v_HWND Hw = ( AAC2020_GINAWIN.PW.W32.handle_to_window );

        #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 ) //:##########://
        #define H aac2020_ginawin_Halt

            if( ((void*)0) ==    Hw ){ H("[BAD_HAN_WIN]"); };
            if( ((void*)0) == ptr_M ){ H("[BAD_MSG_OBJ]"); };

        #undef  H
        #endif //:###########################################://

        /** kel_cal: keep_looping.THE_CALLER **/
        int kel_cal = ( 0 - 48221 ); //:ReturnThisFlag

        /** WindowTick function added DATE[ 2020_10_27 ]     **/
        /** To add SINGLE THREADING support for this window  **/
        /** class.                                           **/

        //:GET:U32F:-----------------------------------------://

            struct aac2020_ginawin_functions_USER32*
            U32F = &(
                aac2020_ginawin_function_pointers
               .USER32
            );;

            struct aac2020_ginawin_data_USER32* 
            U32DATA = &( U32F -> DATA);

            #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 ) //:######://    
            #define H aac2020_ginawin_Halt

                if( ((void*)0) == U32F    ){ H("[NO:U32F]"); };
                if( ((void*)0) == U32DATA ){ H("[NO:DATA]"); };

            #undef  H
            #endif //:#######################################://

        //:-----------------------------------------:GET:U32F://

        { //:SCOPE::::::::::::::::::::::::::::::::::::::SCOPE://
        #define H aac2020_ginawin_Halt
        #define V ((void*)0) 

            //:#_SETFOCUS_FAILS_IF_DIALOG_IS_OPEN_#://
            //:#_SETFOCUS_DOES_NOT_PUT_WINDOW_TOP_#://
            
            int  sw_show = U32DATA -> sw_show;
            int       SW = U32F ->  ShowWindow(  Hw,sw_show); 
            int       UW = U32F ->  UpdateWindow(Hw        ); 
            void*     SF = U32F ->  SetFocus(    Hw        );  

            if( 0  == SW ){ /** NOT AN ERROR **/ };
            if( 0  != SW ){ /** NOT AN ERROR **/ };
                
            if( 0  == UW ){ H("[UpdateWindow:FAIL]"); };
    ////    if( V  == SF ){ H("[SetFocus:::::FAIL]"); };
            if(       SF ){ /** NOOP **/ };

            #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 ) //:######://
             if( AAC2020_SILENCE.GINAWIN     <= 0 ){

                    static int counter = 0; counter++;
                    if( counter % 1024 == 0 ){
                        INFO("[SHOWING_WINDOW]");  
                    };;

            };;
            #endif //:#######################################://

        #undef  H
        #undef  V
        } //:SCOPE::::::::::::::::::::::::::::::::::::::SCOPE://

        UINT_u32_4B          wm_quit     ;                
        wm_quit = U32DATA -> wm_quit     ;

        
        //:     aac2020_ginawin_LookMessage(    &M );
                aac2020_ginawin_LookMessage( ptr_M );


        //:WAS_MESSAGE_WHILE_LOOP_BEFORE_REFACTOR:-----------://

        #if( AAC2020_CRASH_ON_VITAL_TODO >= 1 ) //:##########://

            #error : Maybe_Remove_This_I_Did_My_Best

            I tried to fix the code here... And we got some
            results with "nom > 1" showing in the printf
            statements. But I must be doing something else
            wrong somewhere else in window code.

        #endif //:###########################################://

            //:IS_QUIT_MESSAGE:NO:---------------------------://
            if( wm_quit != (*ptr_M).message ){
                
                //:While loop should be around this to empty
                //:the queue.
                I32 miv=( 0 ); /** miv:Message_Is_Available **/
                I32 nom=( 0 ); /** Number_Of_Messages **/

                //:DO_WHILE:---------------------------------://
                do{
                #define  TAKE  aac2020_ginawin_TakeMessage
                #define  TRAN  U32F -> TranslateMessage
                #define  DISP  U32F -> DispatchMessageW

                    //:#_GINAWIN_DOLOOP_ISNOTTHE_FINALFIX_#://

                        miv=( TAKE( ptr_M  ) );
                    if( miv >= 1             ){                        
                        TRAN(       ptr_M  )  ;
                        DISP(       ptr_M  )  ;
                        nom++                 ;
                    };;;;;;;;;;;;;;;;;;;;;;;;;;

                    /** Confirm this do-loop is necessary. **/
                    if( nom >1 && AAC2020_SILENCE.GINAWIN<= 0 ){

                        AAC2020_GINAWIN_Info_dec(
                        "[GINAWIN:nom]:%d\n", nom );

                    };;

                #undef   TAKE
                #undef   TRAN
                #undef   DISP
                }while( miv >= 1 );
                //:---------------------------------:DO_WHILE://

                #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
                 if( AAC2020_SILENCE.GINAWIN     <= 0 ){

                    static int counter=( 0 );
                    counter++;
                    if( counter % ( 512*256 ) == 0 ){
                        INFO("INSIDE_MESSAGE_LOOP\n");
                    };;
                
                };;
                #endif

                kel_cal = ( 1 );
            };;
            //:---------------------------:IS_QUIT_MESSAGE:NO://
            //:IS_QUIT_MESSAGE:YES:--------------------------://
            if( wm_quit == (*ptr_M).message ){
                kel_cal = ( 0 );

                #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
                 if( AAC2020_SILENCE.GINAWIN     <= 0 ){

                    /**  WTF:WindowTickFunction **/
                    /**  KLZ: KeepLoopingZero   **/

                    INFO("[DEBUG#1:WTP_KLZ]\n"); 
                    
                };;
                #endif
            };;
            //:--------------------------:IS_QUIT_MESSAGE:YES://

        //:-----------:WAS_MESSAGE_WHILE_LOOP_BEFORE_REFACTOR://

        return( kel_cal  /** keep_looping.THE_CALLER **/ );

    } //:[aac2020_ginawin_WindowTick_private]://

#undef I32
#undef INFO
//:=================================:window_code.TICK_PRIVATE://
//:window_code.WINDOW_LOOP:==================================://
#define HALT aac2020_ginawin_Halt

    MSG_48B
    aac2020_ginawin_WindowLoop(
       /**  v_HWND Hw **/
    ){

        //##_DONT_LET_WINDOW_CODE_MAKE_OPENGL_CALLS_##//

        v_HWND  Hw = AAC2020_GINAWIN.PW.W32.handle_to_window;
        if( ((void*)0)==Hw ){ HALT("[454PM.F]");};

        MSG_48B M; /** Message Object. 48 Bytes In Size **/

        //:SPINLOCK:-----------------------------------------://
        while( 1 == aac2020_ginawin_WindowTick_private( 
            /** Hw : Gotten from member variable **/
                &M 
        ) ){

            //:#_DONT_CALL_FUNCTION_POINTER_IN_SPINLOCK_#://

        };; //:-------------------------------------:SPINLOCK://

        AAC2020_GINAWIN
        .window_just_closed = ('t'|'r'|'u'|'e');

        //# [HACK]:Sleep a bit so other threads    #//
        //#        see "window_just_closed" update.#//
        //# You really should use a proper mutex.  #//
        /** Sleep(64); TODO: Uncomment when you find the  **/
        /**                  .DLL file with "Sleep" in it **/
        /**                   because I am NOT including  **/
        /**                   windows.h                   **/

        return( M );
    }  

#undef HALT
//:==================================:window_code.WINDOW_LOOP://
//:window_code.MAKE_GL_COMPATIBLE:===========================://
#define OKAY aac2020_ginawin_Okay
#define HALT aac2020_ginawin_Halt

    void
    aac2020_ginawin_MakeWindowCompatibleWith_GL(
        v_HWND  Hw
    ){

        /** con_win: ContextWindow / window_device_context **/

        aac2020_ginawin_FUNCTION_POINTERS_struct*
        FP = &(aac2020_ginawin_function_pointers);

        struct aac2020_ginawin_PW_WINDOWS*
        W32 = &( AAC2020_GINAWIN.PW.W32 );

        void* /** HDC **/
        con_win =( FP->USER32.GetWindowDC( Hw ) );;

        int
        pixel_format_number=(
            FP->GDI32.ChoosePixelFormat(
                con_win
            , &( W32 -> pixel_format_descriptor )
            )
        );;
        
        int /** BOOL **/
        setting_pixel_format_worked=(
        FP->GDI32.SetPixelFormat(
        /**/  con_win
        ,     pixel_format_number
        ,   &( W32 -> pixel_format_descriptor )
        ));;

        if( setting_pixel_format_worked ){
            OKAY("[SPF:GOOD:2020_12_09]\n");
        }else{
            HALT("[SPF:FAIL:2020_12_09]\n");
        };;

        AAC2020_GINAWIN.PW.W32.window_device_context=(
                    con_win /**window_device_context**/ );;

    }  

#undef OKAY
#undef HALT
//:===========================:window_code.MAKE_GL_COMPATIBLE://
//:window_code.OPEN_WINDOW:==================================://
#define HALT aac2020_ginawin_Halt
#define LERT aac2020_ginawin_Alert

    void* /** Returns Handle To Window **/ 
    aac2020_ginawin_OPEN_WINDOW(

        c_LPCWSTR_b16_2B 
        unique_window_name

    )
    {

        #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
         if( AAC2020_SILENCE.GINAWIN     <= 0 ){

            //:OWIN:OPEN_WINDOW
            wprintf( L"[OWIN:unique_window_name]%s\n" 
                      , unique_window_name );;
            
        };;
        #endif

        //:DECLARE_VARIABLES:--------------------------------://
        #define V_P ((void*)0)
        #define FUN aac2020_ginawin_FUNCTION_POINTERS_struct
        #define DAT struct aac2020_ginawin_data_USER32

            int ok=( 1 ); //@STP_VAR@//

            FUN*              FP =( V_P );
            v_HMODULE        hin =( V_P );
            DAT*         U32DATA =( V_P );
            v_HWND            Hw =( V_P );
        //: MSG_48B          Msg =( V_P );

            int X   =( 0 - 8732 );
            int Y   =( 0 - 8732 );
            int WID =( 0 - 8732 );
            int HIG =( 0 - 8732 );

        #undef V_P
        #undef FUN
        #undef DAT
        //:--------------------------------:DECLARE_VARIABLES://
        if( ok > 0 ){ //:------------------------------------://

            FP = &(aac2020_ginawin_function_pointers);

            //:hin: AKA[ handle_to_instance / handle_to_exe ]
            hin=( FP -> KERNEL32.GetModuleHandleW(
                                                ((void*)0)  ));;

            //: FTG_MODHAN: FailedToGetModuleHandle
            if(NULL==hin){ HALT( "[FTG_MODHAN]" );};

            //:FreeConsole();

            U32DATA = &( FP->USER32.DATA);

        };; //:-----------------------------------:( ok > 0 )://
        if( ok > 0 ){ //:------------------------------------://
            if(!

                aac2020_ginawin_RegisterWindow(
                    hin
                ,   unique_window_name
                )

            ){ 

                const char* 
                err_msg=( "[FailedToRegisterWindow]" );;

                LERT( err_msg );
                HALT(  err_msg );

                ok=( 0 );
                /** return( (void*)0 ); #ONE_EXIT_POINT_NOW# **/

            };;

        };; //:-----------------------------------:( ok > 0 )://
        if( ok > 0 ){ //:------------------------------------://

            X   = AAC2020_GINAWIN.X   ;
            Y   = AAC2020_GINAWIN.Y   ;
            WID = AAC2020_GINAWIN.WID ;
            HIG = AAC2020_GINAWIN.HIG ;

            Hw=FP->USER32.CreateWindowExW(
                //: dwExStyle   (EXT-窓style)
            /**/ /** U32DATA -> ws_ex_topmost **/
                0x00000000L /** #_WINTOP_IS_ANNOYING_#**/

                //: lpClassName (窓class    )
            ,   unique_window_name    

                //: lpWindowName(窓titlebar )
            ,   L"[GLEB_TITLE_BAR](題圌)"       

                //: (窓style)
            ,   (
                    U32DATA -> ws_overlappedwindow  | 
                    U32DATA -> cs_owndc             |
                0)

                //: x,y,w,h
            ,   X,Y,WID,HIG       

                //: hWndParent(parent窓)
            ,   FP->USER32.GetDesktopWindow() 

                //: hMenu(HandleToMenu)
            ,   NULL        

                //: hInstance(柯to例)
            ,   hin                

                //: lpParam( ??? )
            ,   NULL               
            );;
            if( ((void*)0) == Hw ){
                HALT("[WindowCreateFail]");
                ok =( 0 );
                /** return( (void*)0 ); #ONE_EXIT_POINT_NOW# **/
            };;

        };; //:-----------------------------------:( ok > 0 )://
        if( ok > 0 ){ //:------------------------------------://

            //:Store the handle to window in global state:
            AAC2020_GINAWIN.PW.W32.handle_to_window=Hw;

            //:Modifications to make window opengl compatible:
            aac2020_ginawin_MakeWindowCompatibleWith_GL( Hw );

            //:#_SET_FLAG_AFTER_SETTING_DEVICE_CONTEXT_#://
            AAC2020_GINAWIN.window_created =( 1 );                             
 
        };; //:-----------------------------------:( ok > 0 )://

        //:Fail_Fast_If_Window_Is_Null:
        if( ((void*)0) == Hw ){ HALT("[ER1122]");};
        
        /** #ONE_EXIT_POINT_NOW# **/
        return( ok > 0 ? Hw : ((void*)0) );
    }

#undef  HALT
#undef  LERT
//:==================================:window_code.OPEN_WINDOW://
//:window_code.OPEN_WINDOW_LOOP_FOREVER:=====================://
#define NiL ((void*)0)   
#define HAL aac2020_ginawin_Halt   
#define WiN AAC2020_GINAWIN.PW.W32.handle_to_window  

    //@CALL_FROM_ANOTHER_THREAD@//

    WPARAM_u64_8B 
    aac2020_ginawin_OPEN_WINDOW_LOOP_FOREVER(
        //:UNICODE_STRING
        c_LPCWSTR_b16_2B 
        unique_window_name
    ){

        #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
         if( AAC2020_SILENCE.GINAWIN     <= 0 ){

            //:OWLF:OPEN_WINDOW_LOOP_FOREVER
            wprintf( L"[OWLF:unique_window_name]%s\n" 
                      , unique_window_name );;
         
        };;
        #endif

        void*   Hw  = ((void*)0); /** HandleToWindow **/
        MSG_48B Msg = {0};        /** MessageObject  **/

        Hw = aac2020_ginawin_OPEN_WINDOW( unique_window_name );
        if( NiL == Hw  ){ HAL("[NULLWIN:ONE:2020_10_30]"); };
        if( NiL == WiN ){ HAL("[NULLWIN:TWO:2020_10_30]"); };

        //:#_WHY_HW_COMMENTED_OUT_IN_CALL_BELOW_#://
        Msg = aac2020_ginawin_WindowLoop( /** Hw **/ );

        return Msg.wParam;
    } 

#undef  NiL   
#undef  HAL   
#undef  WiN   
//:=====================:window_code.OPEN_WINDOW_LOOP_FOREVER://
//:window_code.FORGOT_TO_INIT_WINDOW_SIZE:===================://

    void
    aac2020_ginawin_ForgotToInitWindowSize(){

        aac2020_ginawin_Alert(
            "[You_Forgot_To_Init_Window_Size]"
        );;

    }  

//:===================:window_code.FORGOT_TO_INIT_WINDOW_SIZE://
//:window_code.CHANGE_WINDOW_DIMS_IF_NOT_OKAY:===============://
#define INFO aac2020_ginawin_Info

    int
    aac2020_ginawin_ChangeWinDimsIfNotOkay(){

        /** Change window dimensions if they are NOT okay. **/

        struct_aac2020_ginawin_global_state*
        GS = &(AAC2020_GINAWIN);

        int window_size_changed = 0;

        if( 
            0 >= GS -> X   &&
            0 >= GS -> Y   &&
            0 >= GS -> WID &&
            0 >= GS -> HIG &&
        1){
            aac2020_ginawin_ForgotToInitWindowSize();

            GS -> X   =  0;
            GS -> Y   =  0;
            GS -> WID = 1024;
            GS -> HIG = 64;
            window_size_changed=1;
        }else
        if( 
            0 >= GS -> WID || 
            0 >= GS -> HIG ||
        0){

            INFO(
                "[XY Set, but window]\n"
                "[size not__________]\n"
            );;

            if( GS -> WID <= 0 ){
                INFO("[ForgotToSet:WID]\n");
                GS -> WID = 1024;
                window_size_changed=2;
            };; 
            if( GS -> HIG <= 0 ){
                INFO("[ForgotToSet:HIG]\n");
                GS -> HIG =  128;
                window_size_changed=3;
            };;
        };;

        return( window_size_changed );
    }  

#undef  INFO
//:===============:window_code.CHANGE_WINDOW_DIMS_IF_NOT_OKAY://

//:##############################################:WINDOW_CODE://
//:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
//:                                                          ://
//:                  W:WINDOW_CODE:(ABOVE)                   ://
//:                                                          ://
//:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://


void  aac2020_ginawin_FUNCTION_POINTERS_init( void ){

    aac2020_ginawin_FUNCTION_POINTERS_struct*
    FP=&(aac2020_ginawin_function_pointers);

    //:Load DLLS:
    //////////////////////////////////////////////

    FP->DLL.gdi32=aac2020_ginawin_LoadLibrary(
           "gdi32" );;

    FP->DLL.kernel32=aac2020_ginawin_LoadLibrary(
           "kernel32" );;

    FP->DLL.user32=aac2020_ginawin_LoadLibrary(
           "user32" );;

    //:Make sure you didn't accidentially swap
    //:any function pointer addresses:
    //|-  --  --  --  --  --  --  --  --  --  -|//
    A_D_A_N_Z_aac2020_ginawin_function_pointer
    A_D_A_N_Z=&( 
        aac2020_ginawin_AssertDifferentAndNonZero 
    );;

    A_D_A_N_Z( FP->DLL.gdi32,
               FP->DLL.kernel32  );;

    A_D_A_N_Z( FP->DLL.kernel32,
               FP->DLL.user32    );;

    A_D_A_N_Z( FP->DLL.user32,
               FP->DLL.gdi32     );;
    //|-  --  --  --  --  --  --  --  --  --  -|//

    //////////////////////////////////////////////

    //:Load FUNCTIONS from DLLS:
    //////////////////////////////////////////////

    aac2020_ginawin_pfn_GPA
    G=&(aac2020_ginawin_GPA);

    //:G: GDI32:
    //:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://
                                           //[G]//
    //:DATA:                               //[G]//
    FP->GDI32.DATA.BRUSH.BLACK = 4;        //[G]//
                                           //[G]//
    #define T(n) typedef aac2020_ginawin_pfn_ ## n
    T( ChoosePixelFormat ) G_01;           //[G]//
    T( GetStockObject    ) G_02;           //[G]//
    T( SetPixelFormat    ) G_03;           //[G]//
    T( SwapBuffers       ) G_04;           //[G]//
    #undef T                               //[G]//
                                           //[G]//
    FP->/**/GDI32                          //[G]//
        .ChoosePixelFormat=(G_01)(G(       //[G]//
        "ChoosePixelFormat" ,              //[G]//
    FP->DLL.gdi32 ));;                     //[G]//
                                           //[G]//
    FP->/**/GDI32                          //[G]//
        .GetStockObject   =(G_02)(G(       //[G]//
        "GetStockObject" ,                 //[G]//
    FP->DLL.gdi32 ));;                     //[G]//
                                           //[G]//
    FP->/**/GDI32                          //[G]//
        .SetPixelFormat   =(G_03)(G(       //[G]//
        "SetPixelFormat" ,                 //[G]//
    FP->DLL.gdi32 ));;                     //[G]//
                                           //[G]//
    FP->/**/GDI32                          //[G]//
        .SwapBuffers      =(G_04)(G(       //[G]//
        "SwapBuffers" ,                    //[G]//
    FP->DLL.gdi32 ));;                     //[G]//
                                           //[G]//
    //:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://
    //:K: KERNEL32:
    //:KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK://


    struct aac2020_ginawin_data_KERNEL32*
    K32D = &(         
        FP->KERNEL32.DATA 
    );;
              
    K32D -> heap_zero_memory = 0x00000008;
    K32D -> wait_failed      = 0xFFFFFFFF;
    K32D -> infinite         = 0xffffffff;

    #define T(n) typedef aac2020_ginawin_pfn_ ## n
    T( CloseHandle         ) K_01;       //[K32]//
    T( CreateThread        ) K_02;       //[K32]//
    T( HeapAlloc           ) K_03;       //[K32]//
    T( HeapFree            ) K_04;       //[K32]//
    T( GetModuleHandleW    ) K_05; 
    T( GetProcessHeap      ) K_06;       //[K32]//
    T( WaitForSingleObject ) K_07;       //[K32]//
    #undef T                             //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .CloseHandle        =(K_01)(G(   //[K32]//
        "CloseHandle" ,                  //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .CreateThread       =(K_02)(G(   //[K32]//
        "CreateThread" ,                 //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .HeapAlloc          =(K_03)(G(   //[K32]//
        "HeapAlloc" ,                    //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .HeapFree           =(K_04)(G(   //[K32]//
        "HeapFree" ,                     //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .GetModuleHandleW   =(K_05)(G(   //[K32]//
        "GetModuleHandleW" ,             //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//

    FP->/**/KERNEL32                     //[K32]//
        .GetProcessHeap     =(K_06)(G(   //[K32]//
        "GetProcessHeap" ,               //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    FP->/**/KERNEL32                     //[K32]//
        .WaitForSingleObject=(K_07)(G(   //[K32]//
        "WaitForSingleObject" ,          //[K32]//
    FP->DLL.kernel32 ));;                //[K32]//
                                         //[K32]//
    //:U: USER32:                        //[K32]//
    //:UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU://
                                         //[U32]//
    struct aac2020_ginawin_data_USER32*        //[U32]//
    U32D = &(                            //[U32]//
        FP->USER32.DATA                  //[U32]//
    );;                                  //[U32]//
                                         //[U32]//
    U32D -> sw_show     = 5;             //[U32]//
                                         //[U32]//
    U32D -> wm_quit     = 0x0012;        //[U32]//
    U32D -> pm_noremove = 0x0000;        //[U32]//
    U32D -> pm_remove   = 0x0001;        //[U32]//
                                         //[U32]//
                                         //[U32]//
    U32D -> mb_iconexclamation =(        //[U32]//
                    0x00000030L          //[U32]//
    );;                                  //[U32]//
    U32D -> mb_ok =(                     //[U32]//
                    0x00000000L          //[U32]//
    );;                                  //[U32]//
                                         //[U32]//
    U32D -> cs_owndc    = 0x0020;        //[U32]//
                                         //[U32]//
    U32D -> ws_ex_topmost  = 0x00000008L;//[U32]//
                                         //[U32]//
    U32D -> ws_caption     = 0x00C00000L;//[U32]//
    U32D -> ws_maximizebox = 0x00010000L;//[U32]//
    U32D -> ws_minimizebox = 0x00020000L;//[U32]//
    U32D -> ws_overlapped  = 0x00000000L;//[U32]//
    U32D -> ws_sysmenu     = 0x00080000L;//[U32]//
    U32D -> ws_thickframe  = 0x00040000L;//[U32]//
                                         //[U32]//
    UINT_u32_4B                          //[U32]//
    same =(                              //[U32]//
        U32D -> ws_overlapped  |         //[U32]//
        U32D -> ws_caption     |         //[U32]//
        U32D -> ws_sysmenu     |         //[U32]//
        U32D -> ws_thickframe  |         //[U32]//
        U32D -> ws_minimizebox |         //[U32]//
        U32D -> ws_maximizebox |         //[U32]//
    0);;                                 //[U32]//
                                         //[U32]//
    //:Both are the same exact style:    //[U32]//
    U32D -> ws_overlappedwindow = same;  //[U32]//
    U32D -> ws_tiledwindow      = same;  //[U32]//
                                         //[U32]//
    U32D -> A.idi_application=(          //[U32]//
        //: [0111][1111][0000][0000]     //[U32]//
        AAC2020_GINAWIND_MakeIntResourceA( 32512 )        //[U32]//
    );;                                  //[U32]//
    U32D -> A.idc_arrow=(                //[U32]//
        //: [0111][1111][0000][0000]     //[U32]//
        AAC2020_GINAWIND_MakeIntResourceA( 32512 )        //[U32]//
    );;                                  //[U32]//
                                         //[U32]//
    //+----------------------------------------+//
    //|EXAMPLE_MACRO_USAGE:                 U32|//
    //|T( Update ) U_99;                    U32|//
    //|                                     U32|//
    //|AFTER_PRE_PROCESSING:                U32|//
    //|typedef aac2020_ginawin_pfn_Update U_99;   U32|//
    //+----------------------------------------+//
    #define T(n) typedef aac2020_ginawin_pfn_ ## n
    T( CreateWindowExW  )  U_01;         //[U32]//
    T( DefWindowProcW   )  U_02;         //[U32]//
    T( DestroyWindow    )  U_03;         //[U32]//
    T( DispatchMessageW )  U_04;         //[U32]//
    T( GetClientRect    )  U_05;         //[U32]//
    T( GetDesktopWindow )  U_06;         //[U32]//
    T( GetWindowDC      )  U_07;         //[U32]//
    T( LoadCursorA      )  U_08;         //[U32]//
    T( LoadIconA        )  U_09;         //[U32]//
    T( MessageBoxW      )  U_10;         //[U32]//
    T( PeekMessageW     )  U_11;         //[U32]//
    T( PostQuitMessage  )  U_12;         //[U32]//
    T( RegisterClassExW )  U_13;         //[U32]//
    T( SetFocus         )  U_14;         //[U32]//
    T( ShowWindow       )  U_15;         //[U32]//
    T( TranslateMessage )  U_16;         //[U32]//
    T( UpdateWindow     )  U_17;         //[U32]//
    #undef T                             //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .CreateWindowExW   =(U_01)(G(    //[U32]//
        "CreateWindowExW" ,              //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .DefWindowProcW    =(U_02)(G(    //[U32]//
        "DefWindowProcW" ,               //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .DestroyWindow     =(U_03)(G(    //[U32]//
        "DestroyWindow" ,                //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .DispatchMessageW  =(U_04)(G(    //[U32]//
        "DispatchMessageW",              //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .GetClientRect     =(U_05)(G(    //[U32]//
        "GetClientRect",                 //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .GetDesktopWindow  =(U_06)(G(    //[U32]//
        "GetDesktopWindow",              //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .GetWindowDC       =(U_07)(G(    //[U32]//
        "GetWindowDC",                   //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .LoadCursorA       =(U_08)(G(    //[U32]//
        "LoadCursorA" ,                  //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .LoadIconA         =(U_09)(G(    //[U32]//
        "LoadIconA" ,                    //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .MessageBoxW       =(U_10)(G(    //[U32]//
        "MessageBoxW" ,                  //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .PeekMessageW      =(U_11)(G(    //[U32]//
        "PeekMessageW" ,                 //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .PostQuitMessage   =(U_12)(G(    //[U32]//
        "PostQuitMessage" ,              //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .RegisterClassExW  =(U_13)(G(    //[U32]//
        "RegisterClassExW" ,             //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .SetFocus          =(U_14)(G(    //[U32]//
        "SetFocus" ,                     //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .ShowWindow        =(U_15)(G(    //[U32]//
        "ShowWindow" ,                   //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .TranslateMessage  =(U_16)(G(    //[U32]//
        "TranslateMessage",              //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //                                   //[U32]//
    FP->/**/USER32                       //[U32]//
        .UpdateWindow      =(U_17)(G(    //[U32]//
        "UpdateWindow" ,                 //[U32]//
    FP->DLL.user32 ));;                  //[U32]//
    //:UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU://
                                           //[P]//
    //[ [NICE_TO_HAVE]:                      [P]//
    //[ Every block should add function      [P]//
    //[ pointer to a temporary array then    [P]//
    //[ do simple n * n loop to make sure    [P]//
    //[ all addresses are unique. Also       [P]//
    //[ check for non-null while at it.      [P]//
                                           //[P]//
} //[aac2020_ginawin_FUNCTION_POINTERS_init]//   //[P]//

//| Section:MULTI_THREADING_CODE:beg __________|//
//|MCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMC|//
          
//:PRINT_CUSTOM_THREAD_DATA:=================================://                                 
    void                                       
    aac2020_ginawin_PrintCustomThreadData(     
                                               
        v_HINSTANCE custom_data                
                                               
    ){                                                                               
        struct_aac2020_ginawin_global_state*   
        GS = &(AAC2020_GINAWIN);        
                
        if( AAC2020_SILENCE.GINAWIN <= 0 ){
            //!Both will print the same thing:!//    
            /////////////////////////////////////  
            printf(                            //               
                "[AAC2020_GINAWIN:PARAMS]:( %d, %d )\n"          
            ,   ((aac2020_ginawin_PMYDATA)                      
                GS->PW.W32.custom_data)->val1  //               
                                               //               
            ,   ((aac2020_ginawin_PMYDATA)                      
                GS->PW.W32.custom_data)->val2  //               
            );                                 //               
                                               //               
            printf(                            //               
                "[AAC2020_GINAWIN:PARAMS]:( %d, %d )\n"          
            ,   ((aac2020_ginawin_PMYDATA)         
                custom_data)->val1             //  
                                               //  
            ,   ((aac2020_ginawin_PMYDATA)         
                custom_data)->val2             //  
            );                                 //  
            /////////////////////////////////////  
        };;                                    
    }  

//:=================================:PRINT_CUSTOM_THREAD_DATA://
                                           
DWORD_u32_4B 
__stdcall /** WINAPI calling convention **/                      
aac2020_ginawin_THREAD_FUNCTION(                //|MC|//
                                          //|MC|//
    v_HINSTANCE  custom_data              //|MC|//
                                          //|MC|//
){                                        //|MC|//
    aac2020_ginawin_PrintCustomThreadData(      //|MC|//
        custom_data                       //|MC|//
    );;                                   //|MC|//
                                          //|MC|//
    //!UNICODE_STRING                        MC!//
    c_LPCWSTR_b16_2B                      //|MC|//
    unique_window_name=(                  
        L"AAC2020_GINAWIN_UNIQUE_WINDOW_NAME"    
    );;                                  

    #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
     if( AAC2020_SILENCE.GINAWIN     <= 0 ){

        //:TFUN:THREAD_FUNCTION
        wprintf( L"[TFUN:unique_window_name]%s\n" 
                  , unique_window_name );;
        
    };;
    #endif


 
    aac2020_ginawin_OPEN_WINDOW_LOOP_FOREVER(   //|MC|//
        unique_window_name                //|MC|//
    );;                                   //|MC|//
                                          //|MC|//
    return 0;                             //|MC|//
} //[aac2020_ginawin_THREAD_FUNCTION]//          
        
//:ASSERT_THREAD_CREATED:====================================://
#define HALT aac2020_ginawin_Halt
                   
    void                                      
    aac2020_ginawin_AssertThreadCreated(){           
        struct_aac2020_ginawin_global_state*         
        GS = &(AAC2020_GINAWIN);        
                                               
        //!If thread NULL, creation failed: !//    
        if( NULL == GS->PW.W32.platform_window_thread  ){                                     
            HALT( "[GLEB:THREAD_CREATE_FAIL]\n" );                                                 
        };;                                    
    }     
      
#undef HALT
//:====================================:ASSERT_THREAD_CREATED://                                   
void                                      
aac2020_ginawin_CreateThread(){                 //|MC|//
                                          //|MC|//
    struct_aac2020_ginawin_global_state*        //|MC|//
    GS = &(AAC2020_GINAWIN);       //|MC|//
                                          //|MC|//
    aac2020_ginawin_FUNCTION_POINTERS_struct*   //|MC|//
    FP = &(aac2020_ginawin_function_pointers);  //|MC|//
                                          //|MC|//
    struct aac2020_ginawin_functions_KERNEL32*  //|MC|//
    K32F = &(FP -> KERNEL32);             //|MC|//
                                          //|MC|//
    if(NULL==K32F -> HeapAlloc){          //|MC|//
        aac2020_ginawin_NULFUN(                 //|MC|//
            "[HeapAlloc]"                 //|MC|//
        );;                               //|MC|//
    };;                                   //|MC|//
    if(NULL==K32F -> GetProcessHeap){     //|MC|//
        aac2020_ginawin_NULFUN(                 //|MC|//
            "[GetProcessHeap]"            //|MC|//
        );;                               //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
    v_HANDLE                              //|MC|//
    process_heap=(                        //|MC|//
        FP->KERNEL32.GetProcessHeap()     //|MC|//
    );;if(NULL==process_heap){            //|MC|//
        aac2020_ginawin_Halt("process_heap");   //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
    //!Allocate memory for thread data.      MC!//
    GS->PW.W32.custom_data =(             //|MC|//
        (aac2020_ginawin_PMYDATA)               //|MC|//
        FP->KERNEL32.HeapAlloc(           //|MC|//
                                          //|MC|//
            process_heap                  //|MC|//
                                          //|MC|//
        ,   FP->KERNEL32.DATA             //|MC|//
           .heap_zero_memory              //|MC|//
                                          //|MC|//
        ,   sizeof(aac2020_ginawin_MYDATA)      //|MC|//
                                          //|MC|//
        )                                 //|MC|//
    );                                    //|MC|//
                                          //|MC|//
    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯//|MC|//
    //! System if out of memory, you will    MC!//
    //! be unable to print error message.    MC!//
    //! But what about error code?           MC!//
    //|___________________________________//|MC|//
    if( GS->PW.W32.custom_data == NULL ){ //|MC|//
        exit( 9873 );                     //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
    //! Set Some Custom Data           !////|MC|//
    GS->PW.W32.custom_data->val1 = 333;   //|MC|//
    GS->PW.W32.custom_data->val2 = 777;   //|MC|//
                                          //|MC|//
    if(NULL==FP->KERNEL32.CreateThread){  //|MC|//
        aac2020_ginawin_NULFUN("CreateThread"); //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|////|MC|//
    //| Create the thread to begin     |////|MC|//
    //| execution on its own.          |////|MC|//
    //|________________________________|////|MC|//
    GS->PW.W32.platform_window_thread=(   //|MC|//
    FP->KERNEL32.CreateThread( //|¯¯¯¯¯|////|MC|//
    //+ default_security ------------_1+////|MC|//
    /**/NULL                      //[01]////|MC|//
                                  //|  |////|MC|//
    //+ default_stack_size ----------_2+////|MC|//
    ,   0                         //[02]////|MC|//
                                  //|  |////|MC|//
    //+ lpStartAddress --------------_3+////|MC|//
    ,   aac2020_ginawin_THREAD_FUNCTION //[03]////|MC|//
                                  //|  |////|MC|//
    //+ thread_func_arg -------------_4+////|MC|//
    ,   GS->PW.W32.custom_data    //[04]////|MC|//
                                  //|  |////|MC|//
    //+ use default creation flags---_5+////|MC|//
    ,   0                         //[05]////|MC|//
                                  //|  |////|MC|//
    //+ Output_Param ----------------_6+////|MC|//
    ,   &GS->PW.W32.thread_id     //[06]////|MC|//
    ));;//|____________________________|////|MC|//
                                          //|MC|//
} //[aac2020_ginawin_CreateThread]//            //|MC|//
                                          //|MC|//
//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ MC|//
//! If the user of this library improperly   MC!//
//! set the window size (or forgot)          MC!//
//! before calling the intialize function,   MC!//
//! we will warn the user with an alert      MC!//
//! box and attempt to fix the problem.      MC!//
//|-  --  --  --  --  --  --  --  --  --  -- MC|//
void                                      //|MC|//
aac2020_ginawin_CorrectWindowIfNeeded(){        //|MC|//
                                          //|MC|//
    int r=0;                              //|MC|//
    r=aac2020_ginawin_ChangeWinDimsIfNotOkay(); //|MC|//
    r=aac2020_ginawin_ChangeWinDimsIfNotOkay(); //|MC|//
    if( 0 != r ){                         //|MC|//
        aac2020_ginawin_Halt(                   //|MC|//
            "[WindowDimFixFail]"          //|MC|//
        );;                               //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
} //[aac2020_ginawin_CorrectWindowIfNeeded]//   //|MC|//
                                          //|MC|//


//:HEAP_FREE_FAIL:===========================================://
#define HALT aac2020_ginawin_Halt
                        
    void                                       
    aac2020_ginawin_HeapFreeFail(){            
                                               
        HALT( "[GLEBSWIN:HeapFreeFail]\n" );;                                                                           
    }                                          

#undef  HALT  
//:===========================================:HEAP_FREE_FAIL://
                                               
//! af=="assert function"              !// 
void                                       
aac2020_ginawin_af_HeapFreeSuccess(             //|MC|//
    int was_heap_free_success             //|MC|//
){                                        //|MC|//
    if(0==was_heap_free_success){         //|MC|//
                                          //|MC|//
        aac2020_ginawin_HeapFreeFail();         //|MC|//
                                          //|MC|//
    }                                     //|MC|//
                                          //|MC|//
}                                         //|MC|//

//:FREE_CUSTOM_DATA_IF_EXISTS:===============================://
#define HALT aac2020_ginawin_Halt

    void                                       
    aac2020_ginawin_FreeCustomDataIfExists(){        
            
        //:FETCH_FUNCTION_POINTERS:--------------------------://

            struct_aac2020_ginawin_global_state*         
            GS = &(AAC2020_GINAWIN);        
                                                   
            if( NULL == GS->PW.W32.custom_data ){  
                return;                            
            };;                                    
                                                   
            aac2020_ginawin_FUNCTION_POINTERS_struct*    
            FP = &(aac2020_ginawin_function_pointers);   
                                                                                   
            if(NULL==FP->KERNEL32.HeapFree){       
                HALT("[ERROR:4gotFetch:HeapFree]\n" );                                                  
            };;         
                                
        //:--------------------------:FETCH_FUNCTION_POINTERS://
        //:#ABOUT_HEAP_FREE#:--------------------------------://

            BOOL_i32_4B                    
            was_heap_free_success;         
            was_heap_free_success=(        
            FP->KERNEL32.HeapFree(         
                                           
                    /** Heap where memory block **/  
                    /** you want to free lives. **/  
            /**/    FP->KERNEL32.GetProcessHeap()          
                                            
                    /** DWORD dwFlags: (heap free opts) **/
            ,       0                          
                                            
                    /** Pointer to memory block to free: **/         
            ,       GS->PW.W32.custom_data     
            ));;                           
                                          
            aac2020_ginawin_af_HeapFreeSuccess(  
                was_heap_free_success      
            );;                            
                                           
            /** Ensure address is NOT reused. **/
            GS->PW.W32.custom_data = NULL; 
                                      
        //:--------------------------------:#ABOUT_HEAP_FREE#://
                                              
        aac2020_ginawin_Okay("[CustomDataFreed]");    
                                              
    }  

#undef  HALT
//:===============================:FREE_CUSTOM_DATA_IF_EXISTS://
                                         
//! Close window thread and free       !////|MC|//
//! custom data                        !////|MC|//
void                                      //|MC|//
aac2020_ginawin_ShutWinThread_FreeData(){       //|MC|//
                                          //|MC|//
    struct_aac2020_ginawin_global_state*        //|MC|//
    GS = &(AAC2020_GINAWIN);       //|MC|//
                                          //|MC|//
    aac2020_ginawin_FUNCTION_POINTERS_struct*   //|MC|//
    FP = &(aac2020_ginawin_function_pointers);  //|MC|//
                                          //|MC|//
    //|-  --  --  --  --  --  --  --  --  -- MC|//
                                          //|MC|//
    //!Close all thread handles and    !////|MC|//
    //!free memory allocations.        !////|MC|//
    BOOL_i32_4B ok = 0;                   //|MC|//
                                          //|MC|//
    if(NULL==FP->KERNEL32.CloseHandle){   //|MC|//
        aac2020_ginawin_Halt(                   //|MC|//
            "[null:CloseHandle]"          //|MC|//
        );;                               //|MC|//
    };;                                   //|MC|//
    ok = FP->KERNEL32.CloseHandle(        //|MC|//
        GS->PW.W32.platform_window_thread //|MC|//
    );;if( 0 == ok ){                     //|MC|//
        aac2020_ginawin_Halt(                   //|MC|//
            "[CloseHandleFail]"           //|MC|//
        );;                               //|MC|//
    };;                                   //|MC|//
                                          //|MC|//
    aac2020_ginawin_FreeCustomDataIfExists();   //|MC|//
                                          //|MC|//
} //[function]//                          //|MC|//
                                          //|MC|//
                                          //|MC|//
//!fe: "function exists"               !////|MC|//
void                                      //|MC|//
aac2020_ginawin_fe_WaitForSingleObject(){       //|MC|//
                                          //|MC|//
    aac2020_ginawin_FUNCTION_POINTERS_struct*   //|MC|//
    FP = &(aac2020_ginawin_function_pointers);  //|MC|//
                                          //|MC|//
    if(                                   //|MC|//
        NULL                              //|MC|//
        ==                                //|MC|//
        FP->KERNEL32                      //|MC|//
        .WaitForSingleObject              //|MC|//
    ){                                    //|MC|//
        aac2020_ginawin_Halt("[Null:WFSO:PTR]");//|MC|//
    };;                                   //|MC|//
                                          //|MC|//
} //[aac2020_ginawin_fe_WaitForSingleObject]//  //|MC|//
      
//:WAIT_UNTIL_WINDOWS_CLOSED:================================://
#define INFO aac2020_ginawin_Info
#define HALT aac2020_ginawin_Halt
#define OKAY aac2020_ginawin_Okay
                         
    void                                       
    aac2020_ginawin_WaitUntilWindowClosed(){   
                                              
        struct_aac2020_ginawin_global_state*        
        GS = &(AAC2020_GINAWIN);        
                                        
        aac2020_ginawin_FUNCTION_POINTERS_struct*    
        FP = &(aac2020_ginawin_function_pointers);   
                                               
        aac2020_ginawin_fe_WaitForSingleObject();    
                                               
        //!Wait until all threads !//        
        //!have terminated.       !//        
        struct aac2020_ginawin_data_KERNEL32*       
        K32D = &( FP->KERNEL32.DATA );;                                    
                                               
        DWORD_u32_4B dont_fail_me=(            
        FP->KERNEL32.WaitForSingleObject(      
        /**/GS->PW.W32.platform_window_thread  
        ,       K32D -> infinite               
        ));;  
                                 
        if( K32D -> wait_failed  ==  dont_fail_me                       
        ){                                                                   
            /** Should this HALT instead of be INFO ? **/
            INFO( "[ThreadedWindowWaitFail]" );                                                             
        }else{                                                                  
            OKAY( "[ThreadedWindowClosed]" );                                                                
        };;                                    
                                               
    }     

#undef  INFO
#undef  HALT 
#undef  OKAY
//:================================:WAIT_UNTIL_WINDOWS_CLOSED://                                    
                                           
//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
//! A blocking call that loops forever.      MC!//
//! Put it outside of your main loop to      MC!//
//! make sure program does not exit until    MC!//
//! window is closed.                        MC!//
//!                                          MC!//
//! Do NOT put before main loop in code.     MC!//
//!                                          MC!//
//! Wait on:                                 MC!//
//! SWIN(SilkWindow/ThreadedWindow)          MC!//
//|-  --  --  --  --  --  --  --  --  --  --  -|//
void AAC2020_GINAWIN_Wait(){                 
  //:AAC2020_GINAWIN_WaitForUserToCloseWindow

    if( AAC2020_GINAWIN.type_of_threading
    ==  AAC2020_GINAWIN_SINGLE_THREADED
    ){
        aac2020_ginawin_Halt(
            "[WAIT_IS_ONLY_FOR_MULTI_THREADING]"
        );;

    }else
    if( AAC2020_GINAWIN.type_of_threading   
    == AAC2020_GINAWIN__MULTI_THREADED
    ){
        aac2020_ginawin_Okay(
            "[OK:About_To_Wait_In_MultiThreaded_Mode]"
        );;
                                          
        aac2020_ginawin_WaitUntilWindowClosed();     
        aac2020_ginawin_ShutWinThread_FreeData();    

    }else{
        aac2020_ginawin_Halt("[WTF_2020_10_28:1241AM]");
    };;
                                          
} //[AAC2020_GINAWIN_Wait]//             
     
//|MCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMC|//
//| Section:MULTI_THREADING_CODE:end ¯¯¯¯¯¯¯¯¯¯|//



void
aac2020_ginawin_WaitHereUntilWindowExists(){

    struct_aac2020_ginawin_global_state*
    GS = &(AAC2020_GINAWIN);

    int hackish_timer = 0;
    while( GS -> window_created <= 0 ){

        hackish_timer++;
        if( hackish_timer > 1024*1024*32 ){
            aac2020_ginawin_Okay(
                "[Waiting_On_Window_Creation]"
            );;
            fflush( stdout );
            hackish_timer = 0;
        };; 
    };;

    if( ((void*)0) == AAC2020_GINAWIN.PW.W32.handle_to_window ){
        aac2020_ginawin_Halt("[YOUSAYYOUEXISTBUTYOUDONT]");
    };;

    aac2020_ginawin_Okay(
        "[DONE_WAITING_ON_WINDOW_CREATION]"
    );;fflush(stdout);

} //[aac2020_ginawin_WaitHereUntilWindowExists]//


//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
//| Added: DATE[2019_06_14]                    |//
//| Currently trying to get triangle to        |//
//| show up on screen in GA.H of GAKU.H        |//
//| project. Think problem is:                 |//
//| 1. A threading problem.                    |//
//| 2. Screwed up opengl drawing code.         |//
void*                                       //||//
AAC2020_GINAWIN_GetWinDC_ExistsNoWait(){          //||//
    if(                                     //||//
        NULL==AAC2020_GINAWIN.PW.W32 //||//
        .window_device_context              //||//
    ){                                      //||//
        aac2020_ginawin_Halt(                     //||//
            "[FAIL:GetWinDC_ExistsNoWait]"  //||//
        );;                                 //||//
    };;                                     //||//
    return( AAC2020_GINAWIN.PW.W32   //||//
            .window_device_context );       //||//
} //[AAC2020_GINAWIN_GetWinDC_ExistsNoWait]//     //||//
//|____________________________________________|//

//:Returns a (void*) instead of an HDC because:
//: 1. Want to get rid of windows.h eventually.
//: 2. Want to make sure that if this library
//:    is in a project that uses windows.h,
//:    it can still compile.
void*
AAC2020_GINAWIN_GetWinDC(){
    struct_aac2020_ginawin_global_state*
    GS = &(AAC2020_GINAWIN);
    

    //:If you forget to initialize,
    //:then the waiting on window creation
    //:loop will execute forever because
    //:no window creation is happening
    //:on a different thread.
    if( 0 == GS -> init_called ){
        aac2020_ginawin_Halt(
            "[YouForgot:AAC2020_GINAWIN_Init()!]"
        );;
    };;

    //:GAURDED_WAIT_FOR_WINDOW:------------------------------://

        //: WaitHereUntilWindowExists() enforces a wait      ://
        //: every time it is called. Because single threaded ://
        //: mode calls GetWinDC() every frame, we need       ://
        //: this gaurd to protect framerate performance.     ://
        if( AAC2020_GINAWIN.window_created <= 0 ){

            aac2020_ginawin_WaitHereUntilWindowExists();

        };;
    //:------------------------------:GAURDED_WAIT_FOR_WINDOW://

    if( 0 == GS -> PW.W32.window_device_context ){
        aac2020_ginawin_Halt(
            "[WindowWaitMechanismFailed]"
        );;
    };;


    void* /** HCD **/ ret = GS -> PW.W32.window_device_context;
    return(    (void*)ret );
    
} //[AAC2020_GINAWIN_GetWindowDeviceContext]//

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

    int 
    AAC2020_GINAWIN_WindowTick( 
        int
            aac2020_ginawin_single_threaded 
    ){
        //# THIS FUNCTION FOR SINGLE THREADED WINDOW ONLY. #//

        /** kel_cal: keep_looping.THE_CALLER **/
        int kel_cal = ( 0 - 3823 ); /** ReturnThisValue **/

        //:#_ginawin_assert_single_threaded_mode_#:----------://
        #define H aac2020_ginawin_Halt

            if( aac2020_ginawin_single_threaded
            !=  AAC2020_GINAWIN_SINGLE_THREADED
            ){
                H("[SINGLE_THREADED_ONLY]");
            };;
            if( AAC2020_GINAWIN.type_of_threading
            !=  AAC2020_GINAWIN_SINGLE_THREADED  
            ){
                H("[INTENTIONS_PURE_BUT_ARE_MULTI_THREADING]" );
            };;
        
        #undef  H
        //:------------:_ginawin_assert_single_threaded_mode_://
        //:#__END_OF_GINAWIN_BUGHUNT_001__#------------------://
        #if( AAC2020_GINAWIN_BUGHUNT_001 >= 1 )
        #define H       aac2020_ginawin_Halt
        #define HAN_WIN AAC2020_GINAWIN.PW.W32.handle_to_window

            //:Dont_Silence:BUGHUNT_001:sections
            //:That are throwing errors.

            void* con_win = AAC2020_GINAWIN_GetWinDC();
            if( ((void*)0)== HAN_WIN ){ H("[2020_10_30:E1]"); }; 
            if( con_win   == HAN_WIN ){ H("[2020_10_30:E2]"); }; 
            
        #undef H
        #undef HAN_WIN
        #endif
        //:------------------#__END_OF_GINAWIN_BUGHUNT_001__#://
        //:CALL_WRAPPED_FUNCTION:----------------------------://

            /**  I think we CANNOT make this object static.  **/
            MSG_48B msg_48b = {0}; //:<--Expecting clean slate?

            kel_cal=(
                aac2020_ginawin_WindowTick_private( 
                    /** han_win : Get using member variable **/
                    &msg_48b 
                )
            );;

            return( kel_cal /** keep_looping.THE_CALLER **/ );

        //:----------------------------:CALL_WRAPPED_FUNCTION://
    }

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://


//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
//|We will use this for testing if game loop should still be |//
//|running. Do NOT create a function called "IsWindowOpen".  |//
//|We need to be more pedantic than that.                    |//
//|                                                          |//
//| The "still" is an implication that:                      |//
//|     1. A window was opened previously.                   |//
//|     2. Maybe we are trying to close window?              |//
//| - - - - - - - - - - - - - ---- - - - - - - - - - - - - - |//
int                                             //|STILL_OPEN|//
AAC2020_GINAWIN_IsWindowStillOpen( void ){      //|STILL_OPEN|//
             //:IsWindowStillOpen://            //|STILL_OPEN|//
                                                //|STILL_OPEN|//
    int is_window_still_open = (0-666);         //|STILL_OPEN|//
                                                //|STILL_OPEN|//
    if( AAC2020_GINAWIN.window_created <= 0 ){  //|STILL_OPEN|//                                   
        aac2020_ginawin_Halt(                   //|STILL_OPEN|//
            "[ObjectionYourHonor________]\n"    //|STILL_OPEN|//
            "[TheStatementAssumesAWindow]\n"    //|STILL_OPEN|//
            "[WasOpenToBeginWith________]\n"    //|STILL_OPEN|//
        );;                                     //|STILL_OPEN|//
    };;                                         //|STILL_OPEN|//
                                                //|STILL_OPEN|//
    if( AAC2020_GINAWIN.window_just_closed >0 ){//|STILL_OPEN|//                                      
        is_window_still_open = 0;               //|STILL_OPEN|//
    }else{                                      //|STILL_OPEN|//
        is_window_still_open = 1;               //|STILL_OPEN|//
    };;                                         //|STILL_OPEN|//
                                                //|STILL_OPEN|//
    //: Any_Value_Besides_Zero_Or_1_Not      :////|STILL_OPEN|//
    //: Allowed____Narrowing_Acceptable      :////|STILL_OPEN|//
    //: Values_WillPrevent_Errors_In_Code.   :////|STILL_OPEN|//
                                                //|STILL_OPEN|//
    if( 1                                       //|STILL_OPEN|//
    &&  is_window_still_open != 0               //|STILL_OPEN|//
    &&  is_window_still_open != 1               //|STILL_OPEN|//
    ){                                          //|STILL_OPEN|//
        aac2020_ginawin_Halt(                   //|STILL_OPEN|//
            "[Exp:(1|0):IWSO]"                  //|STILL_OPEN|//
        );;                                     //|STILL_OPEN|//
    };;                                         //|STILL_OPEN|//
                                                //|STILL_OPEN|//
    return( is_window_still_open );             //|STILL_OPEN|//
                                                //|STILL_OPEN|//
}                                               //|STILL_OPEN|//
//|__________________________________________________________|//

int
AAC2020_GINAWIN_GetClient_X(){

    struct AAC2020_GINAWIN_RECT r; //:TempRect
    v_HWND handle_to_window=(
           AAC2020_GINAWIN.PW.W32.handle_to_window
    );;

    aac2020_ginawin_function_pointers
    .USER32
    .GetClientRect(
    /**/   handle_to_window
    ,    &(r)
    );;

    int X = r.lef; /** r.left **/
    return( X );
}
int
AAC2020_GINAWIN_GetClient_Y(){
    struct AAC2020_GINAWIN_RECT r; //:TempRect
    v_HWND handle_to_window=(
           AAC2020_GINAWIN.PW.W32.handle_to_window
    );;

    aac2020_ginawin_function_pointers
    .USER32
    .GetClientRect(
    /**/   handle_to_window
    ,    &(r)
    );;

    int Y = r.top; /** r.top **/
    return( Y );
}
int
AAC2020_GINAWIN_GetClient_WID(){
    struct AAC2020_GINAWIN_RECT r; //:TempRect
    v_HWND handle_to_window=(
           AAC2020_GINAWIN.PW.W32.handle_to_window
    );;

    aac2020_ginawin_function_pointers
    .USER32
    .GetClientRect(
    /**/   handle_to_window
    ,    &(r)
    );;

    //:No need for +1 because right exclusive.
//: int WID = ( r.right - r.left ) + 0;
    int WID = ( r.rig   - r.lef  ) + 0;
    return( WID );
}
int
AAC2020_GINAWIN_GetClient_HIG(){
    struct AAC2020_GINAWIN_RECT r; //:TempRect
    v_HWND handle_to_window=(
           AAC2020_GINAWIN.PW.W32.handle_to_window
    );;

    aac2020_ginawin_function_pointers
    .USER32
    .GetClientRect(
    /**/   handle_to_window
    ,    &(r)
    );;

    //:No need for +1 because bottom exclusive.
//: int HIG =( r.bottom - r.top ) + 0;
    int HIG =( r.bot    - r.top ) + 0;
    return( HIG );
}


void
AAC2020_GINAWIN_SwapBuffers( void ){

    if(NULL==AAC2020_GINAWIN.PW.W32
    .window_device_context){

        aac2020_ginawin_Halt(
            "[CantSwapBuffersWithNullDevice]"
        );;

    };;

    aac2020_ginawin_function_pointers
    .GDI32.SwapBuffers(
        AAC2020_GINAWIN.PW.W32
        .window_device_context
    );;

}


//! Its not just enough to create a window,  GS!//
//! the window must have the proper pixel    GS!//
//! format descriptor associated with it's   GS!//
//! device context for open gl to work.      GS!//
//!                                          GS!//
//!  YOU ONLY GET ONE SHOT!                  GS!//
//!  YOU CAN ONLY SET IT ONCE!               GS!//
//!                                          GS!//
//!  https://www.khronos.org/opengl/wiki     GS!//
//!  /Creating_an_OpenGL_Context_(WGL)       GS!//
void                                      //|GS|//
aac2020_ginawin_InitPixelFormatDescriptor(      //|GS|//
    void                                  //|GS|//
){                                        //|GS|//
                                           
    struct
    AAC2020_GINAWIN_PIXELFORMATDESCRIPTOR                  
    pixel_format_descriptor ={            //|GS|//
        sizeof( 
            struct 
            AAC2020_GINAWIN_PIXELFORMATDESCRIPTOR 
        )
        ,
        1,                                //|GS|//
                                          //|GS|//
        (   //! Flags________!//          //|GS|//
        0
        |   0x00000004 /** PFD_DRAW_TO_WINDOW:wingdi.h **/           
        |   0x00000020 /** PFD_SUPPORT_OPENGL          **/           
        |   0x00000001 /** PFD_DOUBLEBUFFER:wingdi.h   **/  
        |
        0)                                //|GS|//
                                          //|GS|//
        ,                                 //|GS|//
                                          //|GS|//
        //! The kind of framebuffer.         GS!//
        //! RGBA or palette.                 GS!//
        0 /** PFD_TYPE_RGBA:wingdi.h **/
        ,
                                          //|GS|//
        //! Colordepth of the framebuffer.   GS!//
        32,                               //|GS|//
                                          //|GS|//
        0, 0, 0, 0, 0, 0,                 //|GS|//
        0,                                //|GS|//
        0,                                //|GS|//
        0,                                //|GS|//
        0, 0, 0, 0,                       //|GS|//
                                          //|GS|//
        //! Number_Of_Bits: depthbuffer      GS!//
        24,                               //|GS|//
                                          //|GS|//
        //! Number_Of_Bits: stencilbuffer    GS!//
        8,                                //|GS|//
                                          //|GS|//
        //! Number of Aux buffers            GS!//
        //! in the framebuffer.              GS!//
        0,                                //|GS|//
                                          //|GS|//
        0 /** PFD_MAIN_PLANE **/,         //|GS|//
        0,                                //|GS|//
        0, 0, 0                           //|GS|//
    };;                                   //|GS|//
                                          //|GS|//
    //! Copy memory. For a brief moment We   GS!//
    //! are using double memory for the      GS!//
    //! pixel format descriptor,but easiest  GS!//
    //! way I can think of to get it         GS!//
    //! properly initialized and put into    GS!//
    //! global state container as            GS!//
    //! NON-Pointer.                         GS!//
    AAC2020_GINAWIN.PW.W32                      //|GS|//
    .pixel_format_descriptor=(            //|GS|//
        pixel_format_descriptor           //|GS|//
    );;                                   //|GS|//
                                          //|GS|//
} //[InitPixelFormatDescriptor]//         //|GS|//
                                          //|GS|//
void                                      //|GS|//
aac2020_ginawin_InitGlobalStateContainer(       //|GS|//
    void                                  //|GS|//
){                                        //|GS|//
    //+---------------------------+-++-+////|GS|//
    //+---------------------------+-++-+////|GS|//   
    //+ Convinience Methods to help    +////|GS|//
    //+ with formatting of code that   +////|GS|//
    //+ [[USES]] AAC2020_GINAWIN             +////|GS|//
    //+---------------------------+-++-+////|GS|//
    //+---------------------------+-++-+////|GS|//
    AAC2020_GINAWIN.GetClient.X   =&( //+ || +////|GS|//
    AAC2020_GINAWIN_GetClient_X);     //+ || +////|GS|//
                                //+ || +////|GS|//
    AAC2020_GINAWIN.GetClient.Y   =&( //+ || +////|GS|//
    AAC2020_GINAWIN_GetClient_Y);     //+ || +////|GS|//
                                //+ || +////|GS|//
    AAC2020_GINAWIN.GetClient.WID =&( //+ || +////|GS|//
    AAC2020_GINAWIN_GetClient_WID);   //+ || +////|GS|//
                                //+ || +////|GS|//
    AAC2020_GINAWIN.GetClient.HIG =&( //+ || +////|GS|//
    AAC2020_GINAWIN_GetClient_HIG);   //+ || +////|GS|//
    //+---------------------------+-++-+////|GS|//
    //+---------------------------+-++-+////|GS|//
                                          //|GS|//
    aac2020_ginawin_InitPixelFormatDescriptor();//|GS|//
                                          //|GS|//
} //[aac2020_ginawin_InitGlobalStateContainer]////|GS|//
                                          //|GS|//
//[GSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGSGS]//

//:GINAWIN_INIT:=============================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    void AAC2020_GINAWIN_Init(

        //: A:  AAC2020_GINAWIN_SINGLE_THREADED
        //: B:  AAC2020_GINAWIN__MULTI_THREADED
        //: int SINGLE_THREADED__or__MULTI_THREADED

        U32 is_multi_threaded
    ){   

        /**  Original initialization design forced you to    **/
        /**  set These values before calling the             **/
        /**  initializer,but I think we should do            **/
        /**  "convention over configuration"                 **/
        AAC2020_GINAWIN.X   = 22  ;
        AAC2020_GINAWIN.Y   = 22  ;
        AAC2020_GINAWIN.WID = 1024;
        AAC2020_GINAWIN.HIG = 512 ;
                
         
        //:DONE_IN_BOTH_THREADING_MODES:---------------------://

            AAC2020_GINAWIN.init_called = 1;

            aac2020_ginawin_InitGlobalStateContainer();  
                                                         
            aac2020_ginawin_AssertCorrectSizesOfTypes(); 
                                                         
            aac2020_ginawin_FUNCTION_POINTERS_init();    
                                                         
            aac2020_ginawin_CorrectWindowIfNeeded();     

        //:---------------------:DONE_IN_BOTH_THREADING_MODES://
        //:PICK_INIT_LOGIC_FOR_THREADING_TYPE:---------------://

            switch( is_multi_threaded ){
            case 1:{

                AAC2020_GINAWIN.type_of_threading=(
                    AAC2020_GINAWIN__MULTI_THREADED
                );;

                aac2020_ginawin_CreateThread();              
                aac2020_ginawin_AssertThreadCreated();      

            };break;
            case 0:{

                AAC2020_GINAWIN.type_of_threading=(
                    AAC2020_GINAWIN_SINGLE_THREADED
                );;

                /** Directly create window in this thread... **/
                /** apposed to :                             **/
                /** "aac2020_ginawin_CreateThread()"         **/
                c_LPCWSTR_b16_2B 
                unique_window_name=( 
                    //: L"SINGLE_THREADED_WINDOW" 
                        L"AAC2020_GINAWIN_UNIQUE_WINDOW_NAME"
                );;

                void* han_win=(
                aac2020_ginawin_OPEN_WINDOW( 
                    unique_window_name      ));;

                if( ((void*)0) == han_win ){
                    //:FTC_STW:
                    //:         FTC:FAILED_TO_CREATE
                    //:         STW:SINGLE_THREADED_WINDOW
                    aac2020_ginawin_Halt("[FTC_STW]");
                };;

                aac2020_ginawin_WaitHereUntilWindowExists();

            };break;
            default:{

                aac2020_ginawin_Halt("[BAD_THREADING_BOOL]");

            };;};;

        //:---------------:PICK_INIT_LOGIC_FOR_THREADING_TYPE://
        //:COMMON_TAIL_LOGIC:--------------------------------://

            AAC2020_GINAWIN.init_finished = 1;

        //:--------------------------------:COMMON_TAIL_LOGIC://
                                                     
    }   

#undef  U32
//:=============================================:GINAWIN_INIT://

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

    void*
    AAC2020_GINAWIN_GET_han_win(){
//: AAC2020_GINAWIN_GetHandleToWindow

        void* han_win = AAC2020_GINAWIN.PW.W32.handle_to_window;
        int   win_exi = AAC2020_GINAWIN.window_created;

        #define H aac2020_ginawin_Halt
        if(        1  != win_exi ){   H("[WIN_EXI]"); };
        if(((void*)0) == han_win ){   H("[HAN_WIN]"); };
        #undef  H

        return( han_win );
    }    

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://     
        
//:DEMO_FUNC:================================================://
                                             
    int 
    AAC2020_GINAWIN_Demo( void ){
        aac2020_ginawin_Info( "[BEG:GINAWIN_Demonstration]\n" );
        
        AAC2020_GINAWIN.X   = 22  ;
        AAC2020_GINAWIN.Y   = 22  ;
        AAC2020_GINAWIN.WID = 1024;
        AAC2020_GINAWIN.HIG = 512 ;


        //:This creates our window:
        AAC2020_GINAWIN_Init( AAC2020_GINAWIN__MULTI_THREADED );
       
        //:This gets our window's device
        //:context, which can be used to
        //:create OpenGL context.
        //:GL=="Graphics Library"
        AAC2020_GINAWIN_GetWinDC();

        int X   = AAC2020_GINAWIN_GetClient_X  ();
        int Y   = AAC2020_GINAWIN_GetClient_Y  ();
        int WID = AAC2020_GINAWIN_GetClient_WID();
        int HIG = AAC2020_GINAWIN_GetClient_HIG();

        if( AAC2020_SILENCE.GINAWIN <= 0 ){

            printf(
            /**/"[CLIENT_DIMS]\n"
            /**/" X  :%d\n"
            /**/" Y  :%d\n"
            /**/" WID:%d\n"
            /**/" HIG:%d\n"
            ,X,Y,WID,HIG
            );;

        };;

        //: Uncomment this line if you want
        //: to observe proof that the window's
        //: loop is off in another thread.
        //: while( 1 ){ };
       
        //:Put this after your game loop
        //:so that program does not exit
        //:until window is closed.
        AAC2020_GINAWIN_Wait();

        aac2020_ginawin_Info("[GINAWIN_Demonstration]\n");

        return 0;
    }  

//:================================================:DEMO_FUNC://