//:----------------------------------------------------------://
//:    GRAQUAD.F: GRAphics_QUAD.FUNCTIONS                    ://
//:    (Refactored from V:/TESAWIND/TESAWIND.H)              ://
//:                                                          ://
//:    Yes_The_Librarys_Job:                                 ://
//:                                                          ://
//:         #1: Setup QUAD and simple gradient shader.       ://
//:         #2: #1 was it!                                   ://
//:                                                          ://
//:    NOT_THE_LIBRARYS_JOB: #1: Advanced Shaders.           ://
//:    NOT_THE_LIBRARYS_JOB: #2: Atomic_Alice_2_Data_Structs ://
//:----------------------------------------------------------://
//:REFACTOR_NOTES:===========================================://
/** ******************************************************** ***

    GLEB_SWIN --> GINAWIN (Graphics_Init_And_WINdow)
    GLEB -------> GLEBIND (open_GL_Easy_BINDings   )

*** ******************************************************** **/
//:LIBRARY_CHAIN_INTEGRITY_CHECK:============================://

    //:GINAWIN: AAC2020_GINAWIN_*
    //:GLEBIND: AAC2020_GLEBIND_*

    #if( AAC2020_INCLUDE_GINAWIN <= 0 )
        #error "REQUIRE[GINAWIN--->GRAQUAD]"
    #endif
    #if( AAC2020_INCLUDE_GLEBIND <= 0 )
        #error "REQUIRE[GLEBEND--->GRAQUAD]"
    #endif

    #ifndef AAC2020_INCLUDE_GINAWIN 
        #error "GRAQUAD.SAYS[NOT_DEFINED_AND_REQUIRED:GINAWIN]"
    #endif
    #ifndef AAC2020_INCLUDE_GLEBIND 
        #error "GRAQUAD.SAYS[NOT_DEFINED_AND_REQUIRED:GLEBEND]"
    #endif

//:============================:LIBRARY_CHAIN_INTEGRITY_CHECK://
//:GRAQUAD_LIBRARY_MACROS:TOP:===============================://

    //:LALODEX:LAyout_LOcation_inDEX

    #define  MACRO_LALODEX_verpos ((0)) //:VERtex____POSition
    #define  MACRO_LALODEX_texcoo ((1)) //:TEXture_COOrdinate

    //: RTS: Resolve_Then_Stringify.
    //: Injects macro values into hardcoded source strings.

    #define macro_rts( s ) #s
    #define MACRO_RTS( s ) macro_rts( s )

    //:TD: TypeDef: For creating PFN types.
    //:RT: FuncTyp: For creating FUN types.

    #define TD(return_type) typedef return_type
    #define RT(return_type)         return_type

//:===============================:GRAQUAD_LIBRARY_MACROS:TOP://
//:MACROS:ROOT_LEVEL_OOP.TOP:================================://

    //:INCLUDE AFTER ANY CLASSES (If any)
    //: #include "00/OOP/ROOT_LEVEL_OOP.TOP._"
    
    #define                MACRO_GXY(x, y) x##y 
    #define RL_FuNaM(x, y) MACRO_GXY(x, y)
    #define      LIB_PFN  AAC2020_GRAQUAD_PFN_ //:  PFN
    #define      LIB_VIS  AAC2020_GRAQUAD_ //:PUBLIC/VISIBLE
    #define      lib_hid  aac2020_graquad_ //:PRIVATE/HIDDEN
    #define POM( n )   RL_FuNaM( LIB_PFN, n    )
    #define  PO( n ) (*RL_FuNaM( LIB_PFN, n    ) )
    #define  FN( n )   RL_FuNaM( LIB_VIS, n    )   
    #define  fn( n )   RL_FuNaM( lib_hid, n    )
    #define   H(msg)   fn(   Halt   )(   msg   )  
    #define  PRIVATE_FUNCTION( stuff ) stuff

//:================================:MACROS:ROOT_LEVEL_OOP.TOP://

//:HALTING_FUNCTIONS:========================================://
#define U32 uint32_t /** stdint.h **/

    //:FUNCTION:HALT(ALWAYS):================================://

    void aac2020_graquad_Halt( const char* err_msg ){

        printf(
        /**/"[aac2020_graquad_Halt]%s\n"
        ,   err_msg
        );;fflush(stdout);exit(666);

    }

    //:================================:FUNCTION:HALT(ALWAYS)://
    //:FUNCTION:HALT_OR_STATUS(HOS):=========================://
    #define HAS_FAILED_FAST  AAC2020_GRAQUAD_HAS_FAILED_FAST
    
        U32
        aac2020_graquad_HOS( 

            int         HOS     //:Halt_Or_Status 
                                //:(failure_method)
            //: 1: HOS == AAC2020_GRAQUAD_FAIL_FAST
            //: 2: HOS == AAC2020_GRAQUAD_FAIL_CODE
     
        ,   const char* err_msg //:Error Message 
        ,   U32         err_hex //:Error_Code_In:HEX
        ,   U32         err_dec //:Error_Code_In:DEC

        )
        {
            /** This function either fails fast or returns   **/
            /** an error status code. This function was made **/
            /** to allow for feature:                        **/
            /** #FEATURE:FAULT_TOLERANT_USER_FRAG_SHADERS#   **/
            /** FUNCTION_ADDED_DATE[ 2020_11_06 ]            **/

            U32 status_code=( 0x00 /** No Trouble **/ );

            //:ERROR_CODE_REDUNDANCY:========================://
            if( err_hex != err_dec ){ //:--------------------://
            #define P printf

                P("[#define:A2G:aac2020_graquad)]\n"         );
                P("[A2G_HOS:ERROR_CODE_ERROR]:...\n"         );
                P("[A2G_HOS:err_msg]:%s          \n" ,err_msg);
                P("[A2G_HOS:err_hex]:%0x         \n" ,err_hex);
                P("[A2G_HOS:err_dec]:%d          \n" ,err_dec);
                
                fflush(stdout);
                exit( 666 );

            #undef P
            };; //:-------------------:( err_hex != err_dec )://
            //:========================:ERROR_CODE_REDUNDANCY://
            //:HALT_OR_STATUS:===============================://

            switch( HOS /** failure_method **/ ){
            
            case    AAC2020_GRAQUAD_FAIL_FAST:
            
                    aac2020_graquad_Halt( "[BGP_OGL:001]" );
                    status_code = HAS_FAILED_FAST ;
                    break;
            
            case    AAC2020_GRAQUAD_FAIL_CODE:
            
                    assert(       err_hex == err_dec );
                    status_code = err_hex ;
                    break;
            
                
            default: 
                    /** BFM: Bad_Failure_Method/HOS_Value **/
                    aac2020_graquad_Halt("[#BFM/HOS#]");
            };;
            //:===============================:HALT_OR_STATUS://
            //:RETURN_STATUS_CODE:===========================://

            /** Fail fast status code should never be        **/
            /** returned because failing fast means failing  **/
            /** immediately and NOT returning a status code. **/

            assert( status_code != HAS_FAILED_FAST );
            return( status_code );

            //:===========================:RETURN_STATUS_CODE://
        }

    #undef  HAS_FAILED_FAST
    //:=========================:FUNCTION:HALT_OR_STATUS(HOS)://

#undef  U32
//:========================================:HALTING_FUNCTIONS://

//:WINDOW_RESIZE_CALLBACK_FUNCTION:==========================://
//:CALLED_BY:AAC2020_OnWindowResize:=========================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32  AAC2020_GRAQUAD_OnWindowResize( U32 u32 )
    {
        printf("[AAC2020_GRAQUAD_OnWindowResize]\n");

        if( u32 ){ /** reserved for future use **/ };

        //:Resize_OpenGL_Viewport_To_New_Screen_Size:--------://

            AAC2020_GLEBIND.glViewport(
                0 , 0 //: x,y
            ,   AAC2020_GINAWIN_GetClient_WID()
            ,   AAC2020_GINAWIN_GetClient_HIG()
            );;

        //:--------:Resize_OpenGL_Viewport_To_New_Screen_Size://
        //:Re_Load_Shader_Uniforms:--------------------------://

        /** Done By:                                         **/
        /** AAC2020_BASUNIF_ReLoadShaderUniforms_iResolution **/

        //:--------------------------:Re_Load_Shader_Uniforms://


        return( 0x00 );
    }

#undef  U32
//:==========================:WINDOW_RESIZE_CALLBACK_FUNCTION://
//:=========================:CALLED_BY:AAC2020_OnWindowResize://






PRIVATE_FUNCTION( static void )
fn( Init_Data )( void ){

    #define T_1        const float /** GLfloat **/   
    #define T_2        const     int  ////////////

    T_1* ARR = aac2020_graquad_vertex_buffer_data     ; 
    T_2  NUM = aac2020_graquad_vertex_buffer_data_num ; 

    //: 12345678      TRI
        aac2020_graquad.data.tri.ce.ARR = ARR;
        aac2020_graquad.data.tri.ce.NUM = NUM;
    //: 12345678      TRI

    #undef T_1  //////////////////////////////////
    #undef T_2  //////////////////////////////////

    aac2020_graquad.data.
    we_have_4_corner_verts_making_quad=(
    aac2020_graquad_we_have_4_corner_verts_making_quad
    );;

    aac2020_graquad.data.FAG_SAD_SRC =(
         aac2020_graquad_fag_sad_src   );;

    aac2020_graquad.data.VET_SAD_SRC =(
         aac2020_graquad_vet_sad_src   );;
    

}


//! Did openGL emit any errors? -------------- !//
PRIVATE_FUNCTION( static void )
fn( ErrChk /**ga_ErrChk**/ )( 
    const char* onn_err_msg /** on_fail_msg **/
){
int num_errors_found = 0;

    //:######################################################://
    #define GLE unsigned int /** GLenum **/ //:##############://

            GLE err;

            //: fem: First_Error_Message
            GLE fem  = AAC2020_GLEBIND.ERR.gl_no_error; 

    #undef  GLE //:##########################################://
    //:######################################################://

    err = AAC2020_GLEBIND.glGetError();
    if( err != AAC2020_GLEBIND.ERR.gl_no_error ){
        fem = err;
        num_errors_found++;
    };; 

    //# MUST BE CALLED IN A LOOP!              #//
    //# SEE[ youtu.be/FBbPWSOQ0-w?t=6m30s ]    #//
    const int loop_till_i_say_break = 1;
    while( loop_till_i_say_break ){
        err = AAC2020_GLEBIND.glGetError();
        if( err != AAC2020_GLEBIND.ERR.gl_no_error ){
            num_errors_found++;
        }else{
            break; //:Ext loop, no error.
        };;
    };;

    
    //| If errors are found to be stacked,     |//
    //| Give abnoxious warning message but     |//
    //| do not halt program yet.               |//
    if( 1 == num_errors_found ){
        printf("[Found_One_Error]\n");
    }else
    if( 1  < num_errors_found ){
        printf(
            "[BEG:FIX_THIS_FIRST_________]   \n"
            "[ERRORS_HAVE_BEEN_STACKED!!!]   \n"
            "[ERRORS_HACK_BEEN_STACKED!!!]   \n"
            "[- - - - - - - - - - - - - -]   \n"
            "[num_errors_found___________]:%d\n"
            "[- - - - - - - - - - - - - -]   \n"
            "[ERRORS_HAVE_BEEN_STACKED!!!]   \n"
            "[ERRORS_HAVE_BEEN_STACKED!!!]   \n"
            "[END:FIX_THIS_FIRST_________]   \n"
            , num_errors_found
        );;
    }else
    if( 0  > num_errors_found ){
        fn(Halt)("[NegativeErrorsHow?]\n");
    };;

    //| Make sure your flags agree             |//
    //| with each other.                       |//
    //| You'd think something like this is     |//
    //| overly cautious. But it found bug      |//
    //| in my code when I wrote it.            |//
    //| And I did not write it to find a bug.  |//
    //| I wrote it this way because I have     |//
    //| a paranoid style.                      |//
    //////////////////////////////////////////////
    if( num_errors_found     >=1    && 
        AAC2020_GLEBIND.ERR.gl_no_error != fem &&
    1){
        //:Do nothing. (Not YET, we have error)
    }else
    if( 0 == num_errors_found       &&
        AAC2020_GLEBIND.ERR.gl_no_error == fem &&
    1){
        //:Do nothing. (Never. No Error)
    }else{
        printf("[JM:num_errors_found]:%d\n" 
               "[JM:value_of_fem____]:%d\n" 
               ,    num_errors_found
               ,    fem
        );;

        fn(Halt)("[JohnMarksFault:FMM]");
    };;
    //////////////////////////////////////////////
        

    //:Finally, throw error if occured:
    if( fem != AAC2020_GLEBIND.ERR.gl_no_error ){
        printf("[ga_ErrChk:About_To_Halt]\n");
        printf("[ERR_NO:fem]:%d\n", fem );
        fn(Halt)( onn_err_msg );
    };;
} //[ErrChk]//


//:COMPILE_SHADER_PRIVATE:===================================://
#define U32 uint32_t /** GCC: <stdint.h>  **/
#define  OK ( 0 )    /** Okay Status Code **/

    U32
    aac2020_graquad_CompileShader(
        
        //:     AT: Argument_Type  ::::::::::::::::::::::::::://
        #define AT_1  int          /////////////////////////////
        #define AT_2  unsigned int /** GLuint **/ //////////////
        #define AT_3  const char*  /////////////////////////////
        #define AT_4  const char*  /////////////////////////////
        //:     AT: Argument_Type  ::::::::::::::::::::::::::://
        
        AT_1  HOS /** halt_or_status (failure_method) **/
    ,   AT_2  wev_sad_iid //:[fag_sad_iid|vet_sad_iid]
    ,   AT_3  wev_sad_src //:[fag_sad_src|vet_sad_src]
    ,   AT_4  onn_err_msg //:[fag_sad_err|vet_sad_err]

        //:     AT: Argument_Type  ::::::::::::::::::::::::::://
        #undef  AT_1  //////////////////////////////////////////
        #undef  AT_2  //////////////////////////////////////////
        #undef  AT_3  //////////////////////////////////////////
        #undef  AT_4  //////////////////////////////////////////
        //:     AT: Argument_Type  ::::::::::::::::::::::::::://
    ){

        /** Function name previously written as:  * **/
        /** fn( CompileShader ) * * * * * * * * * * **/

        //:DECLARE_VARIABLES:--------------------------------://

        //:##################################################://
        #define GLI int /** GLint **/ //:####################://

                int HOS_status_code = ( 0 /** OKAY **/ );

                int ino_log_num = ( 0-666 ); //:InfoLogLength 
                int         num = ( 0-555 ); //:num_chars
                int         siz = ( 0-444 ); //:num_bytes
                char*       ems = ( NULL  ); //:err_msg
                GLI     cmd_ret = ( 
                            AAC2020_GLEBIND.BOL.gl_false );;

        #undef  GLI  //:#####################################://
        //:##################################################://

        //:--------------------------------:DECLARE_VARIABLES://
        //:RUN_OPEN_GL_COMMANDS:-----------------------------://
        if( OK == HOS_status_code ){

            /** WEV: WHATEVER (FragmentShader|VertexShader)  **/
            /** WEV == "ver(vert)" or "fag(frag)"            **/
            /** wev_sad_src===ga_fragment_shader_source      **/
            /** wev_sad_src===ga_vertex_shader_source        **/
 
            AAC2020_GLEBIND.glShaderSource(           
            /**/wev_sad_iid                           
            ,   1 //+AlistOfOneMonoLithicString+//    
            ,   &(wev_sad_src)  //:WEV:Whatever                      
            ,   NULL //|array_of_string_lengths|//    
            );;       
                                
            AAC2020_GLEBIND.glCompileShader(          
                wev_sad_iid                           
            );;                                       
                                                      
            AAC2020_GLEBIND.glGetShaderiv(            
            /**/wev_sad_iid                           
            ,   AAC2020_GLEBIND.SPN.gl_compile_status         
            ,   &( cmd_ret )                                  
            );;   

        };; //:-------------------------:RUN_OPEN_GL_COMMANDS://
        //:CHECK_COMPILE_STATUS:-----------------------------://
        if( OK == HOS_status_code ){
    
            //:CHECK_COMPILE_STATUS:OK:----------------------://
            if( cmd_ret == AAC2020_GLEBIND.BOL.gl_true){

                //:Do nothing. All is okay.

            };; //:------------------:CHECK_COMPILE_STATUS:OK://
            //:CHECK_COMPILE_STATUS:HAS_ERROR:---------------://
            if( cmd_ret != AAC2020_GLEBIND.BOL.gl_true){ 
     
                //:ERROR_LOGS:GET_SIZE:----------------------://

                    AAC2020_GLEBIND.glGetShaderiv(                
                    /**/wev_sad_iid                      
                    ,   AAC2020_GLEBIND.SPN.gl_info_log_length    
                    ,   &(ino_log_num)                  
                    );;   

                //:----------------------:ERROR_LOGS:GET_SIZE://
                //:ERROR_LOGS:ALLOCATE_AND_PRINT:------------://
                //:##########################################://
                #define P printf //:#########################://
                if(ino_log_num>0){ 
                
                    P("[AAC2020_GRAQUAD:WEV:ino_log_num>0]\n"); 
                                                   
                    /** +1 because null terminator. **/ 
                    num =(ino_log_num+1   );       
                    siz = sizeof(  char   );       
                    ems = malloc( siz*num );       
                                                   
                    AAC2020_GLEBIND.glGetShaderInfoLog(       
                    /**/wev_sad_iid                
                    ,   ino_log_num                
                    ,   NULL                       
                    ,   ems                        
                    );;                            
                                                   
                    P( "[WEV:2019_08_02:MSG]:%s\n" , ems );
                    fflush(stdout);             
                                                   
                    free(             ems );       
                    
                    //:Clue as too root error:
                    P("[RE_CLUE001:]:%s\n",onn_err_msg);;

                    #define CODE AAC2020_GRAQUAD_SHADER_FAIL
                    assert( CODE == 0x123 );
                    HOS_status_code = aac2020_graquad_HOS( 
                    HOS , "[HALT:0x123(291)]" , CODE , 291 );;
                    #undef  CODE
                }else{                             
                    P("[NO_GOD_DAMN_INFO_LOGS]\n");                        
                    P("[RE_CLUE:002:]:%s\n",onn_err_msg);;    
                    
                    HOS_status_code = aac2020_graquad_HOS( 
                    HOS , "[HALT:0x1B1(433)]" , 0x1B1 , 433 );;
                };; 
                #undef  P //:################################://
                //:##########################################://
                //:------------:ERROR_LOGS:ALLOCATE_AND_PRINT://

            };; //:-----------:CHECK_COMPILE_STATUS:HAS_ERROR://                             
        };; //:-------------------------:CHECK_COMPILE_STATUS://
        //:RETURN_STATUS_CODE:-------------------------------://
        #define STOP_MOTHER_FUCKER  aac2020_graquad_Halt

            /** STOP MOTHERFUCKER * * * * * * * * * **/
            /** www.youtube.com/watch?v=3kcH23tyzsI **/

            //:Status code used when not in fail fast mode.
            if(     HOS == AAC2020_GRAQUAD_FAIL_FAST ){ 
                if( 0 != HOS_status_code ){
                    //:SHBCE:SHOULD_HAVE_BEEN_CAUGHT_EARLIER
                    STOP_MOTHER_FUCKER("[SHBCE]");
                };;
            };;

            return( HOS_status_code );

        #undef  STOP_MOTHER_FUCKER
        //:-------------------------------:RETURN_STATUS_CODE://
    }

#undef   OK
#undef  U32
//:===================================:COMPILE_SHADER_PRIVATE://

PRIVATE_FUNCTION( static void )
fn( CheckTheProgram )( void ){

    //:######################################################://
    #define GLE  int /** GLint **/ //:#######################://

            //! Command_Result:______________________________!//
            GLE     cmd_res = (0-54); 

            //! Number_Of_Characters:________________________!//
            int         num = 0;
            
            //! Size_In_Bytes_Of_String:_____________________!//
            int         siz = 0;

            //! ems:err_msg/error_message:___________________!//
            char*       ems = NULL;

            //! info_log_length (num/number==length):________!//
            int ino_log_num = (0-3472);

    #undef  GLE //:##########################################://
    //:######################################################://

    //|P|P|P|P|P|P|P|P|P|----|P|P|P|P|P|P|P|P|P|//
    /////////////////////////////////////////|P|//
    #define POG_IID (aac2020_graquad.data.POG_IID)//|P|//
    /////////////////////////////////////////|P|//
    PFN_glGetProgramiv                     //|P|//
    GPIV=AAC2020_GLEBIND.glGetProgramiv;              //|P|//
                                           //|P|//
    GPIV(                                  //|P|//
    /**/POG_IID                            //|P|//
    ,   AAC2020_GLEBIND.PPN.gl_link_status            //|P|//
    ,   &cmd_res                           //|P|//
    );                                     //|P|//
                                           //|P|//
    if(cmd_res != AAC2020_GLEBIND.BOL.gl_true){       //|P|//
        AAC2020_GLEBIND.glGetProgramiv(               //|P|//
        /**/POG_IID                        //|P|//
        ,   AAC2020_GLEBIND.PPN.gl_info_log_length    //|P|//
        ,   &(ino_log_num)                 //|P|//
        );;                                //|P|//
                                           //|P|//
        if(ino_log_num>0){                 //|P|//
            printf("[FS:ino_log_num>0]");  //|P|//
                                           //|P|//
            //|+1 because null terminator.   |P|//
            num = (ino_log_num+1);         //|P|//
            siz = sizeof( char  );         //|P|//
            ems = malloc(siz*num);         //|P|//
                                           //|P|//
            AAC2020_GLEBIND.glGetProgramInfoLog(      //|P|//
            /**/POG_IID                    //|P|//
            ,   ino_log_num                //|P|//
            ,   NULL                       //|P|//
            ,   ems                        //|P|//
            );;                            //|P|//
                                           //|P|//
            printf(                        //|P|//
                "[PO:2019_08_03:MSG]:%s"   //|P|//
            ,   ems                        //|P|//
            );;fflush(stdout);             //|P|//
                                           //|P|//
            free( ems );                   //|P|//
                                           //|P|//
            fn(Halt)(                      //|P|//
                "[PO:2019_08_03:SEE_ABOVE]"//|P|//
            );;                            //|P|//
        }else{                             //|P|//
            fn(Halt)(                      //|P|//
                "[X_X:PO:COMPILE_STATUS]\n"//|P|//
                "[X_X:PO:NO_LOG_HELP@_@]\n"//|P|//
            );;                            //|P|//
        };;                                //|P|//
    };;                                    //|P|//
    /////////////////////////////////////////|P|//
    #undef POG_IID //////////////////////////|P|//
    /////////////////////////////////////////|P|//
    //|P|P|P|P|P|P|P|P|P|----|P|P|P|P|P|P|P|P|P|//

}

PRIVATE_FUNCTION( static void )
fn( ReclaimMemory_OpenGL_ShaderStuff )( void ){

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //|RM|RM|RM|RM|RM|RM|----|RM|RM|RM|RM|RM|RM|//
    //|                                        |//
    //|why detach?                             |//
    //|This doesn't do what I think it does.   |//
    //|It deletes the objects used to create   |//
    //|the program, but the program itself     |//
    //|still has compiled shader code in it    |//
    //|even after the glDetachShader and       |//
    //|glDeleteShader                          |//
    //|                                        |//
    //|[BEG:QUOTE]:                            |//
    //|Shader objects take up a lot of memory  |//
    //|compared to each program. It's better to|//
    //|delete them after you're done compiling |//
    //|your programs and have more memory      |//
    //|available for more important things     |//
    //|[END:QUOTE]:                            |//
    //|SRC: gamedev.stackexchange.com          |//
    //|              /questions/47910          |//
    //|RM|RM|RM|RM|RM|RM|----|RM|RM|RM|RM|RM|RM|//
                                     //| -- |RM|//
    ///////////////////////////////////| -- |RM|//
    #define D_D     (aac2020_graquad.data)  //| -- |RM|//
    #define POG_IID ( D_D.POG_IID )  //| -- |RM|//
    ///////////////////////////////////| -- |RM|//
                                     //| -- |RM|//
    //: GLU:GLuint           //:##:////| -- |RM|//
    #define GLU unsigned int //:##:////| -- |RM|//
                                     //| -- |RM|//
            GLU vet_sad_iid =(       //| -- |RM|//
            D_D.VET_SAD_IID   );;    //| -- |RM|//
                                     //| -- |RM|//
            GLU fag_sad_iid =(       //| -- |RM|//
            D_D.FAG_SAD_IID   );;    //| -- |RM|//
                                     //| -- |RM|//
    #undef  GLU //:###############:////| -- |RM|//
                                     //| -- |RM|//
             PFN_glDetachShader      //| -- |RM|//
    DetSad=(AAC2020_GLEBIND.glDetachShader);    //| -- |RM|//
                                     //| -- |RM|//
             PFN_glDeleteShader      //| -- |RM|//
    KilSad=(AAC2020_GLEBIND.glDeleteShader);    //| -- |RM|//
                                     //| -- |RM|//
    DetSad(POG_IID, vet_sad_iid);    //| -- |RM|//
	DetSad(POG_IID, fag_sad_iid);    //| -- |RM|//
	                                 //| -- |RM|//
	KilSad(vet_sad_iid);             //| -- |RM|//
	KilSad(fag_sad_iid);             //| -- |RM|//
                                     //| -- |RM|//
    ///////////////////////////////////| -- |RM|//
    #undef  POG_IID ///////////////////| -- |RM|//
    #undef  D_D     ///////////////////| -- |RM|//
    ///////////////////////////////////| -- |RM|//
                                     //| -- |RM|//
    //|RM|RM|RM|RM|RM|RM|----|RM|RM|RM|RM|RM|RM|//
    //|________________________________________|//

}

PRIVATE_FUNCTION( static void )
fn( CreateTheShaders )( void ){

    #define GLU unsigned int /** GLuint **/ //:##############://

        GLU fag_sad_iid = 27772;
        GLU vet_sad_iid = 16661;

    #undef  GLU //:##########################################://
    

    //|C|C|C|C|C|C|C|C|C|----|C|C|C|C|C|C|C|C|C|//
    vet_sad_iid   =(                       //|C|//
        AAC2020_GLEBIND.glCreateShader(               //|C|//
            AAC2020_GLEBIND.ST.gl_vertex_shader       //|C|//
        )                                  //|C|//
    );;fn(ErrChk)("[aac2020_graquad:CREATE_VS]"); //|C|//
                                           //|C|//
    //|-  --  --  --  ---  --  --  --  -|////|C|//
                                           //|C|//
    fag_sad_iid =(                         //|C|//
        AAC2020_GLEBIND.glCreateShader(               //|C|//
            AAC2020_GLEBIND.ST.gl_fragment_shader     //|C|//
        )                                  //|C|//
    );;fn(ErrChk)("[aac2020_graquad:CREATE_FS]"); //|C|//
                                           //|C|//
    //|-  --  --  --  ---  --  --  --  -|////|C|//
                                           //|C|//
    if(           0  >= vet_sad_iid    ){  //|C|//
        fn(Halt)("[0 >= vet_sad_iid]"  );  //|C|//
    };;                                    //|C|//
    if(           0  >= fag_sad_iid  ){    //|C|//
        fn(Halt)("[0 >= fag_sad_iid]");    //|C|//
    };;                                    //|C|//
                                           //|C|//
    //|C|C|C|C|C|C|C|C|C|----|C|C|C|C|C|C|C|C|C|//

    //! Store_The_Result:______________________!//
    aac2020_graquad.data.VET_SAD_IID=(
                  vet_sad_iid  );;

    aac2020_graquad.data.FAG_SAD_IID=(
                  fag_sad_iid  );

}

//:CREATESHADERCODE:=========================================://
#define U32        uint32_t 
#define HALT_BITCH aac2020_graquad_Halt
#define  OK        ( 0x00 )

    U32
    aac2020_graquad_CreateShaderCode(

        int    HOS /** failure_method       **/
        //: 1: HOS == AAC2020_GRAQUAD_FAIL_FAST
        //: 2: HOS == AAC2020_GRAQUAD_FAIL_CODE

    )
    {
        /** AKA: fn( CreateShaderCode ) **/
        
        int HOS_status_code =( 0 /** Success / OK **/ );

        //:VARS:- - - - - - - - - - - - - - - - - - - - - - -://
            //:LOAD__DATA:- - - - - - - - - - - - - - - - - -://
            const char*              vet_sad_src=(
                aac2020_graquad.data.VET_SAD_SRC
            );;
            
            const char*              fag_sad_src=(
                aac2020_graquad.data.FAG_SAD_SRC
            );;
            
            /**  These messages are used to let us know      **/
            /**  if "CompileShader(...)" failed because      **/
            /**  of a bad vertex shader (vet_sad_msg)        **/
            /**  or a fragment shader.  (fag_sad_msg)        **/
            
            const char* vet_sad_msg ="[VET_SAD_MSG]";
            const char* fag_sad_msg ="[FAG_SAD_MSG]";
            //:- - - - - - - - - - - - - - - - - -:LOAD__DATA://
            //:OTHER_TOP_SCOPE_VARS:- - - - - - - - - - - - -://

                /** FOR:Retrieve_Shader_IDs_Generated **/
      
                #define T1 unsigned int /** GLuint **/ 
                    /** T1 **/                         
                        T1    vet_sad_iid =(0-83); 
                        T1    fag_sad_iid =(0-84);                       
                #undef  T1  

            //:- - - - - - - - - - - - -:OTHER_TOP_SCOPE_VARS://
        //:- - - - - - - - - - - - - - - - - - - - - - -:VARS://
        //:ALLOCATE_SHADER_MEMORY:---------------------------://
        if( OK == HOS_status_code ){

            //:ALLOCATE:-------------------------------------://

                /** Creates allocations for our vertex and   **/
                /** fragment shaders. Does not look at       **/
                /** any shader source code.                  **/
                

                fn( CreateTheShaders )( );

            //:-------------------------------------:ALLOCATE://
            //:RETRIEVE:Set_Via_Side_Effect:-----------------://

                /** DO::Retrieve_Shader_IDs_Generated **/
      
                #define T1 unsigned int /** GLuint **/                                      
                                         vet_sad_iid =(       
                    aac2020_graquad.data.VET_SAD_IID   );;    
                    /** T1 **/                        
                    /** T1 **/           fag_sad_iid =(       
                    aac2020_graquad.data.FAG_SAD_IID   );;   
                    /** T1 **/                         
                #undef  T1  
                 
            //:-----------------:RETRIEVE:Set_Via_Side_Effect://

        };; //:-----------------------:ALLOCATE_SHADER_MEMORY://
        //:COMPILE_SHADER:ALL:-------------------------------://
        if( OK == HOS_status_code ){

            //:COMPILE_SHADER:VERTEX:------------------------://
            if( OK == HOS_status_code ){

                /** Because the USER never inputs VERTEX     **/
                /** shader code. This will always fail fast. **/
                HOS_status_code =(
                fn( CompileShader )(      

                /**/AAC2020_GRAQUAD_FAIL_FAST /** HOS **/

                ,   vet_sad_iid   //:Vertex_Shader_Integer_ID
                ,   vet_sad_src   //:Vertex_Shader_Source
                ,   vet_sad_msg   //:Vertex_Shader_Message
                ));;    

                if( HOS_status_code != 0 ){ 
                    HALT_BITCH("[EXPECTED_FAIL_FAST_001]"); 
                };;
         
            };; //:--------------------:COMPILE_SHADER:VERTEX://
            //:COMPILE_SHADER:FRAGMENT:----------------------://
            if( OK == HOS_status_code ){

                /** HOS == AAC2020_GRAQUAD_FAIL_CODE         **/
                /**         *** WHEN ***                     **/
                /** the pipeline's fragment shader           **/
                /** input is user defined source code.       **/

                HOS_status_code =(
                fn( CompileShader )(    
  
                /**/HOS
                        //: 1. HOS == AAC2020_GRAQUAD_FAIL_CODE
                        //: 2. HOS == AAC2020_GRAQUAD_FAIL_FAST

                ,   fag_sad_iid  //:Fragment_Shader_Integer_ID                    
                ,   fag_sad_src  //:Fragment_Shader_Source                    
                ,   fag_sad_msg  //:Fragment_Shader_Message                    
                ));;                                  
            
            };; //:------------------:COMPILE_SHADER:FRAGMENT://

        };; //:---------------------------:COMPILE_SHADER:ALL://
        //:LINK_THE_PROGRAM:---------------------------------://
        if( OK == HOS_status_code ){ //:---------------------://

            /** If everything was successful so far then:    **/
            /** 1: create program (Allocate)                 **/
            /** 2: attach shaders                            **/
            /** 3: link   program (Compile I Think)          **/
                                
            #define D_D (aac2020_graquad.data)        
            #define C_P (AAC2020_GLEBIND.glCreateProgram) 
                                                   
                    D_D.POG_IID = C_P();           
            if(     D_D.POG_IID <= 0 ){            
                fn(Halt)(                          
                  "[D_D.POG_IID <= 0]"             
                );;                                
            };;                                    
                PFN_glAttachShader                 
                AS=(AAC2020_GLEBIND.glAttachShader);          
                                                   
                AS( D_D.POG_IID, vet_sad_iid  );   
                AS( D_D.POG_IID, fag_sad_iid  );   
                                                   
                PFN_glLinkProgram                  
                LP=(AAC2020_GLEBIND.glLinkProgram);           
                                                   
                LP( D_D.POG_IID );                 
                                                   
            #undef  D_D   
            #undef  C_P   
 
        };; //:-----------------------------:LINK_THE_PROGRAM://
        //:MISC_STUFF_AT_THE_END:----------------------------://
        if( OK == HOS_status_code ){

            /** MISC_STUFF_AT_END: ************************* **/
            /** Miscellanious stuff at the end that I'am not **/
            /** going to comment because I don't remember    **/
            /** what is does and as long as it isn't broken, **/
            /** that is good enough for me.                  **/
            /** ******************************************** **/

            fn(CheckTheProgram)(  );  
       
            fn(ReclaimMemory_OpenGL_ShaderStuff)( );

            AAC2020_GLEBIND.glUseProgram( 
                aac2020_graquad.data.POG_IID 
            );;

            fn( ErrChk )( 
                "[2019_08_03:glUseProgram]"
            );;

        };; //:------------------------:MISC_STUFF_AT_THE_END://

        return( HOS_status_code );
    }

#undef OK
#undef HALT_BITCH
#undef U32
//:=========================================:CREATESHADERCODE://

PRIVATE_FUNCTION( static void )
fn( JunkCode_ErrorCheckOtherLibData )(void){

    //:this code is kind of junk.
    //:It breaks the chaining rule.
    //:#THE_CHAINING_RULE#

    if(NULL==AAC2020_GLEBIND.glGetUniformLocation){
        fn(Halt)(
            "[aac2020_graquad:NIL_2019_08_03_0351AM:01]"
        );;
    };;
    if(NULL==pfn_glGetUniformLocation){
        fn(Halt)(
            "[aac2020_graquad:NIL_2019_08_03_0351AM:02]"
        );;
    };;

}

PRIVATE_FUNCTION( static void )
fn( UseThatProgram )( void ){

    AAC2020_GLEBIND.glUseProgram( aac2020_graquad.data.POG_IID );
    
    fn(JunkCode_ErrorCheckOtherLibData)( );

}

//////////////////////////////////////////////////

PRIVATE_FUNCTION( static void )
fn(       glGenBuffers )( ){ 
//: ga_qs_glGenBuffers

    //:glGenBuffers — generate buffer object names
    AAC2020_GLEBIND  .glGenBuffers(
        ( 1 )//:JustMakeOne
    ,   &(aac2020_graquad.data.tri.ga.VBO) 
    );;fn(ErrChk)("[glGenBuffers]");

}
PRIVATE_FUNCTION( static void )
fn(       glBindBuffer )( ){ 
//: ga_qs_glBindBuffer

    //:BBT:BUFFER_BINDING_TARGET

    AAC2020_GLEBIND  .glBindBuffer(
        AAC2020_GLEBIND.BBT.gl_array_buffer
    ,   aac2020_graquad.data.tri.ga.VBO
    );;fn(ErrChk)("[glBindBuffer]");

}
PRIVATE_FUNCTION( static void )
fn(       glBufferData )( ){ 
//: ga_qs_glBufferData

    //[ Give our vertices to OpenGL.     ]//
    //||||||||||||||||||||||||||||||||||||//
    #define d_d (aac2020_graquad.data) /////|   |//
    AAC2020_GLEBIND  .glBufferData(           //|   |//
        AAC2020_GLEBIND.BBT                   //|TAR|//
        .gl_array_buffer           //|   |//
    ,                              //|   |//
        sizeof(d_d.tri.ce.ARR[0])  //|SIZ|//
             *(d_d.tri.ce.NUM)     //| ++|//
    ,          d_d.tri.ce.ARR      //|DAT|//
    ,                              //|   |//
        AAC2020_GLEBIND.BUFFER_DATA           //|USE|//
        -> gl_static_draw          //|   |//
    );;                            //|   |//
    fn(ErrChk)("[glBufferData]");  //|   |//
    #undef  d_d  ////////////////////|   |//
    //||||||||||||||||||||||||||||||||||||//

}

PRIVATE_FUNCTION( static void )
fn(       glGenVertexArrays )( ){ 
//: ga_qs_glGenVertexArrays

    AAC2020_GLEBIND  .glGenVertexArrays(
        ( 1 )//:JustMakeMeOne
    ,   &(aac2020_graquad.data.tri.ga.VAO)
    );;fn(ErrChk)("[glGenVertexArrays]");

}
PRIVATE_FUNCTION( static void )
fn(       glBindVertexArray )( ){ 
//: ga_qs_glBindVertexArray

    AAC2020_GLEBIND.  glBindVertexArray(
        aac2020_graquad.data.tri.ga.VAO
    );;fn(ErrChk)("[glBindVertexArray]");

}
PRIVATE_FUNCTION( static void )
fn(       glVertexAttribPointer )( 
//: ga_qs_glVertexAttribPointer

    /**/unsigned int /** GLuint **/  
        layout_index
    ,   
        int /** GLsizei **/ 
        attrib_size_in_elements
){ 

    //|////////////////////////////////////////|//
    //| glVertexAttribPointer :                |//
    //| define an array of generic vertex      |//
    //| attribute data                         |//
    //|////////////////////////////////////////|//

    //:#FEEBUS# #FEBUS# But not spelled that way.
    //:febis:first_element_buffer_inset_seek
    //:midep:measured_in_data_element_points
    #define G_L_U_E(x,y) x##_##y /////////////////
    size_t  G_L_U_E(febis,midep)=0;//:febis_midep
    size_t  G_L_U_E(febis,bytes)=0;//:febis_bytes
    #undef  G_L_U_E //////////////////////////////
    
    //:#LAYOUT_INDEX_SHOULD_BE_PRE_APPROVED#://          
    if(MACRO_LALODEX_verpos //:Vertex_Position
        ==layout_index
    ){
        size_t      seek_to_vertex_position=0;
        febis_midep=seek_to_vertex_position;
    }else
    if(MACRO_LALODEX_texcoo //:Texture_Coordinate
        ==layout_index
    ){
        size_t      seek_to_first_texcoord=3;
        febis_midep=seek_to_first_texcoord;
    }else{
        fn(Halt)("[UnknownLayoutIndex]");
    };;
    
    //:febis:first_element_buffer_inset_seek
    //:midep:measured_in_data_element_points
    //:bytes:bytes (measured_in_bytes/febis_bytes)
    int siz = sizeof(float)  ;
    int num = febis_midep    ;
    febis_bytes=( siz * num );

    //:#GET_THAT_FUCKING_STRIDE#:#############################//
    #define GLS  int /** GLsizei **/ //:#####################://

            GLS sin_elm =( //:stride_in_elements
                aac2020_graquad_total_data_points_per_vertex
                    //:ga_total_data_points_per_vertex
            );;
            GLS sin_byt =( //:stride_in_bytes
                sin_elm * siz 
            );;

    #undef  GLS //:##########################################://
    //:############################:#GET_THAT_FUCKING_STRIDE#://
    
    AAC2020_GLEBIND.glVertexAttribPointer(
    //+   +-----------------------------+      +//
    //+   | attribute 0.                |      +//
    //+   | No particular reason for 0, |      +//
    //+   | but must match the          |      +//
    //+   | layout in the shader.       |      +//
    //+   |                             |      +//
    //+   +---+-------------------------+      +//
    //+       |                                +//
    /**/layout_index                      //[01]//
    ,   attrib_size_in_elements           //[02]//
    //                    //+                  +//
    ,   AAC2020_GLEBIND.TYP.gl_float //| _ : type       03|//
    ,   AAC2020_GLEBIND.BOL.gl_false //| _ : normalized?04|//
    //                    //+                  +//
    //| GLsizei   : stride                     |//
    ,   sin_byt //:stride_in_bytes
    //                            
    //| array buffer offset                    |//
    ,   (void*)febis_bytes  
    );;
    fn(ErrChk)("[X_X:glVertexAttribPointer]");

    AAC2020_GLEBIND.glEnableVertexAttribArray(layout_index);
    fn(ErrChk)("[X_X:glEnableVertexAttribArray]");

}
PRIVATE_FUNCTION( static void )
fn(       glBindBuffer_GL_ARRAY_BUFFER_0_ZERO)(){
//: ga_qs_glBindBuffer_GL_ARRAY_BUFFER_0_ZERO

    //:#ITS_A_GOOD_HABIT_LIKE_NULLING_POINTERS#://
    AAC2020_GLEBIND.glBindBuffer(
    /**/AAC2020_GLEBIND.BBT.gl_array_buffer
    ,   0 //:<<<<<<<<<<<<<<<<<<<<<<<<<ZERO!
    );;fn(ErrChk)("[aac2020_graquad2019_08_04_0226AM]");

}
PRIVATE_FUNCTION( static void )
fn(       glBindVertexArray_0_ZERO )(){
//: ga_qs_glBindVertexArray_0_ZERO

    //:#UNBIND_VERTEX_ARRAY_WHEN_DONE_HABIT#://
    AAC2020_GLEBIND.glBindVertexArray(0); 
    fn(ErrChk)("[YouMightAsWellErrorCheck]");

}






//////////////////////////////////////////////////


//! Setup the single polygon used to render    !//
//! pixels to the viewport. ------------------ !//
PRIVATE_FUNCTION( static void )
fn( QuadSetup )( void ){

    fn( ErrChk )(
        "[tesawin:FailedBeforeYouStarted]"
    );;

    fn( UseThatProgram )();


    //:Create the raw vertex data (VAO):
    //////////////////////////////////////////////
    fn( glGenBuffers )();      //: GEN BUF
    fn( glBindBuffer )();      //: BND BUF
    fn( glBufferData )();      //: BUF DAT
    //////////////////////////////////////////////
    
    //:Create VIEWS of that VAO known as VBO(s).
    //////////////////////////////////////////////
    
    //:Create the vertex arrays:
    fn( glGenVertexArrays )(); //: GEN VRT ARR
    fn( glBindVertexArray )(); //: BND VRT ARR
    
    //:View (VBO) of POSITION info in VAO.
    fn( glVertexAttribPointer )(
    //-GA_MACRO_VERPOS_LAYOUT_LOCDEX-//
          MACRO_LALODEX_verpos
    ,3 //:Size_In_Elements
    );;
    
    //:View (VBO) of TEXCOORDS info in VAO.
    //:( vs_texcoord )
    fn( glVertexAttribPointer )(
    //-GA_MACRO_VERPOS_LAYOUT_LOCDEX-//
        MACRO_LALODEX_verpos
    ,2 //:Size_In_Elements
    );;
    
    //////////////////////////////////////////////
    
    //| Unbind(de-select) the data you were    |//
    //| working on so other state-full commands|//
    //| do not accidentially modify your data. |//
    fn( glBindBuffer_GL_ARRAY_BUFFER_0_ZERO )( );
    fn( glBindVertexArray_0_ZERO            )( );
    
    
//   //:#FUNCTION_EXECUTION_ORDER_MATTERS#://
//   ga_MakeViewportTextureAndActivate( 1 );  <<<<<<<<<<<< BOARDWIN's job
//   ga_ConfigureTextureSampling_PORPIX( 1 ); <<<<<<<<<<<< BOARDWIN's job
//   ga_UploadTexturePixels_PORPIX( 1 );      <<<<<<<<<<<< BOARDWIN's job
//

    printf("[endofquadsetup]\n");
}

#define V void ///////////////////////////////////
PRIVATE_FUNCTION( static void )
fn(    MakeContextCurrentAndSetWindowSize )( V ){
//: ga_MakeContextCurrentAndSetWindowSize
#undef  V ////////////////////////////////////////


    //:Make context current:
    int /** BOOL **/ make_current_worked = (0-777);
    make_current_worked=(
    AAC2020_GLEBIND_wglMakeCurrent(
    /**/AAC2020_GINAWIN_GetWinDC_ExistsNoWait()
    ,   AAC2020_GLEBIND.handle_to_gl_rendering_context
    ));;

    //:#CONVOLUTED_BUT_I_WILL_ALLOW_IT#://    
    if(1 == make_current_worked ){
        //:DO_NOTHING://
    }else
    if(1 != make_current_worked ){
        int is_window_still_open=(
            AAC2020_GINAWIN_IsWindowStillOpen()
        );;
        if(is_window_still_open > 0){
            printf(
            /**/"[GA:is_window_still_open]:%d\n"
            ,        is_window_still_open
            );;    

            #define D   (aac2020_graquad.data)    ///////
            #define MCF  make_current_fail ///////
            #define NUM  D.MCF.NUM         ///////
            #define MAX  D.MCF.MAX         ///////

            if( ++(NUM) > MAX ){

                aac2020_glebind_Alert(
                    "[MCF:FAIL:2019_08_04]\n"
                );;

            }else{
                printf(
                    "[MCF:OK:AllowThisTime]\n"
                );;

                /** Sleep(2); **/
                //: return; #NAFOMEP#
            };;

            #undef  D    /////////////////////////
            #undef  MCF  /////////////////////////
            #undef  NUM  /////////////////////////
            #undef  MAX  /////////////////////////
        }else{
            printf(
                "[MCF:OK:CaughtWhileClosing]\n"
            );;
            //: return; #NAFOMEP#
        };;
    }else{
        H("[2019_08_04:EDCL]");
    };;

  //: //:Set size of viewport:
  //: int X   = AAC2020_GINAWIN_GetClient_X  ();
  //: int Y   = AAC2020_GINAWIN_GetClient_Y  ();
  //: int WID = AAC2020_GINAWIN_GetClient_WID();
  //: int HIG = AAC2020_GINAWIN_GetClient_HIG();
  //: AAC2020_GLEBIND.glViewport(
  //: /**/(GLint) X
  //: ,   (GLint) Y
  //: ,   (GLint) WID
  //: ,   (GLint) HIG
  //: );;

}

 
//:BUILD_GRAPHICS_PIPELINE:OPENGL:===========================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    fn( BGP_OpenGL  )( 

        //: A4[ #FEATURE:FAULT_TOLERANT_USER_FRAG_SHADERS# ] ://
        //: If function fails, what should it do?            ://
        //: AAC2020_GRAQUAD_FAIL_FAST                        ://
        //: AAC2020_GRAQUAD_FAIL_CODE                        ://
        int HOS /** Halt Or StatusCode (failure_method) **/

    ){
    #define OK ( 0 )

        #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 ) //:##########://

            printf("[BEG:BUILD_GRAPHICS_PIPELINE:OPENGL]\n");
            printf("[HOS(failure_method)]:%d\n", HOS );
            printf("[CODE==9001 , FAST==9002]\n");
            fflush(stdout);
        
        #endif //:###########################################://

        int status_code =( 0  /** success / OK **/ );
        
        /** BGP_OpenGL: Build Graphics Pipeline. OpenGL.  **/
        /** Prev_Name: Init_NotSureWhatToCallThis_GLSetup **/

        if( OK == status_code ){ //:-------------------------://

            /** Make Open GL Context Current **/

            int /** BOOL **/ make_current_worked=(
            AAC2020_GLEBIND_wglMakeCurrent(
            /**/AAC2020_GINAWIN_GetWinDC_ExistsNoWait()
            ,   AAC2020_GLEBIND.handle_to_gl_rendering_context
            ));;if(!make_current_worked){

                /** Failure To Set Current Context **/

                //:#HFC_ASO_BREAKAGE#::::::::::::::::::::::::://
                assert( AAC2020_GRAQUAD_CURCON_FAIL == 0x2D4 );
                status_code = aac2020_graquad_HOS( 
                HOS , "[HALT:0x2D4(724)]" , 0x2D4 , 724  );;

                //:#WHY_WGL_FAIL_PRINTF_HERE#::::::::::::::::://
                #define P printf //:#########################://
                P("[Specific_Failure_Code_Above_This_Line]\n");
                P("[Generic_Failure_Code_Below]:%s\n",
                AAC2020_GRAQUAD_BGP_STATUS_WGL_FAIL );
                fflush(stdout);
                #undef  P //:################################://

            };;

        };; //:----------------------------------------------://
        if( OK == status_code ){ //:-------------------------://

            /** CreateShaderCode:                            **/
            /** Creates Vertex And Fragment Shader Code      **/
            /** for the current pipeline setup.              **/
            /** At the moment, pipeline is re-built when     **/
            /** we change editors becuase different editors  **/
            /** use different fragment shaders.              **/
            /** DATE_WRITTEN[  2020_11_06 ]                  **/
            /** LAST_VERIFIED[ 2020_11_06 ]                  **/

            //: Do not create any textures! When texture  - -://
            //: sampler switchboard's uniform is zero     - -://
            //: it uses a default fragshader that         - -://
            //: does not sample from texture.             - -://
            status_code =(
                //:aac2020_graquad_CreateShaderCode
                fn(CreateShaderCode)( 
                    HOS /** failure_method **/
                )
            );;

        };; //:----------------------------------------------://
        if( OK == status_code ){ //:-------------------------://
            
            //[ EVERYTHING_ELSE_FAILS_FAST ----------------- ]//
            
            //:#WHY_EVERYTHING_FAILS_FAST_HERE_IN_BGP#://

            fn(QuadSetup)();
            fn(MakeContextCurrentAndSetWindowSize)();

            //[ ----------------- EVERYTHING_ELSE_FAILS_FAST ]//

        };; //:----------------------------------------------://


        #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 ) //:##########://

            printf("[END:BUILD_GRAPHICS_PIPELINE:OPENGL]\n");
            fflush(stdout);
        
        #endif //:###########################################://

        return( status_code );

    #undef OK
    }

#undef U32
//:===========================:BUILD_GRAPHICS_PIPELINE:OPENGL://

PRIVATE_FUNCTION( static void )
fn(Init_HaltIfChecksumsFail)(){
//:ga_HaltIfChecksumsFail
//:Init_HaltIfChecksumsFail
//:HaltIfChecksumsFail

    if(aac2020_graquad_vertex_buffer_data_num !=
       aac2020_graquad_vertex_buffer_data_num_actual
    ){  
        //:VETCESFAL:VertexChecksumFail
        fn(Halt)("[VETCESFAL:2019_08_04]");
    };;
} //[ga_HaltIfChecksumsFail]//

//:Not certain if this
PRIVATE_FUNCTION( static void )
fn( Init )( void ){

    if( 0 != aac2020_graquad_inited ){
        aac2020_graquad_Halt("[NOT_IDEMPOTENT_INIT]");
    };;

    //+ Commented out. + + + + + + + + + + + + + + + + + + + +//
    //- COG_Init();    - - - - - - - - - - - - - - - - - - - -//
    /**   Initialize after other dependencies. But don't     **/
    /**   Initialize dependencies inside here. That works,   **/
    /**   but makes the logic a lot harder to follow.        **/
    /**   It also could create a very large init chain       **/
    /**   that unecessarily creates a very deeply            **/
    /**   nested stack.                                      **/
    //- - - - - - - - - - - - - ---- - - - - - - - - - - - - -//
    //+ - - - - - - - - - - - - ---- - - - - - - - - - - - - +//


    fn( Init_HaltIfChecksumsFail )( );
    fn( Init_Data )( );

    //: If this fails, crash immediately. :::::::::::::::::::://
    fn( BGP_OpenGL )( AAC2020_GRAQUAD_FAIL_FAST );


    #if( AAC2020_GRAQUAD_BUGHUNT_001 >= 1 )
        printf("\n");
        printf("[EXITING:GRAQUAD.Init()]\n");
        printf("\n");
        fflush(stdout);
    #endif

    /** **************************************************** ***
        iMouse listener callback moved to: BASUNIF.F._   

        AAC2020_GINAWIN_OnMouseMove_SetCallback(
        AAC2020_*******_ReLoadShaderUniforms_iMouse );;
    *** **************************************************** **/

    aac2020_graquad_inited=( 777 );return;
}
void FN(Init)( void ){
     fn(Init)(      );
}

//:DONT_DO_THIS:=============================================://
/** ******************************************************** ***

    PRIVATE_FUNCTION( static void )
    fn( OnWindowResize )( void ){

        //[   OnWindowResize is leftover from TESAWIND.H     ]//
        //[   AAC2020 should have less convoluted logic      ]//
        //[   by centralizing all of the resize logic for    ]//
        //[   different libraries in our library chain.      ]//
        //[   LIBCHAN==Library_Chain                         ]//

//:     //:A "BEFORE" COG window resize function pointer?
//:     if( tesawind.data.onn_win_riz.top.HAS_FUN ){
//:         tesawind.data.onn_win_riz.top.FUN_ADD( );
//:     };;

        
            //:Any resize code for 
            //:THIS_LIBRARY/SELF/TESAWIND.H
            //:goes here.

            //+ The previous library in our library chain    +//
            //+ From when we had a library chain of discrete +//
            //+ projects that could be isolated and compiled +//
            //+ on their own if need be.                     +//
            //- COG_FitViewportToWindow(); -//


//:     //:A "BEFORE" COG window resize function pointer?
//:     if( tesawind.data.onn_win_riz.bot.HAS_FUN ){
//:         tesawind.data.onn_win_riz.bot.FUN_ADD( );
//:     };;

    }

*** ******************************************************** **/
//:=============================================:DONT_DO_THIS://
//:DONT_DO_THIS:=============================================://

    PRIVATE_FUNCTION( static void )
    fn( CheckForWindowResizeFlagAndAct )( void ){
    //:ga_CheckForWindowResizeFlagAndAct

        /** This old code used threading to do it's work.    **/
        /** We want to avoid this if we can, as threading    **/
        /** our code makes it really easy to get weird       **/
        /** running code due to the lack of....              **/
        /** memory consistency...                            **/
        /** AND... coherency.                                **/
        /**                                                  **/
        /** CONSISTENCY: Ordering of processor operations.   **/
        /**   COHERENCY: Memory caches storing same values.  **/
    
        //: LONG64 val=(
        //:     ENGETHER.THREADING.
        //:     InterlockedExchangeAcquire64(
        //:     &(GINAWIN.THREAD_SAFE_FLAGS.
        //:         resize_message_count), 0
        //:     )
        //: );;
        //: 
        //: //:ga_completed_loop_ticks
        //: int completed_loop_ticks =(
        //:     tesawind.data.COM_LOP_TIK
        //: );;
        //: 
        //: //:#AVOID_DOUBLE_REDRAW_ON_STARTUP#://
        //: if( val > 0                     ){
        //: if( completed_loop_ticks > 0    ){
        //: 
        //:     int v = (int)val;
        //:     printf("[ga_~resizeCheck~:v]:%d\n", v );
        //:     fflush(stdout);
        //: 
        //:     fn( OnWindowResize )( );
        //: 
        //: }};;
    
    }
//:=============================================:DONT_DO_THIS://
//:DONT_DO_THIS:=============================================://
/** ******************************************************** ***
    //:tesawind_DestructiveRead_IsRedrawFlagSet
    //:#NOT_THE_REDRAW_YOU_THINK#://
    PRIVATE_FUNCTION( static int )
    fn(DestructiveRead_IsRedrawFlagSet)( void ){

        //[ ************************************************ ]//
        //[ If it uses "ENGETHER" remove it!                 ]//
        //[ Engether is for multi-threading. And             ]//
        //[ my experience is that it is way too easy         ]//
        //[ to make hard to find mistakes.                   ]//
        //[                                                  ]//
        //[ Even worse is incorrect threading code will      ]//
        //[ behave inconsistently. Which means it can        ]//
        //[ fail at seemingly random spots.                  ]//
        //[                                                  ]//
        //[ Similiar to a "memory stomp"'s bad               ]//
        //[ behavior.                                        ]//
        //[                                                  ]//
        //[ -John Mark Issac Madison DATE[2020_11_03]        ]//
        //[ ************************************************ ]//

        //- //#UNCERTAIN_ABOUT_INTERLOCKED_EX#//   -//
        //- LONG64 val=(                           -//
        //-     ENGETHER.THREADING.                -//
        //-     InterlockedExchangeAcquire64(      -//
        //-        &(GINAWIN.THREAD_SAFE_FLAGS.    -//
        //-          redraw_message_count), 0      -//
        //-     )                                  -//
        //- );;                                    -//
        //-                                        -//
        //- if( val>0 ){ return 1; }               -//
        //- return( 0 );                           -//

        return( 0 );
    } 
*** ******************************************************** **/
//:=============================================:DONT_DO_THIS://
//:DONT_DO_THIS:=============================================://

    PRIVATE_FUNCTION( void )
    fn( HandleWindowLoopMessage_WM_PAINT )(void){

        /** This is too complex. Just have window code       **/
        /** call a function pointer that calls's this        **/
        /** librarie's "loopTick" function to update the     **/
        /** graphics. No mutex/semaphore bullshit.           **/

        //- //:#NOT_THE_REDRAW_YOU_THINK#://                 -//
        //- int should_redraw=(                              -//
        //-                                                  -//
        //-     //#UNCERTAIN_ABOUT_INTERLOCKED_EX#//         -//
        //-     fn(DestructiveRead_IsRedrawFlagSet)()        -//
        //-                                                  -//
        //- );;                                              -//
        //- if( should_redraw > 0 ){                         -//
        //-     //[[TODO]: Figure out how to trigger   ]//   -//
        //-     //[redraw flag at proper screen refersh]//   -//
        //-     //[rate.                               ]//   -//
        //-     printf("[tesawind:should_redraw]\n");        -//
        //- };;                                              -//
                                                        
    }

//:=============================================:DONT_DO_THIS://
//:SHADER_UNIFORM_RE_LOADING:================================://


    /** DATE[ 2020_11_17 ] ********************************* **/
    /**                                                      **/
    /** These functions were ripped out of BASUNIF           **/
    /** And refactored from callback functions to            **/
    /** Functions that update by using values                **/
    /** Stored in CPUNIFO                                    **/
    /**                                                      **/
    /** ********************************* DATE[ 2020_11_17 ] **/

    //:RE_LOAD_SHADER_UNIFORMS:iMouse:=======================://
    #define U32 uint32_t /** GCC: <stdint.h> **/

        U32 
        aac2020_graquad_ReLoadShaderUniforms_iMouse(
            U32 u32
        )
        {
            if( u32 ){ /** Reserved For Future Use **/ };;

            //:GET_HANDLE_TO_MEMORY_ADDRESS:-----------------://
            #define POG_IID  (aac2020_graquad.data.POG_IID)
            int /** GLint **/ f32_loc =(
                AAC2020_GLEBIND.glGetUniformLocation(
                    POG_IID      //:Program:Program_Integer_ID
                ,  "iMouse"      //:Shader[uniform/var]in:GLSL
                )
            );;
            #undef  POG_IID
            //:-----------------:GET_HANDLE_TO_MEMORY_ADDRESS://
            //:SET_VALUE_AT_MEMORY_ADDRESS:------------------://
            #define F32 float /** 32 bits even on X64 **/
               
                //:Removed: Mouse XY printf debugging.

                //:SET__UNIFORM:- - - - - - - - - - - - - - -://
                AAC2020_GLEBIND.glUniform4f(
                    f32_loc
                ,   ( F32 ) AAC2020_CPUNIFO_iMouse_vec4_x
                ,   ( F32 ) AAC2020_CPUNIFO_iMouse_vec4_y

                    /** [ vec4_z , vec4_w ] **************** **/
                    /** I don't fully understand these yet   **/
                    /** But they communicate if you are      **/
                    /** currently clicking or dragging.      **/
                    /** And LOCATE where that is happening.  **/
                    /** ************************************ **/

                ,   ( F32 ) AAC2020_CPUNIFO_iMouse_vec4_z
                ,   ( F32 ) AAC2020_CPUNIFO_iMouse_vec4_w
                );;      
                //:- - - - - - - - - - - - - - -:SET__UNIFORM://

            #undef  F32
            //:------------------:SET_VALUE_AT_MEMORY_ADDRESS://
        
            return( 0x00 );

        }

    #undef  U32
    //:=======================:RE_LOAD_SHADER_UNIFORMS:iMouse://
    //:RE_LOAD_SHADER_UNIFORMS:iTime:========================://
    #define U32 uint32_t /** GCC: <stdint.h> **/

        /** This also increments iTime **/
        U32  
        aac2020_graquad_ReLoadShaderUniforms_iTime()
        {
            #define POG_IID  (aac2020_graquad.data.POG_IID)
            int /** GLint **/ f32_loc =(
                AAC2020_GLEBIND.glGetUniformLocation(
                    POG_IID      //:Program:Program_Integer_ID
                ,  "iTime"       //:Shader[uniform/var]in:GLSL
                )
            );;
            #undef  POG_IID

            #define F float //:##############################://
            AAC2020_GLEBIND.glUniform1f(
                f32_loc
            ,   ( F ) AAC2020_CPUNIFO_iTime
            );;       

            #undef  F //:####################################://
        
            return( 0x00 );
        }

    #undef  U32
    //:=======================:RE_LOAD_SHADER_UNIFORMS:iTime://
    //:RE_LOAD_SHADER_UNIFORMS:iResolution:==================://
    #define U32 uint32_t /** GCC: <stdint.h> **/

        U32  
        aac2020_graquad_ReLoadShaderUniforms_iResolution(
            U32 u32
        )
        {
            if( u32 ){ /** Reserved For Furture Use **/ };

            #define POG_IID  (aac2020_graquad.data.POG_IID)
            int /** GLint **/ f32_loc =(
                AAC2020_GLEBIND.glGetUniformLocation(
                    POG_IID      //:Program:Program_Integer_ID
                ,  "iResolution" //:Shader[uniform/var]in:GLSL
                )
            );;
            #undef  POG_IID

            #define F float //:##############################://
            //: khronos.org/.../gl4/html/glUniform.xhtml     ://
            //: e.g.,glUniform3f or glUniform3fv can be used ://
            //: to load a uniform variable array of type vec3://
            AAC2020_GLEBIND.glUniform3f(
                f32_loc
            ,   ( F ) AAC2020_CPUNIFO_iResolution_wid
            ,   ( F ) AAC2020_CPUNIFO_iResolution_hig
            ,   ( F ) AAC2020_CPUNIFO_iResolution_par
            );;                    
            #undef  F //:####################################://
        
            return( 0x00 );
        }

    #undef  U32
    //:==================:RE_LOAD_SHADER_UNIFORMS:iResolution://

//:================================:SHADER_UNIFORM_RE_LOADING://

PRIVATE_FUNCTION( static void )
fn( LoopTick )( void ){
    /** AKA: aac2020_graquad_LoopTick **/
    //:GA_LoopTick  //:#ORIGINALLY_GA_LOOPTICK#

    //:UPDATE_BASIC_UNIFORMS:--------------------------------://
    /** Originally this code called from the future using    **/
    /** a callback. But decided.                             **/
    /**                                                      **/
    /** 1: Calling from future violates LIBCHAN design.      **/
    /** 2: Callbacks made the code harder to follow.         **/
    /**    Avoid them when possible.                         **/
    /**                                                      **/
    /**    (Still a fan of using callback to create   )      **/
    /**    (abstract classes, like my tilemap entities)      **/
    /**    (that exist by rendering themselves as     )      **/
    /**    (tiles on a tilemap using function pointers)      **/
    /**    (to GetTile and SetTile functions.         )      **/
    /**  * * * * * * * * * * * * *** * * * * * * * * * * * * **/

        aac2020_graquad_ReLoadShaderUniforms_iMouse      (0x00);
        aac2020_graquad_ReLoadShaderUniforms_iTime       (0x00);
        aac2020_graquad_ReLoadShaderUniforms_iResolution (0x00);

    //:--------------------------------:UPDATE_BASIC_UNIFORMS://

    
    /** **************************************************** **/
    /** Originally called:                                   **/
    /** aac2020_graquad_ReLoadShaderUniforms_iTime();        **/
    /** But refactored all uniforms into "BASUNIF.F._"       **/
    /**                                                      **/
    /** This is a bit convoluted, so let's do our best       **/
    /** to keep notes so people in the future can find       **/
    /** where this is happening.                             **/
    /**                         FFU:From_Future_Update       **/
 //        if( aac2020_graquad_FFU_iTime_HAS ){             ///
 //            aac2020_graquad_FFU_iTime_PFN( 0x00 );       ///
 //        };;            /**  FFU:From_Future_Update **/   ///
    /**                                                      **/
    /**                                                      **/
    /** **************************************************** **/

    //[ GUTTED_THIS_FUNCTION. Does_Nothing. ]//
    fn( HandleWindowLoopMessage_WM_PAINT )( );

    int /** BOOL **/ make_current_worked=(
    AAC2020_GLEBIND_wglMakeCurrent(
    /**/AAC2020_GINAWIN_GetWinDC_ExistsNoWait()
    ,   AAC2020_GLEBIND.handle_to_gl_rendering_context
    ));;if(!make_current_worked){
        //:MCF_ILT:MakeCurrentFailInLoopTick
        fn(Halt)("[MCF_ILT]"); 
    };;

    //[ GUTTED_THIS_FUNCTION. Does_Nothing. ]//
    fn( CheckForWindowResizeFlagAndAct )( ); 
   

    AAC2020_GLEBIND.glClearColor(0.0f,0.1f,0.5f, 1.0f);

    #if(MACRO_AAC2020_GRAQUAD_DEBUG_MODE>=1) ////////////
    fn(ErrChk)("[glClearColor]"); //#<<<<<<<<<<<<<<<PerformanceHit/[MAN_HIT]? #//
    #endif ///////////////////////////////////////

    AAC2020_GLEBIND.glClear( 
        AAC2020_GLEBIND.MAS.gl_color_buffer_bit
    );;

    #if(MACRO_AAC2020_GRAQUAD_DEBUG_MODE>=1) ////////////
    fn(ErrChk)("[glClear]"); //#<<<<<<<<<<<<<<<<<<<<<PerformanceHit/[MAN_HIT]? #//
    #endif ///////////////////////////////////////

    //:######################################################://
    #define GLE unsigned int /** GLenum **/ //:##############://

        GLE err; /** GLenum:err **/

    #undef  GLE //:##########################################://
    //:######################################################://

    glBindVertexArray(
        aac2020_graquad.data.tri.ga.VAO
    );;fn(ErrChk)("[2019_08_04_0518PM]");
    //:     LoopTick:glBindVertexArray

    int four_4_quad=(
        aac2020_graquad.data
       .we_have_4_corner_verts_making_quad
    );;
    
    //: Draw the triangle !
    AAC2020_GLEBIND.glDrawArrays(
    /**/AAC2020_GLEBIND.MOD.gl_triangle_strip
    ,   0  //: Starting from vertex 0;
    ,   four_4_quad
    );;
    err = AAC2020_GLEBIND.glGetError();
    if( err != AAC2020_GLEBIND.ERR.gl_no_error ){
        fn(Halt)("[FAIL:glDrawArrays]");
    };; 

    AAC2020_GINAWIN_SwapBuffers();
    
    //[ DON'T DO THIS.                         ]//
    //[ Your triangle will vanish!             ]//
    //- AAC2020_GLEBIND.glDisableVertexAttribArray(0);    -//
    //- fn(ErrChk)("[DisVerAttArr]");          -//

    //: ga_completed_loop_ticks++;
    aac2020_graquad.data.COM_LOP_TIK++;

}

//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://
//:PUBLIC_LOOP_TICK:=========================================://
#define U32 uint32_t /** GCC: <stdint.h> **/

    U32
    AAC2020_GRAQUAD_LoopTick( U32 u32 )
    {
        if( u32 ){ /** Reserved For Future Use **/ };

        /** Public version of LoopTick. **/
        /** ADDED[DATE[2020_11_03]]     **/
        /** To use with AAC2020.C11     **/

        aac2020_graquad_LoopTick();

        return( 0x00 );
    }

#undef U32
//:=========================================:PUBLIC_LOOP_TICK://
//: - - - - - - - - - - - - - ---- - - - - - - - - - - - - - ://

//:tesawind_Loop( )
PRIVATE_FUNCTION( void )
fn( Loop )( void ){

    while( AAC2020_GINAWIN_IsWindowStillOpen() > 0 ){
    
        aac2020_graquad_LoopTick();
        
    };;

}

//:DONT_DO_THIS:=============================================://

    /**  We wrapped these functions because this code came   **/
    /**  from a previous project where we chained together   **/
    /**  discrete compilable projects into larger projects.  **/
    /**                                                      **/
    /**  The library chain of AAC2020 is not composed to     **/
    /**  discrete projects, only discrete sub libraries      **/
    /**  that are chained together.                          **/
    /**                                                      **/
    /**  Wrapping function calls of previous library like    **/
    /**  this does not make sense in AAC2020 and only serves **/
    /**  to:                                                 **/
    /**       1. Increase code surface area "BAD"            **/
    /**       2. Make more than one way to do the            **/
    /**          same thing. Also "BAD".                     **/

    //- PRIVATE_FUNCTION( static void )                      -//
    //- fn( Wait )( void ){                                  -//
    //-                                                      -//
    //-     COG_Wait(); //:#ABOUT_TESAWIND_Wait#://          -//
    //-                                                      -//
    //- }                                                    -//
    //- void FN( Wait )( void ){                             -//
    //-      fn( Wait )(      );                             -//
    //- }                                                    -//

//:=============================================:DONT_DO_THIS://


TD(void) (*AAC2020_GRAQUAD_PFN_Test)( void );
RT(void)   AAC2020_GRAQUAD_Test(        void ){

    printf("[TODO:AAC2020_GRAQUAD_Test()...]\n");
}

TD(void) (*AAC2020_GRAQUAD_PFN_Ping)( void );
RT(void)   AAC2020_GRAQUAD_Ping(      void ){
    
    printf("[HelloFrclearom:AAC2020_GRAQUAD]\n");

}


//:REMOVED_BECAUSE_NO_LONGER_A_PROJECT_IN_ITSELF:============://

    /** The library chain of AAC2020 is discrete             **/
    /** SUB-libraries that can be chained together.          **/
    /** Previously this code was part of discrete            **/
    /** PROJECTS that could be chained together.             **/
    /**                                                      **/
    /** Call them:                                           **/
    /**     DIPCHAN : DIscrete Project Chain                 **/
    /**     LIBCHAN : LIbrary  Chain (using sub libraries)   **/

    //- //|IQ:[IGNITE|QUENCH]__________________________|//   -//
    //- //|                                            |//   -//
    //- //|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|//   -//
    //- TD(void) PO( Ignite )( void );                       -//
    //- RT(void) FN( Ignite )( void ){                       -//
    //-                                                      -//
    //-     tesawind_Init( );                                -//
    //-     tesawind_Loop( );                                -//
    //-     tesawind_Wait( );                                -//
    //-                                                      -//
    //- }                                                    -//
    //- //|-  --  --  --  --  --  --  --  --  --  --  -|//   -//
    //- TD(void) PO( Quench )( void );                       -//
    //- RT(void) FN( Quench )( void ){                       -//
    //-                                                      -//
    //-     printf("[TODO:Quench:AAC2020_GRAQUAD]\n");              -//
    //-                                                      -//
    //- }                                                    -//
    //- //|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|IQ|//   -//
    //- //|____________________________________________|//   -//
    //-                                                      -//
    //-                                                      -//
    //-                                                      -//
    //- //|DM:[DEMO]___________________________________|//   -//
    //- //|                                            |//   -//
    //- //|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|//   -//
    //- TD(void) (*AAC2020_GRAQUAD_PFN_Demo)( void );               -//
    //- RT(void)   AAC2020_GRAQUAD_Demo(      void ){               -//
    //-                                                      -//
    //-     AAC2020_GRAQUAD_Ping(   );                              -//
    //-     AAC2020_GRAQUAD_Ignite( );                              -//
    //-                                                      -//
    //- }                                                    -//
    //- //|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|DM|//   -//

//:============:REMOVED_BECAUSE_NO_LONGER_A_PROJECT_IN_ITSELF://
//:ALLOW_FOR_RE_LOADING_DIFFERENT_FRAGMENT_SHADERS:==========://


    int
    AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed(
        const char* const frag_shader_str
    ,   const  int        frag_shader_len
    )
    {
        /** SUMMARY: Hackishly switch fragment shaders by:   **/
        /**          1. Inject your own fragment shader.     **/
        /**          2. Hijack relevant initializers.        **/
        /**                                                  **/
        /** One sentence summary:                            **/
        /**     Re-use library initialization code to        **/
        /**     load arbitrary fragment shader source.       **/

        //:RELOAD_FRAGMENT_SHADER:---------------------------://
        //[DO_NOT_EXTRACT_CODE_TO_FUNCTION:------------------]//

            /** * * #DO_NOT_EXTRACT:COPY_PASTE_PAIR:001# * * **/
 

            //:Make sure reported length of shader matches
            //:the length we find when using strlen(...).
            int len_chk=( strlen( frag_shader_str ));
            if( len_chk        != frag_shader_len ){
                aac2020_graquad_Halt("[SHADER_LEN_CHK_FAIL]");
            };;

            //: Alter shader reference set in: fn( Init_Data )( );
            aac2020_graquad.data.FAG_SAD_SRC=(
                frag_shader_str
            );;

            //:BGP_OpenGL:-----------------------------------://
            //:Re-build your entire shader pipeline:
            //:fn( Init_NotSureWhatToCallThis_GLSetup )( );
            aac2020_graquad_BGP_OpenGL( 

                /** If fail, crash immediately, because  * * **/
                /** errors in "frag_shader_str" are not  * * **/
                /** allowed.                             * * **/
                AAC2020_GRAQUAD_FAIL_FAST 
            );; //:-------------------------------:BGP_OpenGL://

            //:After re-building shader pipeline, re-load
            //:your "built-in" / "standard" uniforms.
            //:(The ones YOU (JMIM) say are standard)
            //: AAC2020_GRAQUAD_ReLoadShaderUniforms_iResolution();

        //[------------------:DO_NOT_EXTRACT_CODE_TO_FUNCTION]//
        //:---------------------------:RELOAD_FRAGMENT_SHADER://

        return( 0 );
    }

    int
    AAC2020_GRAQUAD_RFS_HACKTEST(void)
    {            //:RFS:ReLoadFragShader
        /** AKA: ReLoadFragShader_HACKTEST                   **/
        /**                                                  **/
        /** A hackish test of "ReLoadFragShader".            **/
        /** If no visible effect when ran after              **/
        /** library initialization, we will assume           **/
        /** it was successful.                               **/

        //:AKA[ AAC2020_GRAQUAD_RFS ]
        AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed(
                    aac2020_graquad_fag_sad_src
        ,   strlen( aac2020_graquad_fag_sad_src )
        );;

        return( 0 );
    }

    int
    AAC2020_GRAQUAD_RFS_StatusReady(void)
    {            //:RFS:ReloadFragShader
        /** AKA: ReLoadFragShader_StatusReady                **/
        /**                                                  **/
        /**  Call ReLoadFragShader(...) with shader code     **/
        /**  that notifies you things are okay.              **/

        const char* frag_shader_str=(
            AAC2020_GRAQUAD_FRAG_iready
        );;
        int frag_shader_len=( strlen( frag_shader_str ) );

        //:AKA[ AAC2020_GRAQUAD_RFS ]
        AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed(
            frag_shader_str
        ,   frag_shader_len
        );;

        return( 0 );
    }

    int
    AAC2020_GRAQUAD_RFS_StatusSyntaxError(void)
    {
        /**  AKA:  ReLoadFragShader_StatusSyntaxError        **/
        /**                                                  **/
        /**  Call ReLoadFragShader(...) with shader code     **/
        /**  that notifies you things are [BAD/ERROR].       **/
    
        const char* frag_shader_str=(
            AAC2020_GRAQUAD_FRAG_synerr
        );;
        int frag_shader_len=( strlen( frag_shader_str ) );
    
        //:AKA[ AAC2020_GRAQUAD_RFS ]
        AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed(
            frag_shader_str
        ,   frag_shader_len
        );;
    
        return( 0 );
    }

    #define U32 uint32_t /** GCC: <stdint.h> **/
    U32
    AAC2020_GRAQUAD_ReLoadFragShader_SyntaxErrorsOk(
        const char* const frag_shader_str
    ,   const  int        frag_shader_len
    ){

        assert( 0   == AAC2020_GRAQUAD_LOAD_STATUS_OK     );
        assert( 606 == AAC2020_GRAQUAD_LOAD_STATUS_SYNERR );
        assert( 404 == AAC2020_GRAQUAD_LOAD_STATUS_NOT_SET);

        U32 load_status=(AAC2020_GRAQUAD_LOAD_STATUS_NOT_SET);


        //:RELOAD_FRAGMENT_SHADER:---------------------------://
        //[DO_NOT_EXTRACT_CODE_TO_FUNCTION:------------------]//

            /** * * #DO_NOT_EXTRACT:COPY_PASTE_PAIR:001# * * **/

            //:Make sure reported length of shader matches
            //:the length we find when using strlen(...).
            int len_chk=( strlen( frag_shader_str ));
            if( len_chk        != frag_shader_len ){
                aac2020_graquad_Halt("[SHADER_LEN_CHK_FAIL]");
            };;

            //: Alter shader reference set in: fn( Init_Data )( );
            aac2020_graquad.data.FAG_SAD_SRC=(
                frag_shader_str
            );;

            //:Re-build your entire shader pipeline:
            load_status =(
                fn( BGP_OpenGL )( AAC2020_GRAQUAD_FAIL_CODE )
            );;

            //:After re-building shader pipeline, re-load
            //:your "built-in" / "standard" uniforms.
            //:(The ones YOU (JMIM) say are standard)
            //: AAC2020_GRAQUAD_ReLoadShaderUniforms_iResolution();
        

        //[------------------:DO_NOT_EXTRACT_CODE_TO_FUNCTION]//
        //:---------------------------:RELOAD_FRAGMENT_SHADER://
        //:LOAD_STATUS:VALID_SHADER_CODE_LOADED?:------------://
    
        if( //: AKA:AAC2020_GRAQUAD_LOAD_STATUS_SUCCESS
                    AAC2020_GRAQUAD_LOAD_STATUS_OK
        == load_status
        ){

            //+ OK: Do nothing. ++++++++++++++++++++++++++++ +//

        }else
        if( //:AKA: AAC2020_GRAQUAD_LOAD_STATUS_SYNTAX_ERROR
                    AAC2020_GRAQUAD_LOAD_STATUS_SYNERR
        == load_status
        ){
            //-BAD: Notify user with error message shader. - -//

            //:Indirectly_Call:                              ://
            //:AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed
            //:                                              ://
            //:By calling: Reload_Fragment_Shader(RFS)       ://
            //:With out shader that displays "synerr"        ://
            //:to notify user of a syntax error.             ://
            AAC2020_GRAQUAD_RFS_StatusSyntaxError();
   
        }else
        if( AAC2020_GRAQUAD_SHADER_FAIL
        ==      load_status
        ){

            /** Probably a syntax error in user supplied     **/
            /** Fragment shader. So that is what we will     **/
            /** show to user.                                **/
            AAC2020_GRAQUAD_RFS_StatusSyntaxError();

        }else
        if( AAC2020_GRAQUAD_CURCON_FAIL
        ==  load_status
        ){
                 
            /** If reason for failure was a failure to set   **/
            /** current opengl context... I have no way to   **/
            /** recover gracefully. So always fail fast.     **/
            aac2020_graquad_Halt("[No_Way_To_Fail_Gracefully]");

        }else{

            printf("[load_status]:(((%d)))\n", load_status );
            aac2020_graquad_Halt("[Bad_Load_Status]"); 

        };;
        //:------------:LOAD_STATUS:VALID_SHADER_CODE_LOADED?://

        
        return( load_status );
    }
    #define U32 uint32_t /** GCC: <stdint.h> **/


//:
//:==========================================================://
//::::::::::::NO_FUNCTIONS_BELONG_BELOW_THIS_POINT:::::::::::://
//:==========================================================://

#undef  MACRO_AAC2020_GRAQUAD_DEBUG_MODE ///////////////////////

//|//////////////////////////////////////////////////////////|//
//|     -///-                                      -\\\-     |//
//|....(( 0 ))|| ||_ _--                --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __   ||      ||   __  __  __      __  _|//
//| \/  \    /  \/  \/  \______________/  \/  \/  \    /  \/ |//
//|      \  /                                      \  /      |//
//|       \/                                        \/       |//
//+ BEG:       ##BOTTOMOF_FILE_COMMENTS_SECTION##            +//
//|           /\                                /\           |//
//|          /  \        ______________        /  \          |//
//|_--__--__/    \__/\__/              \__/\__/    \__--__--_|//
//|                                                          |//
//|       ____________________________________________       |//
//|______/                                            \______|//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||

#DO_NOT_EXTRACT:COPY_PASTE_PAIR:001#

    Two of these tags are in two different code blocks.
    You might notice the code blocks are the SAME or slightly
    different. Do NOT try to make a common 3rd utility
    function.

    We need to reserve the right for the functions
    below to DIVERGE in the future in terms of how
    they perform their fragment shader loading logic.

    AAC2020_GRAQUAD_ReLoadFragShader_ErrorsNotAllowed
    AAC2020_GRAQUAD_ReLoadFragShader_SyntaxErrorsOk
                                                   
#AVOID_PLURALITY#
    Do NOT use plural forms of words.   
    1. Increases mental search space.
    2. Plurality is NOT consistent in english.
       EX: Deer, Sheep, Octopi, Octopuses

#ABOUT_AAC2020_GRAQUAD_Wait#
    Just a wrapper for COG_Wait, the idea is
    to try to de-couple the libraries I am 
    chaining together.

    Think of each library as a coarse grain
    module. No library should be so big that
    it is unaffordable to scrap it and 
    re-write it.

    I am treating code more like building houses.
    Need a new garage? Tear down the old one
    with a bulldozer, and build a new garage.
    
    Need a new bathroom?
    Tear apart the whole thing and re-model.

    Need a new sink? No you don't.

    Need a new sink, toilet, and shower.
    Okay, let's tear down the bathroom.

    The sink is really broken? Are you sure?
    The only thing wrong with the bathroom is
    the sink?
    
    Okay... Tear down the entire bathroom then
    and make a new bathroom.

    Yes, a bit crazy. But the idea is course
    grain modularity and course grain refactoring.

#AAC2020_GLEBIND(LIBRARY)ERROR#
#CheckFileNameSpelling#
    Fix: You probably need:
    OPEN_GL_SEARCH_PATHS.TXT
    OPEN_CL_SEARCH_PATHS.TXT
    In the same folder as wherever the
    executable will be generated.

#UNCERTAIN_ABOUT_INTERLOCKED_EX#
    (I am uncertain about interlocking exchange)
    Looking over the code. I think it actually
    might be correct. However this was written
    before I knew anything about how to properly
    use atomic objects. Hence the worry.

    ----------------------------------------------

    I did not know what I was doing   
    and pretty sure this uses         
    "InterlockingExchange" commands   
    in the WRONG way.                 
                                      
    [TODO] : Potential_Code_Killer    
    [WARN] : Potential_Code_Killer  

    ----------------------------------------------

#LAYOUT_INDEX_SHOULD_BE_PRE_APPROVED#
    layout_index should be one   
    of the expected values.      


#ITS_A_GOOD_HABIT_LIKE_NULLING_POINTERS#

    #GOOD_PRACTICE_LIKE_NULLING_POINTERS#
    #A_GOOD_PRACTICE_LIKE_NULLING_POINTERS#
    #YOU_CAN_UNBIND_WHEN_YOU_ARE_FINISHED# 
    #GOOD_PRACTICE_LIKE_NULLING_POINTERS#  

    note that this is allowed, 
    the call to glVertexAttribPointer 
    registered VBO as the vertex attribute's 
    bound vertex buffer object so afterwards 
    we can safely unbind

#UNBIND_VERTEX_ARRAY_WHEN_DONE_HABIT#
    You can unbind the VAO afterwards so    
    other VAO calls won't accidentally      
    modify this VAO,but this rarely         
    happens. Modifying other                
                                            
    VAOs requires a call to                 
    glBindVertexArray anyways so we         
    generally don't unbind VAOs (nor VBOs)  
    when it's not directly necessary.       
    SOURCE[SC[ logl-hellotri-scr-url ]]     

#GET_THAT_FUCKING_STRIDE#
    The offset in datum (bytes or elements)
    to the next element of the same type.
    SEE[ SC[ AHK_STRIDE_IMAGE ] ]

#CONVOLUTED_BUT_I_WILL_ALLOW_IT#
    If failed, it coulde be because
    the window was closed while the loop
    was running. The window loop being on
    a different thread could make this
    possible.
    NOTE: is_window_still_open really
        should be a proper mutex.
    UPDATE:2019_08_04:
        This code looks kinda hackish
        to me, but doesn't look like it
        is breaking anything, so allow
        it to be convoluted.
    
#NAFOMEP#
    Not a fan of multiple exit points

#ORIGINALLY_GA_LOOPTICK#
    Function is a refactor of GA_LoopTick
    in GAKU.H (NOT GAKU02.H)

#AVOID_DOUBLE_REDRAW_ON_STARTUP#
    I've observed the first time (val>0),
    the window hasn't been resized by user
    but rather just adjusted for init.
    Avoid double re-draw at startup by
    gaurding with (ga_completed_loop_ticks>0)

iResolution:
    Using the same variable name as that used in SHADERTOY.
    Being able to cut+paste [to|from] shadertoy should be
    advantageous.

#FEATURE:FAULT_TOLERANT_USER_FRAG_SHADERS#

    Some refactoring to prevent program from executing
    "fail fast" code when problem of re-making the
    open-gl pipeline is because of end-user loaded
    fragment shader code. DATE[ 2002_11_06 ]

ADDFOR : 
    Means "Added For"
    Specifically, what feature was this added for?

aac2020_graquad_BGP_OpenGL:

    BGP_OpenGL: BuildGraphicsPipeline - OpenGL
    Originally Called: Init_NotSureWhatToCallThis_GLSetup
    But that function name is:
    
    1: Gives less information.
    2: Is way too many columns long in characters.

#WHY_EVERYTHING_FAILS_FAST_HERE_IN_BGP#

    /:: Everything else. Right now, all of this will     ::/
    /:: FAIL_FAST ( AAC2020_GRAQUAD_FAIL_FAST )          ::/
    /:: Because  FAIL_CODE ( AAC2020_GRAQUAD_FAIL_CODE ) ::/
    /:: was implemented to make feature:                 ::/
    /::                                                  ::/
    /:: #FEATURE:FAULT_TOLERANT_USER_FRAG_SHADERS#       ::/
    /::                                                  ::/
    /:: Possible.                                        ::/

#WHY_WGL_PRINTF_HERE#
#WHY_WGL_FAIL_PRINTF_HERE#

    //: So I can find:                             ::://
    //: AAC2020_GRAQUAD_BGP_STATUS_WGL_FAIL, while ::://
    //: still using unique hard coded error codes  ::://
    //: for aac2020_graquad_HOS(...)               ::://

#HCF_ASO_BREAKAGE#:
#HFC_ASO_BREAKAGE#:

    HFC_ASO_BREAKAGE: 
        HFC:::::: Hardcode_Failure_Code
        ASO:::::: At_Site_Of
        BREAKAGE: BREAKAGE

    //:AAC2020_GRAQUAD_BGP_STATUS_WGL_FAIL://
    //:Hardcode failure status at site of breakage:::://

A4:
    Added_For:
    What feature was some code added for?
                                                   
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|¯¯¯¯¯¯\                                            /¯¯¯¯¯¯|//
//|       ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯       |//
//|                                                          |//
//|¯--¯¯--¯¯\    /¯¯\/¯¯\              /¯¯\/¯¯\    /¯¯--¯¯--¯|//
//|          \  /        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯        \  /          |//
//|           \/                                \/           |//
//+ BEG:       ##BOTTOMOF_FILE_COMMENTS_SECTION##            +//
//|       /\                                        /\       |//
//|      /  \                                      /  \      |//
//|_/\__/    \__/\__/\__/¯¯¯¯¯¯¯¯¯¯¯¯¯¯\__/\__/\__/    \__/\_|//
//|....                    ||      ||                    ....|//
//|    (( 0 ))|| ||¯ ¯--                --¯ ¯|| ||(( 0 ))    |//
//|     -###-                                      -###-     |//
//|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|//






//:tessawin.data WRONG
//:tesawin.data  WRONG
//:tesawind.data YEAH!
//:12345678

//:MACROS:ROOT_LEVEL_OOP.TOP:================================://

    //:REDEFINE_REDUNDANCY_TO_ASSERT_CORRECT_VALUES:=========://

    //:INCLUDE AFTER ANY CLASSES (If any)
    //: #include "00/OOP/ROOT_LEVEL_OOP.TOP._"
    
    #define                MACRO_GXY(x, y) x##y 
    #define RL_FuNaM(x, y) MACRO_GXY(x, y)
    #define      LIB_PFN  AAC2020_GRAQUAD_PFN_ //:  PFN
    #define      LIB_VIS  AAC2020_GRAQUAD_ //:PUBLIC/VISIBLE
    #define      lib_hid  aac2020_graquad_ //:PRIVATE/HIDDEN
    #define POM( n )   RL_FuNaM( LIB_PFN, n    )
    #define  PO( n ) (*RL_FuNaM( LIB_PFN, n    ) )
    #define  FN( n )   RL_FuNaM( LIB_VIS, n    )   
    #define  fn( n )   RL_FuNaM( lib_hid, n    )
    #define   H(msg)   fn(   Halt   )(   msg   )  
    #define  PRIVATE_FUNCTION( stuff ) stuff

    //:=========:REDEFINE_REDUNDANCY_TO_ASSERT_CORRECT_VALUES://
    //:UNDEFINE_AFTER_HACKISH_REDEFINE_CHECK:================://

    #undef  MACRO_GXY 
    #undef  RL_FuNaM 

    #undef  LIB_PFN  
    #undef  LIB_VIS  
    #undef  lib_hid  

    #undef  POM 
    #undef   PO 
    #undef   FN 
    #undef   fn 
    #undef    H 
    #undef   PRIVATE_FUNCTION 

    //:================:UNDEFINE_AFTER_HACKISH_REDEFINE_CHECK://

//:================================:MACROS:ROOT_LEVEL_OOP.TOP://
//:GRAQUAD_LIBRARY_MACROS:BOT:===============================://

    //:REDEFINE_REDUNDANCY_TO_ASSERT_CORRECT_VALUES:=========://

    #define  MACRO_LALODEX_verpos ((0)) //:VERtex____POSition
    #define  MACRO_LALODEX_texcoo ((1)) //:TEXture_COOrdinate

    #define  macro_rts( s ) #s
    #define  MACRO_RTS( s ) macro_rts( s )
             
    #define  TD(return_type) typedef return_type
    #define  RT(return_type)         return_type
    
    //:=========:REDEFINE_REDUNDANCY_TO_ASSERT_CORRECT_VALUES://
    //:UNDEFINE_AFTER_HACKISH_REDEFINE_CHECK:================://

    #undef   MACRO_LALODEX_verpos 
    #undef   MACRO_LALODEX_texcoo 

    #undef   macro_rts 
    #undef   MACRO_RTS 
  
    #undef   TD 
    #undef   RT 

    //:================:UNDEFINE_AFTER_HACKISH_REDEFINE_CHECK://
   

//:===============================:GRAQUAD_LIBRARY_MACROS:BOT://