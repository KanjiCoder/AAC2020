//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_rencore_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:aac2020_rencore]:%s\n", msg_err );
        fflush(stdout);
        exit( 189 );
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 01 ://
#define CHR const char                                //: 02 ://
#define ERR aac2020_rencore_Halt                      //: 03 ://

    void
    aac2020_rencore_Info_any(
        CHR*  str_fmt
    ,   void* dat_any   
    )
    { 
        I32 logging_is_on=( 0 - 1234 /**INVALID_VALUE**/ );
        
        #ifdef AAC2020_INCLUDE_SILENCE
        /** Compiled as part of main AAC2020 engine. **/
            
            if( AAC2020_SILENCE.RENCORE <= 0 ){
                logging_is_on=( 1 );
            }else
            if( AAC2020_SILENCE.RENCORE >= 1 ){
                logging_is_on=( 0 );
            }else{
                ERR("[WTF_ARE_YOU_DOING?]");
            };;

            /** @VID_IID[ 0128 ]TIME[ 03:33:33 ]ORIGINAL *** **/
            /** @VID_IID[ 0156 ]TIME[ 02:36:13 ]UPDATED **** **/
            /** Override turns of logging for ALL SYSTEMS.   **/
            if( AAC2020_SILENCE.SILENCE >=( 0+1 ) ){
                logging_is_on=( 0 ); //:EVERYONE_SHUT_UP
            }else
            if( AAC2020_SILENCE.SILENCE <=( 0-1 ) ){
                logging_is_on=( 1 ); //:EVERYBODY_SCREAM
            };;

        #else
        /** Compiled as stand-alone command line utility. **/

            logging_is_on =( 
                AAC2020_RENCORE_STAND_ALONE_ONLY_LOGGING_ON );;

        #endif

        //: 
        if( logging_is_on >= 1 ){
            /** Same Line As Next Printf **/
            printf("[rencore_log]....(   " ); fflush( stdout );
            printf( str_fmt , dat_any      ); fflush( stdout );
            printf(               "   )\n" ); fflush( stdout );
        }else
        if( 0 == logging_is_on ){
            /** do nothing **/
        }else{
            ERR("[YOUR_LOGGING_CONFIG_LOGIC_SUCKS_2021]");
        };;
        
    }

#undef  I32  //:----------------------------------------: 01 ://
#undef  CHR  //:----------------------------------------: 02 ://
#undef  ERR  //:----------------------------------------: 03 ://
//:===========================================:LOG_AFTER_HALT://
//:INFO_PRINT_STRING:========================================://
#define CHR const char
#define ERR aac2020_rencore_Halt

    /** **************************************************** **/
    /** It is a bit annoying to have lots of specific   **** **/
    /** logging functions like this when we could just  **** **/
    /** have one[ aac2020_rencore_Info_any ]function... **** **/
    /** But the casting nonsense you have to do with    **** **/
    /** [ aac2020_rencore_Info_any ]annoys the hell out **** **/
    /** of me. @VID_IID[ 0274 ]TIME[ 01:57:17 ]         **** **/
    /** **************************************************** **/

    void
    aac2020_rencore_Info_str( 
        CHR* msg_fmt /** Format String **/
    ,   CHR* msg_inf /** Information String **/
    )
    {
        if( ((CHR*)0) == msg_fmt ){ ERR("[NIL:msg_fmt]"); };
        if( ((CHR*)0) == msg_inf ){ ERR("[NIL:msg_inf]"); };
        
        aac2020_rencore_Info_any(
                msg_fmt
        ,   (void*)msg_inf
        );;
    }

#undef  CHR
#undef  ERR
//:========================================:INFO_PRINT_STRING://
//:INFO_PRINT_SIGNED_32_BIT_INT:=============================://
#define CHR const char                                //: 01 ://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 02 ://
#define I_P intmax_t /** GCC: <stdint.h> **/          //: 03 ://
#define ERR aac2020_rencore_Halt                      //: 04 ://

    void
    aac2020_rencore_Info_i32( 
        CHR* msg_fmt /** Format String **/
    ,   I32  msg_inf /** Information String **/
    )
    {
        if( ((CHR*)0) == msg_fmt ){ ERR("[NIL:msg_fmt:i32]"); };
    //- if( ((I32 )0) == msg_inf ) -//
        
        aac2020_rencore_Info_any(
                        msg_fmt
        ,   (void*)(I_P)msg_inf
        );;
    }

#undef  CHR  //:----------------------------------------: 01 ://
#undef  I32  //:----------------------------------------: 02 ://
#undef  I_P  //:----------------------------------------: 03 ://
#undef  ERR  //:----------------------------------------: 04 ://
//:=============================:INFO_PRINT_SIGNED_32_BIT_INT://
//:PRINT_NEWLINE_SPACES:=====================================://
#define I32 int32_t /** GCC: <stdint.h> **/
#define ERR aac2020_rencore_Halt

    void
    aac2020_rencore_Info_spc(
        I32 nos //:Number_Of_Spaces
    )
    {
        I32 logging_is_on=( 0 - 1234 /**INVALID_VALUE**/ );
        
        #ifdef AAC2020_INCLUDE_SILENCE
        /** Compiled as part of main AAC2020 engine. **/
            
            if( AAC2020_SILENCE.RENCORE <= 0 ){
                logging_is_on=( 1 );
            }else
            if( AAC2020_SILENCE.RENCORE >= 1 ){
                logging_is_on=( 0 );
            }else{
                ERR("[WTF_ARE_YOU_DOING?]");
            };;

            /** @VID_IID[ 0128 ]TIME[ 03:33:33 ]ORIGINAL *** **/
            /** @VID_IID[ 0156 ]TIME[ 02:36:13 ]UPDATED **** **/
            /** Override turns of logging for ALL SYSTEMS.   **/
            if( AAC2020_SILENCE.SILENCE >=( 0+1 ) ){
                logging_is_on=( 0 ); //:EVERYONE_SHUT_UP
            }else
            if( AAC2020_SILENCE.SILENCE <=( 0-1 ) ){
                logging_is_on=( 1 ); //:EVERYBODY_SCREAM
            };;

        #else
        /** Compiled as stand-alone command line utility. **/

            logging_is_on =( 
                AAC2020_RENCORE_STAND_ALONE_ONLY_LOGGING_ON );;

        #endif

        //: 
        if( logging_is_on >= 1 ){
            
            I32 i = nos;
            while( i-- ){
                printf("[rencore_spc]\n"); 
            };;
            fflush( stdout );
        }else
        if( 0 == logging_is_on ){
            /** do nothing **/
        }else{
            ERR("[YOUR_LOGGING_CONFIG_LOGIC_SUCKS_2021]");
        };;

    }

#undef  I32  //:----------------------------------------: 01 ://
#undef  ERR  //:----------------------------------------: 02 ://
//:=====================================:PRINT_NEWLINE_SPACES://
//:INIT_NONE:================================================://
#define U32 uint32_t /** GCC: <stdint.h> **/
        U32 AAC2020_RENCORE_InitNone( U32 u32 ){
            if( u32 ){ }; return( 0x00 );   }
#undef  U32
//:================================================:INIT_NONE://
//:NON_STANDARD_TODOMAN_POLYFILL:============================://
#define CHR const char                                //: 01 ://
#define U32 uint32_t /** GCC: <stdint.h> **/          //: 02 ://
#define ERR aac2020_rencore_Halt                      //: 03 ://
#define LOS aac2020_rencore_Info_str                  //: 04 ://

    void
    aac2020_rencore_todomsg(
        CHR* msg
    )
    {
        U32 cot=( 0 ); /** cot == "Crash_On_Todo(message)" **/

        #if defined( AAC2020_INCLUDE_SILENCE )

            //:Project Compiled As SubSystem Of AAC2020:
            cot=( 0
                | AAC2020_CRASH_ON_VITAL_TODO
                | AAC2020_CRASH_ON_MAYBE_TODO
                | AAC2020_CRASH_ON_NIAVE_CODE
            );;

        #else

            //:Project Compiled As Stand Alone:
            cot=(AAC2020_RENCORE_STAND_ALONE_ONLY_TODO_CRASH);

        #endif

        if( cot > 0 ){
            printf("[aac2020_rencore_todomsg:msg]%s",msg);
            ERR("[CONFIGED_TO_CRASH_ON_TODO_MESSAGE]");
        }else{
            LOS( "[aac2020_rencore_todomsg:msg]%s",msg);
        };;
    }

#undef  CHR  //:----------------------------------------: 01 ://
#undef  U32  //:----------------------------------------: 02 ://
#undef  ERR  //:----------------------------------------: 03 ://
#undef  LOS  //:----------------------------------------: 04 ://
//:============================:NON_STANDARD_TODOMAN_POLYFILL://
//:FILE_SYSTEM_ACCESS_HELPERS:===============================://
#define     I32   int32_t /** GCC: <stdint.h> **/     //: 01 ://
#define     CHR   const char                          //: 02 ://
#define     NCC         char                          //: 03 ://
#define     ERR   aac2020_rencore_Halt                //: 04 ://
#define     LOS   aac2020_rencore_Info_str            //: 05 ://
#define CWD_NOC ( aac2020_rencore_MACRO_max_noc )     //: 06 ://

 
    I32
    aac2020_rencore_GetCWD(
        NCC* *BYREF_cwd_iov //:AKA[ cwd_buf | cwd_got ]
    )
    {
        //:error_check_inputs:-------------------------------://
    
            if( ((NCC**)0) == BYREF_cwd_iov ){
                ERR("[REFSCANNEVERBENULL:2021]");
            };;
            if( ((NCC* )0) ==*BYREF_cwd_iov ){
                ERR("[BUFFER_MUST_BE_SUPPLIED:cwd_iov]");
            };;

        //:error_check_inputs:-------------------------------://
        //:define_vars:--------------------------------------://

            I32  o_k=( 0 /** Indeterminant State **/ );

            NCC* cwd_buf=( *BYREF_cwd_iov );
            NCC* cwd_got=((NCC*)0);

        //:--------------------------------------:define_vars://
        //:CORE_LOGIC:=======================================://

            cwd_got=(
                getcwd( cwd_buf , CWD_NOC ));;

            if( ((NCC*)0) != cwd_got && cwd_got == cwd_buf ){
                //:Good
                o_k=( 0 + 777 );
            }else
            if( ((NCC*)0) == cwd_got ){
                aac2020_rencore_msg_err=( "[NIL_cwd_got]" );
                o_k=( 0 - 1 );
            }else
            if( ((NCC*)0) != cwd_got && cwd_got != cwd_buf ){
                //:Not null, but got back a different pointer!
                aac2020_rencore_msg_err=( "[DIF_cwd_got]" );
                o_k=( 0 - 2 );
            }else{
                aac2020_rencore_msg_err=( "[UNKNOWN_ERR_001]" );
                o_k=( 0 - 3 );
            };;
        
        //:=======================================:CORE_LOGIC://
        //:DEBUG_SECTION:====================================://
        if( o_k >= 1 ){

            LOS( "[CWD:cwd_got]:%s", cwd_got );

        }else{

            LOS( "[OH_NOO!]%s","[EVERYTHINGS_NOT_OKAY]");

        };;
        //:====================================:DEBUG_SECTION://
        //:load_output_param:--------------------------------://

            (*BYREF_cwd_iov)=( cwd_got );

        //:--------------------------------:load_output_param://
        return( o_k );
    }

#undef      I32  //:------------------------------------: 01 ://
#undef      CHR  //:------------------------------------: 02 ://
#undef      NCC  //:------------------------------------: 03 ://
#undef      ERR  //:------------------------------------: 04 ://
#undef      LOS  //:------------------------------------: 05 ://
#undef  CWD_NOC  //:------------------------------------: 06 ://
//:===============================:FILE_SYSTEM_ACCESS_HELPERS://
//:MAIN_SECTION:=============================================://
#define CHR       const char                     //:----: 01 ://
#define NCC             char                     //:----: 02 ://
#define U32       uint32_t /** GCC: <stdint.h>**///:----: 03 ://
#define I32        int32_t /** GCC: <stdint.h>**///:----: 04 ://
#define ERR       aac2020_rencore_Halt           //:----: 05 ://
#define LOG       aac2020_rencore_Info_any       //:----: 06 ://
#define LOI       aac2020_rencore_Info_i32       //:----: 07 ://
#define SPC       aac2020_rencore_Info_spc       //:----: 08 ://
#define EXT       extern                         //:----: 09 ://
#define FIL       FILE                           //:----: 10 ://
#define SIZ       size_t   /** GCC: <stddef.h>**///:----: 11 ://
#define LOS       aac2020_rencore_Info_str       //:----: 12 ://
#define ECI       aac2020_rencore_MACRO_eci      //:----: 13 ://
#define E_M       aac2020_rencore_msg_err        //:----: 14 ://
#define CWD_NOC ( aac2020_rencore_MACRO_max_noc )//:----: 15 ://
#define MAX_NOC ( aac2020_rencore_MACRO_max_noc )//:----: 16 ://
    //:LoadExtensions:---------------------------------------://

        void
        aac2020_rencore_LoadExtensions_ByOrderFound()
        {           /** LoadExtensions_ByOrderFound **/
            //[  THIS_FUNCTION_SHOULD_ALWAYS_CRASH_THE_CODE  ]//
            //[  @VID_IID[0274]TIME[00:03:00 ]               ]//

            //:----------------------------------------------://
            //: WE WANT:                                     ://
            //:     1: consistent   execution paths.         ://
            //:     2: reduction of execution paths.         ://
            //:                                              ://
            //: So if an "EXT_ORD.TXT" list does not         ://
            //: exist...                                     ://
            //:                                              ://
            //: 1: Build one by finding the different        ://
            //:    extension projects in the folder.         ://
            //:                                              ://
            //: 2: Call[ rencore_LoadExtensions_UsingList ]  ://
            //:    using that procedurally generated list.   ://
            //:                                              ://
            //: This makes the code take a                   ://
            //: @DETOUR_AND_REJOIN_LATER@ rather than        ://
            //: spin off a 100% different path of            ://
            //: execution.                                   ://
            //:                                              ://
            //: -John Mark Isaac Madison                     ://
            //:  DATE( 2021_04_25 )                          ://
            //:                                              ://
            //:----------------------------------------------://
            ERR("[DO_NOT_DO_THIS:2021_04_25]");
        }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

        void
        aac2020_rencore_filesys_SET_ext_arr()
        {
        /** ************************************************ ***
        CURRENT_NAME:
            aac2020_rencore_filesys_SET_ext_arr
            filesys: file_system (conceptual parameter)
                SET: Side_Effect_TO (Like CTO, but missing args)
            ext_arr: EXTension_ARRay
        OLD_NAME:
            aac2020_rencore_Create_ext_arr_ByReadingFolders
        *** ************************************************ **/

            aac2020_rencore_todomsg("[2021_04_25_913PM]");
        }

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

        void
        aac2020_rencore_LoadExtensions_UsingList()
        {
    
            aac2020_rencore_todomsg("[X_X:aac2020_rencore_LoadExtensions_UsingList]");

        }

    //:---------------------------------------:LoadExtensions://
    
    I32 //:<--[ o_k variable return ]
    aac2020_rencore_ExtensionOrderList_Parse(
        FIL* filhand
    )   
    {
        //:error_check_inputs:-------------------------------://

            if( ((FIL*)0) == filhand ){
                ERR("[NULL:filhand]");
            };;

        //:-------------------------------:error_check_inputs://
        //:Declare_Vars:-------------------------------------://

            I32 o_k =( 0 /** UndefinedState **/ );

        //:-------------------------------------:Declare_Vars://
        //:TODO: logic <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< TODO

        //:CORE_LOGIC:=======================================://

            /** Set to FALSE if errors found in EXT_ORD.TXT **/
            o_k=( 0 - 837 );

        //:=======================================:CORE_LOGIC://

        //:Important output is file scope var:
        //:[ aac2020_rencore_ext_arr ]
        return( o_k );
    }

    I32 /** <-- found without errors is positive **/
    aac2020_rencore_parfold_relpath_CTO_abspath(
        CHR*    parfold       //:<--INN[ parent_folder    ]
    ,   CHR*    relpath       //:<--INN[ relative_path    ]
    ,   I32    *BYREF_f_found //:<--OUTPUT_PARAM[ f_found ]
    ,   NCC*   *BYREF_abspath //:<--OUTPUT_PARAM[ abspath ]
    ){
        //:error_check_inputs:-------------------------------://
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
            if( ((CHR* )0) == parfold       ){
                ERR("[NULL:parfold(parent_folder)]");
            };;
            if( ((CHR* )0) == relpath       ){
                ERR("[NULL:relpath(relative_path)]");
            };;
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
            if( ((I32* )0) ==( BYREF_f_found) ){
                ERR("[NIL_REF:BYREF_f_found]");
            };;
            if( ((I32  )0) !=(*BYREF_f_found) ){
                ERR("[EXPECT_TO_BE_ZEROED_OUT]");
            };;
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
            if( ((NCC**)0) ==( BYREF_abspath) ){
                ERR("[NIL_REF:abspath]");
            };;
            if( ((NCC* )0) ==(*BYREF_abspath) ){
                /**  Buffer must be provided because this **/
                /**  function does __NOT__ allocate any   **/
                /**  memory.                              **/
                ERR("[NIL_STR:abspath]");
            };;
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
        //:-------------------------------:error_check_inputs://
        //:declare_vars:-------------------------------------://

            I32 o_k=( 0 /**UndefinedState**/ );

        //:-------------------------------------:declare_vars://
        //:CORE_LOGIC:=======================================://

            LOG("[FINDING_ABS_PATH_OF_PARFOLD]","[...]");
            LOS("[parfold]:%s\n", parfold );
            LOS("[relpath]:%s\n", relpath );

            //:merge_paths_together:
            I32 noc_parfold=( strlen( parfold ) );
            I32 noc_relpath=( strlen( relpath ) );
            I32 noc_abspath=( 0 /** unset **/   );

            I32 dex_parfold=( 0 - 1);
            I32 dex_relpath=( 0 - 1);
            
            //:Trim off trailing "\" from[ parfold ]( -1 -1 )
            I32 m_i_parfold=( noc_parfold -1 -1 );
            I32 m_i_relpath=( noc_relpath -1 +0 );

            I32 phase=( 0 /**collection_phase**/ );

            I32 max_abspath=( noc_parfold + noc_relpath );
            NCC*    abspath=(*BYREF_abspath);
           
 
            //:get_first_slash_index:------------------------://
            #define M_I (( noc_parfold - 1 )) 

                I32 s_i_relpath=( 0 );
                for( I32 s_i = 0 ; s_i <=( M_I ) ; s_i++ ){

                    if( relpath[ s_i ] == '/' ){
                        s_i_relpath=( s_i ); //:FORWARD_SLASH
                        break;
                    };;
                    if( relpath[ s_i ] == '\\' ){
                        s_i_relpath=( s_i ); //:BACK____SLASH
                        break;
                    };;
                };;

            #undef  M_I
            //:------------------------:get_first_slash_index://
            //:CONCAT_PATHS:---------------------------------://
            //:abspath=parfold+relpath:----------------------://
                for( I32 dex = 0 ; dex <=(max_abspath-1) ; dex++ ){

                    if( 0 == phase /**collection_phase**/ ){
                        dex_parfold++;
                        abspath[ dex ]=( parfold[ dex_parfold ] );
                        if( dex_parfold+1 > m_i_parfold ){
                            phase=( 1 );
                            dex_relpath=( s_i_relpath );
                        };;
                    }else
                    if( 1 == phase /**Insert "/" phase**/ ){
                        abspath[ dex ]=( '/' );
                        phase=( 2 );
                    }else
                    if( 2 == phase /**collection_phase**/ ){
                        dex_relpath++;
                        abspath[ dex ]=( relpath[ dex_relpath ] );
                        if( dex_relpath+1 > m_i_relpath ){
                            phase=( 2 );
                            noc_abspath=( dex + 1 );
                            break;
                        };;
                    };;
                };;
            //:----------------------:abspath=parfold+relpath://
            //:---------------------------------:CONCAT_PATHS://
            //:Normalize_AbsPath:----------------------------://
                
                NCC b_slash=( '\\' );
                NCC f_slash=( '/'  );

                for( I32 i = 0 ; i <=( noc_abspath-1 ); i++ ){
                    if( abspath[i] == b_slash ){
                        abspath[i]  = f_slash ;
                    };;
                };;

            //:----------------------------:Normalize_AbsPath://
            //:Log_Absolute_Path_Created:--------------------://
           
                SPC( 3 );
                LOI("[noc_abspath]:%d\n", noc_abspath );
                LOS("[abspath]:%s\n"    ,     abspath );
                SPC( 3 );

            //:--------------------:Log_Absolute_Path_Created://
            //:SKIP:Make_Sure_Path_Is_Valid:-----------------://
                        
                //[ UPDATE:@VID_IID[ 0276 ]TIME[02:38:10]]//
                //[ Code needs to be written truthfully..]//
                //[ do ___NOT___ skip this step.         ]//
                /** ************************************ **/
                /** @VID_IID[ 0276 ]TIME[ 02:34:23 ]     **/
                /** Skip because it will be easier to do **/
                /** this when we __TRY__ to open up the  **/
                /** file pointed to by the absolute path.**/
                /** ************************************ **/

                    //:[   o_k ]: True if nothing catastrophic.
                    //:[f_found]: True if able to open file.

                FIL* fil = fopen( str_abspath , "r" );
                if( ((FIL*)0) != fil ){
                    (*BYREF_f_found)=(0 + 777  );
                    o_k=(             0 + 777  );
                    fclose( fil );
                }else{
                    (*BYREF_f_found)=(0 - 666  );
                    o_k=(             0 + 777  );
                };;

            //:-----------------:Make_Sure_Path_Is_Valid:SKIP://
        //:=======================================:CORE_LOGIC://

        /** Positive[ o_k ]does not mean found. It just **/
        /** means nothing went horribly wrong.          **/
        return( o_k );
    }
        
    I32 //:<-- o_k flag.
    aac2020_rencore_abspath_CTO_filhand(
        CHR*        abspath
    ,   FIL* *BYREF_filhand
    )
    {
        #if( ECI )//:########################################://

            if( ((CHR*)0) == abspath ){ 
                ERR("[NULL_ABSPATH]");
            };;

            /** FIL** : expecting non-null    **/
            /** FIL*    expecting     null    **/

            if( ((FIL**)0) ==( BYREF_filhand ) ){
                ERR("[NIL_REF:filhand]");
            }else
            if( ((FIL* )0) !=(*BYREF_filhand ) ){
                ERR("[EXP_NIL:filhand]");
            };;
        #endif //:####################################( ECI )://
        //:declare_vars:-------------------------------------://

            I32  o_k =( 0 /** UndefinedState **/ );
            FIL* filhand=((FIL*)0);

        //:-------------------------------------:declare_vars://
        //:CORE_LOGIC:=======================================://

            o_k=( 0 - 666 );
            aac2020_rencore_msg_err=("[FINISHTHIS:2021]");

        //:=======================================:CORE_LOGIC://
        //:return:byref:-------------------------------------://

            (*BYREF_filhand)=( filhand );

        //:-------------------------------------:return:byref://
        //:return:byval:-------------------------------------://

            return( o_k );
    
        //:-------------------------------------:return:byval://
    }

    I32
    aac2020_rencore_FindParentFolderOf(
        CHR*        chifold //:<--[ INN:child_folder  ]
    ,   NCC* *BYREF_parfold //:<--[ OUT:parent_folder ]
    )
    {
        //:error_check_inputs:-------------------------------://

            if( 0 != strcmp( chifold , "AAC2020" ) ){
                ERR("[REMOVE_IF_NO_LONGER_THE_ONLY_USE_CASE]");
            };;

            if( ((CHR*)0) == chifold ){
                ERR("[NULL:chifold]");
            };;

            if( ((NCC**)0) ==  BYREF_parfold ){
                ERR("[REFS_CAN_NEVER_BE_NULL]");
            };;
            if( ((NCC* )0) ==(*BYREF_parfold) ){
                ERR("[PARENT_FOLDER_BUFFER_NOT_SUPPLIED]");
            };;

        //:-------------------------------:error_check_inputs://
        //:declare_vars:-------------------------------------://
        #define NOC ( aac2020_rencore_MACRO_max_noc )

            I32  o_k =( 1 ); //:JavaScript_Promise_Like_Syntax

        
            NCC  cwd_buf[ NOC ]={0}; //!cwd_charbuffer       !//
            NCC* cwd_str=&( cwd_buf[ 0 ] );

            ///  cwd_got=((NCC* )0); //!cwd_gotten_charbuffer!//

            
        #undef  NOC
        //:-------------------------------------:declare_vars://
        
        if( o_k >= 1 ){

            o_k=(
            aac2020_rencore_GetCWD(

                //: (NCC**)&(cwd_buf) @IDKWTFID@
                &( cwd_str )
            ));;

            if( ((NCC*)0) == cwd_buf ){
                o_k =( 0-1 );
                E_M =("[GetCWD_FAILED]");
                LOS( "[X_X:E_M]:%s" , E_M );
            }else
            if( o_k <= 0 ){
                o_k =( 0-2 );
                /** RNN: Returned Non-Null       **/
                /** BFF: But Flagged  as Failure **/
                E_M=("[ERR_RNN_BFF]");
                LOS( "[X_X:E_M]:%s" , E_M );
            };;
        };;
        if( o_k >= 1 ){

            LOS("[cwd_buf]:%s" , cwd_buf );

            //: o_k=( 0-7 );    
            //: E_M=("[FINISH_THIS_CODE_HERE]");
            //: LOS( "[X_X:E_M]:%s" , E_M );

            //:Loop backwards through string and match
            //:backwards to slash before "AAC2020"
            I32 noc_chi =(( strlen( chifold ) )  ); 
            /// noc_buf =(( strlen( cwd_buf ) )  );

            I32 dex_chi =(( strlen( chifold ) )  );//:OOB_BY_1
            I32 dex_buf =(( strlen( cwd_buf ) )  );//:OOB_BY_1

            I32 dex     =(( 0 - 1 )              );
            I32 m_i     =(( strlen( cwd_buf ) )-1);
            I32 t_f     =( 0 ); //:Total_Found
            I32 s_i     =( 0 ); //:Slash_Index
            I32 fou     =( 0 ); //:Found_Sub_String?

            LOG("[ABOUT_TO_EXE_SUBSTR_SEARCH]:%s","[...]");
            LOI("[m_i]:%d\n" , m_i );
            for( dex = 0 ; dex <= m_i ; dex++ ){
 
                dex_buf=( m_i - dex ); 
                dex_chi--;

                if( chifold[ dex_chi ] 
                ==  cwd_buf[ dex_buf ] 
                ){
                        t_f++; //:total_found
                    if( t_f == noc_chi ){
                        s_i =( dex_buf - 1 );
                        fou =(    0+777    );
                        break;
                    };;
                }else{
                    t_f=( 0 );
                    dex_chi=( noc_chi );//:OOB_BY_1
                };;
            };;

            if( fou <= 0 ){
                o_k =( 0 );
                LOS( "[NOT_FOUND:parfold]:%s" , "[...]" );
            }else{
                o_k =( 1 );
                LOS( "[YES_FOUND:parfold]:%s" , "[...]" );
                LOI( "[YES_FOUND:....s_i]:%d" ,   s_i   );
            };;

            //:Copy Sub String:
            if( fou >= 1 && o_k >= 1 ){
                NCC* parfold=(  *BYREF_parfold );
                I32  parfold_noc=(   s_i + 1 );
                if(  parfold_noc > MAX_NOC   ){
                    o_k =( 0 ); //:Path_Too_Big
                }else{
                    
                    //:Add null terminator to end of string.
                    parfold[ parfold_noc + 0 ]=( 0 );

                    //:Copy path into[ parfold ]:
                    #define M_I ( parfold_noc - 1 ) //://////://
                    for( I32 p = 0 ; p <= ( M_I ) ; p++ ){

                        parfold[ p ]=( cwd_buf[ p ] );

                    };;
                    #undef  M_I //://////////////////////////://
                };;
            }else
            if( fou <= 0 && o_k <= 0 ){
                //:OKAY THIS CAN HAPPEN. DO NOTHING.
            }else{
                ERR("[@EDCL@:unexpected_state:2021]");
            };;
        };;
        if( o_k >= 1 ){

            //:Debug: Print out the sub path string:
            LOS( "[about_to_print:parfold]:%s" , "[...]" );
            NCC* parfold=(  *BYREF_parfold );
            SPC(3);
            LOS( "[parfold]:%s" ,  parfold );
            SPC(3);
        };;
        
        return( o_k /** >= 1 if no errors **/ );
    }

    void
    aac2020_rencore_LOAD()
    {
        //:declare_vars:-------------------------------------://
        #define NOC ( aac2020_rencore_MACRO_max_noc )

            I32 o_k=( 1 ); //:<=0 if error somewhere.

            I32 f_found=( 0 ); //:flag_found

            NCC  abspath[NOC]={ 0}; //:[ Absolute_Path         ]
            NCC  parfold[NOC]={ 0}; //:[ AAC2020's parfold     ]
            FIL* filhand=((FIL*)0); //:[ file_handle / fin_han ]

            /** Necessary Hack **/
            NCC* str_abspath =&( abspath[ 0 ] );

            I32 extension_list_was_detected =( 0 );
            I32 problems_with_extension_list=( 0 );

        #undef  NOC
        //:-------------------------------------:declare_vars://

        if( o_k >= 1 ){ //:1111111111111111111111111111111111://

            //:----------------------------------------------://
            //:Get the parent folder of the project folder.  ://
            //:All extension projects are to be placed next  ://
            //:to the main engine project (AAC2020).         ://
            //:PARENT_FOLDER [-]                             ://
            //:               |                              ://
            //:               +---[ AAC2020                 ]://
            //:               +---[ AAC2020_EXTCODE_MANDELA ]://
            //:               +---[ AAC2020_EXTCODE_SHATTER ]://
            //:               +---[ AAC2020_EXT_ORD         ]://
            //:----------------------------------------------://

            NCC*  str_parfold=( &(    parfold[0]) );

            o_k=(
                aac2020_rencore_FindParentFolderOf(
            
                    //:AAC2020 Game engine project folder:
                    "AAC2020"  

                    //:AAC2020's parent folder:
                ,  &(str_parfold)

                ));;

        };; //:1111111111111111111111111111111111111111111111://
        if( o_k >= 1 ){

            o_k=(
            aac2020_rencore_parfold_relpath_CTO_abspath(    
                parfold //:<----------------------:parent_folder
            ,   "./AAC2020_EXT_ORD/EXT_ORD.TXT" //:relpath
            ,          &(f_found) //:Flag____Found
            ,          &(str_abspath ) //:Absolute_Path
            ));;

        };;
        if( o_k >= 1 ){
            if( ((CHR*)0) !=  str_abspath && (f_found <= 0) ){  
                
                extension_list_was_detected=( 0 - 666 );
            }else
            if( ((CHR*)0) !=  str_abspath && (f_found >= 1) ){  
                extension_list_was_detected=( 0 + 777 );

                o_k=(
                aac2020_rencore_abspath_CTO_filhand(
                            str_abspath  ,&(filhand) ));;

                
                if( o_k <= 0 || ((FIL*)0)==filhand){

                        problems_with_extension_list=( 1 );
                }else{

                    I32 parse_success =(
                    aac2020_rencore_ExtensionOrderList_Parse(
                                          filhand ));;

                    if( parse_success <= 0 ){
                        problems_with_extension_list=( 1 );
                    };;
                };;

            }else{
                /** parfold_relpath_CTO_filhand              **/
                /** returned values that don't agree with    **/
                /** each other.                              **/

                LOI("[f_found]:%d\n", f_found );
                ERR("[MIS_MATCHING_FLAGS_FROM:REL_CTO_FIL]");
            };;

        };;
        if( 1 == 1 /** ALWAYS RUN **/ ){

            if( extension_list_was_detected  <= 0 ){
            if( problems_with_extension_list >= 1 ){
                /**@VID_IID[ 0273 ]TIME[ 02:18:00 ] **/
                ERR("[#_C_H_P_W_A_U_L_#]");
            };;};;

            if( 1
            &&  extension_list_was_detected  >= 1
            &&  problems_with_extension_list >= 1 
            ){
            /** End up here if:                   -----------**/
            /** 1: Extension list does not exist. -----------**/
            /** 2: Extension list failed to open. -----------**/
            /** 3: Extension list was malformed.  -----------**/

                aac2020_rencore_ext_noe =( 0 );
            //: aac2020_rencore_ext_cap     ://
            //: aac2020_rencore_ext_arr     ://

                /** **************************************** **/
                /** Maybe popup to notify user?              **/
                /** **************************************** **/
                /** Possible bad situation with end user     **/
                /** where adding of a MALFORMED extension    **/
                /** list leads to extensions that were       **/
                /** previously auto-loaded in the absense of **/
                /** an "EXT_ORD.TXT" file to be 100%         **/
                /** omitted. @VID_IID[ 0274 ]T[06:44:23]     **/
                /** **************************************** **/
                /** Another idea:                            **/
                /** Default "Error Extension" can be loaded  **/
                /** at this point. Like "SYN_ERR" shader.    **/
                /** @VID_IID[ 0274 ]T[06:46:06 ]             **/
                /** **************************************** **/
                LOG("[EXTENSION_LOADING_ABORTED]",0);

            }else
            if( 1
            &&  extension_list_was_detected  >= 1 
            &&  problems_with_extension_list <= 0 
            ){
                
                aac2020_rencore_LoadExtensions_UsingList();

            }else
            if( 1
            && extension_list_was_detected  <= 0
            && problems_with_extension_list <= 0
            ){
                LOS("[extension_list_not_found]:%s\n","[...]");

                /** ************************************** **/
                /** If no extension list is found, we auto **/
                /** detect extensions and load them by the **/
                /** order in which they are found.         **/
                /** This means a deletion of "EXT_ORD.TXT" **/
                /** could lead to __MORE__ extensions being**/
                /** brought in rather than __LESS__        **/
                /** The idea is that "EXT_ORD.TXT" is an   **/
                /** __OPTIONAL__ build system component.   **/
                /** ************************************** **/

                //[ @MINIMIZE_CODE_PATHS@/////////////////// ]//
                //+ Minimize code paths by taking detour to  +//
                //+ build[ ext_arr ]by reading[ filesys ],   +//
                //+ then re-join path of normal execution by +//
                //+ calling rencore_LoadExtensions_UsingList +//
                //+                                          +//
                //+ ext_arr : Extension_List (array)         +//
                //+ filesys : FileSystem (conceptual arg)    +//
                //+                                          +//
                //-         LoadExtensions_ByOrderFound();   -//
                    aac2020_rencore_filesys_SET_ext_arr();
                    aac2020_rencore_LoadExtensions_UsingList();
                //[ ///////////////////@MINIMIZE_CODE_PATHS@ ]//
            }else{
                ERR("[@EDC@:2021_04_26]");
            };;
        };;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_rencore_Ping( void )
    {
        printf("[aac2020_rencore_Ping:I_EXIST!]\n");
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    I32 
    AAC2020_RENCORE_StandAloneMain(
        I32    arg_cou //:<--[ argument_count ]
    ,   char** arg_arr //:<--[ argument_array ]
    )
    {
    LOG("[RENCORE.F._:main:BEG]",0);
        //:ERROR_CHECK_INPUTS:-------------------------------://

            if( arg_cou > 0 ){
            if( ((char**)0) == arg_arr ){
                ERR("[NULL_ARG_ARR_INPUT:RENCORE]");
            }};;

        //:-------------------------------:ERROR_CHECK_INPUTS://
        //:LazyUnitTest:-------------------------------------://
        if( aac2020_rencore_UTC_ror <= 0 ){
        if( arg_cou                 <= 1 ){

            /** Why are we only running unit tests if  ***** **/
            /** no user supplied arguments (arg_cou<=1) are  **/
            /** supplied? @VID_IID[ 0272 ]TIME[ 03:09:00 ]   **/

            /** Only call unit test if test has not been *** **/
            /** ran before. ror == "ran or running"      *** **/

            EXT U32 AAC2020_RENCORE_UnitTest( U32  );
                    AAC2020_RENCORE_UnitTest( 0x00 );

            printf("[LAZY_UNIT_TEST_HAS_RAN]\n");
            fflush(stdout);

        };;};;
        //:-------------------------------------:LazyUnitTest://
        //:Declare_Vars:-------------------------------------://



        //:-------------------------------------:Declare_Vars://
        //:CORE_LOGIC:=======================================://
    
            I32 number_of_user_supplied_args =( arg_cou - 1 );

            if( 1 == number_of_user_supplied_args ){

                if( 0 == strcmp( arg_arr[1] , "PING" )){

                    aac2020_rencore_Ping( );

                }else
                if( 0 == strcmp( arg_arr[1] , "LOAD" )){

                    aac2020_rencore_LOAD();

                }else{
                    printf("[COMMANDS_MUST_BE_UPPERCASE]\n");
                };;

            }else
            if( 0 == number_of_user_supplied_args ){
                printf("[FEED_ME_ARGUMENTS]\n");
            }else{
                printf("[INVALID_NUMBER_OF_ARGS]");
            };;

        //:=======================================:CORE_LOGIC://

    LOG("[RENCORE.F._:main:END]",0);
    return( 0 );
    }

#undef      CHR  //:------------------------------------: 01 ://
#undef      NCC  //:------------------------------------: 02 ://
#undef      U32  //:------------------------------------: 03 ://
#undef      I32  //:------------------------------------: 04 ://
#undef      ERR  //:------------------------------------: 05 ://
#undef      LOG  //:------------------------------------: 06 ://
#undef      LOI  //:------------------------------------: 07 ://
#undef      SPC  //:------------------------------------: 08 ://
#undef      EXT  //:------------------------------------: 09 ://
#undef      FIL  //:------------------------------------: 10 ://
#undef      SIZ  //:------------------------------------: 11 ://
#undef      LOS  //:------------------------------------: 12 ://
#undef      ECI  //:------------------------------------: 13 ://
#undef      E_M  //:------------------------------------: 14 ://
#undef  CWD_NOC  //:------------------------------------: 15 ://
#undef  MAX_NOC  //:------------------------------------: 16 ://
//:=============================================:MAIN_SECTION://
//:UNIT_TEST_SECTION:========================================://
#define I32  int32_t  /** GCC: <stdint.h>     **/     //: 01 ://
#define U32 uint32_t  /** GCC: <stdint.h>     **/     //: 02 ://
#define U08  uint8_t  /** GCC: <stdint.h>     **/     //: 03 ://
#define ERR aac2020_rencore_Halt                      //: 04 ://
#define E_U extern U32                                //: 05 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    AAC2020_RENCORE_UnitTest( U32 u32_var )
    {
        if( aac2020_rencore_UTC_ror >= 1 ){
            /** Ignore Call. **/
            printf("[IGNORED:AAC2020_RENCORE_UnitTest]\n");
            fflush(stdout);
        }else{
            aac2020_rencore_UTC_ror =( 1  );

            E_U aac2020_rencore_UnitTest( U32     );
                aac2020_rencore_UnitTest( u32_var );
        };;

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    U32
    aac2020_rencore_UnitTest( U32 u32 )
    {
        if( u32 ){ /** Reserved_For_Future_Use **/ };

        aac2020_rencore_todomsg("[RENCORE_TESTS]");

        return( 0x00 );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

#undef  I32  //:----------------------------------------: 01 ://
#undef  U32  //:----------------------------------------: 02 ://
#undef  U08  //:----------------------------------------: 03 ://
#undef  ERR  //:----------------------------------------: 04 ://
#undef  E_U  //:----------------------------------------: 05 ://
//:========================================:UNIT_TEST_SECTION://
