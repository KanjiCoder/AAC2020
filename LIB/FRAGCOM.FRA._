
    //:FILESEC[ FRAGCOM.FRA._ ]//////////////////////////://

    //+//////////////////////////////////////////////////+//
    //#HOW_IS_THIS_HEADER_ALLOWED_IN_THIS_FILE           #//
    //#The precision and iResolution and what not?       #//
    //[I think it is allowed because the declarations    ]//
    //[are identical to previous ones?                   ]//
    //+ WRONG... We moved all of the common fragment     +//
    //+ shader code into here a while ago. This          +//
    //+ prelude ONLY OCCURES HERE NOW and thus           +//
    //+ [FRAGCOM.FRA._] must be included by other        +//
    //+ shaders, such as file[ P5D_001._ ]               +//
    //+ @VID_IID[ 0250 ]TIME[ 01:07:07 ]ITS_OKAY         +//
    //[//////////////////////////////////////////////////]//

    //:ALL_SHADERS_KNOW_ABOUT_ALL_MEMORY:----------------://
    //:glsl_file_scope_stuff:----------------------------://
    #ifdef AAC2020_MACRO_THIS_IS_OPEN_GL           //| # |//
                                                   //| # |//
        //:#_KEEP_USAMPLER_HIGH_#          ://     //| # |//
        //:#_SAM_PRECISION_BEFORE_SAM_VAR_#://     //| # |//
        precision highp usampler2D;                //| # |//
                                                   //| # |//
        //|(( UNI ))____________________________|////| # |//
        //[:::::::SHADERTOY_COMPATIBILITY:::::::]////| # |//
        #define fragCoord gl_FragCoord             //| # |//
        #define       F_C gl_FragCoord             //| # |//
                                                   //| # |//
        uniform vec3  iResolution;                 //| # |//
        uniform float iTime      ;                 //| # |//
        uniform vec4  iMouse     ;                 //| # |//
                                                   //| # |//
        uniform usampler2D taudepo;                //| # |//
        uniform usampler2D paint5d;                //| # |//
                                                   //| # |//
        //|(( INN ))____________________________|////| # |//
        //:     fag_tec:FrAGshaderTExtureCoord  :////| # |//
        in vec2 fag_tec;                           //| # |//
                                                   //| # |//
        //|(( OUT ))____________________________|////| # |//
        out vec4 FragColor;                        //| # |//
                                                   //| # |//
    #endif                                         //| # |//
    //:----------------------------:glsl_file_scope_stuff://
    //:----------------:ALL_SHADERS_KNOW_ABOUT_ALL_MEMORY://

    //[CUT_AND_PASTE_THIS_INTO_GLSL_SOURCE:==============]//
    //[AAC2020_FRAGCOM_DEFAULT_001:======================]//
    //[PASTE_INTO_FILE[ COM_001._ ]:=====================]//
    //:COM_001____AAC2020_FRAGCOM_DEFAULT_001:===========://
    //|SIM:Shim_Ifdef_Macros:|||||||||||||||||||||||||||||//
    //:FRAGCOM_FRA_FILE_MACROS:==========================://
    /** @VID_IID[ 0112 ]T[ 00:56:50 ]ORIGINAL   **///:---://
    /** @VID_IID[ 0292 ]T[ 02:53:23 ]GUTTED     **///:---://
    /** SEE[ AAC2020/LIB/MAC/FRA/TOP._ ] ****** **///:---://
    /** SEE[ AAC2020/LIB/MAC/FRA/BOT._ ]******* **///:---://
                                                   //:---://
    #if( AAC2020_MACRO_THIS_IS_OPEN_GL >= 1 )      //:---://
        #define     ERR /** nothing **/            //:---://
        #define TYP_F_C /** nothing **/            //:---://
        #define INN_F_C /** nothing **/            //:---://
    #else                                          //:---://
        #define     ERR aac2020_fragcom_Halt_FRAG  //:---://
        #define TYP_F_C struct AAC2020_POLYOGL_FV4 //:---://
        #define INN_F_C F_C                        //:---://
    #endif                                         //:---://
    //:==========================:FRAGCOM_FRA_FILE_MACROS://
    //||||||||||||||||||||||||||||||SIM:Shim_Ifdef_Macros|//
    //+C99_FRAG_SHADER_ONLY:=============================+//
    #if !defined( AAC2020_MACRO_THIS_IS_OPEN_GL ) // NOTGLSL

        void
     //-aac2020_fragcom_Halt_GLSL-//
        aac2020_fragcom_Halt_FRAG(
            const char* msg_err
        )
        {
        /** ******************************************** ***
        @VID_IID[ 0250 ]TIME[ 05:16:00 ]                 ***
        Fragment shader code doesn't know about the      ***
        CPU-side code. So if we want to invoke an[ ERR ] ***
        function from this code. We need to create one   ***
        in this file.                                    ***
        *** ******************************************** **/
            printf( E_S([fragcom_Halt_FRAG]:%s),msg_err );
            fflush(stdout);
            exit( 232 );
        }

    #endif // ////////////////////////////////////// NOTGLSL
    //+=============================:C99_FRAG_SHADER_ONLY+//
    //:COMMON_DATA_TYPES_USED_IN_SHADERS:================://

        //:INTEGER_RECTANGLE:----------------------------://

            struct AAC2020_FRAGCOM_REC{
                //:X_BOUNDS:
                I32 x_0 ; //:<--@_NEVER_NEGATIVE_@.
                I32 x_1 ; //:   But use signed for ease of
                          //:   use as well as underflow
                          //:   detection.
                          //:   @_SHOULD_NOT_BE_NEGATIVE_@
        
                //:Y_BOUNDS:
                I32 y_0 ; //:<--@_NEVER_NEGATIVE_@.
                I32 y_1 ; //:   But use signed for ease of
                          //:   use as well as underflow
                          //:   detection.
                          //:   @_SHOULD_NOT_BE_NEGATIVE_@
            };

        //:----------------------------:INTEGER_RECTANGLE://

    //:================:COMMON_DATA_TYPES_USED_IN_SHADERS://
    //:MULTIPLY_FUNCTIONS:===============================://
        F32 AAC2020_FRAGCOM_MUL_F32_F32( F32 a , F32 b ){
                                return(      a *     b );}
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV2
        AAC2020_FRAGCOM_MUL_FV2_FV2(
            FV2 aye
        ,   FV2 bee
        ){          //:@VID_IID[0301]T[07:16:50]:::::::::://    
            FV2 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x * bee.x );
            res.y =( aye.y * bee.y );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_MUL_FV3_FV3(
            FV3 aye
        ,   FV3 bee
        ){          //:@VID_IID[0301]T[07:17:23]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x * bee.x );
            res.y =( aye.y * bee.y );
            res.z =( aye.z * bee.z );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV4
        AAC2020_FRAGCOM_MUL_FV4_FV4(
            FV4 aye
        ,   FV4 bee
        ){          //:@VID_IID[0301]T[07:17:42]:::::::::://
            FV4 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x * bee.x );
            res.y =( aye.y * bee.y );
            res.z =( aye.z * bee.z );
            res.w =( aye.w * bee.w );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_MUL_FV3_F32(
            FV3 fv3
        ,   F32 f32
        ){          //:@VID_IID[0301]T[07:18:10]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( fv3.x * f32 );
            res.y =( fv3.y * f32 );
            res.z =( fv3.z * f32 );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_MUL_F32_FV3(
            F32 f32
        ,   FV3 fv3
        ){          //:@VID_IID[0301]T[07:18:42]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( fv3.x * f32 );
            res.y =( fv3.y * f32 );
            res.z =( fv3.z * f32 );

            return( res );
        }
    //:===============================:MULTIPLY_FUNCTIONS://
    //:DIVIDE_FUNCTIONS:=================================://
        F32 AAC2020_FRAGCOM_DIV_F32_F32( F32 a , F32 b ){
                                return(      a /     b );}
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV2
        AAC2020_FRAGCOM_DIV_FV2_FV2(
            FV2 aye
        ,   FV2 bee
        ){          //:@VID_IID[0301]T[07:19:00]:::::::::://
            FV2 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x / bee.x );
            res.y =( aye.y / bee.y );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_DIV_FV3_FV3(
            FV3 aye
        ,   FV3 bee
        ){          //:@VID_IID[0301]T[07:19:23]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x / bee.x );
            res.y =( aye.y / bee.y );
            res.z =( aye.z / bee.z );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV4
        AAC2020_FRAGCOM_DIV_FV4_FV4(
            FV4 aye
        ,   FV4 bee
        ){          //:@VID_IID[0301]T[07:19:42]:::::::::://    
            FV4 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x / bee.x );
            res.y =( aye.y / bee.y );
            res.z =( aye.z / bee.z );
            res.w =( aye.w / bee.w );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_DIV_FV3_F32(
            FV3 fv3
        ,   F32 f32
        ){          //:@VID_IID[0301]T[07:20:00]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( fv3.x / f32 );
            res.y =( fv3.y / f32 );
            res.z =( fv3.z / f32 );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_DIV_F32_FV3(
            F32 f32
        ,   FV3 fv3
        ){          //:@VID_IID[0301]T[07:20:23]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( f32 / fv3.x );
            res.y =( f32 / fv3.y );
            res.z =( f32 / fv3.z );

            return( res );
        }
    //:=================================:DIVIDE_FUNCTIONS://
    //:ADDITION_FUNCTIONS:===============================://  
        F32 AAC2020_FRAGCOM_ADD_F32_F32( F32 a , F32 b ){
                                return(      a +     b );}
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://  
        FV2
        AAC2020_FRAGCOM_ADD_FV2_FV2(
            FV2 aye
        ,   FV2 bee
        ){          //:@VID_IID[0301]T[07:20:42]:::::::::://
            FV2 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x + bee.x );
            res.y =( aye.y + bee.y );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_ADD_FV3_FV3(
            FV3 aye
        ,   FV3 bee
        ){          //:@VID_IID[0301]T[07:21:00]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x + bee.x );
            res.y =( aye.y + bee.y );
            res.z =( aye.z + bee.z );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV4
        AAC2020_FRAGCOM_ADD_FV4_FV4(
            FV4 aye
        ,   FV4 bee
        ){          //:@VID_IID[0301]T[07:21:13]:::::::::://
            FV4 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x + bee.x );
            res.y =( aye.y + bee.y );
            res.z =( aye.z + bee.z );
            res.w =( aye.w + bee.w );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_ADD_FV3_F32(
            FV3 fv3
        ,   F32 f32
        ){          //:@VID_IID[0301]T[07:21:30]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( fv3.x + f32 );
            res.y =( fv3.y + f32 );
            res.z =( fv3.z + f32 );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_ADD_F32_FV3(
            F32 f32
        ,   FV3 fv3
        ){          //:@VID_IID[0301]T[07:21:42]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( f32 + fv3.x );
            res.y =( f32 + fv3.y );
            res.z =( f32 + fv3.z );

            return( res );
        }
    //:===============================:ADDITION_FUNCTIONS://    
    //:SUBTRACT_FUNCTIONS:===============================://
        F32 AAC2020_FRAGCOM_SUB_F32_F32( F32 a , F32 b ){
                                return(      a -     b );}
    //: - - - - - - - - - - - -- - - - - - - - - - - - - :// 
        FV2
        AAC2020_FRAGCOM_SUB_FV2_FV2(
            FV2 aye
        ,   FV2 bee
        ){          //:@VID_IID[0301]T[07:22:00]:::::::::://
            FV2 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x - bee.x );
            res.y =( aye.y - bee.y );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_SUB_FV3_FV3(
            FV3 aye
        ,   FV3 bee
        ){          //:@VID_IID[0301]T[07:22:12]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x - bee.x );
            res.y =( aye.y - bee.y );
            res.z =( aye.z - bee.z );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV4
        AAC2020_FRAGCOM_SUB_FV4_FV4(
            FV4 aye
        ,   FV4 bee
        ){          //:@VID_IID[0301]T[07:23:23]:::::::::://
            FV4 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( aye.x - bee.x );
            res.y =( aye.y - bee.y );
            res.z =( aye.z - bee.z );
            res.w =( aye.w - bee.w );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_SUB_FV3_F32(
            FV3 fv3
        ,   F32 f32
        ){          //:@VID_IID[0301]T[07:22:42]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( fv3.x - f32 );
            res.y =( fv3.y - f32 );
            res.z =( fv3.z - f32 );

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FV3
        AAC2020_FRAGCOM_SUB_F32_FV3(
            F32 f32
        ,   FV3 fv3
        ){          //:@VID_IID[0301]T[07:23:00]:::::::::://
            FV3 res;//:@_NO_ZERO_INIT_@::::::::::::::::::://

            res.x =( f32 - fv3.x );
            res.y =( f32 - fv3.y );
            res.z =( f32 - fv3.z );

            return( res );
        }
    //:===============================:SUBTRACT_FUNCTIONS://
    //:TRIG_FUNCTIONS_COS_SIN_ETC:=======================://

        F32
        AAC2020_FRAGCOM_SIN_F32(
        F32                 f32
        ){
            return( sin( f32 ) );
        }

        F32
        AAC2020_FRAGCOM_COS_F32(
        F32                 f32
        ){
            return( cos( f32 ) );
        }

    //:=======================:TRIG_FUNCTIONS_COS_SIN_ETC://
    //:MAX_MIN_ABS:======================================://
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        F32
        AAC2020_FRAGCOM_ABS_F32(
            F32 f32
        )
        {
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )

                return( abs( f32 ) );

            #else
                //:C99 Code Here
                F32 f32_out;
                if( f32 >= 0 ){
                    f32_out =( 0 + f32 );
                }else{
                    f32_out =( 0 - f32 );
                };;
                return( f32_out );
            #endif
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        F32
        AAC2020_FRAGCOM_MAX_F32(
            F32 aye
        ,   F32 bee
        )
        {
            F32 f32=( 0 );
            if( aye > bee ){ f32=( aye ); };
            if( bee > aye ){ f32=( bee ); };
            return( f32 );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        I32
        AAC2020_FRAGCOM_MAX_I32(
            I32 aye
        ,   I32 bee
        )
        {
            I32 i32=( 0 );
            if( aye > bee ){ i32=( aye ); };
            if( bee > aye ){ i32=( bee ); };
            return( i32 );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        F32
        AAC2020_FRAGCOM_MIN_F32(
            F32 aye
        ,   F32 bee
        )
        {
            F32 f32=( 0 );
            if( aye < bee ){ f32=( aye ); };
            if( bee < aye ){ f32=( bee ); };
            return( f32 );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        I32
        AAC2020_FRAGCOM_MIN_I32(
            I32 aye
        ,   I32 bee
        )
        {
            I32 i32=( 0 );
            if( aye < bee ){ i32=( aye ); };
            if( bee < aye ){ i32=( bee ); };
            return( i32 );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
    //:======================================:MAX_MIN_ABS://
    //:Floor_Round_Ceil:---------------------------------://
        I32                                           //:://
        AAC2020_FRAGCOM_FLO_F32(                      //:://
            F32 f32                                   //:://
        )                                             //:://
        {                                             //:://
            return( MAK_I32( FLO_NAT( f32 ) ) );      //:://
        }                                             //:://
        I32                                           //:://
        AAC2020_FRAGCOM_ROU_F32(                      //:://
            F32 f32                                   //:://
        )                                             //:://
        {                                             //:://
            return( MAK_I32( ROU_NAT( f32 ) ) );      //:://
        }                                             //:://
        I32                                           //:://
        AAC2020_FRAGCOM_CEL_F32(                      //:://
            F32 f32                                   //:://
        )                                             //:://
        {                                             //:://
            return( MAK_I32( CEL_NAT( f32 ) ) );      //:://
        }                                             //:://
    //:---------------------------------:Floor_Round_Ceil://
    //:Ceil_Or_Floor:------------------------------------://
    /** TRASHED. SEE[ DOC/TRASH/006._ ] **************** **/
        
        //: DO_NOT_USE_THIS_FUNCTION.                    ://
        //: You are doing something very wrong in your   ://
        //: code if you need branching like this.        ://
        #define AAC2020_FRAGCOM_COF_F32 0000

    //:------------------------------------:Ceil_Or_Floor://
    //|==================================================|//
    //|MATRIX_OPERATIONS:|||||||||||||||||||||||||||||||||//
    //+MATRIX_OPERATIONS:-------------------------------|+//
        
    //:MUL_SCA_MAT:--------------------------------------://
        FM2
        AAC2020_FRAGCOM_MUL_F32_FM2(
            F32 sca //:SCA:Scalar
        ,   FM2 mat //:MAT:Matrix
        ){              //:@VID_IID[0301]T[07:14:23]:::::://
            FM2     res;//:@_NO_ZERO_INIT_@::::::::::::::://
    
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )
                    res=( sca * mat );
            #else
                    res.col[0][0]=( mat.col[0][0] * sca );
                    res.col[0][1]=( mat.col[0][1] * sca );
    
                    res.col[1][0]=( mat.col[1][0] * sca );
                    res.col[1][1]=( mat.col[1][1] * sca );
            #endif

            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FM3
        AAC2020_FRAGCOM_MUL_F32_FM3(
            F32 sca //:SCA:Scalar
        ,   FM3 mat //:MAT:Matrix
        ){               //:@VID_IID[0301]T[07:14:42]::::::::://
            FM3     res; //:@_NO_ZERO_INIT_@:::::::::::::::::://
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )
                    res=( sca * mat );
            #else
                    res.col[0][0]=( mat.col[0][0] * sca );
                    res.col[0][1]=( mat.col[0][1] * sca );
                    res.col[0][2]=( mat.col[0][2] * sca );
    
                    res.col[1][0]=( mat.col[1][0] * sca );
                    res.col[1][1]=( mat.col[1][1] * sca );
                    res.col[1][2]=( mat.col[1][2] * sca );
    
                    res.col[2][0]=( mat.col[2][0] * sca );
                    res.col[2][1]=( mat.col[2][1] * sca );
                    res.col[2][2]=( mat.col[2][2] * sca );
            #endif
            return( res );
        }
    //: - - - - - - - - - - - -- - - - - - - - - - - - - ://
        FM4
        AAC2020_FRAGCOM_MUL_F32_FM4(
            F32 sca //:SCA:Scalar
        ,   FM4 mat //:MAT:Matrix
        ){              //:@VID_IID[0301]T[07:15:10]:::::://
            FM4     res;//:@_NO_ZERO_INIT_@::::::::::::::://
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )
                    res=( sca * mat );
            #else
                #if !defined( AAC2020_MACRO_THIS_IS_C99 )
                    #error JOHN_MARK_IS_KANJI_CODER_2021
                #endif
                if( sca          > 0 ){ /**NOOP**/  };
                if( mat.col[0][0]> 0 ){ /**NOOP**/  };
                res.col[0][0]=( 0 );
                ERR( E_S( [NOT_IMPLEMENT:2022_01_26] ) );
            #endif
            return( res );
        }
    //:--------------------------------------:MUL_SCA_MAT://
    //:MUL_MAT_SCA:--------------------------------------://
    #define RET return  //:12345678901:------------------://
        //:---------------:123_123_123:------------------://
        FM2 AAC2020_FRAGCOM_MUL_FM2_F32( FM2 m , F32 s ){
        RET(AAC2020_FRAGCOM_MUL_F32_FM2(     s ,     m ));}
                    
        FM3 AAC2020_FRAGCOM_MUL_FM3_F32( FM3 m , F32 s ){
        RET(AAC2020_FRAGCOM_MUL_F32_FM3(     s ,     m ));}
                    
        FM4 AAC2020_FRAGCOM_MUL_FM4_F32( FM4 m , F32 s ){
        RET(AAC2020_FRAGCOM_MUL_F32_FM4(     s ,     m ));}
        //:---------------:123_123_123:------------------://
    #undef  RET         //:12345678901:------------------://
    //:--------------------------------------:MUL_MAT_SCA://
    //:MUL_VEC_MAT:--------------------------------------://
        FV2  
        AAC2020_FRAGCOM_MUL_FV2_FM2(  
            FV2 vec   //:--------------------------------://
        ,   FM2 mat   //:              +---+---+         ://
        ){            //:              | a | c |         ://
                      //:              +---+---+<<[2x2]  ://
                      //:              | b | d |         ://
                      //:    [  1x2  ] +---+---+         ://
                      //:    +---+---+ +---+---+         ://
                      //: vec| x | y | | e | f |<<[1x2]  ://
                      //:    +---+---+ +---+---+         ://
                      //:--------------------------------://
            FV2 res;  //:@VID_IID[0301]T[07:15:35]:::::::://
                      //:@_NO_ZERO_INIT_@::::::::::::::::://
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )
                    res=( vec * mat );
            #else
            //:     res.e  ://
            /**/    res.x=(( vec.x * mat.col[0][0] )
            /**/          +( vec.y * mat.col[0][1] ));
            //:     res.f  ://           
            /**/    res.y=(( vec.x * mat.col[1][0] )
            /**/          +( vec.y * mat.col[1][1] ));
            #endif
    
            return( res );
        }
    //:--------------------------------------:MUL_VEC_MAT://
    //:MUL_MAT_VEC:--------------------------------------://
        FM4
        AAC2020_FRAGCOM_MUL_FM2_FV2( //:[ 1_X_2 ]        ://
            FM2 mat   //:               +---+---+        ://
        ,   FV2 vec   //:               | x | y |        ://
        ){  //:                         +---+---+        ://
            //:               +---+---+ +---+---+        ://
            //:               | 1 | 2 | | a | c |        ://
            //:               +---+---+ +---+---+        ://
            //:               | 3 | 4 | | b | d |        ://
            //:               +---+---+ +---+---+        ://
            //:               [ 2_X_2 ]                  ://
            //:                                          ://
            //:                 INVALID_OPERATION        ://
            //:                        |                 ://
            //:                     +--+--+              ://
            //:                     |     |              ://
            //:               [ 2_X_2 ]*[ 1_X_2 ]        ://
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )
                FM4     bogusvar  ;
                return( bogusvar );
            #else
                if( mat.col[0][0] > 0 ){ /** NOOP **/ };
                if( vec.x         > 0 ){ /** NOOP **/ };
                ERR(E_S([INVALID_OPERATION:MUL_FM2_FV2]));        
                FM4     bogusvar;
                        bogusvar.col[0][0]=(0);
                return( bogusvar );
            #endif
        }
    //:MUL_MAT_VEC:--------------------------------------://
    //+-------------------------------|:MATRIX_OPERATIONS+//
    //|||||||||||||||||||||||||||||||||:MATRIX_OPERATIONS|//
    //|==================================================|//
    //:VECTOR_OPERATIONS:================================://

        FV3
        AAC2020_FRAGCOM_SWI_ZYX_FV3(
            FV3 vec
        ){              //:@VID_IID[0301]T[07:13:42]:::::://
            FV3     res;//:@_NO_ZERO_INIT_@::::::::::::::://
                    res.x=( vec.z );
                    res.y=( vec.y );
                    res.z=( vec.x );
            return( res );
        } 

    //:VECTOR_OPERATIONS:================================://

        /** TRASHED: AAC2020_FRAGCOM_rv0_CTO_rv1         **/
        /** TRASHED: AAC2020_FRAGCOM_big_MAP_lit_ONE_AXE **/
        /** SEE[ DOC/TRASH/007._ ]                       **/
        /** VID_IID[ 0145 ]T[ 03:07:44 ]                 **/
                                                   //: m ://
        IV2                                        //: m ://
        AAC2020_FRAGCOM_big_MAP_lit(               //: m ://
            I32 big_s_x  //:BIG:source(value)x     //: m ://
        ,   I32 big_s_y  //:BIG:source(value)y     //: m ://
                                                   //: m ://
        ,   I32 big_sx0  //:rec_src: BOUND_MIN     //: m ://
        ,   I32 big_sy0  //:rec_src: BOUND_MIN     //: m ://
        ,   I32 big_sx1  //:rec_src: BOUND_MAX     //: m ://
        ,   I32 big_sy1  //:rec_src: BOUND_MAX     //: m ://
                                                   //: m ://
        ,   I32 lit_dx0  //:rec_dst: BOUND_MIN     //: m ://
        ,   I32 lit_dy0  //:rec_dst: BOUND_MIN     //: m ://
        ,   I32 lit_dx1  //:rec_dst: BOUND_MAX     //: m ://
        ,   I32 lit_dy1  //:rec_dst: BOUND_MAX     //: m ://
        )                                          //: m ://
        {
            /** FUNCTION_SUMMARY[ big_MAP_lit ] ******** **/
            /** @VID_IID[ 0142 ]TIME[ 01:34:32 ] ******* **/
            /** Map a value on one range to a value on   **/
            /** another range. Written assuming the      **/
            /** destination range is same size or smaller**/
            /** than the input range. Have no clue how   **/
            /** this will work if that logic is flipped. **/
            /** **************************************** **/
            //:output_xy_coord_var:----------------------://
            
                IV2 dst;

            //:----------------------:output_xy_coord_var://
            //:INTEGER_DOWNSCALE_FORMULA:----------------://
            #define NOT_CTF /** NOT_Convert_To_Float **/
            #define NO_CAST /** No casting logic needed **/

                #define S_I big_s_x
                #define S_0 big_sx0
                #define S_1 big_sx1
                #define D_0 lit_dx0
                #define D_1 lit_dx1
                #define D_P dst.x
                D_P =NO_CAST(
                    (  
                        NOT_CTF(S_I - S_0)
                        / 
                        (   
                            NOT_CTF( (S_1 - S_0) +1 )  
                        /   NOT_CTF( (D_1 - D_0) +1 )  
                        )
                    )
                    +NOT_CTF( D_0 ) //:Add_New_Origin
                );;
                #undef  S_I 
                #undef  S_0 
                #undef  S_1 
                #undef  D_0 
                #undef  D_1 
                #undef  D_P 

                #define S_I big_s_y
                #define S_0 big_sy0
                #define S_1 big_sy1
                #define D_0 lit_dy0
                #define D_1 lit_dy1
                #define D_P dst.y
                D_P =NO_CAST(
                    (  
                        NOT_CTF(S_I - S_0)
                        / 
                        (   
                            NOT_CTF( (S_1 - S_0) +1 )  
                        /   NOT_CTF( (D_1 - D_0) +1 )  
                        )
                    )
                    +NOT_CTF( D_0 ) //:Add_New_Origin
                );;
                #undef  S_I 
                #undef  S_0 
                #undef  S_1 
                #undef  D_0 
                #undef  D_1 
                #undef  D_P 
                
            #undef  NOT_CTF
            #undef  NO_CAST
            //:----------------:INTEGER_DOWNSCALE_FORMULA://        

            return( dst );
        }

        IV2                                         
        AAC2020_FRAGCOM_fic_MAP_cuv(       

            IV2 fic      //:fic:Fragment_Integer_Coord       
        ,   REC p5d_vp0  //:BOUNDS_OF_INPUT[ fic ]
        ,   REC p5d_vp1  //:BOUNDS_OF_FETCH[ cuv ]

        )                                           
        {
            /** **************************************** ***
                @VID_IID[ 0151 ]TIME[ 04:51:23 ]

                Designed to scan over the on-screen
                viewport (p5d_vp0) and map to the
                offscreen data (p5d_vp1).

                p5d_vp0 == ON SCREEN SUB AREA OF CLIENT
                p5d_vp1 == OFF SCREEN DATA TO SAMPLE

                fic: Fragment_Integer_Coordinate  
                cuv: Canvas_User_View             
            *** **************************************** **/
            //:output_xy_coord_var:----------------------://
            
                IV2 dst;

            //:----------------------:output_xy_coord_var://
            //:INTEGER_DOWNSCALE_FORMULA:----------------://
            #define NOT_CTF /** NOT_Convert_To_Float **/
            #define YES_CTF MAK_F32

                #define S_I     fic.x   //: big_s_x
                #define S_0 p5d_vp0.x_0 //: big_sx0
                #define S_1 p5d_vp0.x_1 //: big_sx1
                #define D_0 p5d_vp1.x_0 //: lit_dx0
                #define D_1 p5d_vp1.x_1 //: lit_dx1
                #define D_P dst.x
                D_P =MAK_I32(
                    (  
                        YES_CTF(S_I - S_0)
                        / 
                        (   
                            YES_CTF( (S_1 - S_0) +1 )  
                        /   YES_CTF( (D_1 - D_0) +1 )  
                        )
                    )
                    +YES_CTF( D_0 )//:Add_New_Origin
                );;
                #undef  S_I 
                #undef  S_0 
                #undef  S_1 
                #undef  D_0 
                #undef  D_1 
                #undef  D_P 

                #define S_I     fic.y   //: big_s_y
                #define S_0 p5d_vp0.y_0 //: big_sy0
                #define S_1 p5d_vp0.y_1 //: big_sy1
                #define D_0 p5d_vp1.y_0 //: lit_dy0
                #define D_1 p5d_vp1.y_1 //: lit_dy1
                #define D_P dst.y
                D_P =MAK_I32(
                    (  
                        YES_CTF(S_I - S_0)
                        / 
                        (   
                            YES_CTF( (S_1 - S_0) +1 )  
                        /   YES_CTF( (D_1 - D_0) +1 )  
                        )
                    )
                    +YES_CTF( D_0 )//:Add_New_Origin
                );;
                #undef  S_I 
                #undef  S_0 
                #undef  S_1 
                #undef  D_0 
                #undef  D_1 
                #undef  D_P 
                
            #undef  NOT_CTF
            #undef  YES_CTF
            //:----------------:INTEGER_DOWNSCALE_FORMULA://        

            return( dst );
        }
        //:- - - - - - - - - - - -- - - - - - - - - - - -://  
        /** TRASHED:AAC2020_FRAGCOM_rec_src_MAP_rec_dst  **/
        /** SEE[ DOC/TRASH/005._ ]                       **/
        /** VID_IID[ 0145 ]TIME[ 02:43:23 ]              **/
        //:- - - - - - - - - - - -- - - - - - - - - - - -://  

        U32                                       //[ TF ]//
        AAC2020_FRAGCOM_TexelFetch_U32(           //[ TF ]//
            SAM u32_sam //:<-[C99/C11]AND[GLSL]:////[ TF ]//
        ,   IV2 glo                               //[ TF ]//
        ,   I32 levodet_ALWAYS_ZERO               //[ TF ]//
        )                                         //[ TF ]//
        {                                         //[ TF ]//
            U32 u32_var; /** Output/Return **/    //[ TF ]//
                                                  //[ TF ]//
            //:TEXEL_FETCH_RETURNS_XYZW_U08:-------------://     
            /** GET: [ x,y,z,w ] / [r,g,b,a]  **/ //[ TF ]//
            /**      texel As a uvec 4 type.  **/ //[ TF ]//
                UV4 uv4=(                         //[ TF ]//
                    T_F(                          //[ TF ]//
                        u32_sam                   //[ TF ]//
                    ,   glo                       //[ TF ]//
                    ,   levodet_ALWAYS_ZERO       //[ TF ]//
                    ));;                          //[ TF ]//
                                                  //[ TF ]//
            //:-------------:TEXEL_FETCH_RETURNS_XYZW_U08://
            //:BIT_PACK_YOUR_PIXEL:----------------------://
            #define CPU_PIX AAC2020_PIXNAME_paint5d_cpu_pix
            /** **************************************TF *** 
                @VID_IID[ 0177 ]TIME[ 01:05:33 ]  //[ TF ]//
                #_EXT_COM_2021_03_13_313PM_#      //[ TF ]//
            *** **************************************TF **/ 
                                                  //[ TF ]//
                u32_var=( U32_000                 //[ TF ]//
                | ( uv4.x << 24 ) //: R ://       //[ TF ]//
                | ( uv4.y << 16 ) //: G ://       //[ TF ]//
                | ( uv4.z <<  8 ) //: B ://       //[ TF ]//
                | ( uv4.w <<  0 ) //: A ://       //[ TF ]//
                );;  /**@PAIR_CODE_2021_01_14@ **///[ TF ]//
                                                  //[ TF ]//
            #undef  CPU_PIX                       //[ TF ]//
            //:----------------------:BIT_PACK_YOUR_PIXEL://
            return( u32_var );                    //[ TF ]//
        }                                         //[ TF ]//
        //:- - - - - - - - - - - -- - - - - - - - - - - -://
        U32                                       //[ TF ]//
        AAC2020_FRAGCOM_TexelFetch_U32XY(         //[ TF ]//
            SAM u32_sam //:<-[C99/C11]AND[GLSL]:////[ TF ]//
        ,   I32 g_x                               //[ TF ]//
        ,   I32 g_y                               //[ TF ]//
        ,   I32 levodet_ALWAYS_ZERO               //[ TF ]//
        )                                         //[ TF ]//
        {                                         //[ TF ]//
            /** #_EXT_COM_2020_03_13_315PM_# **/  //[ TF ]//
            return(                               //[ TF ]//
            AAC2020_FRAGCOM_TexelFetch_U32(       //[ TF ]//
                u32_sam                           //[ TF ]//
            ,   MAK_IV2( g_x , g_y )              //[ TF ]//
            ,   levodet_ALWAYS_ZERO               //[ TF ]//
            ));;                                  //[ TF ]//
        }                                         //[ TF ]//
                                                  //[ TF ]//
        //:- - - - - - - - - - - -- - - - - - - - - - - -:// 
        //:@VID_IID[ 0183 ]TIME[ 02:48:00 ]:- - - - - - -://
        F32
        FRAGCOM_GET_res_wid( void )
        {
            #ifdef AAC2020_MACRO_THIS_IS_OPEN_GL
                return( iResolution.x );
            #else
                return( AAC2020_CPUNIFO_iResolution_wid );
            #endif
        }
        F32
        FRAGCOM_GET_res_hig( void )
        {
            #ifdef AAC2020_MACRO_THIS_IS_OPEN_GL
                return( iResolution.y );
            #else
                return( AAC2020_CPUNIFO_iResolution_hig );
            #endif
        }
        //:- - - - - - -:@VID_IID[ 0183 ]TIME[ 02:48:00 ]://
        //:@VID_IID[ 0271 ]TIME[ 07:07:42 ]:- - - - - - -://
        F32
        AAC2020_FRAGCOM_GET_iTime( void )
        {
            #if defined( AAC2020_MACRO_THIS_IS_OPEN_GL )

                return( iTime );
            #else
                return( AAC2020_POLYOGL_GET_iTime() );
            #endif
        }
        //:- - - - - - -:@VID_IID[ 0271 ]TIME[ 07:07:42 ]://
        //:- - - - - - - - - - - -- - - - - - - - - - - -:// 
        IV2
        FRAGCOM_GET_mou_glo( void )
        {
            IV2 mou_glo;

            #ifdef AAC2020_MACRO_THIS_IS_OPEN_GL //:#####://
            //:[GPU_SIDE]################################://
            /** @VID_IID[ 0250 ]TIME[ 01:57:42 ][TOP_LEF]**/
            /** Mouse Origin Adjusted To Top_Left ****** **/
            /** @VID_IID[ 0252 ]TIME[ 02:54:23 ][UN_FLIP]**/

                mou_glo.x = MAK_I32( iMouse.x );
                mou_glo.y = MAK_I32( iMouse.y );

            //- mou_glo.y = MAK_I32(       NO_FUCKIN_FLIP-//
            //-    ( iResolution.y - 1.0 ) NO_FUCKIN_FLIP-//
            //-     -                      NO_FUCKIN_FLIP-//
            //-    (      iMouse.y       ) NO_FUCKIN_FLIP-//
            //- );;                        NO_FUCKIN_FLIP-//

            #else
            //:[CPU_SIDE]################################://
                                   mou_glo.x =(
                AAC2020_POLYOGL_Get_iMouse_X());;

                                   mou_glo.y =(
                AAC2020_POLYOGL_Get_iMouse_Y());;

            #endif //:###################################://
            //:##########################################://

            return( mou_glo );
        }
        //:- - - - - - - - - - - -- - - - - - - - - - - -://
        I32
        AAC2020_FRAGCOM_MOD_I32(
            I32 inn_i32
        ,   I32 divisor
        )
        {
            I32 mod_i32; //:<--[ output_variable ]

            #ifdef AAC2020_MACRO_THIS_IS_OPEN_GL //:#####://

                F32 inn_f32=( MAK_F32( inn_i32 ) );
                F32 div_f32=( MAK_F32( divisor ) );

                F32 mod_f32 =( mod( inn_f32 , div_f32 ) );

                mod_i32 =( MAK_I32( mod_f32 ) );
 
            #else //:####################################://

                mod_i32 =( inn_i32 % divisor );
                ERR( E_S([ONLY_RUN_AS_GLSL_2021_04_08] ) );

            #endif //:###################################://

            return( mod_i32 );
        }
 
        //:- - - - - - - - - - - -- - - - - - - - - - - -:// 
    //:FRAGCOM_FRA_FILE_MACROS:==========================://
    /**@VID_IID[ 0093 ]T[00:31:40]MAKE_FOR_MAKE**/ //: - ://
    /**@VID_IID[ 0293 ]T[00:25:10]MACRO_GUTTING**/ //: - ://
                                                   //: - ://
        #undef      ERR                            //: - ://
        #undef  TYP_F_C                            //: - ://
        #undef  INN_F_C                            //: - ://
                                                   //: - ://
        /**SEE[ AAC2020/LIB/MAC/FRA/TOP._ ]** **/  //: - ://
        /**SEE[ AAC2020/LIB/MAC/FRA/BOT._ ]** **/  //: - ://
                                                   //: - ://
    //:==========================:FRAGCOM_FRA_FILE_MACROS://
    //:===========:COM_001____AAC2020_FRAGCOM_DEFAULT_001://  
    //[=====================:PASTE_INTO_FILE[ COM_001._ ]]//
    //[======================:AAC2020_FRAGCOM_DEFAULT_001]//
    //[==============:CUT_AND_PASTE_THIS_INTO_GLSL_SOURCE]//

    //://////////////////////////FILESEC[ FRAGCOM.FRA._ ]://